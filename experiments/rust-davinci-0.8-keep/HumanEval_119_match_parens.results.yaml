name: HumanEval_119_match_parens
language: rust
results:
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (mut lhs, mut rhs) = match lst.split_first() {\n      \
    \  Some((x, xs)) => (x.chars().collect::<Vec<char>>(), xs[0].chars().collect::<Vec<char>>()),\n\
    \        None => return \"No\".to_string(),\n    };\n    let mut bal = 0;\n  \
    \  while let Some(x) = lhs.pop() {\n        if x == '(' {\n            bal +=\
    \ 1;\n        } else {\n            bal -= 1;\n        }\n        if bal < 0 {\n\
    \            return \"No\".to_string();\n        }\n    }\n    while let Some(x)\
    \ = rhs.pop() {\n        if x == '(' {\n            bal += 1;\n        } else\
    \ {\n            bal -= 1;\n        }\n        if bal < 0 {\n            return\
    \ \"No\".to_string();\n        }\n    }\n    if bal == 0 {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp03pdskmj.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut f_str = String::new();\n    let mut s_str = String::new();\n\
    \    let mut stack = vec![];\n    if let Some(first) = lst.get(0) {\n        f_str\
    \ = first.clone();\n    }\n    if let Some(second) = lst.get(1) {\n        s_str\
    \ = second.clone();\n    }\n    for c in f_str.chars() {\n        if c == '('\
    \ {\n            stack.push(c);\n        } else {\n            match stack.pop()\
    \ {\n                Some(_) => {}\n                None => return \"No\".to_string(),\n\
    \            }\n        }\n    }\n    for c in s_str.chars() {\n        if c ==\
    \ '(' {\n            stack.push(c);\n        } else {\n            match stack.pop()\
    \ {\n                Some(_) => {}\n                None => return \"No\".to_string(),\n\
    \            }\n        }\n    }\n    if stack.is_empty() {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpnbnx0ehb.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    for s in lst {\n\
    \        for c in s.chars() {\n            if c == '(' {\n                stack.push(c);\n\
    \            } else {\n                if stack.is_empty() {\n               \
    \     return \"No\".to_string();\n                }\n                stack.pop();\n\
    \            }\n        }\n    }\n    if stack.is_empty() {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmppqcw6wfp.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lhs = 0;\n    let mut rhs = 0;\n    for ch in lst[0].chars()\
    \ {\n        if ch == '(' {\n            lhs += 1;\n        } else {\n       \
    \     lhs -= 1;\n        }\n    }\n    for ch in lst[1].chars() {\n        if\
    \ ch == '(' {\n            rhs += 1;\n        } else {\n            rhs -= 1;\n\
    \        }\n    }\n    if lhs == rhs && lhs + rhs == 0 {\n        return \"Yes\"\
    .to_string();\n    }\n    return \"No\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpdatw272k.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    for w in lst {\n        for c in w.chars()\
    \ {\n            match c {\n                '(' => count += 1,\n             \
    \   ')' => {\n                    if count == 0 {\n                        return\
    \ \"No\".to_string();\n                    }\n                    count -= 1;\n\
    \                }\n                _ => continue,\n            }\n        }\n\
    \    }\n    if count > 0 {\n        \"No\".to_string()\n    } else {\n       \
    \ \"Yes\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpvvuk72bg.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut count = 0;\n  \
    \  for c in s1.iter() {\n        if *c == '(' {\n            count += 1;\n   \
    \     } else {\n            count -= 1;\n        }\n    }\n    for c in s2.iter()\
    \ {\n        if *c == '(' {\n            count += 1;\n        } else {\n     \
    \       count -= 1;\n        }\n    }\n    if count == 0 {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp3mmob7hw.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut flag = true;\n    for s in lst {\n        for c in\
    \ s.chars() {\n            match c {\n                '(' => flag = true,\n  \
    \              ')' => {\n                    if flag {\n                     \
    \   flag = false;\n                    } else {\n                        return\
    \ \"No\".to_string();\n                    }\n                }\n            \
    \    _ => unreachable!(\"Invalid character\"),\n            }\n        }\n   \
    \ }\n    if flag {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpnoxgrwdh.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    for s in lst {\n        for c in s.chars()\
    \ {\n            match c {\n                '(' => count += 1,\n             \
    \   ')' => {\n                    if count == 0 {\n                        return\
    \ \"No\".to_string();\n                    }\n                    count -= 1;\n\
    \                }\n                _ => {}\n            }\n        }\n    }\n\
    \    if count == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp84h_13au.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut a = lst[0].clone();\n    let mut b = lst[1].clone();\n\
    \    while a.len() != 0 {\n        let (tail, head) = (a.pop().unwrap(), b.remove(0));\n\
    \        if tail == '(' && head == ')' {\n            continue;\n        } else\
    \ if tail == ')' && head == '(' {\n            return \"No\".to_string();\n  \
    \      } else {\n            if tail == '(' {\n                a.push(tail);\n\
    \                b.insert(0, head);\n            } else {\n                b.insert(0,\
    \ head);\n                b.insert(0, tail);\n            }\n        }\n    }\n\
    \    if b.len() == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"\
    No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'cannot remove a char from the end of a string',\
    \ /rustc/e092d0b6b43f2de967af0887873151bb1c0b18d3/library/alloc/src/string.rs:1336:21\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let str1 = lst[0].chars().count();\n    let str2 = lst[1].chars().count();\n\
    \    let mut stack1 = Vec::new();\n    let mut stack2 = Vec::new();\n    let mut\
    \ j = 0;\n    for i in 0..str1 {\n        if lst[0].chars().nth(i).unwrap() ==\
    \ '(' {\n            stack1.push('(');\n        } else {\n            if stack1.len()\
    \ == 0 {\n                if j < str2 {\n                    if lst[1].chars().nth(j).unwrap()\
    \ == '(' {\n                        stack1.push('(');\n                      \
    \  j += 1;\n                    } else {\n                        return \"No\"\
    .to_string();\n                    }\n                } else {\n             \
    \       return \"No\".to_string();\n                }\n            } else {\n\
    \                stack1.pop();\n            }\n        }\n    }\n    let mut j\
    \ = 0;\n    for i in 0..str2 {\n        if lst[1].chars().nth(i).unwrap() == '('\
    \ {\n            stack2.push('(');\n        } else {\n            if stack2.len()\
    \ == 0 {\n                if j < str1 {\n                    if lst[0].chars().nth(j).unwrap()\
    \ == '(' {\n                        stack2.push('(');\n                      \
    \  j += 1;\n                    } else {\n                        return \"No\"\
    .to_string();\n                    }\n                } else {\n             \
    \       return \"No\".to_string();\n                }\n            } else {\n\
    \                stack2.pop();\n            }\n        }\n    }\n    \"Yes\".to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpw_mhs42_.rs:66:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut ret = String::from(\"Yes\");\n    let mut stack = Vec::new();\n\
    \    let mut open = 0;\n    let mut close = 0;\n    let mut bad = false;\n   \
    \ for i in 0..lst.len() {\n        for ch in lst[i].chars() {\n            if\
    \ ch == '(' {\n                stack.push(ch);\n                open += 1;\n \
    \           } else {\n                if stack.is_empty() {\n                \
    \    close += 1;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n        }\n    }\n    let mut diff = 0;\n \
    \   if open > close {\n        diff = open - close;\n    } else {\n        diff\
    \ = close - open;\n    }\n    if stack.len() != diff {\n        bad = true;\n\
    \    }\n    if bad {\n        ret = String::from(\"No\");\n    }\n    ret\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpsfk859r1.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut v1 = 0;\n    let mut v2 = 0;\n    for ch in lst[0].chars()\
    \ {\n        if ch == '(' {\n            v1 += 1;\n        } else {\n        \
    \    v1 -= 1;\n        }\n    }\n    for ch in lst[1].chars() {\n        if ch\
    \ == '(' {\n            v2 += 1;\n        } else {\n            v2 -= 1;\n   \
    \     }\n    }\n    if v1 == 0 {\n        if v2 == 0 {\n            return \"\
    Yes\".to_string();\n        } else {\n            if v2 > 0 {\n              \
    \  return \"No\".to_string();\n            } else {\n                if lst[0].contains('(')\
    \ {\n                    return \"Yes\".to_string();\n                } else {\n\
    \                    return \"No\".to_string();\n                }\n         \
    \   }\n        }\n    } else {\n        if v1 > 0 {\n            if v2 >= 0 {\n\
    \                return \"Yes\".to_string();\n            } else {\n         \
    \       return \"No\".to_string();\n            }\n        } else {\n        \
    \    if v2 > 0 {\n                return \"No\".to_string();\n            } else\
    \ {\n                if v2 == 0 {\n                    return \"Yes\".to_string();\n\
    \                } else {\n                    if lst[1].contains(')') {\n   \
    \                     return \"Yes\".to_string();\n                    } else\
    \ {\n                        return \"No\".to_string();\n                    }\n\
    \                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp9tb0m5fw.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    for i in 0..lst.len()\
    \ {\n        for c in lst[i].chars() {\n            if c == '(' {\n          \
    \      stack.push(c);\n            } else {\n                if !stack.is_empty()\
    \ {\n                    stack.pop();\n                } else {\n            \
    \        return \"No\".to_string();\n                }\n            }\n      \
    \  }\n    }\n    if stack.is_empty() {\n        \"Yes\".to_string()\n    } else\
    \ {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpg4dzzqq4.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter().map(|s| to_parens(s)).fold(to_parens(\"\"), |acc,\
    \ x| acc + x)\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_parens` in this scope\n  --> /tmp/tmppk12usr3.rs:13:24\n\
    \   |\n13 |     lst.iter().map(|s| to_parens(s)).fold(to_parens(\"\"), |acc, x|\
    \ acc + x)\n   |                        ^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `to_parens` in this scope\n  --> /tmp/tmppk12usr3.rs:13:43\n\
    \   |\n13 |     lst.iter().map(|s| to_parens(s)).fold(to_parens(\"\"), |acc, x|\
    \ acc + x)\n   |                                           ^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Checking that the list is only composed of open and close\
    \ parentheses.\n    if lst.len() != 2 || lst[0].chars().find(|c| !\"()\".contains(*c)).is_some()\
    \ ||\n        lst[1].chars().find(|c| !\"()\".contains(*c)).is_some() {\n    \
    \    return \"No\".to_string();\n    }\n\n    // Checking that the concatenation\
    \ of the two strings results in a good string.\n    // The checking is done by\
    \ a recursive function.\n    if is_good(&lst[0] + &lst[1]) {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpnxtg44p9.rs:21:8\n\
    \   |\n21 |     if is_good(&lst[0] + &lst[1]) {\n   |        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0369]: cannot add `&String` to `&String`\n  --> /tmp/tmpnxtg44p9.rs:21:24\n\
    \   |\n21 |     if is_good(&lst[0] + &lst[1]) {\n   |                ------- ^\
    \ ------- &String\n   |                |       |\n   |                |      \
    \ `+` cannot be used to concatenate two `&str` strings\n   |                &String\n\
    \   |\n   = note: string concatenation requires an owned `String` on the left\n\
    help: remove the borrow to obtain an owned `String`\n   |\n21 -     if is_good(&lst[0]\
    \ + &lst[1]) {\n21 +     if is_good(lst[0] + &lst[1]) {\n   | \n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0369, E0425.\n\
    For more information about an error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 2 {\n        let s1 = &lst[0];\n        let\
    \ s2 = &lst[1];\n        let mut left = 0;\n        let mut right = 0;\n     \
    \   let mut l = 0;\n        let mut r = 0;\n        for c in s1.chars() {\n  \
    \          if c == '(' {\n                left += 1;\n            } else {\n \
    \               left -= 1;\n            }\n            if left < 0 {\n       \
    \         break;\n            }\n        }\n        for c in s2.chars() {\n  \
    \          if c == '(' {\n                right += 1;\n            } else {\n\
    \                right -= 1;\n            }\n            if right < 0 {\n    \
    \            break;\n            }\n        }\n        for c in s1.chars() {\n\
    \            if c == '(' {\n                l += 1;\n            } else {\n  \
    \              l -= 1;\n            }\n        }\n        for c in s2.chars()\
    \ {\n            if c == '(' {\n                r += 1;\n            } else {\n\
    \                r -= 1;\n            }\n        }\n        if (left == 0 && right\
    \ == 0) || (left > 0 && right < 0 && l >= r) ||\n           (left < 0 && right\
    \ > 0 && l <= r) {\n            \"Yes\".to_string()\n        } else {\n      \
    \      \"No\".to_string()\n        }\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpxup_rsy8.rs:69:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    if s1.len() > s2.len()\
    \ {\n        std::mem::swap(&mut s1, &mut s2);\n    }\n    for _ in 0..s1.len()\
    \ {\n        if is_good(&mut s1) {\n            return \"Yes\".to_string();\n\
    \        }\n        s1.rotate_left(1);\n    }\n    \"No\".to_string()\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpse7eic_m.rs:19:12\n\
    \   |\n19 |         if is_good(&mut s1) {\n   |            ^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let l = lst[0].len();\n    let r = lst[1].len();\n    let mut\
    \ cnt = 0;\n    for c in lst[0].chars() {\n        if c == '(' {\n           \
    \ cnt += 1;\n        } else {\n            cnt -= 1;\n        }\n    }\n    for\
    \ c in lst[1].chars() {\n        if c == '(' {\n            cnt += 1;\n      \
    \  } else {\n            cnt -= 1;\n        }\n    }\n    if cnt == 0 {\n    \
    \    \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpjhrr8say.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    let mut ans = true;\n    for c in lst[0].chars()\
    \ {\n        match c {\n            '(' => count += 1,\n            ')' => count\
    \ -= 1,\n            _ => panic!(\"invalid char in input\"),\n        }\n    \
    \    if count < 0 {\n            ans = false;\n            break;\n        }\n\
    \    }\n    for c in lst[1].chars() {\n        match c {\n            '(' => count\
    \ += 1,\n            ')' => count -= 1,\n            _ => panic!(\"invalid char\
    \ in input\"),\n        }\n        if count < 0 {\n            ans = false;\n\
    \            break;\n        }\n    }\n    if count != 0 {\n        ans = false;\n\
    \    }\n    if ans {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpjcg22l9h.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut v1 = Vec::new();\n    let mut v2 = Vec::new();\n  \
    \  for i in lst[0].chars() {\n        v1.push(i);\n    }\n    for i in lst[1].chars()\
    \ {\n        v2.push(i);\n    }\n    if is_balanced(&v1) || is_balanced(&v2) {\n\
    \        String::from(\"Yes\")\n    } else {\n        String::from(\"No\")\n \
    \   }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp3yh11lak.rs:21:8\n\
    \   |\n21 |     if is_balanced(&v1) || is_balanced(&v2) {\n   |        ^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_balanced`\
    \ in this scope\n  --> /tmp/tmp3yh11lak.rs:21:28\n   |\n21 |     if is_balanced(&v1)\
    \ || is_balanced(&v2) {\n   |                            ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst: Vec<char> = lst.join(\"\").chars().collect();\n\
    \    let mut left_parens = Vec::new();\n    for paren in lst {\n        if paren\
    \ == '(' {\n            left_parens.push(paren);\n        } else {\n         \
    \   match left_parens.pop() {\n                Some(_) => continue,\n        \
    \        None => return \"No\".to_string(),\n            }\n        }\n    }\n\
    \    if left_parens.is_empty() {\n        \"Yes\".to_string()\n    } else {\n\
    \        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpwf3jcy_h.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut first = &lst[0];\n    let mut second = &lst[1];\n \
    \   let mut tmp = String::new();\n    let mut balance: i32 = 0;\n    while first.len()\
    \ > 0 {\n        tmp.push_str(first);\n        tmp.push_str(second);\n       \
    \ for c in tmp.chars() {\n            if c == '(' {\n                balance +=\
    \ 1;\n            } else {\n                balance -= 1;\n            }\n   \
    \         if balance < 0 {\n                tmp.clear();\n                balance\
    \ = 0;\n                break;\n            }\n        }\n        if balance ==\
    \ 0 {\n            return \"Yes\".to_string();\n        }\n        first = &first[..first.len()\
    \ - 1];\n        second = &second[1..];\n    }\n    \"No\".to_string()\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfi2py72h.rs:35:17\n   |\n\
    13 |     let mut first = &lst[0];\n   |                     ------- expected due\
    \ to this value\n...\n35 |         first = &first[..first.len() - 1];\n   |  \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `String`, found `str`\n\
    \   |\n   = note: expected reference `&String`\n              found reference\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpfi2py72h.rs:36:18\n\
    \   |\n14 |     let mut second = &lst[1];\n   |                      ------- expected\
    \ due to this value\n...\n36 |         second = &second[1..];\n   |          \
    \        ^^^^^^^^^^^^ expected struct `String`, found `str`\n   |\n   = note:\
    \ expected reference `&String`\n              found reference `&str`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        return \"No\".to_string();\n \
    \   }\n    let mut lst1 = lst[0].clone();\n    let mut lst2 = lst[1].clone();\n\
    \    let mut ans = String::new();\n    for c in lst1.chars() {\n        ans.push(c);\n\
    \    }\n    for c in lst2.chars() {\n        ans.push(c);\n    }\n    if balanced_parens(&ans)\
    \ {\n        return \"Yes\".to_string();\n    }\n    let mut ans = String::new();\n\
    \    for c in lst2.chars() {\n        ans.push(c);\n    }\n    for c in lst1.chars()\
    \ {\n        ans.push(c);\n    }\n    if balanced_parens(&ans) {\n        return\
    \ \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `balanced_parens` in this scope\n  -->\
    \ /tmp/tmpzlcsr7or.rs:25:8\n   |\n25 |     if balanced_parens(&ans) {\n   |  \
    \      ^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `balanced_parens` in this scope\n  --> /tmp/tmpzlcsr7or.rs:35:8\n   |\n35 |\
    \     if balanced_parens(&ans) {\n   |        ^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        return \"No\".to_string();\n \
    \   }\n    let mut stk = vec![];\n    let mut s = &lst[0];\n    while !s.is_empty()\
    \ {\n        if let Some(c) = s.chars().next() {\n            if c == '(' {\n\
    \                stk.push(c);\n            } else {\n                if let Some(p)\
    \ = stk.pop() {\n                    if p != '(' {\n                        return\
    \ \"No\".to_string();\n                    }\n                } else {\n     \
    \               break;\n                }\n            }\n            s = &s[1..];\n\
    \        }\n    }\n    s = &lst[1];\n    while !s.is_empty() {\n        if let\
    \ Some(c) = s.chars().next() {\n            if c == ')' {\n                stk.push(c);\n\
    \            } else {\n                if let Some(p) = stk.pop() {\n        \
    \            if p != ')' {\n                        return \"No\".to_string();\n\
    \                    }\n                } else {\n                    break;\n\
    \                }\n            }\n            s = &s[1..];\n        }\n    }\n\
    \    if stk.is_empty() {\n        \"Yes\".to_string()\n    } else {\n        \"\
    No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp0bbszmjh.rs:31:17\n   |\n\
    17 |     let mut s = &lst[0];\n   |                 ------- expected due to this\
    \ value\n...\n31 |             s = &s[1..];\n   |                 ^^^^^^^ expected\
    \ struct `String`, found `str`\n   |\n   = note: expected reference `&String`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp0bbszmjh.rs:48:17\n   |\n17 |     let mut s = &lst[0];\n   |       \
    \          ------- expected due to this value\n...\n48 |             s = &s[1..];\n\
    \   |                 ^^^^^^^ expected struct `String`, found `str`\n   |\n  \
    \ = note: expected reference `&String`\n              found reference `&str`\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Make sure we've got just two strings.\n    if lst.len()\
    \ != 2 {\n        return \"No\".to_string();\n    }\n\n    // Make sure both strings\
    \ only contain open or close parentheses.\n    let mut s1 = lst[0].chars();\n\
    \    let mut s2 = lst[1].chars();\n    for c in s1.by_ref() {\n        if c !=\
    \ '(' && c != ')' {\n            return \"No\".to_string();\n        }\n    }\n\
    \    for c in s2.by_ref() {\n        if c != '(' && c != ')' {\n            return\
    \ \"No\".to_string();\n        }\n    }\n\n    // If both strings are empty, we're\
    \ good.\n    if s1.len() == 0 && s2.len() == 0 {\n        return \"Yes\".to_string();\n\
    \    }\n\n    // If only one string is empty, we're not good.\n    if s1.len()\
    \ == 0 || s2.len() == 0 {\n        return \"No\".to_string();\n    }\n\n    //\
    \ No need to generate all possible combinations, we can just look at\n    // the\
    \ first and last parentheses of each string, and make sure they\n    // match.\n\
    \    if s1.next_back().unwrap() == '(' && s2.next().unwrap() == ')' {\n      \
    \  return \"Yes\".to_string();\n    }\n    if s1.next_back().unwrap() == ')' &&\
    \ s2.next().unwrap() == '(' {\n        return \"Yes\".to_string();\n    }\n\n\
    \    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `len` found for struct `Chars` in the current\
    \ scope\n  --> /tmp/tmp4n9klxk9.rs:33:11\n   |\n33 |     if s1.len() == 0 && s2.len()\
    \ == 0 {\n   |           ^^^ method not found in `Chars<'_>`\n\nerror[E0599]:\
    \ no method named `len` found for struct `Chars` in the current scope\n  --> /tmp/tmp4n9klxk9.rs:33:28\n\
    \   |\n33 |     if s1.len() == 0 && s2.len() == 0 {\n   |                    \
    \        ^^^ method not found in `Chars<'_>`\n\nerror[E0599]: no method named\
    \ `len` found for struct `Chars` in the current scope\n  --> /tmp/tmp4n9klxk9.rs:38:11\n\
    \   |\n38 |     if s1.len() == 0 || s2.len() == 0 {\n   |           ^^^ method\
    \ not found in `Chars<'_>`\n\nerror[E0599]: no method named `len` found for struct\
    \ `Chars` in the current scope\n  --> /tmp/tmp4n9klxk9.rs:38:28\n   |\n38 |  \
    \   if s1.len() == 0 || s2.len() == 0 {\n   |                            ^^^ method\
    \ not found in `Chars<'_>`\n\nerror: aborting due to 4 previous errors\n\nFor\
    \ more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let res: String = lst.into_iter().rev().collect();\n    if\
    \ &res[..] == &res[..].chars().rev().collect::<String>() {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpaes1wtwi.rs:23:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lhs = lst[0].clone();\n    let mut rhs = lst[1].clone();\n\
    \    let mut rv = \"Yes\".to_string();\n    loop {\n        if lhs.ends_with('(')\
    \ && rhs.starts_with(')') {\n            lhs.pop();\n            rhs.remove(0);\n\
    \        } else if lhs.ends_with(')') && rhs.starts_with('(') {\n            lhs.pop();\n\
    \            rhs.remove(0);\n        } else if lhs.len() == 0 {\n            rv\
    \ = \"Yes\".to_string();\n            break;\n        } else if rhs.len() == 0\
    \ {\n            rv = \"Yes\".to_string();\n            break;\n        } else\
    \ {\n            rv = \"No\".to_string();\n            break;\n        }\n   \
    \ }\n    return rv;\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpkbto8az8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open_parens = 0;\n    let mut close_parens = 0;\n \
    \   for s in lst {\n        let mut i = 0;\n        while i < s.len() {\n    \
    \        if s.chars().nth(i).unwrap() == '(' {\n                open_parens +=\
    \ 1;\n            } else {\n                close_parens += 1;\n            }\n\
    \            i += 1;\n        }\n    }\n    if open_parens == close_parens {\n\
    \        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp9xhyu5p4.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter().fold(String::new(), |acc, s| {\n        if acc.contains(')')\
    \ && s.contains('(') {\n            acc + s\n        } else if acc.contains('(')\
    \ && s.contains(')') {\n            format!(\"{}{}\", s, acc)\n        } else\
    \ {\n            String::new()\n        }\n    })\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"\"`,\n right: `\"Yes\"`', /tmp/tmpho5cjpl1.rs:26:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    fn match_parens(parens: &str) -> bool {\n        let mut n\
    \ = 0;\n        for c in parens.chars() {\n            match c {\n           \
    \     '(' => n += 1,\n                ')' => n -= 1,\n                _ => (),\n\
    \            }\n            if n < 0 {\n                return false;\n      \
    \      }\n        }\n        return n == 0;\n    }\n\n    let parens = &lst[0]\
    \ + &lst[1];\n    for i in 0..parens.len() {\n        if match_parens(&parens[..i])\
    \ && match_parens(&parens[i..]) {\n            return \"Yes\".to_string();\n \
    \       }\n    }\n    return \"No\".to_string();\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0369]: cannot add `&String` to `&String`\n  --> /tmp/tmpqjwowmcg.rs:28:26\n\
    \   |\n28 |     let parens = &lst[0] + &lst[1];\n   |                  -------\
    \ ^ ------- &String\n   |                  |       |\n   |                  |\
    \       `+` cannot be used to concatenate two `&str` strings\n   |           \
    \       &String\n   |\n   = note: string concatenation requires an owned `String`\
    \ on the left\nhelp: remove the borrow to obtain an owned `String`\n   |\n28 -\
    \     let parens = &lst[0] + &lst[1];\n28 +     let parens = lst[0] + &lst[1];\n\
    \   | \n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0369`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    for &c in lst[0].chars().chain(lst[1].chars())\
    \ {\n        if c == '(' {\n            stack.push(c);\n        } else {\n   \
    \         if let Some(&'(') = stack.last() {\n                stack.pop();\n \
    \           } else {\n                return \"No\".to_string();\n           \
    \ }\n        }\n    }\n    if stack.is_empty() {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpfx2m5wxk.rs:14:9\n   |\n\
    14 |     for &c in lst[0].chars().chain(lst[1].chars()) {\n   |         ^^   \
    \ ------------------------------------ this expression has type `Option<char>`\n\
    \   |         |\n   |         expected `char`, found reference\n   |         help:\
    \ you can probably remove the explicit borrow: `c`\n   |\n   = note:   expected\
    \ type `char`\n           found reference `&_`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut chars = lst[0].chars().collect::<Vec<char>>();\n  \
    \  chars.append(&mut lst[1].chars().collect::<Vec<char>>());\n    let mut balance\
    \ = 0;\n    for c in chars {\n        if c == '(' {\n            balance += 1;\n\
    \        } else {\n            balance -= 1;\n        }\n        if balance <\
    \ 0 {\n            return \"No\".to_string();\n        }\n    }\n    if balance\
    \ == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpo38omm7z.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut ans = String::from(\"\
    Yes\");\n    for s in lst {\n        for c in s.chars() {\n            if c ==\
    \ '(' {\n                stack.push(c);\n            } else {\n              \
    \  if stack.is_empty() {\n                    ans = String::from(\"No\");\n  \
    \                  break;\n                } else {\n                    stack.pop();\n\
    \                }\n            }\n        }\n    }\n    ans\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmplcslgrjd.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut x = 0;\n    let mut y = 0;\n    for v in lst[0].chars()\
    \ {\n        if v == '(' {\n            x += 1;\n        } else {\n          \
    \  x -= 1;\n        }\n    }\n    for v in lst[1].chars() {\n        if v == '('\
    \ {\n            y += 1;\n        } else {\n            y -= 1;\n        }\n \
    \   }\n    if x + y == 0 {\n        return \"Yes\".to_string();\n    }\n    return\
    \ \"No\".to_string();\n}\n\nfn main() {\n    let candidate = match_parens;\n \
    \   assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpk80nit5g.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (s1, s2) = (lst[0].clone(), lst[1].clone());\n    let mut\
    \ c = 0;\n    for ch in s1.chars() {\n        if ch == '(' {\n            c +=\
    \ 1;\n        } else {\n            c -= 1;\n        }\n    }\n    for ch in s2.chars()\
    \ {\n        if ch == '(' {\n            c += 1;\n        } else {\n         \
    \   c -= 1;\n        }\n    }\n    if c == 0 {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpzf9iadyo.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut balance = 0;\n    for s in lst {\n        for c in\
    \ s.chars() {\n            if c == '(' {\n                balance += 1;\n    \
    \        } else {\n                balance -= 1;\n            }\n            if\
    \ balance < 0 {\n                return \"No\".to_string();\n            }\n \
    \       }\n    }\n    if balance == 0 {\n        \"Yes\".to_string()\n    } else\
    \ {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpd2cz0j05.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    let mut ret = \"Yes\";\n    for s in\
    \ lst {\n        for c in s.chars() {\n            if c == '(' {\n           \
    \     count += 1;\n            } else {\n                count -= 1;\n       \
    \     }\n            if count < 0 {\n                ret = \"No\";\n         \
    \       break;\n            }\n        }\n    }\n    if count != 0 {\n       \
    \ ret = \"No\";\n    }\n    String::from(ret)\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpo4amhhw1.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp99ftp2ug.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    lst.sort();\n    let (first, second)\
    \ = (lst[0].clone(), lst[1].clone());\n    let l1 = first.chars().filter(|&c|\
    \ c == '(').count();\n    let l2 = second.chars().filter(|&c| c == '(').count();\n\
    \    let r1 = first.chars().filter(|&c| c == ')').count();\n    let r2 = second.chars().filter(|&c|\
    \ c == ')').count();\n    if l1 + l2 == r1 + r2 {\n        if l1 >= r2 {\n   \
    \         \"Yes\".to_string()\n        } else {\n            \"No\".to_string()\n\
    \        }\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp87x9cz4_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut results = vec![];\n    let mut parens_count = 0;\n\
    \    for s in lst {\n        for c in s.chars() {\n            match c {\n   \
    \             '(' => parens_count += 1,\n                ')' => parens_count -=\
    \ 1,\n                _ => panic!(\"wrong input\"),\n            }\n         \
    \   if parens_count < 0 {\n                results.push(String::from(\"No\"));\n\
    \                break;\n            }\n        }\n        if parens_count ==\
    \ 0 {\n            results.push(String::from(\"Yes\"));\n        }\n        parens_count\
    \ = 0;\n    }\n    if results.contains(&String::from(\"No\")) {\n        String::from(\"\
    No\")\n    } else {\n        String::from(\"Yes\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpu8bxf3rb.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open = 0;\n    let mut close = 0;\n    for s in lst.iter()\
    \ {\n        for c in s.chars() {\n            match c {\n                '('\
    \ => open += 1,\n                ')' => close += 1,\n                _ => (),\n\
    \            }\n        }\n    }\n    if open == close {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpgkygfqz4.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    s1.push_str(&s2);\n    let mut cnt = 0;\n    for c in s1.chars() {\n    \
    \    if c == '(' {\n            cnt += 1;\n        } else {\n            cnt -=\
    \ 1;\n        }\n        if cnt < 0 {\n            return \"No\".to_string();\n\
    \        }\n    }\n    if cnt == 0 {\n        \"Yes\".to_string()\n    } else\
    \ {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpvh8e8c5l.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open = 0;\n    let mut close = 0;\n    for c in lst[0].chars()\
    \ {\n        if c == '(' {\n            open += 1;\n        } else {\n       \
    \     close += 1;\n        }\n    }\n    for c in lst[1].chars() {\n        if\
    \ c == '(' {\n            open -= 1;\n        } else {\n            close -= 1;\n\
    \        }\n    }\n    if open < 0 || close < 0 {\n        return \"No\".to_string();\n\
    \    }\n    if open == 0 || close == 0 {\n        return \"Yes\".to_string();\n\
    \    }\n    if lst[0].len() < lst[1].len() {\n        for c in lst[0].chars()\
    \ {\n            if c == '(' {\n                open -= 1;\n            } else\
    \ {\n                close -= 1;\n            }\n            if open < 0 || close\
    \ < 0 {\n                return \"No\".to_string();\n            }\n        }\n\
    \    } else {\n        for c in lst[1].chars() {\n            if c == '(' {\n\
    \                open -= 1;\n            } else {\n                close -= 1;\n\
    \            }\n            if open < 0 || close < 0 {\n                return\
    \ \"No\".to_string();\n            }\n        }\n    }\n    \"Yes\".to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpcgpjcjhd.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Count the number of open and close parens in the first string\n\
    \    let mut num_open_parens = 0;\n    let mut num_close_parens = 0;\n    for\
    \ i in 0..lst[0].len() {\n        match lst[0].chars().nth(i) {\n            Some('(')\
    \ => num_open_parens += 1,\n            Some(')') => num_close_parens += 1,\n\
    \            _ => continue,\n        }\n    }\n\n    // Count the number of open\
    \ and close parens in the second string\n    let mut num_open_parens2 = 0;\n \
    \   let mut num_close_parens2 = 0;\n    for i in 0..lst[1].len() {\n        match\
    \ lst[1].chars().nth(i) {\n            Some('(') => num_open_parens2 += 1,\n \
    \           Some(')') => num_close_parens2 += 1,\n            _ => continue,\n\
    \        }\n    }\n\n    // Check if the number of open parens and close parens\
    \ in each string are equal\n    if num_open_parens == num_close_parens && num_open_parens2\
    \ == num_close_parens2 {\n        String::from(\"Yes\")\n    } else {\n      \
    \  String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpdx9b053m.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    for i in 0..2 {\n        for j in 0..2 {\n            let mut\
    \ s = lst[i].clone();\n            s.push_str(&lst[j]);\n            if is_balanced(&s)\
    \ {\n                return \"Yes\".to_string();\n            }\n        }\n \
    \   }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpodak2iah.rs:17:16\n\
    \   |\n17 |             if is_balanced(&s) {\n   |                ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let left = lst[0].clone();\n    let right = lst[1].clone();\n\
    \    let mut count = 0;\n    for c in left.chars() {\n        if c == '(' {\n\
    \            count += 1;\n        } else {\n            count -= 1;\n        }\n\
    \    }\n    for c in right.chars() {\n        if c == '(' {\n            count\
    \ += 1;\n        } else {\n            count -= 1;\n        }\n    }\n    if count\
    \ == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpjy2nw_aq.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut l_open = 0;\n    let mut r_open = 0;\n    for char\
    \ in lst[0].chars() {\n        if char == '(' {\n            l_open += 1;\n  \
    \      } else {\n            l_open -= 1;\n        }\n    }\n    for char in lst[1].chars()\
    \ {\n        if char == '(' {\n            r_open += 1;\n        } else {\n  \
    \          r_open -= 1;\n        }\n    }\n    let mut s = String::new();\n  \
    \  let mut diff = (l_open - r_open).abs();\n    if l_open > r_open {\n       \
    \ for _ in 0..diff {\n            s.push('(');\n        }\n        s.push_str(&lst[0]);\n\
    \        s.push_str(&lst[1]);\n        for _ in 0..diff {\n            s.push(')');\n\
    \        }\n    } else {\n        for _ in 0..diff {\n            s.push(')');\n\
    \        }\n        s.push_str(&lst[0]);\n        s.push_str(&lst[1]);\n     \
    \   for _ in 0..diff {\n            s.push('(');\n        }\n    }\n    if s.len()\
    \ == 0 {\n        return String::from(\"Yes\");\n    }\n    let mut open = 0;\n\
    \    for char in s.chars() {\n        if char == '(' {\n            open += 1;\n\
    \        } else {\n            open -= 1;\n        }\n        if open < 0 {\n\
    \            return String::from(\"No\");\n        }\n    }\n    if open == 0\
    \ {\n        return String::from(\"Yes\");\n    }\n    String::from(\"No\")\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0689]: can't call method `abs` on ambiguous numeric type `{integer}`\n\
    \  --> /tmp/tmpto01cens.rs:30:38\n   |\n30 |     let mut diff = (l_open - r_open).abs();\n\
    \   |                                      ^^^\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0689`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = \"\".to_string();\n    for st in lst {\n      \
    \  s.push_str(&st);\n    }\n    let mut cnt = 0;\n    for c in s.chars() {\n \
    \       if c == '(' {\n            cnt += 1;\n        } else {\n            cnt\
    \ -= 1;\n        }\n        if cnt < 0 {\n            return \"No\".to_string();\n\
    \        }\n    }\n    if cnt == 0 {\n        \"Yes\".to_string()\n    } else\
    \ {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpmzam6l3d.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        return \"No\".to_string();\n \
    \   }\n    let mut res = \"Yes\".to_string();\n    let mut ok = true;\n    let\
    \ mut ss: String = lst[0].clone();\n    ss.push_str(&lst[1]);\n    let mut s =\
    \ ss.as_str();\n    while ok && s.len() > 0 {\n        match s.chars().next()\
    \ {\n            Some('(') => {\n                s = &s[1..];\n            }\n\
    \            Some(')') => {\n                s = &s[1..];\n                if\
    \ let Some(idx) = s.rfind('(') {\n                    s = &s[idx..];\n       \
    \         } else {\n                    ok = false;\n                }\n     \
    \       }\n            Some(_) => {\n                ok = false;\n           \
    \ }\n            None => {\n                ok = false;\n            }\n     \
    \   }\n    }\n    if !ok {\n        res = \"No\".to_string();\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpx83dsi5v.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cnt = 0;\n    for c in lst[0].chars().chain(lst[1].chars())\
    \ {\n        match c {\n            '(' => cnt += 1,\n            ')' => cnt -=\
    \ 1,\n            _ => {}\n        }\n        if cnt < 0 {\n            return\
    \ \"No\".to_string();\n        }\n    }\n    if cnt == 0 {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp1lba76qq.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let left: String = lst[0].clone();\n    let right: String =\
    \ lst[1].clone();\n    let mut tmp = String::new();\n    for ch in left.chars()\
    \ {\n        if ch == '(' {\n            tmp.push(ch);\n        } else {\n   \
    \         tmp.pop();\n        }\n    }\n    for ch in right.chars() {\n      \
    \  if ch == '(' {\n            tmp.push(ch);\n        } else {\n            tmp.pop();\n\
    \        }\n    }\n    if tmp.is_empty() {\n        \"Yes\".to_string()\n    }\
    \ else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpprsayhn7.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut balance = 0;\n    for c in lst[0].chars().chain(lst[1].chars())\
    \ {\n        match c {\n            '(' => balance += 1,\n            ')' => balance\
    \ -= 1,\n            _ => {},\n        }\n        if balance < 0 {\n         \
    \   return \"No\".to_string();\n        }\n    }\n    if balance == 0 {\n    \
    \    \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpenqudmfr.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let s0 = &lst[0];\n    let s1 = &lst[1];\n    if s0.is_empty()\
    \ {\n        return s1.to_string();\n    }\n    if s1.is_empty() {\n        return\
    \ s0.to_string();\n    }\n    if s0.chars().next().unwrap() == ')' && s1.chars().next().unwrap()\
    \ == ')' {\n        return \"No\".to_string();\n    }\n    let mut d0 = 0;\n \
    \   let mut d1 = 0;\n    for c in s0.chars() {\n        if c == '(' {\n      \
    \      d0 += 1;\n        } else {\n            d0 -= 1;\n        }\n    }\n  \
    \  for c in s1.chars() {\n        if c == '(' {\n            d1 += 1;\n      \
    \  } else {\n            d1 -= 1;\n        }\n    }\n    if d0 > 0 && d1 > 0 {\n\
    \        return \"No\".to_string();\n    }\n    if d0 < 0 && d1 < 0 {\n      \
    \  return \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp5w8kpiqj.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    s.push_str(&lst[1]);\n   \
    \ let mut count = 0;\n    for c in s.chars() {\n        if c == '(' {\n      \
    \      count += 1;\n        } else {\n            count -= 1;\n        }\n   \
    \     if count < 0 {\n            return \"No\".to_string();\n        }\n    }\n\
    \    if count == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpjndz935h.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.is_empty() {\n        return \"Yes\".to_string();\n\
    \    }\n\n    let mut stk = Vec::new();\n    let mut rev = String::new();\n  \
    \  let mut last_str: String = lst[0].clone();\n    let mut first_str: String =\
    \ String::new();\n\n    for (i, s) in lst.iter().enumerate() {\n        if i ==\
    \ 0 {\n            for c in s.chars() {\n                if c == '(' {\n     \
    \               stk.push(c);\n                } else {\n                    if\
    \ stk.is_empty() {\n                        return \"No\".to_string();\n     \
    \               }\n                    stk.pop();\n                }\n       \
    \     }\n        } else {\n            for c in s.chars() {\n                rev.push(c);\n\
    \            }\n            for c in last_str.chars() {\n                rev.push(c);\n\
    \            }\n            first_str = rev.chars().rev().collect();\n       \
    \     break;\n        }\n    }\n\n    let mut par = Vec::new();\n    for c in\
    \ first_str.chars() {\n        if c == '(' {\n            par.push(c);\n     \
    \   } else {\n            if par.is_empty() {\n                return \"No\".to_string();\n\
    \            }\n            par.pop();\n        }\n    }\n\n    if !par.is_empty()\
    \ {\n        return \"No\".to_string();\n    }\n\n    \"Yes\".to_string()\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpt9xtunte.rs:70:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let a = &lst[0];\n    let b = &lst[1];\n    let mut open =\
    \ 0;\n    let mut close = 0;\n    for c in a.chars() {\n        if c == '(' {\n\
    \            open += 1;\n        } else {\n            close += 1;\n        }\n\
    \    }\n    for c in b.chars() {\n        if c == '(' {\n            open += 1;\n\
    \        } else {\n            close += 1;\n        }\n    }\n    if open == close\
    \ {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpz5wlv33b.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open_parens = 0;\n    let mut close_parens = 0;\n \
    \   let mut has_open_parens = false;\n    let mut has_close_parens = false;\n\
    \    for string in lst {\n        for ch in string.chars() {\n            match\
    \ ch {\n                '(' => {\n                    has_open_parens = true;\n\
    \                    open_parens += 1;\n                }\n                ')'\
    \ => {\n                    has_close_parens = true;\n                    close_parens\
    \ += 1;\n                }\n                _ => {\n                    return\
    \ \"No\".to_string();\n                }\n            }\n        }\n    }\n  \
    \  if open_parens > close_parens {\n        if has_close_parens {\n          \
    \  return \"No\".to_string();\n        }\n    } else if close_parens > open_parens\
    \ {\n        if has_open_parens {\n            return \"No\".to_string();\n  \
    \      }\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp3rlc0nxs.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open = 0;\n    let mut close = 0;\n    let mut opener_first\
    \ = true;\n    let mut closer_first = true;\n    let mut maybe = true;\n    for\
    \ (i, s) in lst.iter().enumerate() {\n        if i == 0 {\n            opener_first\
    \ = s.starts_with('(');\n            closer_first = s.starts_with(')');\n    \
    \    }\n        for c in s.chars() {\n            if c == '(' {\n            \
    \    open += 1;\n            } else {\n                close += 1;\n         \
    \   }\n        }\n        if closer_first {\n            maybe = false;\n    \
    \    }\n    }\n    if opener_first {\n        maybe = false;\n    }\n    if maybe\
    \ && open == close {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpw1vmk_6r.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    let mut t = lst[1].clone();\n\
    \    let mut n = 0;\n    for c in s.chars() {\n        if c == '(' {\n       \
    \     n += 1;\n        } else {\n            n -= 1;\n        }\n    }\n    for\
    \ c in t.chars() {\n        if c == '(' {\n            n += 1;\n        } else\
    \ {\n            n -= 1;\n        }\n    }\n    if n == 0 {\n        return \"\
    Yes\".to_string();\n    }\n    let mut bal = 0;\n    let mut pos = 0;\n    for\
    \ c in s.chars() {\n        if c == '(' {\n            bal += 1;\n        } else\
    \ {\n            bal -= 1;\n        }\n        if bal == -1 {\n            pos\
    \ = 1;\n            break;\n        }\n    }\n    if pos == 0 {\n        s.push_str(&t);\n\
    \        if is_balanced(s) {\n            return \"Yes\".to_string();\n      \
    \  }\n    }\n    t.push_str(&s);\n    if is_balanced(t) {\n        return \"Yes\"\
    .to_string();\n    }\n    return \"No\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmpytdkab49.rs:48:12\n\
    \   |\n48 |         if is_balanced(s) {\n   |            ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_balanced` in this scope\n\
    \  --> /tmp/tmpytdkab49.rs:53:8\n   |\n53 |     if is_balanced(t) {\n   |    \
    \    ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open_count = 0;\n    let mut close_count = 0;\n   \
    \ for s in lst {\n        for c in s.chars() {\n            match c {\n      \
    \          '(' => open_count += 1,\n                ')' => close_count += 1,\n\
    \                _ => (),\n            }\n        }\n    }\n    if open_count\
    \ == close_count {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp05uah3z7.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (s1, s2) = (lst[0].as_str(), lst[1].as_str());\n    let\
    \ min_len = s1.len().min(s2.len());\n    for i in 0..=min_len {\n        let a\
    \ = &s1[i..];\n        let b = &s2[..s2.len() - i];\n        if is_good(a) &&\
    \ is_good(b) {\n            return \"Yes\".to_string();\n        }\n    }\n  \
    \  return \"No\".to_string();\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpjipn06_m.rs:18:12\n\
    \   |\n18 |         if is_good(a) && is_good(b) {\n   |            ^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `is_good` in this\
    \ scope\n  --> /tmp/tmpjipn06_m.rs:18:26\n   |\n18 |         if is_good(a) &&\
    \ is_good(b) {\n   |                          ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    let mut stack = Stack::new();\n    for c in s.chars() {\n        if\
    \ c == '(' {\n            stack.push(c);\n        } else {\n            if let\
    \ Some(x) = stack.pop() {\n                if x != '(' {\n                   \
    \ return \"No\".to_string();\n                }\n            } else {\n      \
    \          return \"No\".to_string();\n            }\n        }\n    }\n    if\
    \ stack.is_empty() {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmpowrb3yi7.rs:17:21\n   |\n17 |     let mut stack = Stack::new();\n  \
    \ |                     ^^^^^ use of undeclared type `Stack`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    fn balance(s: &str) -> i32 {\n        s.chars().fold(0, |acc,\
    \ c| {\n            match c {\n                '(' => acc + 1,\n             \
    \   ')' => acc - 1,\n                _ => acc,\n            }\n        })\n  \
    \  }\n\n    if balance(&lst[0]) < 0 && balance(&lst[1]) > 0 {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmps6wm63ac.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    s.push_str(&lst[0]);\n    s.push_str(&lst[1]);\n\
    \    if is_good(&s) {\n        return String::from(\"Yes\");\n    }\n    return\
    \ String::from(\"No\");\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp2kjfyhk0.rs:16:8\n\
    \   |\n16 |     if is_good(&s) {\n   |        ^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    let mut is_good = true;\n    for s\
    \ in lst {\n        for ch in s.chars() {\n            match ch {\n          \
    \      '(' => count += 1,\n                ')' => count -= 1,\n              \
    \  _ => (),\n            }\n            if count < 0 {\n                is_good\
    \ = false;\n                break;\n            }\n        }\n    }\n    return\
    \ if is_good && count == 0 {\n        \"Yes\".to_string()\n    } else {\n    \
    \    \"No\".to_string()\n    };\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp_a3wqg2s.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst: Vec<String> = lst;\n    let mut cnt = 0;\n   \
    \ let mut ncnt = 0;\n    lst.sort();\n    for ch in lst[0].chars() {\n       \
    \ if ch == '(' {\n            cnt += 1;\n        } else {\n            if cnt\
    \ > 0 {\n                cnt -= 1;\n            } else {\n                ncnt\
    \ += 1;\n            }\n        }\n    }\n    for ch in lst[1].chars() {\n   \
    \     if ch == ')' {\n            if ncnt > 0 {\n                ncnt -= 1;\n\
    \            } else {\n                cnt -= 1;\n            }\n        } else\
    \ {\n            cnt += 1;\n        }\n    }\n    if cnt == 0 {\n        return\
    \ \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp1qnqr4oe.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (mut str1, mut str2) = (&lst[0], &lst[1]);\n    let mut\
    \ res = \"Yes\";\n    let mut i = 0;\n    while i < str1.len() {\n        if str1.chars().nth(i).unwrap()\
    \ == '(' {\n            let mut j = 0;\n            while j < str2.len() {\n \
    \               if str2.chars().nth(j).unwrap() == ')' {\n                   \
    \ let (str1a, str1b) = str1.split_at(i);\n                    let (str2a, str2b)\
    \ = str2.split_at(j);\n                    str1 = &format!(\"{}{}\", str1a, str2b);\n\
    \                    str2 = &format!(\"{}{}\", str2a, str1b);\n              \
    \      i = 0;\n                    break;\n                }\n               \
    \ j += 1;\n            }\n            if j == str2.len() {\n                res\
    \ = \"No\";\n                break;\n            }\n        }\n        i += 1;\n\
    \    }\n    res.to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0716]: temporary value dropped while borrowed\n  --> /tmp/tmpndoyppti.rs:23:29\n\
    \   |\n16 |     while i < str1.len() {\n   |               ---------- borrow later\
    \ used here\n...\n23 |                     str1 = &format!(\"{}{}\", str1a, str2b);\n\
    \   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- temporary value\
    \ is freed at the end of this statement\n   |                             |\n\
    \   |                             creates a temporary which is freed while still\
    \ in use\n   |\n   = note: consider using a `let` binding to create a longer lived\
    \ value\n   = note: this error originates in the macro `format` (in Nightly builds,\
    \ run with -Z macro-backtrace for more info)\n\nerror[E0716]: temporary value\
    \ dropped while borrowed\n  --> /tmp/tmpndoyppti.rs:24:29\n   |\n24 |        \
    \             str2 = &format!(\"{}{}\", str2a, str1b);\n   |                 \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^- temporary value is freed at the end\
    \ of this statement\n   |                             |\n   |                \
    \             creates a temporary which is freed while still in use\n...\n30 |\
    \             if j == str2.len() {\n   |                     ---------- borrow\
    \ later used here\n   |\n   = note: consider using a `let` binding to create a\
    \ longer lived value\n   = note: this error originates in the macro `format` (in\
    \ Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0716`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let string1 = lst[0].as_str();\n    let string2 = lst[1].as_str();\n\
    \    let mut string1_stack = Vec::new();\n    let mut string2_stack = Vec::new();\n\
    \    for i in string1.chars() {\n        if i == '(' {\n            string1_stack.push(i);\n\
    \        } else {\n            if string1_stack.len() > 0 {\n                string1_stack.pop();\n\
    \            } else {\n                return \"No\".to_string();\n          \
    \  }\n        }\n    }\n    for i in string2.chars() {\n        if i == '(' {\n\
    \            string2_stack.push(i);\n        } else {\n            if string2_stack.len()\
    \ > 0 {\n                string2_stack.pop();\n            } else {\n        \
    \        return \"No\".to_string();\n            }\n        }\n    }\n    if string1_stack.len()\
    \ > 0 {\n        if string2_stack.len() > 0 {\n            return \"No\".to_string();\n\
    \        } else {\n            return \"Yes\".to_string();\n        }\n    } else\
    \ {\n        if string2_stack.len() > 0 {\n            return \"Yes\".to_string();\n\
    \        } else {\n            return \"Yes\".to_string();\n        }\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp1uebilfh.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (mut open, mut close) = (0, 0);\n    for ch in lst[0].chars()\
    \ {\n        match ch {\n            '(' => open += 1,\n            ')' => close\
    \ += 1,\n            _ => (),\n        }\n    }\n    for ch in lst[1].chars()\
    \ {\n        match ch {\n            '(' => open -= 1,\n            ')' => close\
    \ -= 1,\n            _ => (),\n        }\n    }\n    if close <= 0 && open >=\
    \ 0 {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmppk12bdkq.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // 1. sort the strings, putting the longer string first\n \
    \   // 2. split the first string into 2 substrings, the first and the second\n\
    \    // 3. the second string is the last char of the first string + second string\n\
    \    // 4. check if the first string is good\n    // 5. if first string is good,\
    \ check if second string is good\n    // 6. if first and second strings are good,\
    \ return 'Yes', otherwise return 'No'\n    let mut first = String::new();\n  \
    \  let mut second = String::new();\n    match lst.len() {\n        1 => {\n  \
    \          if lst[0].is_empty() {\n                return \"Yes\".to_string();\n\
    \            } else {\n                return \"No\".to_string();\n          \
    \  }\n        }\n        2 => {\n            if lst[0].len() > lst[1].len() {\n\
    \                first = lst[0].clone();\n                second = lst[1].clone();\n\
    \            } else {\n                first = lst[1].clone();\n             \
    \   second = lst[0].clone();\n            }\n        }\n        _ => panic!(\"\
    too many strings in list\"),\n    }\n    let mut first_substr = String::new();\n\
    \    let mut second_substr = String::new();\n    let char_count = first.len();\n\
    \    if char_count == 1 {\n        first_substr = first.clone();\n        second_substr\
    \ = second.clone();\n    } else {\n        first_substr = first.get(0..char_count\
    \ - 1).unwrap().to_string();\n        second_substr = second.clone();\n      \
    \  second_substr.insert(0, first.get(char_count - 1..char_count).unwrap().chars().next().unwrap());\n\
    \    }\n    if is_valid(&first_substr) {\n        if is_valid(&second_substr)\
    \ {\n            return \"Yes\".to_string();\n        }\n    }\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_valid` in this scope\n  --> /tmp/tmp4a63cp70.rs:51:8\n\
    \   |\n51 |     if is_valid(&first_substr) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `is_valid` in this scope\n\
    \  --> /tmp/tmp4a63cp70.rs:52:12\n   |\n52 |         if is_valid(&second_substr)\
    \ {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open = 0;\n    let mut close = 0;\n    for s in lst\
    \ {\n        for c in s.chars() {\n            match c {\n                '('\
    \ => open += 1,\n                ')' => close += 1,\n                _ => (),\n\
    \            }\n        }\n    }\n    if open >= close {\n        String::from(\"\
    Yes\")\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp12y6ygja.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let res: bool = lst.iter().all(|s|\
    \ {\n        for c in s.chars() {\n            match c {\n                '('\
    \ => stack.push(c),\n                ')' => {\n                    if let Some('(')\
    \ = stack.pop() {\n                        continue;\n                    } else\
    \ {\n                        return false;\n                    }\n          \
    \      }\n                _ => return false,\n            }\n        }\n     \
    \   true\n    });\n    if res && stack.is_empty() {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpc7mawoub.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpjqse4lkr.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let s = format!(\"{}{}\", lst[0], lst[1]);\n    if s.starts_with(')')\
    \ || s.ends_with('(') {\n        return \"No\".to_string();\n    }\n    let mut\
    \ stack = Vec::new();\n    for c in s.chars() {\n        if c == '(' {\n     \
    \       stack.push(c);\n        } else {\n            if let Some(x) = stack.pop()\
    \ {\n                if x != '(' {\n                    return \"No\".to_string();\n\
    \                }\n            } else {\n                return \"No\".to_string();\n\
    \            }\n        }\n    }\n    if stack.is_empty() {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp7wii_bho.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (first, second) = (lst[0].clone(), lst[1].clone());\n \
    \   let mut total_open = 0;\n    let mut total_close = 0;\n    for c in first.chars()\
    \ {\n        if c == '(' {\n            total_open += 1;\n        } else {\n \
    \           total_close += 1;\n        }\n    }\n    for c in second.chars() {\n\
    \        if c == '(' {\n            total_open += 1;\n        } else {\n     \
    \       total_close += 1;\n        }\n    }\n    if total_open == total_close\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpc4vvpxnx.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut q: VecDeque<char> = VecDeque::new();\n    let mut result\
    \ = String::from(\"Yes\");\n    for string in lst {\n        for c in string.chars()\
    \ {\n            if c == '(' {\n                q.push_back(c);\n            }\
    \ else {\n                if let Some(x) = q.pop_back() {\n                  \
    \  if x != '(' {\n                        result = String::from(\"No\");\n   \
    \                     break;\n                    }\n                } else {\n\
    \                    result = String::from(\"No\");\n                    break;\n\
    \                }\n            }\n        }\n    }\n    if q.len() > 0 {\n  \
    \      result = String::from(\"No\");\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `VecDeque` in this scope\n  --> /tmp/tmpddk7r416.rs:13:16\n\
    \   |\n13 |     let mut q: VecDeque<char> = VecDeque::new();\n   |           \
    \     ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing this struct\n\
    \   |\n1  | use std::collections::VecDeque;\n   |\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared type `VecDeque`\n  --> /tmp/tmpddk7r416.rs:13:33\n   |\n13\
    \ |     let mut q: VecDeque<char> = VecDeque::new();\n   |                   \
    \              ^^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::VecDeque;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0412, E0433.\n\
    For more information about an error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    let mut lst_it\
    \ = lst.iter();\n    let str1 = lst_it.next().unwrap();\n    let str2 = lst_it.next().unwrap();\n\
    \    for c in str1.chars() {\n        if c == '(' {\n            stack.push(c);\n\
    \        } else {\n            if stack.is_empty() {\n                return \"\
    No\".to_string();\n            }\n            let x = stack.pop().unwrap();\n\
    \            if x != '(' {\n                return \"No\".to_string();\n     \
    \       }\n        }\n    }\n    for c in str2.chars() {\n        if c == '('\
    \ {\n            stack.push(c);\n        } else {\n            if stack.is_empty()\
    \ {\n                return \"No\".to_string();\n            }\n            let\
    \ x = stack.pop().unwrap();\n            if x != '(' {\n                return\
    \ \"No\".to_string();\n            }\n        }\n    }\n    if stack.is_empty()\
    \ {\n        return \"Yes\".to_string();\n    }\n    return \"No\".to_string();\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp69o0jfk_.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut left = Vec::new();\n    let mut right = Vec::new();\n\
    \    for (i, s) in lst.iter().enumerate() {\n        for c in s.chars() {\n  \
    \          if c == '(' {\n                left.push(i);\n            } else {\n\
    \                right.push(i);\n            }\n        }\n    }\n    let mut\
    \ l_i = 0;\n    let mut r_i = 0;\n    while l_i < left.len() && r_i < right.len()\
    \ {\n        if left[l_i] > right[r_i] {\n            break;\n        }\n    \
    \    l_i += 1;\n        r_i += 1;\n    }\n    if l_i < left.len() {\n        String::from(\"\
    No\")\n    } else {\n        String::from(\"Yes\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpx1qkrve9.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.into_iter().map(|s| s.as_bytes()).collect::<Vec<_>>();\n\
    \    lst.sort_by_key(|s| s.len());\n    let mut res = String::from(\"No\");\n\
    \    for s in &lst {\n        if s.starts_with(b\")\") || s.ends_with(b\"(\")\
    \ {\n            continue;\n        }\n        if s.iter().fold(0, |acc, x| if\
    \ *x == b'(' { acc + 1 } else { acc - 1 }) == 0 {\n            res = String::from(\"\
    Yes\");\n            break;\n        }\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0515]: cannot return reference to function parameter `s`\n  -->\
    \ /tmp/tmphu8c79pi.rs:13:43\n   |\n13 |     let mut lst = lst.into_iter().map(|s|\
    \ s.as_bytes()).collect::<Vec<_>>();\n   |                                   \
    \        ^^^^^^^^^^^^ returns a reference to data owned by the current function\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0515`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmph3r62v6s.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match_parens_recursive(&lst[0].chars().collect::<Vec<char>>(),\n\
    \                           &lst[1].chars().collect::<Vec<char>>(),\n        \
    \                   0,\n                           0)\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `match_parens_recursive` in this scope\n\
    \  --> /tmp/tmpjhp7e7ww.rs:13:5\n   |\n13 |     match_parens_recursive(&lst[0].chars().collect::<Vec<char>>(),\n\
    \   |     ^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let a = lst[0].as_str();\n    let b = lst[1].as_str();\n  \
    \  let mut count = 0;\n    for c in a.chars() {\n        if c == '(' {\n     \
    \       count += 1;\n        } else {\n            count -= 1;\n        }\n  \
    \  }\n    for c in b.chars() {\n        if c == '(' {\n            count += 1;\n\
    \        } else {\n            count -= 1;\n        }\n    }\n    if count ==\
    \ 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp0g0pqkou.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut a = String::new();\n    let mut b = String::new();\n\
    \    for s in lst {\n        if s.contains('(') {\n            a = s;\n      \
    \  } else {\n            b = s;\n        }\n    }\n    match check_balance(&a)\
    \ {\n        Ok(_) => match check_balance(&b) {\n            Ok(_) => return \"\
    Yes\".to_string(),\n            Err(_) => return \"No\".to_string(),\n       \
    \ },\n        Err(_) => return \"No\".to_string(),\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `check_balance` in this scope\n  -->\
    \ /tmp/tmp3097hk7w.rs:22:11\n   |\n22 |     match check_balance(&a) {\n   |  \
    \         ^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `check_balance` in this scope\n  --> /tmp/tmp3097hk7w.rs:23:24\n   |\n23 | \
    \        Ok(_) => match check_balance(&b) {\n   |                        ^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    for x in 0..lst[0].len() {\n        for y in 0..lst[1].len()\
    \ {\n            let mut s = String::from(&lst[0][0..x]);\n            s.push_str(&lst[1][0..y]);\n\
    \            s.push_str(&lst[0][x..]);\n            s.push_str(&lst[1][y..]);\n\
    \            if check_parens(&s) {\n                return String::from(\"Yes\"\
    );\n            }\n        }\n    }\n    String::from(\"No\")\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `check_parens` in this scope\n  -->\
    \ /tmp/tmpfzoha5cd.rs:19:16\n   |\n19 |             if check_parens(&s) {\n  \
    \ |                ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    s.push_str(&lst[0]);\n    s.push_str(&lst[1]);\n\
    \    match parse_parens(&s) {\n        Ok(_) => String::from(\"Yes\"),\n     \
    \   Err(_) => String::from(\"No\"),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parse_parens` in this scope\n  -->\
    \ /tmp/tmpr5sscsvo.rs:16:11\n   |\n16 |     match parse_parens(&s) {\n   |   \
    \        ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let string1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ string2 = lst[1].chars().collect::<Vec<char>>();\n    let mut stack = Vec::new();\n\
    \    let mut string1_balanced = true;\n    let mut string2_balanced = true;\n\
    \    for ch in string1 {\n        if ch == '(' {\n            stack.push(ch);\n\
    \        } else {\n            if stack.len() == 0 {\n                string1_balanced\
    \ = false;\n                break;\n            } else {\n                stack.pop();\n\
    \            }\n        }\n    }\n    for ch in string2 {\n        if ch == '('\
    \ {\n            stack.push(ch);\n        } else {\n            if stack.len()\
    \ == 0 {\n                string2_balanced = false;\n                break;\n\
    \            } else {\n                stack.pop();\n            }\n        }\n\
    \    }\n    if stack.len() == 0 && string1_balanced && string2_balanced {\n  \
    \      \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpvwjmkrgg.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for item in lst {\n       \
    \ s.push_str(&item);\n    }\n    let mut balance = 0;\n    for c in s.chars()\
    \ {\n        if c == '(' {\n            balance += 1;\n        } else {\n    \
    \        balance -= 1;\n        }\n        if balance < 0 {\n            return\
    \ \"No\".to_string();\n        }\n    }\n    if balance == 0 {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp8wznzc96.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 0 {\n        return \"No\".to_string();\n \
    \   }\n\n    if lst.len() == 1 {\n        return is_good_string(&lst[0])\n   \
    \ }\n\n    let mut v = Vec::new();\n    let mut first = true;\n    let mut second\
    \ = true;\n    for s in lst {\n        if is_good_string(&s) == \"Yes\" {\n  \
    \          if first {\n                v.push(s);\n                first = false;\n\
    \            } else if second {\n                v.push(s);\n                second\
    \ = false;\n            }\n        }\n    }\n\n    if v.len() == 0 {\n       \
    \ return \"No\".to_string();\n    }\n\n    if v.len() == 1 {\n        return \"\
    Yes\".to_string();\n    }\n\n    let mut ptr1 = 0;\n    let mut ptr2 = v[1].len()\
    \ - 1;\n    let mut r = Vec::new();\n    let mut c1 = 0;\n    let mut c2 = 0;\n\
    \    while ptr1 < v[0].len() && ptr2 >= 0 {\n        let (p1, p2) = (v[0].chars().nth(ptr1).unwrap(),\
    \ v[1].chars().nth(ptr2).unwrap());\n        if p1 == '(' {\n            c1 +=\
    \ 1;\n        } else {\n            c1 -= 1;\n        }\n        if p2 == '('\
    \ {\n            c2 += 1;\n        } else {\n            c2 -= 1;\n        }\n\
    \        r.push(p1);\n        r.push(p2);\n        ptr1 += 1;\n        ptr2 -=\
    \ 1;\n    }\n\n    r.push(v[0].chars().nth(ptr1).unwrap());\n    if is_good_string(&r.iter().collect::<String>())\
    \ == \"Yes\" {\n        return \"Yes\".to_string();\n    }\n\n    return \"No\"\
    .to_string();\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good_string` in this scope\n  -->\
    \ /tmp/tmpfyrisith.rs:18:16\n   |\n18 |         return is_good_string(&lst[0])\n\
    \   |                ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `is_good_string` in this scope\n  --> /tmp/tmpfyrisith.rs:25:12\n\
    \   |\n25 |         if is_good_string(&s) == \"Yes\" {\n   |            ^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_good_string`\
    \ in this scope\n  --> /tmp/tmpfyrisith.rs:68:8\n   |\n68 |     if is_good_string(&r.iter().collect::<String>())\
    \ == \"Yes\" {\n   |        ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 3 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    for s in lst {\n        for c in s.chars()\
    \ {\n            if c == '(' {\n                count += 1;\n            } else\
    \ {\n                count -= 1;\n            }\n            if count < 0 {\n\
    \                return \"No\".to_string();\n            }\n        }\n    }\n\
    \    if count == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpxx_hju6k.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Balance of each string\n    let mut bal_lst = Vec::new();\n\
    \    for s in lst {\n        let mut bal = 0;\n        for c in s.chars() {\n\
    \            match c {\n                '(' => bal += 1,\n                ')'\
    \ => bal -= 1,\n                _ => panic!(\"Unexpected character\"),\n     \
    \       }\n        }\n        bal_lst.push(bal);\n    }\n    // Main loop\n  \
    \  let mut seq = String::new();\n    let mut stack = Vec::new();\n    let mut\
    \ cur_bal = 0;\n    loop {\n        // If the balance is more than the stack,\
    \ pop from the stack\n        while cur_bal < 0 && !stack.is_empty() {\n     \
    \       let (i, j) = stack.pop().unwrap();\n            seq.push_str(&lst[i]);\n\
    \            cur_bal -= bal_lst[i];\n            if j < lst[i].len() - 1 {\n \
    \               stack.push((i, j + 1));\n            }\n        }\n        //\
    \ Check if the stack is empty\n        if stack.is_empty() {\n            break;\n\
    \        }\n        // Push to the stack\n        let (i, j) = stack.pop().unwrap();\n\
    \        seq.push_str(&lst[i][j..(j + 1)]);\n        cur_bal += match lst[i].chars().nth(j).unwrap()\
    \ {\n            '(' => 1,\n            ')' => -1,\n            _ => panic!(\"\
    Unexpected character\"),\n        };\n        if j < lst[i].len() - 1 {\n    \
    \        stack.push((i, j + 1));\n        }\n    }\n    // Check if the balance\
    \ is zero at the end\n    if cur_bal == 0 {\n        \"Yes\".to_string()\n   \
    \ } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0282]: type annotations needed\n  --> /tmp/tmpu9i1r0cx.rs:36:20\n\
    \   |\n36 |             if j < lst[i].len() - 1 {\n   |                    ^^^^^^\
    \ cannot infer type\n   |\n   = note: type must be known at this point\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0282`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    let mut combined\
    \ = lst[0].clone() + &lst[1];\n    for c in combined.chars() {\n        if c ==\
    \ '(' {\n            stack.push(c);\n        } else {\n            if stack.len()\
    \ > 0 {\n                stack.pop();\n            } else {\n                return\
    \ \"No\".to_string();\n            }\n        }\n    }\n    if stack.len() ==\
    \ 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp8waotp9e.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpih_a6sxx.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    use std::collections::HashMap;\n    use std::iter::FromIterator;\n\
    \n    let mut cnt = HashMap::new();\n    for s in lst {\n        for c in s.chars()\
    \ {\n            let e = cnt.entry(c).or_insert(0);\n            *e += 1;\n  \
    \      }\n    }\n    let mut s = String::from_iter(cnt.into_iter().filter(|&(_,\
    \ v)| v > 0).map(|(k, _)| k));\n    if s.len() == 0 {\n        return String::from(\"\
    Yes\");\n    }\n    while s.len() > 0 {\n        if s.starts_with(\"()\") {\n\
    \            s = s.replace(\"()\", \"\");\n        } else {\n            return\
    \ String::from(\"No\");\n        }\n    }\n    String::from(\"Yes\")\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp66ze3aw_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut vec = Vec::new();\n    for s in lst {\n        let\
    \ mut v = s.chars().collect::<Vec<char>>();\n        vec.append(&mut v);\n   \
    \ }\n    if is_balanced(&vec) {\n        String::from(\"Yes\")\n    } else {\n\
    \        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_balanced` in this scope\n  --> /tmp/tmp44yo50lv.rs:18:8\n\
    \   |\n18 |     if is_balanced(&vec) {\n   |        ^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    s.push_str(&lst[1]);\n   \
    \ if s.chars().count() % 2 != 0 {\n        return \"No\".to_string();\n    }\n\
    \    let mut opens = 0;\n    let mut closes = 0;\n    for c in s.chars() {\n \
    \       if c == '(' {\n            opens += 1;\n        } else {\n           \
    \ closes += 1;\n        }\n        if closes > opens {\n            return \"\
    No\".to_string();\n        }\n    }\n    if opens != closes {\n        return\
    \ \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp164ldw_u.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter().fold(\"\".to_string(), |acc, item| acc + item).is_good_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_good_string` found for struct `String`\
    \ in the current scope\n  --> /tmp/tmp_284i8d9.rs:13:61\n   |\n13 |     lst.iter().fold(\"\
    \".to_string(), |acc, item| acc + item).is_good_string()\n   |               \
    \                                              ^^^^^^^^^^^^^^ method not found\
    \ in `String`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut good = false;\n    let mut good_str = String::new();\n    if s1.contains(\"\
    )\") {\n        s1.push_str(&s2);\n        if check_paren(s1) {\n            good\
    \ = true;\n            good_str = s1;\n        }\n    } else {\n        s2.push_str(&s1);\n\
    \        if check_paren(s2) {\n            good = true;\n            good_str\
    \ = s2;\n        }\n    }\n    match good {\n        true => format!(\"Yes\\n{}\"\
    , good_str),\n        false => String::from(\"No\"),\n    }\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `check_paren` in this scope\n  --> /tmp/tmpr5jknb0t.rs:19:12\n\
    \   |\n19 |         if check_paren(s1) {\n   |            ^^^^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `check_paren` in this scope\n\
    \  --> /tmp/tmpr5jknb0t.rs:25:12\n   |\n25 |         if check_paren(s2) {\n  \
    \ |            ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match lst[0].is_empty() {\n        true => {\n            if\
    \ lst[1].len() % 2 == 0 {\n                String::from(\"Yes\")\n           \
    \ } else {\n                String::from(\"No\")\n            }\n        }\n \
    \       false => {\n            let s1: Vec<char> = lst[0].chars().collect();\n\
    \            let s2: Vec<char> = lst[1].chars().collect();\n            let len1\
    \ = s1.len();\n            let len2 = s2.len();\n            let mut open = 0;\n\
    \            let mut close = 0;\n            let mut max_len = 0;\n          \
    \  for i in 0..len1 {\n                if s1[i] == '(' {\n                   \
    \ open += 1;\n                } else {\n                    close += 1;\n    \
    \            }\n                if open < close {\n                    max_len\
    \ = i + 1;\n                    break;\n                }\n            }\n   \
    \         open = 0;\n            close = 0;\n            for i in 0..len2 {\n\
    \                if s2[i] == '(' {\n                    open += 1;\n         \
    \       } else {\n                    close += 1;\n                }\n       \
    \         if open > close {\n                    max_len = i + 1;\n          \
    \          break;\n                }\n            }\n            if max_len ==\
    \ 0 {\n                String::from(\"Yes\")\n            } else {\n         \
    \       String::from(\"No\")\n            }\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp6zqv3p6b.rs:67:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // input strings are not allowed to be empty\n    let mut stack:\
    \ Vec<char> = Vec::new();\n    let mut balance = 0;\n    let mut flag = true;\n\
    \    let mut output = String::new();\n    for s in lst {\n        for ch in s.chars()\
    \ {\n            if ch == '(' {\n                stack.push(ch);\n           \
    \     balance += 1;\n            } else {\n                if stack.is_empty()\
    \ {\n                    balance -= 1;\n                } else {\n           \
    \         balance -= 1;\n                    stack.pop();\n                }\n\
    \            }\n        }\n    }\n    if balance == 0 {\n        for s in lst\
    \ {\n            output.push_str(&s);\n        }\n        flag = check_balance(&output);\n\
    \    }\n    if flag {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `check_balance` in this scope\n  -->\
    \ /tmp/tmptkb77x6e.rs:37:16\n   |\n37 |         flag = check_balance(&output);\n\
    \   |                ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut clean_parenthesis = lst.iter().fold(0, |acc, s| {\n\
    \        acc + s.chars().fold(0, |acc, c| match c {\n            '(' => acc +\
    \ 1,\n            ')' => acc - 1,\n            _ => acc,\n        })\n    });\n\
    \    if clean_parenthesis == 0 {\n        \"Yes\".to_string()\n    } else {\n\
    \        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpvgrde2zg.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut open_count = 0;\n    let mut close_count = 0;\n   \
    \ for c in lst[0].chars() {\n        if c == '(' {\n            open_count +=\
    \ 1;\n        } else {\n            open_count -= 1;\n        }\n    }\n    for\
    \ c in lst[1].chars() {\n        if c == '(' {\n            close_count += 1;\n\
    \        } else {\n            close_count -= 1;\n        }\n    }\n    if open_count\
    \ != 0 && close_count != 0 {\n        String::from(\"No\")\n    } else {\n   \
    \     String::from(\"Yes\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp5la11cf0.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    lst.sort();\n    let mut s = String::new();\n\
    \    let mut count = 0;\n    for x in lst {\n        for c in x.chars() {\n  \
    \          match c {\n                '(' => count += 1,\n                ')'\
    \ => count -= 1,\n                _ => panic!(\"invalid character\"),\n      \
    \      }\n            if count < 0 {\n                return \"No\".to_string();\n\
    \            }\n        }\n        s.push_str(&x);\n    }\n    while count > 0\
    \ {\n        s.push(')');\n        count -= 1;\n    }\n    is_good(&s)\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpj35gdnfb.rs:34:5\n\
    \   |\n34 |     is_good(&s)\n   |     ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut max_open = 0;\n    let mut open = 0;\n    for (i, c)\
    \ in lst[0].chars().enumerate() {\n        if c == '(' {\n            open +=\
    \ 1;\n            max_open = std::cmp::max(max_open, open);\n        } else {\n\
    \            open -= 1;\n        }\n        if open < 0 {\n            return\
    \ String::from(\"No\");\n        }\n    }\n    open = 0;\n    for (i, c) in lst[1].chars().enumerate()\
    \ {\n        if c == '(' {\n            open += 1;\n        } else {\n       \
    \     open -= 1;\n        }\n        if open < 0 {\n            return String::from(\"\
    No\");\n        }\n    }\n    if open == max_open {\n        String::from(\"Yes\"\
    )\n    } else {\n        String::from(\"No\")\n    }\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp5ftnxifc.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (s1, s2) = (lst[0].clone(), lst[1].clone());\n    if parens_balance(&s1)\
    \ && parens_balance(&s2) {\n        return \"Yes\".to_string();\n    }\n    let\
    \ mut s1 = s1.into_bytes();\n    let mut s2 = s2.into_bytes();\n    let mut s2_parents\
    \ = s2.clone();\n    let mut s1_parents = s1.clone();\n    s1_parents.append(&mut\
    \ s2_parents);\n    s2.append(&mut s1);\n    if parens_balance(&String::from_utf8(s1_parents).unwrap())\n\
    \        || parens_balance(&String::from_utf8(s2).unwrap())\n    {\n        return\
    \ \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `parens_balance` in this scope\n  -->\
    \ /tmp/tmpp24gwwed.rs:14:8\n   |\n14 |     if parens_balance(&s1) && parens_balance(&s2)\
    \ {\n   |        ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot\
    \ find function `parens_balance` in this scope\n  --> /tmp/tmpp24gwwed.rs:14:31\n\
    \   |\n14 |     if parens_balance(&s1) && parens_balance(&s2) {\n   |        \
    \                       ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `parens_balance` in this scope\n  --> /tmp/tmpp24gwwed.rs:23:8\n\
    \   |\n23 |     if parens_balance(&String::from_utf8(s1_parents).unwrap())\n \
    \  |        ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `parens_balance` in this scope\n  --> /tmp/tmpp24gwwed.rs:24:12\n \
    \  |\n24 |         || parens_balance(&String::from_utf8(s2).unwrap())\n   |  \
    \          ^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 4\
    \ previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut ok = true;\n    let mut count = 0;\n    for s in lst\
    \ {\n        for c in s.chars() {\n            if c == '(' {\n               \
    \ count += 1;\n            } else {\n                count -= 1;\n           \
    \ }\n            if count < 0 {\n                ok = false;\n               \
    \ break;\n            }\n        }\n    }\n    if ok && count == 0 {\n       \
    \ \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpr0r84j_0.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for str in lst {\n        s.push_str(&str);\n\
    \    }\n    is_valid(&s)\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_valid` in this scope\n  --> /tmp/tmp7bc5jvwv.rs:17:5\n\
    \   |\n17 |     is_valid(&s)\n   |     ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    for s in lst {\n        for\
    \ c in s.chars() {\n            if c == '(' {\n                stack.push(c);\n\
    \            } else {\n                if stack.len() == 0 {\n               \
    \     return \"No\".to_string();\n                }\n                stack.pop();\n\
    \            }\n        }\n    }\n    stack.len() == 0 ? \"Yes\".to_string() :\
    \ \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n  \
    \  assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"Yes\"\
    `\n  --> /tmp/tmpsiaqbqvh.rs:26:24\n   |\n26 |     stack.len() == 0 ? \"Yes\"\
    .to_string() : \"No\".to_string()\n   |                        ^^^^^ expected\
    \ one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to previous\
    \ error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut x: usize = 0;\n    let mut y: usize = 0;\n    for c\
    \ in lst[0].chars() {\n        if c == '(' {\n            x += 1;\n        } else\
    \ {\n            x -= 1;\n        }\n    }\n    for c in lst[1].chars() {\n  \
    \      if c == '(' {\n            y += 1;\n        } else {\n            y -=\
    \ 1;\n        }\n    }\n    if x == 0 && y == 0 {\n        return \"Yes\".to_string();\n\
    \    }\n    let mut z: usize = 0;\n    for c in lst[0].chars() {\n        if c\
    \ == '(' {\n            z += 1;\n        } else {\n            z -= 1;\n     \
    \   }\n        if z < 0 {\n            break;\n        }\n    }\n    if z >= 0\
    \ {\n        return \"Yes\".to_string();\n    }\n    z = 0;\n    for c in lst[1].chars()\
    \ {\n        if c == '(' {\n            z += 1;\n        } else {\n          \
    \  z -= 1;\n        }\n        if z < 0 {\n            break;\n        }\n   \
    \ }\n    if z >= 0 {\n        return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmp_hvr9ibt.rs:26:13\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let str1 = lst[0].as_str();\n    let str2 = lst[1].as_str();\n\
    \    let mut s1 = str1.to_string();\n    let mut s2 = str2.to_string();\n    //println!(\"\
    {} {}\", s1, s2);\n    let mut result = String::new();\n    if s1.contains(\"\
    (\") {\n        result.push_str(s1.as_str());\n        s1.clear();\n    }\n  \
    \  if s2.contains(\"(\") {\n        result.push_str(s2.as_str());\n        s2.clear();\n\
    \    }\n    if s1.contains(\")\") {\n        result.push_str(s1.as_str());\n \
    \       s1.clear();\n    }\n    if s2.contains(\")\") {\n        result.push_str(s2.as_str());\n\
    \        s2.clear();\n    }\n    if s1.is_empty() && s2.is_empty() {\n       \
    \ if result.chars().count() % 2 == 0 {\n            let mut stack = Vec::new();\n\
    \            for ch in result.chars() {\n                match ch {\n        \
    \            '(' => stack.push(ch),\n                    ')' => {\n          \
    \              if stack.is_empty() {\n                            return \"No\"\
    .to_string();\n                        } else {\n                            stack.pop();\n\
    \                        }\n                    }\n                    _ => {}\n\
    \                }\n            }\n            return \"Yes\".to_string();\n \
    \       } else {\n            return \"No\".to_string();\n        }\n    } else\
    \ {\n        return \"No\".to_string();\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpu5kv3tp4.rs:65:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let first = lst[0].chars().filter(|x| *x == '(').count();\n\
    \    let second = lst[1].chars().filter(|x| *x == '(').count();\n    if first\
    \ == second {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpt93o4lna.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        panic!(\"Invalid input length:\
    \ {}\", lst.len());\n    }\n    let mut res = lst[0].clone();\n    let mut other\
    \ = lst[1].clone();\n    while other.len() > 0 {\n        res.push(other.pop().unwrap());\n\
    \        if !good_string(&res) {\n            res.pop();\n            res.push('(');\n\
    \            other.push(')');\n        }\n    }\n    if good_string(&res) {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `good_string` in this scope\n  --> /tmp/tmp6mjtxyxy.rs:20:13\n\
    \   |\n20 |         if !good_string(&res) {\n   |             ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `good_string` in this\
    \ scope\n  --> /tmp/tmp6mjtxyxy.rs:26:8\n   |\n26 |     if good_string(&res) {\n\
    \   |        ^^^^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens = Vec::new();\n    let mut good = true;\n  \
    \  for s in lst {\n        let mut good_part = true;\n        for c in s.chars()\
    \ {\n            match c {\n                '(' => parens.push(c),\n         \
    \       ')' => {\n                    if let Some('(') = parens.pop() {\n    \
    \                    continue;\n                    } else {\n               \
    \         good_part = false;\n                        break;\n               \
    \     }\n                }\n                _ => panic!(\"Unexpected character!\"\
    ),\n            }\n        }\n        if !good_part || !parens.is_empty() {\n\
    \            good = false;\n            break;\n        }\n    }\n    if good\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp22hiei73.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    for s in lst {\n        for\
    \ c in s.chars() {\n            if c == '(' {\n                stack.push(c);\n\
    \            } else {\n                if stack.is_empty() {\n               \
    \     return \"No\".to_string();\n                }\n                stack.pop();\n\
    \            }\n        }\n    }\n    if stack.is_empty() {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpk88bx6n5.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut x: Vec<char> = Vec::new();\n    let mut y: Vec<char>\
    \ = Vec::new();\n    for i in 0..lst[0].len() {\n        x.push(lst[0].chars().nth(i).unwrap());\n\
    \    }\n    for i in 0..lst[1].len() {\n        y.push(lst[1].chars().nth(i).unwrap());\n\
    \    }\n    //println!(\"{:?}\", x);\n    //println!(\"{:?}\", y);\n    for i\
    \ in 0..3 {\n        if is_good(&x) {\n            return \"Yes\".to_string();\n\
    \        }\n        match i {\n            0 => x.append(&mut y),\n          \
    \  1 => {\n                let mut tmp = x.clone();\n                x.append(&mut\
    \ y);\n                y = tmp;\n            }\n            2 => {\n         \
    \       let mut tmp = x.clone();\n                x.append(&mut y);\n        \
    \        y = tmp;\n                x.reverse();\n            }\n            _\
    \ => {}\n        }\n    }\n    return \"No\".to_string();\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmp3b0hd5h7.rs:24:12\n\
    \   |\n24 |         if is_good(&x) {\n   |            ^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match (get_ltr(lst[0].as_str()), get_rtl(lst[1].as_str()))\
    \ {\n        (0, 0) => String::from(\"Yes\"),\n        _ => String::from(\"No\"\
    ),\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_ltr` in this scope\n  --> /tmp/tmp3p2541sy.rs:13:12\n\
    \   |\n13 |     match (get_ltr(lst[0].as_str()), get_rtl(lst[1].as_str())) {\n\
    \   |            ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `get_rtl` in this scope\n  --> /tmp/tmp3p2541sy.rs:13:38\n   |\n13\
    \ |     match (get_ltr(lst[0].as_str()), get_rtl(lst[1].as_str())) {\n   |   \
    \                                   ^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut out = String::new();\n    let mut open = 0;\n    let\
    \ mut close = 0;\n    for item in lst {\n        for i in item.chars() {\n   \
    \         if i == '(' {\n                open += 1;\n            } else {\n  \
    \              close += 1;\n            }\n        }\n    }\n    if open == close\
    \ {\n        out.push_str(\"Yes\");\n    } else {\n        out.push_str(\"No\"\
    );\n    }\n    out\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpri6tvd6g.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let len = lst.len();\n    let mut lst: Vec<char> = lst.iter().flat_map(|x|\
    \ x.chars()).collect();\n    let mut stack: Vec<char> = Vec::new();\n    for i\
    \ in 0..len {\n        match lst[i] {\n            '(' => stack.push(lst[i]),\n\
    \            ')' => {\n                if stack.is_empty() {\n               \
    \     return \"No\".to_string();\n                } else {\n                 \
    \   stack.pop();\n                }\n            }\n            _ => panic!(\"\
    Invalid character.\"),\n        }\n    }\n    if stack.is_empty() {\n        \"\
    Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpqrvlv_x8.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut l = 0;\n    let mut r = 0;\n    let mut l2 = 0;\n \
    \   let mut r2 = 0;\n    let mut result = String::new();\n    let mut lst2 = lst[0].clone();\n\
    \    let mut lst3 = lst[1].clone();\n    while !lst2.is_empty() {\n        match\
    \ lst2.pop() {\n            Some('(') => l += 1,\n            Some(')') => r +=\
    \ 1,\n            None => (),\n        }\n    }\n    while !lst3.is_empty() {\n\
    \        match lst3.pop() {\n            Some('(') => l2 += 1,\n            Some(')')\
    \ => r2 += 1,\n            None => (),\n        }\n    }\n    if l2 >= l && r2\
    \ >= r {\n        result = \"Yes\".to_string();\n    } else {\n        result\
    \ = \"No\".to_string();\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0004]: non-exhaustive patterns: `Some('\\0'..='\\'')`, `Some('*'..='\\\
    u{d7ff}')` and `Some('\\u{e000}'..='\\u{10ffff}')` not covered\n   --> /tmp/tmpsn8m_pqz.rs:21:15\n\
    \    |\n21  |         match lst2.pop() {\n    |               ^^^^^^^^^^ patterns\
    \ `Some('\\0'..='\\'')`, `Some('*'..='\\u{d7ff}')` and `Some('\\u{e000}'..='\\\
    u{10ffff}')` not covered\n    |\nnote: `Option<char>` defined here\n    = note:\
    \ the matched value is of type `Option<char>`\nhelp: ensure that all possible\
    \ cases are being handled by adding a match arm with a wildcard pattern, a match\
    \ arm with multiple or-patterns as shown, or multiple match arms\n    |\n24  ~\
    \             None => (),\n25  ~             Some('\\0'..='\\'') | Some('*'..='\\\
    u{d7ff}') | Some('\\u{e000}'..='\\u{10ffff}') => todo!(),\n    |\n\nerror[E0004]:\
    \ non-exhaustive patterns: `Some('\\0'..='\\'')`, `Some('*'..='\\u{d7ff}')` and\
    \ `Some('\\u{e000}'..='\\u{10ffff}')` not covered\n   --> /tmp/tmpsn8m_pqz.rs:28:15\n\
    \    |\n28  |         match lst3.pop() {\n    |               ^^^^^^^^^^ patterns\
    \ `Some('\\0'..='\\'')`, `Some('*'..='\\u{d7ff}')` and `Some('\\u{e000}'..='\\\
    u{10ffff}')` not covered\n    |\nnote: `Option<char>` defined here\n    = note:\
    \ the matched value is of type `Option<char>`\nhelp: ensure that all possible\
    \ cases are being handled by adding a match arm with a wildcard pattern, a match\
    \ arm with multiple or-patterns as shown, or multiple match arms\n    |\n31  ~\
    \             None => (),\n32  ~             Some('\\0'..='\\'') | Some('*'..='\\\
    u{d7ff}') | Some('\\u{e000}'..='\\u{10ffff}') => todo!(),\n    |\n\nwarning: value\
    \ assigned to `result` is never read\n  --> /tmp/tmpsn8m_pqz.rs:17:13\n   |\n\
    17 |     let mut result = String::new();\n   |             ^^^^^^\n   |\n   =\
    \ note: `#[warn(unused_assignments)]` on by default\n   = help: maybe it is overwritten\
    \ before being read?\n\nerror: aborting due to 2 previous errors; 1 warning emitted\n\
    \nFor more information about this error, try `rustc --explain E0004`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].to_string();\n    let mut left_parens =\
    \ 0;\n    let mut right_parens = 0;\n    for c in s.chars() {\n        if c ==\
    \ '(' {\n            left_parens += 1;\n        } else {\n            right_parens\
    \ += 1;\n        }\n    }\n    s.push_str(&lst[1]);\n    for c in s.chars() {\n\
    \        if c == '(' {\n            left_parens += 1;\n        } else {\n    \
    \        right_parens += 1;\n        }\n        if right_parens > left_parens\
    \ {\n            return \"No\".to_string();\n        }\n    }\n    if left_parens\
    \ == right_parens {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpn_qi8wfw.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut balance = 0;\n    for ch in lst[0].chars().chain(lst[1].chars())\
    \ {\n        if ch == '(' {\n            balance += 1;\n        } else {\n   \
    \         balance -= 1;\n        }\n        if balance < 0 {\n            return\
    \ \"No\".to_string();\n        }\n    }\n    if balance == 0 {\n        \"Yes\"\
    .to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpp34lfoud.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    let mut t = lst[1].clone();\n\
    \    let mut s_paren_count = 0;\n    let mut t_paren_count = 0;\n    let mut l\
    \ = 0;\n    let mut r = 0;\n    let mut count = 0;\n    for c in s.chars() {\n\
    \        if c == '(' {\n            l += 1;\n        } else {\n            r +=\
    \ 1;\n        }\n        if l < r {\n            count += 1;\n        }\n    }\n\
    \    s_paren_count = l + r - count;\n    l = 0;\n    r = 0;\n    count = 0;\n\
    \    for c in t.chars() {\n        if c == '(' {\n            l += 1;\n      \
    \  } else {\n            r += 1;\n        }\n        if l < r {\n            count\
    \ += 1;\n        }\n    }\n    t_paren_count = l + r - count;\n    if s_paren_count\
    \ % 2 == 1 || t_paren_count % 2 == 1 {\n        return \"No\".to_string();\n \
    \   }\n    let mut s_left_paren_count = 0;\n    let mut t_left_paren_count = 0;\n\
    \    for c in s.chars() {\n        if c == '(' {\n            s_left_paren_count\
    \ += 1;\n        }\n    }\n    for c in t.chars() {\n        if c == '(' {\n \
    \           t_left_paren_count += 1;\n        }\n    }\n    let left_parent_diff\
    \ = s_left_paren_count - t_left_paren_count;\n    let mut t_temp = t.clone();\n\
    \    let mut s_temp = s.clone();\n    if left_parent_diff > 0 {\n        let mut\
    \ push_str = String::from(\"\");\n        for _ in 0..left_parent_diff {\n   \
    \         push_str.push('(');\n        }\n        t_temp = push_str + &t_temp;\n\
    \    } else {\n        let mut push_str = String::from(\"\");\n        for _ in\
    \ 0\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpcnudo3gc.rs:88:3\n\
    \   |\n12 | fn match_parens(lst: Vec<String>) -> String {\n   |              \
    \                               - unclosed delimiter\n...\n69 |     } else {\n\
    \   |            - this delimiter might not be properly closed...\n...\n72 | }\n\
    \   | - ...as it matches this but it has different indentation\n...\n88 | }\n\
    \   |   ^\n\nerror: expected `{`, found `}`\n  --> /tmp/tmpcnudo3gc.rs:72:1\n\
    \   |\n72 | }\n   | ^ expected `{`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpcnudo3gc.rs:12:38\n\
    \   |\n12 | fn match_parens(lst: Vec<String>) -> String {\n   |    ------------\
    \                      ^^^^^^ expected struct `String`, found `()`\n   |    |\n\
    \   |    implicitly returns `()` as its body has no tail or `return` expression\n\
    \nerror: aborting due to 3 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp2dzz_ulk.rs:13:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut cnt = 0;\n    for c in lst[0].chars().chain(lst[1].chars())\
    \ {\n        if c == '(' {\n            cnt += 1;\n        } else {\n        \
    \    cnt -= 1;\n        }\n        if cnt < 0 {\n            return \"No\".to_string();\n\
    \        }\n    }\n    if cnt == 0 {\n        \"Yes\".to_string()\n    } else\
    \ {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp_nx2845m.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in lst {\n        s.push_str(&i);\n\
    \    }\n    if !valid_parentheses(&s) {\n        return \"No\".to_string();\n\
    \    }\n    let mut stack = Vec::new();\n    for ch in s.chars() {\n        if\
    \ ch == '(' {\n            stack.push(ch);\n        } else {\n            if stack.len()\
    \ > 0 {\n                stack.pop();\n            } else {\n                return\
    \ \"No\".to_string();\n            }\n        }\n    }\n    \"Yes\".to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `valid_parentheses` in this scope\n\
    \  --> /tmp/tmpid6ntkqz.rs:17:9\n   |\n17 |     if !valid_parentheses(&s) {\n\
    \   |         ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Try to match the first string with the second string using\n\
    \    // parentheses to match the parentheses.\n    // If the match is found, then\
    \ return Yes, otherwise No.\n    let mut b = 0;\n    for c in lst[0].chars() {\n\
    \        if c == '(' {\n            b += 1;\n        } else {\n            b -=\
    \ 1;\n        }\n    }\n    if b == 0 {\n        return \"Yes\".to_string();\n\
    \    }\n    for c in lst[1].chars() {\n        if c == '(' {\n            b +=\
    \ 1;\n        } else {\n            b -= 1;\n        }\n        if b == 0 {\n\
    \            return \"Yes\".to_string();\n        }\n    }\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp2ui1zsnj.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut sum: i32 = 0;\n    for s in lst {\n        for c in\
    \ s.chars() {\n            if c == '(' {\n                sum += 1;\n        \
    \    } else {\n                sum -= 1;\n            }\n            if sum <\
    \ 0 {\n                return \"No\".to_string();\n            }\n        }\n\
    \    }\n    if sum == 0 {\n        \"Yes\".to_string()\n    } else {\n       \
    \ \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp00mvxfdf.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // variable to store the total number of open parentheses\n\
    \    let mut total_open_parens = 0;\n    // iterate through each string in the\
    \ list\n    for s in lst {\n        // iterate through each character in the string\n\
    \        for c in s.chars() {\n            // increment the total count if an\
    \ open parentheses was found\n            if c == '(' {\n                total_open_parens\
    \ += 1;\n            }\n            // decrement the total count if a close parentheses\
    \ was found\n            else if c == ')' {\n                total_open_parens\
    \ -= 1;\n            }\n            // if there are too many closing parentheses,\
    \ return \"No\" immediately\n            if total_open_parens < 0 {\n        \
    \        return \"No\".to_string();\n            }\n        }\n    }\n    // if\
    \ there are no remaining open parentheses, return \"Yes\"\n    if total_open_parens\
    \ == 0 {\n        \"Yes\".to_string()\n    }\n    // otherwise, return \"No\"\n\
    \    else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpgymbyd8n.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lhs: String = lst[0].clone();\n    let mut rhs: String\
    \ = lst[1].clone();\n    // loop until balanced or nothing more to do\n    loop\
    \ {\n        if balance(&lhs) && balance(&rhs) {\n            return \"Yes\".to_string();\n\
    \        }\n        if lhs.len() > 0 && rhs.len() > 0 {\n            if lhs.remove(0)\
    \ == '(' {\n                rhs.push(')');\n            } else {\n           \
    \     rhs.push('(');\n            }\n        } else {\n            return \"No\"\
    .to_string();\n        }\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `balance` in this scope\n  --> /tmp/tmpheq17_rb.rs:17:12\n\
    \   |\n17 |         if balance(&lhs) && balance(&rhs) {\n   |            ^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `balance` in this\
    \ scope\n  --> /tmp/tmpheq17_rb.rs:17:29\n   |\n17 |         if balance(&lhs)\
    \ && balance(&rhs) {\n   |                             ^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // A string is considered good if and only if all parentheses\
    \ in it are\n    // balanced.\n    // A string is balanced if the number of left\
    \ parenthesis is greater than\n    // or equal to the number of right parenthesis.\n\
    \    let mut n_open = 0;\n    let mut n_close = 0;\n    for c in lst[0].chars()\
    \ {\n        if c == '(' {\n            n_open += 1;\n        } else {\n     \
    \       n_close += 1;\n        }\n    }\n    for c in lst[1].chars() {\n     \
    \   if c == '(' {\n            n_open += 1;\n        } else {\n            n_close\
    \ += 1;\n        }\n    }\n    if n_open >= n_close {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpfg_4_u5r.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    s.push_str(&lst[1]);\n   \
    \ if is_good(&s) { \"Yes\".to_string() } else { \"No\".to_string() }\n}\n\nfn\
    \ main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpo0l706sf.rs:15:8\n\
    \   |\n15 |     if is_good(&s) { \"Yes\".to_string() } else { \"No\".to_string()\
    \ }\n   |        ^^^^^^^ not found in this scope\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (s1, s2) = (&lst[0], &lst[1]);\n    if s1.len() == s2.len()\
    \ {\n        return if s1 == s2 { \"Yes\".to_string() } else { \"No\".to_string()\
    \ };\n    }\n    let (x, y) = (s1.len(), s2.len());\n    let (s1, s2) = if x >\
    \ y {\n        (s1, s2)\n    } else {\n        (s2, s1)\n    };\n    let mut l\
    \ = s1.len() - s2.len();\n    for _ in 0..l {\n        if let Some(c) = s1.chars().last()\
    \ {\n            if c == '(' {\n                if let Some(a) = s2.chars().next()\
    \ {\n                    if a == ')' {\n                        l -= 1;\n    \
    \                }\n                }\n            }\n        }\n    }\n    if\
    \ l > 0 {\n        return \"No\".to_string();\n    }\n    let mut open = 0;\n\
    \    let mut close = 0;\n    for c in s1.chars() {\n        if c == '(' {\n  \
    \          open += 1;\n        } else {\n            close += 1;\n        }\n\
    \    }\n    for c in s2.chars() {\n        if c == '(' {\n            open +=\
    \ 1;\n        } else {\n            close += 1;\n        }\n    }\n    if open\
    \ == close {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpvuwf4oq7.rs:64:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // TODO\n    \"No\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp2ctos2jn.rs:19:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    use std::collections::HashMap;\n    let mut map = HashMap::new();\n\
    \    map.insert('(', ')');\n    map.insert(')', '(');\n    let mut strs = lst.join(\"\
    \");\n    let mut balanced = false;\n    let mut temp = \"\".to_string();\n  \
    \  let mut i = 0;\n    let mut j = strs.len() - 1;\n    while !balanced && i <\
    \ j {\n        let ci = strs.chars().nth(i).unwrap();\n        let cj = strs.chars().nth(j).unwrap();\n\
    \        if ci == map.get(&cj).unwrap() {\n            balanced = true;\n    \
    \    } else {\n            temp.push(ci);\n            i += 1;\n        }\n  \
    \      if !balanced {\n            temp.push(cj);\n            j -= 1;\n     \
    \   }\n    }\n    if balanced {\n        \"Yes\".to_string()\n    } else {\n \
    \       if let Some(c) = strs.chars().nth(i) {\n            temp.push(c);\n  \
    \      }\n        if let Some(c) = strs.chars().nth(j) {\n            temp.push(c);\n\
    \        }\n        if temp.len() == 0 {\n            \"Yes\".to_string()\n  \
    \      } else {\n            \"No\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp2c2moebq.rs:25:18\n   |\n\
    25 |         if ci == map.get(&cj).unwrap() {\n   |                  ^^^^^^^^^^^^^^^^^^^^^\
    \ expected `char`, found `&char`\n   |\nhelp: consider dereferencing the borrow\n\
    \   |\n25 |         if ci == *map.get(&cj).unwrap() {\n   |                  +\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let (a, b) = (lst[0].chars().collect::<Vec<_>>(), lst[1].chars().collect::<Vec<_>>());\n\
    \    let mut stack_a = vec![];\n    let mut stack_b = vec![];\n    let good =\
    \ |stack: &Vec<char>| {\n        for ch in stack {\n            if *ch == ')'\
    \ {\n                return false;\n            }\n        }\n        true\n \
    \   };\n    for ch in a {\n        if ch == '(' {\n            stack_a.push(ch);\n\
    \        } else {\n            if let Some(x) = stack_a.pop() {\n            \
    \    if x != '(' {\n                    return \"No\".to_string();\n         \
    \       }\n            } else {\n                return \"No\".to_string();\n\
    \            }\n        }\n    }\n    for ch in b {\n        if ch == '(' {\n\
    \            stack_b.push(ch);\n        } else {\n            if let Some(x) =\
    \ stack_b.pop() {\n                if x != '(' {\n                    return \"\
    No\".to_string();\n                }\n            } else {\n                return\
    \ \"No\".to_string();\n            }\n        }\n    }\n    if good(&stack_a)\
    \ && good(&stack_b) {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpbejzbhyw.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let l1 = lst[0].chars().fold(0, |acc, c| {\n        match c\
    \ {\n            '(' => acc + 1,\n            ')' => acc - 1,\n            _ =>\
    \ acc,\n        }\n    });\n    let l2 = lst[1].chars().fold(0, |acc, c| {\n \
    \       match c {\n            '(' => acc + 1,\n            ')' => acc - 1,\n\
    \            _ => acc,\n        }\n    });\n    if l1 + l2 == 0 {\n        \"\
    Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpzylxkkh_.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut n_opens = 0;\n    let mut n_closes = 0;\n    let mut\
    \ possible = true;\n    for string in lst {\n        for c in string.chars() {\n\
    \            match c {\n                '(' => n_opens += 1,\n               \
    \ ')' => {\n                    if n_opens > 0 {\n                        n_opens\
    \ -= 1;\n                    } else {\n                        n_closes += 1;\n\
    \                    }\n                }\n                _ => (),\n        \
    \    }\n        }\n    }\n    if n_opens == n_closes {\n        possible = true;\n\
    \    } else {\n        possible = false;\n    }\n    return if possible {\n  \
    \      \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    };\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpmf6b_v7g.rs:54:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    s.push_str(&lst[1]);\n   \
    \ let mut v = Vec::new();\n    for c in s.chars() {\n        match c {\n     \
    \       '(' => v.push(c),\n            ')' => {\n                if let Some(d)\
    \ = v.pop() {\n                    if d != '(' {\n                        return\
    \ \"No\".to_string();\n                    }\n                } else {\n     \
    \               return \"No\".to_string();\n                }\n            }\n\
    \            _ => (),\n        }\n    }\n    if v.len() > 0 {\n        return\
    \ \"No\".to_string();\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpm9twz7pe.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut left = 0;\n    let mut right = 0;\n    let mut left_str\
    \ = String::new();\n    let mut right_str = String::new();\n    for ch in lst[0].chars()\
    \ {\n        if ch == '(' {\n            left += 1;\n            left_str.push(ch);\n\
    \        } else {\n            right += 1;\n            right_str.push(ch);\n\
    \        }\n    }\n    for ch in lst[1].chars() {\n        if ch == '(' {\n  \
    \          left += 1;\n            left_str.push(ch);\n        } else {\n    \
    \        right += 1;\n            right_str.push(ch);\n        }\n    }\n    let\
    \ mut final_str = String::new();\n    if left == right {\n        for _ in 0..left\
    \ {\n            final_str.push('(');\n        }\n        for _ in 0..right {\n\
    \            final_str.push(')');\n        }\n        return \"Yes\".to_string();\n\
    \    } else {\n        if left > right {\n            let mut temp = String::new();\n\
    \            for _ in 0..(left - right) {\n                temp.push('(');\n \
    \           }\n            final_str.push_str(&left_str);\n            final_str.push_str(&right_str);\n\
    \            final_str.push_str(&temp);\n            for _ in 0..right {\n   \
    \             final_str.push(')');\n            }\n            return \"Yes\"\
    .to_string();\n        } else {\n            let mut temp = String::new();\n \
    \           for _ in 0..(right - left) {\n                temp.push(')');\n  \
    \          }\n            final_str.push_str(&left_str);\n            final_str.push_str(&right_str);\n\
    \            final_str.push_str(&temp);\n            for _ in 0..left {\n    \
    \            final_str.push('(');\n            }\n            return \"Yes\".to_string();\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpnq1tg0ik.rs:76:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    s.push_str(&lst[1]);\n   \
    \ let mut count = 0;\n    for c in s.chars() {\n        if c == '(' {\n      \
    \      count += 1;\n        } else {\n            count -= 1;\n        }\n   \
    \     if count < 0 {\n            return \"No\".to_string();\n        }\n    }\n\
    \    if count == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp8nh0p2hj.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    for i in 0..lst[0].len() {\n      \
    \  if lst[0].chars().nth(i).unwrap() == '(' {\n            count += 1;\n     \
    \   } else {\n            count -= 1;\n        }\n        if count < 0 {\n   \
    \         return \"No\".to_string();\n        }\n    }\n    for i in 0..lst[1].len()\
    \ {\n        if lst[1].chars().nth(i).unwrap() == '(' {\n            count +=\
    \ 1;\n        } else {\n            count -= 1;\n        }\n        if count <\
    \ 0 {\n            return \"No\".to_string();\n        }\n    }\n    if count\
    \ == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpuep6ehsl.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    let mut good = false;\n    if is_good(&s1) || is_good(&s2) {\n        good\
    \ = true;\n    } else {\n        for _ in 0..s1.len() {\n            if is_good(&s1)\
    \ || is_good(&s2) {\n                good = true;\n                break;\n  \
    \          }\n            s1.push(s2.pop().unwrap());\n        }\n    }\n    if\
    \ good {\n        String::from(\"Yes\")\n    } else {\n        String::from(\"\
    No\")\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpirzr8t4x.rs:16:8\n\
    \   |\n16 |     if is_good(&s1) || is_good(&s2) {\n   |        ^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_good` in this scope\n\
    \  --> /tmp/tmpirzr8t4x.rs:16:24\n   |\n16 |     if is_good(&s1) || is_good(&s2)\
    \ {\n   |                        ^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_good` in this scope\n  --> /tmp/tmpirzr8t4x.rs:20:16\n\
    \   |\n20 |             if is_good(&s1) || is_good(&s2) {\n   |              \
    \  ^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_good`\
    \ in this scope\n  --> /tmp/tmpirzr8t4x.rs:20:32\n   |\n20 |             if is_good(&s1)\
    \ || is_good(&s2) {\n   |                                ^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 4 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // It is easy to see that if there are no open parentheses\
    \ on one side,\n    // then we need to have equal numbers of closed and open parentheses\
    \ on\n    // the other side, and vice versa.\n    // Thus, we need only count\
    \ the number of closed parentheses on one side\n    // and the number of open\
    \ parentheses on the other side.\n\n    // First, check that both strings have\
    \ equal number of parentheses\n    let num_open_1 = lst[0].chars().filter(|&c|\
    \ c == '(').count();\n    let num_open_2 = lst[1].chars().filter(|&c| c == '(').count();\n\
    \    let num_closed_1 = lst[0].chars().filter(|&c| c == ')').count();\n    let\
    \ num_closed_2 = lst[1].chars().filter(|&c| c == ')').count();\n    if num_open_1\
    \ != num_open_2 || num_closed_1 != num_closed_2 {\n        return \"No\".to_string();\n\
    \    }\n\n    // Now we need to check that the number of closed parentheses in\
    \ lst[0]\n    // is greater than or equal to the number of open parentheses in\
    \ lst[1]\n    // and vice versa.\n    let num_open_diff = num_open_1 - num_open_2;\n\
    \    let num_closed_diff = num_closed_1 - num_closed_2;\n    if num_open_diff.abs()\
    \ <= num_closed_diff {\n        return \"Yes\".to_string();\n    } else {\n  \
    \      return \"No\".to_string();\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `abs` found for type `usize` in the current\
    \ scope\n  --> /tmp/tmp3qhjtqsp.rs:33:22\n   |\n33 |     if num_open_diff.abs()\
    \ <= num_closed_diff {\n   |                      ^^^ method not found in `usize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // We can represent the number of open parens that we need\
    \ to close as an\n    // integer. Here we initialize the value to 0 because we\
    \ have not opened\n    // any parens at this point.\n    let mut num_parens =\
    \ 0;\n\n    // We iterate over the elements of the list, one at a time, building\
    \ a result\n    // string as we go.\n    let result = lst.iter().fold(String::new(),\
    \ |s, e| {\n        // Now we add the current string to the result\n        let\
    \ s = format!(\"{}{}\", s, e);\n\n        // And update the number of parens accordingly.\
    \ If the current string\n        // has an open paren, the number of parens to\
    \ close increases by 1,\n        // otherwise it decreases by 1.\n        match\
    \ e.as_ref() {\n            \"(\" => num_parens += 1,\n            \")\" => num_parens\
    \ -= 1,\n            _ => (),\n        }\n\n        // We return the result string\n\
    \        s\n    });\n\n    // If the number of parens is 0 at the end of the loop\
    \ then we have successfully\n    // balanced all the parens, otherwise we have\
    \ failed.\n    if num_parens == 0 {\n        \"Yes\".to_string()\n    } else {\n\
    \        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpfu4c71fo.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.is_empty() {\n        return \"No\".to_string();\n \
    \   }\n\n    let mut num_parens = 0;\n    for s in lst {\n        for c in s.chars()\
    \ {\n            match c {\n                '(' => num_parens += 1,\n        \
    \        ')' => num_parens -= 1,\n                _ => {}\n            }\n   \
    \         if num_parens < 0 {\n                return \"No\".to_string();\n  \
    \          }\n        }\n    }\n\n    if num_parens == 0 {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpypeigbs6.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let s = lst[0].clone() + &lst[1];\n    let mut stack = vec![];\n\
    \    for c in s.chars() {\n        if c == '(' {\n            stack.push(c);\n\
    \        } else {\n            if stack.is_empty() {\n                return \"\
    No\".to_string();\n            }\n            stack.pop();\n        }\n    }\n\
    \    if stack.is_empty() {\n        \"Yes\".to_string()\n    } else {\n      \
    \  \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmplyg9zpch.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut str1 = &lst[0];\n    let mut str2 = &lst[1];\n    for\
    \ _ in 0..4 {\n        if lst[0].len() + lst[1].len() == count_good_parens(str1,\
    \ str2) {\n            return \"Yes\".to_string();\n        }\n        match str1.split_at(1)\
    \ {\n            (\"(\", tail) => str1 = tail,\n            (\")\", tail) => str1\
    \ = tail,\n            _ => panic!(\"unreachable\"),\n        }\n        match\
    \ str2.split_at(1) {\n            (\"(\", tail) => str2 = tail,\n            (\"\
    )\", tail) => str2 = tail,\n            _ => panic!(\"unreachable\"),\n      \
    \  }\n    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_good_parens` in this scope\n\
    \  --> /tmp/tmp_3m8zasl.rs:16:43\n   |\n16 |         if lst[0].len() + lst[1].len()\
    \ == count_good_parens(str1, str2) {\n   |                                   \
    \        ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp_3m8zasl.rs:20:35\n   |\n13 |     let mut str1 = &lst[0];\n\
    \   |                    ------- expected due to this value\n...\n20 |       \
    \      (\"(\", tail) => str1 = tail,\n   |                                   ^^^^\
    \ expected struct `String`, found `str`\n   |\n   = note: expected reference `&String`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_3m8zasl.rs:21:35\n   |\n13 |     let mut str1 = &lst[0];\n   |    \
    \                ------- expected due to this value\n...\n21 |             (\"\
    )\", tail) => str1 = tail,\n   |                                   ^^^^ expected\
    \ struct `String`, found `str`\n   |\n   = note: expected reference `&String`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_3m8zasl.rs:25:35\n   |\n14 |     let mut str2 = &lst[1];\n   |    \
    \                ------- expected due to this value\n...\n25 |             (\"\
    (\", tail) => str2 = tail,\n   |                                   ^^^^ expected\
    \ struct `String`, found `str`\n   |\n   = note: expected reference `&String`\n\
    \              found reference `&str`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp_3m8zasl.rs:26:35\n   |\n14 |     let mut str2 = &lst[1];\n   |    \
    \                ------- expected due to this value\n...\n26 |             (\"\
    )\", tail) => str2 = tail,\n   |                                   ^^^^ expected\
    \ struct `String`, found `str`\n   |\n   = note: expected reference `&String`\n\
    \              found reference `&str`\n\nerror: aborting due to 5 previous errors\n\
    \nSome errors have detailed explanations: E0308, E0425.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens = vec![];\n    for s in lst {\n        for c\
    \ in s.chars() {\n            if c == '(' {\n                parens.push(c);\n\
    \            } else {\n                match parens.pop() {\n                \
    \    Some('(') => (),\n                    _ => return \"No\".to_string(),\n \
    \               }\n            }\n        }\n    }\n    if parens.is_empty() {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp4x93uzfr.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut ans = String::from(\"Yes\");\n    let mut left = 0;\n\
    \    let mut right = 0;\n    for s in lst {\n        for c in s.chars() {\n  \
    \          if c == '(' {\n                left += 1;\n            } else {\n \
    \               right += 1;\n            }\n        }\n    }\n    if left != right\
    \ {\n        ans = String::from(\"No\");\n    }\n    ans\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp6bb3ub0x.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut first = lst[0].clone();\n    let mut second = lst[1].clone();\n\
    \    let mut count_left = 0;\n    let mut count_right = 0;\n    for c in first.chars()\
    \ {\n        if c == '(' {\n            count_left += 1;\n        } else {\n \
    \           count_right += 1;\n        }\n    }\n    for c in second.chars() {\n\
    \        if c == '(' {\n            count_left += 1;\n        } else {\n     \
    \       count_right += 1;\n        }\n    }\n    if count_left != count_right\
    \ {\n        return \"No\".to_string();\n    }\n    while first.len() > 0 && second.len()\
    \ > 0 {\n        if first.chars().nth(0).unwrap() == '(' && second.chars().nth(0).unwrap()\
    \ == ')' {\n            return \"No\".to_string();\n        }\n        if first.chars().nth(0).unwrap()\
    \ == ')' && second.chars().nth(0).unwrap() == '(' {\n            return \"No\"\
    .to_string();\n        }\n        if first.chars().nth(0).unwrap() == '(' {\n\
    \            first = first.chars().skip(1).collect();\n        } else {\n    \
    \        first = first.chars().skip(1).collect();\n        }\n        if second.chars().nth(0).unwrap()\
    \ == '(' {\n            second = second.chars().skip(1).collect();\n        }\
    \ else {\n            second = second.chars().skip(1).collect();\n        }\n\
    \    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp_xux6qni.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut count = 0;\n  \
    \  for ch in s1.iter() {\n        match ch {\n            '(' => count += 1,\n\
    \            ')' => count -= 1,\n            _ => panic!(\"only parens!\"),\n\
    \        }\n    }\n    for ch in s2.iter() {\n        match ch {\n           \
    \ '(' => count += 1,\n            ')' => count -= 1,\n            _ => panic!(\"\
    only parens!\"),\n        }\n    }\n    if count == 0 {\n        return \"Yes\"\
    .to_string();\n    }\n    return \"No\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"\
    ), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmplbs9cw99.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.iter().map(|s| s.chars().collect::<Vec<_>>()).collect::<Vec<_>>();\n\
    \    let mut left = 0;\n    let mut right = 0;\n    for (i, x) in lst[0].iter().enumerate()\
    \ {\n        if *x == '(' {\n            left += 1;\n        } else {\n      \
    \      right += 1;\n        }\n        if left < right {\n            break;\n\
    \        }\n    }\n    let mut left = 0;\n    let mut right = 0;\n    for (i,\
    \ x) in lst[1].iter().rev().enumerate() {\n        if *x == ')' {\n          \
    \  left += 1;\n        } else {\n            right += 1;\n        }\n        if\
    \ left < right {\n            break;\n        }\n    }\n    if left < right {\n\
    \        \"No\".to_string()\n    } else {\n        \"Yes\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpmdflmckz.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    lst.iter().fold(String::new(), |acc, x| {\n        let mut\
    \ a = acc.chars().rev().peekable();\n        let b = x.chars().peekable();\n \
    \       let mut res = String::new();\n        for c in b {\n            if a.peek()\
    \ == Some(&'(') && c == ')' {\n                a.next();\n            } else {\n\
    \                res.push(c);\n            }\n        }\n        res.chars().rev().collect::<String>()\
    \ + &a.collect::<String>()\n    })\n    .chars()\n    .fold(true, |acc, x| acc\
    \ && x == '(')\n    .to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"false\"`,\n right: `\"Yes\"`', /tmp/tmpt80anps2.rs:33:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.is_empty() {\n        return \"Yes\".to_string();\n\
    \    }\n\n    let mut lst: Vec<char> = lst[0].chars().collect();\n    lst.append(&mut\
    \ lst[1].chars().collect());\n\n    //println!(\"{:?}\", lst);\n\n    let mut\
    \ stack: Vec<char> = Vec::new();\n    for p in lst {\n        if p == '(' {\n\
    \            stack.push(p);\n        } else {\n            if stack.is_empty()\
    \ {\n                return \"No\".to_string();\n            } else {\n      \
    \          stack.pop();\n            }\n        }\n    }\n\n    if stack.is_empty()\
    \ {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `chars` found for type `char` in the current\
    \ scope\n  --> /tmp/tmpnhony7pt.rs:18:28\n   |\n18 |     lst.append(&mut lst[1].chars().collect());\n\
    \   |                            ^^^^^ method not found in `char`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let lst_ref = &lst;\n    let lst_vec: Vec<char> = format!(\"\
    {}{}\", lst_ref[0], lst_ref[1])\n        .chars()\n        .collect();\n    let\
    \ mut bracket_count = 0;\n    for i in lst_vec {\n        if i == '(' {\n    \
    \        bracket_count += 1;\n        } else {\n            bracket_count -= 1;\n\
    \        }\n        if bracket_count < 0 {\n            return \"No\".to_string();\n\
    \        }\n    }\n    if bracket_count == 0 {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpbit4mnd9.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut close_needed = 0;\n    let mut open_needed = 0;\n \
    \   for (i, s) in lst.iter().enumerate() {\n        let mut b = 0;\n        for\
    \ c in s.chars() {\n            if c == '(' {\n                b += 1;\n     \
    \       } else {\n                b -= 1;\n            }\n            if b < 0\
    \ {\n                if i == 0 {\n                    close_needed += 1;\n   \
    \             } else {\n                    open_needed += 1;\n              \
    \  }\n            }\n        }\n        if i == 0 {\n            open_needed +=\
    \ b;\n        } else {\n            close_needed += b;\n        }\n    }\n   \
    \ if open_needed == 0 && close_needed == 0 {\n        \"Yes\".to_string()\n  \
    \  } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpgrgtvicg.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut result = String::from(\"\
    Yes\");\n    for st in lst {\n        for ch in st.chars() {\n            if ch\
    \ == '(' {\n                stack.push(ch);\n            } else {\n          \
    \      if let Some(&lst_ch) = stack.last() {\n                    if lst_ch ==\
    \ '(' {\n                        stack.pop();\n                    } else {\n\
    \                        stack.push(ch);\n                    }\n            \
    \    } else {\n                    stack.push(ch);\n                }\n      \
    \      }\n        }\n    }\n    if !stack.is_empty() {\n        result = String::from(\"\
    No\");\n    }\n    result\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp4akb1lwe.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut ans = 'N';\n    for (i, s) in lst.iter().enumerate()\
    \ {\n        for (j, t) in lst.iter().enumerate() {\n            if i == j {\n\
    \                continue;\n            }\n            if balanced(&(s.clone()\
    \ + t)) {\n                ans = 'Y';\n            }\n        }\n    }\n    ans.to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `balanced` in this scope\n  --> /tmp/tmpfr_wl6rb.rs:19:16\n\
    \   |\n19 |             if balanced(&(s.clone() + t)) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let l0: Vec<_> = lst[0].chars().collect();\n    let l1: Vec<_>\
    \ = lst[1].chars().collect();\n    match l0.len() + l1.len() {\n        0 => \"\
    Yes\".to_string(),\n        2 => {\n            if l0[0] == '(' && l1[0] == ')'\
    \ {\n                \"Yes\".to_string()\n            } else {\n             \
    \   \"No\".to_string()\n            }\n        }\n        4 => {\n           \
    \ if l0[0] == '(' && l0[1] == ')' && l1[0] == '(' && l1[1] == ')' {\n        \
    \        \"Yes\".to_string()\n            } else {\n                \"No\".to_string()\n\
    \            }\n        }\n        _ => \"No\".to_string(),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp7qk4gphx.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // There are two cases:\n    // 1. One starts with an open\
    \ paren and the other starts with a closed paren.\n    // 2. Both start with the\
    \ same kind of paren.\n    // For the first case, the second string will always\
    \ be a suffix of the first,\n    // therefore it must be good.\n    // For the\
    \ second case, we could concatenate the strings to form a larger string.\n   \
    \ // For example, \"()\" and \"()\" will yield \"()()\".\n    // The problem is\
    \ now reduced to checking whether or not the two strings concatenated\n    //\
    \ is a good string.\n    let s1 = &lst[0];\n    let s2 = &lst[1];\n    let s1_open\
    \ = s1.starts_with('(');\n    let s2_open = s2.starts_with('(');\n    if s1_open\
    \ != s2_open {\n        \"Yes\".to_string()\n    } else {\n        if is_good(&(s1.to_string()\
    \ + s2)) {\n            \"Yes\".to_string()\n        } else {\n            \"\
    No\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good` in this scope\n  --> /tmp/tmpdj6_gwz4.rs:29:12\n\
    \   |\n29 |         if is_good(&(s1.to_string() + s2)) {\n   |            ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // your code here\n    unimplemented!();\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8ycgwq0j.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // The fast solution is to just count the number of opening\n\
    \    // and closing parens, and if there is an equal number of\n    // both, then\
    \ it is possible to concatenate them.\n    // There is no need to check order,\
    \ or anything else.\n    let mut open = 0;\n    let mut close = 0;\n    for s\
    \ in lst {\n        for c in s.chars() {\n            match c {\n            \
    \    '(' => open += 1,\n                ')' => close += 1,\n                _\
    \ => (),\n            }\n        }\n    }\n    if open == close {\n        \"\
    Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpt6wbb1il.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        panic!(\"List must contain exactly\
    \ two strings\");\n    }\n    let mut s = String::new();\n    for i in 0..2 {\n\
    \        let mut count = 0;\n        for c in lst[i].chars() {\n            match\
    \ c {\n                '(' => count += 1,\n                ')' => count -= 1,\n\
    \                _ => panic!(\"String must contain only parenthesis\"),\n    \
    \        }\n            if count < 0 {\n                return \"No\".to_string();\n\
    \            }\n        }\n        s.push_str(&lst[i]);\n    }\n    let mut balance\
    \ = 0;\n    for c in s.chars() {\n        match c {\n            '(' => balance\
    \ += 1,\n            ')' => balance -= 1,\n            _ => panic!(\"String must\
    \ contain only parenthesis\"),\n        }\n        if balance < 0 {\n        \
    \    return \"No\".to_string();\n        }\n    }\n    if balance == 0 {\n   \
    \     \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp37tah7oy.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // Write your code here\n    let mut left_stack = vec![];\n\
    \    let mut right_stack = vec![];\n    for (i, v) in lst.iter().enumerate() {\n\
    \        if i == 0 {\n            for c in v.chars() {\n                if c ==\
    \ '(' {\n                    left_stack.push(c);\n                } else {\n \
    \                   right_stack.push(c);\n                }\n            }\n \
    \       } else {\n            for c in v.chars() {\n                if c == '('\
    \ {\n                    if right_stack.len() > 0 {\n                        right_stack.pop();\n\
    \                    } else {\n                        left_stack.push(c);\n \
    \                   }\n                } else {\n                    left_stack.push(c);\n\
    \                }\n            }\n        }\n    }\n    if left_stack.len() >\
    \ 0 {\n        String::from(\"No\")\n    } else {\n        String::from(\"Yes\"\
    )\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp03nnrmeq.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    // TODO: Write solution here\n    unimplemented!();\n}\n\n\
    fn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpxgrlqtxh.rs:14:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    match (lst[0].to_string(), lst[1].to_string()) {\n        (\"\
    (\", \")\") => \"Yes\".to_string(),\n        (\")\", \"(\") => \"Yes\".to_string(),\n\
    \        _ => \"No\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpkdmo716o.rs:14:10\n   |\n\
    13 |     match (lst[0].to_string(), lst[1].to_string()) {\n   |           ----------------------------------------\
    \ this expression has type `(String, String)`\n14 |         (\"(\", \")\") =>\
    \ \"Yes\".to_string(),\n   |          ^^^ expected struct `String`, found `&str`\n\
    \nerror[E0308]: mismatched types\n  --> /tmp/tmpkdmo716o.rs:14:15\n   |\n13 |\
    \     match (lst[0].to_string(), lst[1].to_string()) {\n   |           ----------------------------------------\
    \ this expression has type `(String, String)`\n14 |         (\"(\", \")\") =>\
    \ \"Yes\".to_string(),\n   |               ^^^ expected struct `String`, found\
    \ `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkdmo716o.rs:15:10\n\
    \   |\n13 |     match (lst[0].to_string(), lst[1].to_string()) {\n   |       \
    \    ---------------------------------------- this expression has type `(String,\
    \ String)`\n14 |         (\"(\", \")\") => \"Yes\".to_string(),\n15 |        \
    \ (\")\", \"(\") => \"Yes\".to_string(),\n   |          ^^^ expected struct `String`,\
    \ found `&str`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpkdmo716o.rs:15:15\n\
    \   |\n13 |     match (lst[0].to_string(), lst[1].to_string()) {\n   |       \
    \    ---------------------------------------- this expression has type `(String,\
    \ String)`\n14 |         (\"(\", \")\") => \"Yes\".to_string(),\n15 |        \
    \ (\")\", \"(\") => \"Yes\".to_string(),\n   |               ^^^ expected struct\
    \ `String`, found `&str`\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack: Vec<char> = Vec::new();\n    for char in lst[0].chars()\
    \ {\n        if char == '(' {\n            stack.push(char);\n        } else {\n\
    \            if let Some(c) = stack.pop() {\n                if c != '(' {\n \
    \                   return \"No\".to_string();\n                }\n          \
    \  } else {\n                return \"No\".to_string();\n            }\n     \
    \   }\n    }\n    for char in lst[1].chars() {\n        if char == '(' {\n   \
    \         stack.push(char);\n        } else {\n            if let Some(c) = stack.pop()\
    \ {\n                if c != '(' {\n                    return \"No\".to_string();\n\
    \                }\n            } else {\n                return \"No\".to_string();\n\
    \            }\n        }\n    }\n    \"Yes\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpbc91ezk8.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    use std::collections::HashMap;\n    let mut lst_chars: Vec<Vec<char>>\
    \ = Vec::new();\n    for s in lst {\n        lst_chars.push(s.chars().collect());\n\
    \    }\n    let (lst_chars, mut combinations) = exhaust(&lst_chars, &mut 0);\n\
    \    let mut map: HashMap<String, i32> = HashMap::new();\n    for i in 0..combinations.len()\
    \ {\n        map.insert(combinations[i].clone(), i);\n    }\n    // println!(\"\
    {:?}\", map);\n    let mut res: Vec<String> = Vec::new();\n    // println!(\"\
    {:?}\", lst_chars);\n    permutate(&mut lst_chars, &mut 0, &mut res);\n    //\
    \ println!(\"{:?}\", res);\n    for s in res {\n        if map.contains_key(&s)\
    \ {\n            return \"Yes\".to_string();\n        }\n    }\n    \"No\".to_string()\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `exhaust` in this scope\n  --> /tmp/tmprbxh7r60.rs:18:41\n\
    \   |\n18 |     let (lst_chars, mut combinations) = exhaust(&lst_chars, &mut 0);\n\
    \   |                                         ^^^^^^^ not found in this scope\n\
    \nerror[E0425]: cannot find function `permutate` in this scope\n  --> /tmp/tmprbxh7r60.rs:26:5\n\
    \   |\n26 |     permutate(&mut lst_chars, &mut 0, &mut res);\n   |     ^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let lft = &lst[0];\n    let rgt = &lst[1];\n    if lft.len()\
    \ > rgt.len() {\n        if lft.len() % 2 == 0 {\n            return \"Yes\".to_string();\n\
    \        }\n        return \"No\".to_string();\n    }\n    let mut c = 0;\n  \
    \  for (i, ch) in lft.chars().enumerate() {\n        if ch == '(' {\n        \
    \    c += 1;\n        } else {\n            c -= 1;\n        }\n        if c <=\
    \ 0 {\n            break;\n        }\n        if i == lft.len() - 1 {\n      \
    \      return \"Yes\".to_string();\n        }\n    }\n    if c > 0 {\n       \
    \ return \"No\".to_string();\n    }\n    let mut c = 0;\n    for (i, ch) in rgt.chars().enumerate()\
    \ {\n        if ch == ')' {\n            c += 1;\n        } else {\n         \
    \   c -= 1;\n        }\n        if c <= 0 {\n            break;\n        }\n \
    \       if i == rgt.len() - 1 {\n            return \"Yes\".to_string();\n   \
    \     }\n    }\n    if c > 0 {\n        return \"No\".to_string();\n    }\n  \
    \  \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpv5xc16nw.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s: String = String::new();\n    let mut count: i32\
    \ = 0;\n    for s1 in lst {\n        s.push_str(&s1);\n    }\n    for i in s.chars()\
    \ {\n        if i == '(' {\n            count += 1;\n        } else {\n      \
    \      count -= 1;\n        }\n        if count < 0 {\n            return String::from(\"\
    No\");\n        }\n    }\n    if count == 0 {\n        return String::from(\"\
    Yes\");\n    } else {\n        return String::from(\"No\");\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp3pvnr1rf.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut left = 0;\n    let\
    \ mut right = 0;\n    for i in lst[0].chars() {\n        if i == '(' {\n     \
    \       left += 1;\n        } else {\n            right += 1;\n        }\n   \
    \     stack.push(i);\n    }\n    for i in lst[1].chars() {\n        if i == '('\
    \ {\n            left += 1;\n        } else {\n            right += 1;\n     \
    \   }\n        stack.push(i);\n    }\n    if left != right {\n        return \"\
    No\".to_string();\n    }\n    for i in stack {\n        if i == '(' {\n      \
    \      if let Some(last) = stack.last() {\n                if *last == ')' {\n\
    \                    stack.pop();\n                }\n            }\n        }\n\
    \    }\n    if stack.is_empty() {\n        return \"Yes\".to_string();\n    }\n\
    \    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0382]: borrow of moved value: `stack`\n   --> /tmp/tmp51g8dipp.rs:37:33\n\
    \    |\n13  |     let mut stack = Vec::new();\n    |         --------- move occurs\
    \ because `stack` has type `Vec<char>`, which does not implement the `Copy` trait\n\
    ...\n35  |     for i in stack {\n    |              ----- `stack` moved due to\
    \ this implicit call to `.into_iter()`\n36  |         if i == '(' {\n37  |   \
    \          if let Some(last) = stack.last() {\n    |                         \
    \        ^^^^^^^^^^^^ value borrowed here after move\n    |\nnote: this function\
    \ takes ownership of the receiver `self`, which moves `stack`\n    = note: borrow\
    \ occurs due to deref coercion to `[char]`\nhelp: consider iterating over a slice\
    \ of the `Vec<char>`'s content to avoid moving into the `for` loop\n    |\n35\
    \  |     for i in &stack {\n    |              +\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0382`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut result = lst.clone();\n    result.sort();\n    if result\
    \ == lst {\n        return \"Yes\".to_string();\n    }\n    let mut result = result.clone();\n\
    \    result.reverse();\n    if result == lst {\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpsfhti80k.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let mut res = true;\n    for\
    \ c in lst[0].chars() {\n        if c == '(' {\n            stack.push(c);\n \
    \       } else {\n            if stack.is_empty() {\n                res = false;\n\
    \                break;\n            } else {\n                stack.pop();\n\
    \            }\n        }\n    }\n    for c in lst[1].chars() {\n        if c\
    \ == '(' {\n            stack.push(c);\n        } else {\n            if stack.is_empty()\
    \ {\n                res = false;\n                break;\n            } else\
    \ {\n                stack.pop();\n            }\n        }\n    }\n    if res\
    \ && stack.is_empty() {\n        return \"Yes\".to_string();\n    }\n    \"No\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp8ojfw_su.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut balance: i32 = 0;\n    for s in lst {\n        for\
    \ c in s.chars() {\n            if c == '(' {\n                balance += 1;\n\
    \            } else {\n                balance -= 1;\n            }\n        \
    \    if balance < 0 {\n                return \"No\".to_string();\n          \
    \  }\n        }\n    }\n    if balance == 0 {\n        \"Yes\".to_string()\n \
    \   } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp8ltw99db.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = String::new();\n    for i in &lst {\n        s.push_str(i);\n\
    \    }\n    if s.contains('(') && s.contains(')') {\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp4z7gc01g.rs:27:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut front = 0;\n    let mut back = 0;\n    for ch in lst[0].chars()\
    \ {\n        if ch == '(' {\n            front += 1;\n        } else {\n     \
    \       front -= 1;\n        }\n    }\n    for ch in lst[1].chars() {\n      \
    \  if ch == '(' {\n            back += 1;\n        } else {\n            back\
    \ -= 1;\n        }\n    }\n    if front == back {\n        return \"Yes\".to_string();\n\
    \    }\n    return \"No\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp2lu44gag.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut first = lst[0].clone();\n    let mut second = lst[1].clone();\n\
    \    // if ')' comes first, then we have to flip the second string.\n    if first.chars().next().unwrap()\
    \ == ')' {\n        second = second.chars().rev().collect();\n    }\n    let mut\
    \ stack = vec![];\n    let mut index = 0;\n    // collect 1, 2, 3 or 4 in the\
    \ stack.\n    while index < first.len() + second.len() {\n        if index < first.len()\
    \ {\n            stack.push(char_to_num(first.chars().nth(index).unwrap()));\n\
    \        } else {\n            stack.push(char_to_num(second.chars().nth(index\
    \ - first.len()).unwrap()));\n        }\n        index += 1;\n    }\n    // flip\
    \ 1 to 2 and 2 to 1.\n    while stack.len() > 0 {\n        if stack[0] == 1 &&\
    \ stack[1] == 2 {\n            stack[0] = 2;\n            stack[1] = 1;\n    \
    \    }\n        stack.remove(0);\n    }\n    if stack.len() == 0 {\n        return\
    \ \"Yes\".to_string();\n    } else {\n        return \"No\".to_string();\n   \
    \ }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `char_to_num` in this scope\n  --> /tmp/tmpxcn2fmvo.rs:24:24\n\
    \   |\n24 |             stack.push(char_to_num(first.chars().nth(index).unwrap()));\n\
    \   |                        ^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `char_to_num` in this scope\n  --> /tmp/tmpxcn2fmvo.rs:26:24\n\
    \   |\n26 |             stack.push(char_to_num(second.chars().nth(index - first.len()).unwrap()));\n\
    \   |                        ^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].chars().collect::<Vec<char>>();\n    let\
    \ mut s2 = lst[1].chars().collect::<Vec<char>>();\n    let mut s1_count = 0;\n\
    \    let mut s2_count = 0;\n    for ch in s1.iter() {\n        if *ch == '(' {\n\
    \            s1_count += 1;\n        } else {\n            s1_count -= 1;\n  \
    \      }\n    }\n    for ch in s2.iter() {\n        if *ch == '(' {\n        \
    \    s2_count += 1;\n        } else {\n            s2_count -= 1;\n        }\n\
    \    }\n    if s1_count != 0 && s2_count != 0 {\n        return \"No\".to_string();\n\
    \    }\n    if s1_count == 0 {\n        s1.extend(s2);\n    } else {\n       \
    \ s2.extend(s1);\n        s1 = s2;\n    }\n    let mut count = 0;\n    for ch\
    \ in s1.iter() {\n        if *ch == '(' {\n            count += 1;\n        }\
    \ else {\n            count -= 1;\n        }\n        if count < 0 {\n       \
    \     return \"No\".to_string();\n        }\n    }\n    if count == 0 {\n    \
    \    \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\
    \nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp8z80f7xo.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        return \"Bad input\".to_string();\n\
    \    }\n    if lst[0].len() == 0 || lst[1].len() == 0 {\n        return \"Yes\"\
    .to_string();\n    }\n    let mut st = Stack::new();\n    let mut i = 0;\n   \
    \ let mut tot_st = 0;\n    let mut tot_nd = 0;\n    while i < lst[0].len() {\n\
    \        if lst[0].chars().nth(i).unwrap() == '(' {\n            st.push('(');\n\
    \            tot_st += 1;\n        } else {\n            if st.empty() {\n   \
    \             tot_nd += 1;\n            } else {\n                st.pop();\n\
    \            }\n        }\n        i += 1;\n    }\n    i = 0;\n    while i < lst[1].len()\
    \ {\n        if lst[1].chars().nth(i).unwrap() == '(' {\n            st.push('(');\n\
    \            tot_st += 1;\n        } else {\n            if st.empty() {\n   \
    \             tot_nd += 1;\n            } else {\n                st.pop();\n\
    \            }\n        }\n        i += 1;\n    }\n    if tot_st < tot_nd {\n\
    \        return \"No\".to_string();\n    }\n    if st.empty() {\n        return\
    \ \"Yes\".to_string();\n    }\n    let mut v = st.split_off(tot_st - tot_nd);\n\
    \    if v.empty() {\n        return \"Yes\".to_string();\n    }\n    if v.len()\
    \ % 2 == 0 {\n        return \"Yes\".to_string();\n    }\n    return \"No\".to_string();\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `Stack`\n  -->\
    \ /tmp/tmp7i_yy6c3.rs:19:18\n   |\n19 |     let mut st = Stack::new();\n   | \
    \                 ^^^^^ use of undeclared type `Stack`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst: Vec<Vec<char>> = lst.iter().map(|s| s.chars().collect()).collect();\n\
    \    let mut left = 0;\n    let mut right = 0;\n    while let Some(ch) = lst[0].pop()\
    \ {\n        match ch {\n            '(' => left += 1,\n            ')' => right\
    \ += 1,\n            _ => panic!(\"Only parenthesis allowed\"),\n        }\n \
    \   }\n    while let Some(ch) = lst[1].pop() {\n        match ch {\n         \
    \   '(' => left -= 1,\n            ')' => right -= 1,\n            _ => panic!(\"\
    Only parenthesis allowed\"),\n        }\n    }\n    if left + right == 0 {\n \
    \       \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmprumurra_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut count = 0;\n    for c in lst[0].chars().chain(lst[1].chars())\
    \ {\n        match c {\n            '(' => count += 1,\n            ')' => count\
    \ -= 1,\n            _ => (),\n        }\n        if count < 0 {\n           \
    \ return \"No\".to_string();\n        }\n    }\n    if count == 0 {\n        \"\
    Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpc8f7c374.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let l = lst[0].clone();\n    let r = lst[1].clone();\n    let\
    \ mut stack = Vec::new();\n    for c in l.chars() {\n        if c == '(' {\n \
    \           stack.push(c);\n        } else {\n            if stack.len() == 0\
    \ {\n                return \"No\".to_string();\n            }\n            stack.pop();\n\
    \        }\n    }\n    for c in r.chars() {\n        if c == '(' {\n         \
    \   stack.push(c);\n        } else {\n            if stack.len() == 0 {\n    \
    \            return \"No\".to_string();\n            }\n            stack.pop();\n\
    \        }\n    }\n    if stack.len() == 0 {\n        \"Yes\".to_string()\n  \
    \  } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpryl2wc8z.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        return \"No\".to_string();\n \
    \   }\n    let s1 = lst[0].as_str();\n    let s2 = lst[1].as_str();\n    let mut\
    \ result = \"Yes\".to_string();\n    let mut parens = 0;\n    for c in s1.chars()\
    \ {\n        if c == '(' {\n            parens += 1;\n        } else {\n     \
    \       parens -= 1;\n        }\n        if parens < 0 {\n            result =\
    \ \"No\".to_string();\n            break;\n        }\n    }\n    if result ==\
    \ \"Yes\" {\n        for c in s2.chars() {\n            if c == '(' {\n      \
    \          parens += 1;\n            } else {\n                parens -= 1;\n\
    \            }\n            if parens < 0 {\n                result = \"No\".to_string();\n\
    \                break;\n            }\n        }\n    }\n    if parens != 0 {\n\
    \        result = \"No\".to_string();\n    }\n    result\n}\n\nfn main() {\n \
    \   let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpvw1xsxxd.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stk = Vec::new();\n    let mut balance = 0;\n    for\
    \ elem in lst.iter() {\n        for ch in elem.chars() {\n            match ch\
    \ {\n                '(' => {\n                    stk.push(ch);\n           \
    \         balance += 1;\n                }\n                ')' => {\n       \
    \             if stk.pop() != Some('(') {\n                        return \"No\"\
    .to_string();\n                    }\n                    balance -= 1;\n    \
    \            }\n                _ => panic!(\"non-paren char\"),\n           \
    \ }\n        }\n    }\n    if balance == 0 {\n        \"Yes\".to_string()\n  \
    \  } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmprqv66rsw.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lhs: Vec<char> = lst[0].chars().collect();\n    let\
    \ mut rhs: Vec<char> = lst[1].chars().collect();\n    let mut ok = false;\n  \
    \  let mut cur_bal = 0;\n    for _ in 0..4 {\n        if lhs.iter().filter(|&x|\
    \ *x == '(').count() == lhs.len() - 1 {\n            lhs.push(')');\n        }\
    \ else {\n            lhs.insert(0, '(');\n        }\n        if rhs.iter().filter(|&x|\
    \ *x == '(').count() == rhs.len() - 1 {\n            rhs.push(')');\n        }\
    \ else {\n            rhs.insert(0, '(');\n        }\n        cur_bal = 0;\n \
    \       for c in lhs.iter().chain(rhs.iter()) {\n            if *c == '(' {\n\
    \                cur_bal += 1;\n            } else {\n                cur_bal\
    \ -= 1;\n            }\n            if cur_bal < 0 {\n                break;\n\
    \            }\n        }\n        if cur_bal == 0 {\n            ok = true;\n\
    \            break;\n        }\n    }\n    if ok {\n        return \"Yes\".to_string();\n\
    \    }\n    \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmph5wrv6gd.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst;\n    lst.sort();\n    let s = lst.join(\"\
    \");\n    if s.len() % 2 == 1 {\n        return \"No\".to_string();\n    }\n \
    \   let mut r = 0;\n    for c in s.chars() {\n        match c {\n            '('\
    \ => r += 1,\n            ')' => r -= 1,\n            _ => panic!(\"Invalid character\"\
    ),\n        }\n        if r < 0 {\n            return \"No\".to_string();\n  \
    \      }\n    }\n    if r > 0 {\n        return \"No\".to_string();\n    }\n \
    \   \"Yes\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut left = 0;\n    let mut right = 0;\n    for x in lst[0].chars()\
    \ {\n        match x {\n            '(' => left += 1,\n            ')' => left\
    \ -= 1,\n            _ => (),\n        }\n    }\n    for x in lst[1].chars() {\n\
    \        match x {\n            '(' => right += 1,\n            ')' => right -=\
    \ 1,\n            _ => (),\n        }\n    }\n    if left > 0 && right < 0 {\n\
    \        \"Yes\".to_string()\n    } else if left < 0 && right > 0 {\n        \"\
    Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpkyjfsc_n.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut o = lst[0].clone();\n    let t = lst[1].clone();\n\
    \    o.push_str(&t);\n    if o.chars().rev().collect::<String>() == o {\n    \
    \    return \"Yes\".to_string();\n    }\n    \"No\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp6u7buhi2.rs:24:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut parens: Vec<char> = vec![];\n    for x in lst.join(\"\
    \").chars() {\n        match x {\n            '(' => parens.push(x),\n       \
    \     ')' => {\n                if parens.is_empty() {\n                    return\
    \ \"No\".to_string();\n                }\n                parens.pop();\n    \
    \        }\n            _ => panic!(\"unexpected character\"),\n        }\n  \
    \  }\n    if parens.is_empty() {\n        \"Yes\".to_string()\n    } else {\n\
    \        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp81kpaxic.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    use std::collections::HashMap;\n    let mut count = HashMap::new();\n\
    \    for s in lst {\n        for c in s.chars() {\n            let d = count.entry(c).or_insert(0);\n\
    \            *d += 1;\n        }\n    }\n    let bal = count.get(&'(').unwrap_or(&0)\
    \ - count.get(&')').unwrap_or(&0);\n    if bal == 0 {\n        \"Yes\".to_string()\n\
    \    } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmpx0yc5l_l.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst: Vec<char> = lst.join(\"\").chars().collect();\n\
    \    if lst.len() % 2 != 0 {\n        return \"No\".to_string();\n    }\n    for\
    \ _ in 0..lst.len() / 2 {\n        if let Some(i) = lst.iter().position(|x| *x\
    \ == '(') {\n            lst.remove(i);\n        }\n        if let Some(i) = lst.iter().position(|x|\
    \ *x == ')') {\n            lst.remove(i);\n        }\n    }\n    if lst.len()\
    \ > 0 {\n        \"No\".to_string()\n    } else {\n        \"Yes\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmphuu1a0l8.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s = lst[0].clone();\n    s.push_str(&lst[1]);\n   \
    \ let mut stack = Vec::new();\n    for c in s.chars() {\n        if stack.is_empty()\
    \ && c == ')' {\n            return \"No\".to_string();\n        }\n        if\
    \ c == '(' {\n            stack.push(c);\n        } else {\n            stack.pop();\n\
    \        }\n    }\n    if stack.is_empty() {\n        \"Yes\".to_string()\n  \
    \  } else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpe8l7lxgd.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    fn is_good(s: &str) -> bool {\n        let mut cnt = 0;\n \
    \       for &c in s.as_bytes() {\n            match c {\n                b'('\
    \ => cnt += 1,\n                b')' => cnt -= 1,\n                _ => (),\n\
    \            }\n            if cnt < 0 {\n                return false;\n    \
    \        }\n        }\n        cnt == 0\n    }\n    let &[ref s1, ref s2] = &lst[..];\n\
    \    if is_good(s1) && is_good(s2) {\n        \"Yes\".to_string()\n    } else\
    \ {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0005]: refutable pattern in local binding: `&[]`, `&[_]` and `&[_,\
    \ _, _, ..]` not covered\n  --> /tmp/tmpn03n5g9d.rs:27:9\n   |\n27 |     let &[ref\
    \ s1, ref s2] = &lst[..];\n   |         ^^^^^^^^^^^^^^^^^ patterns `&[]`, `&[_]`\
    \ and `&[_, _, _, ..]` not covered\n   |\n   = note: `let` bindings require an\
    \ \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n\
    \   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n\
    \   = note: the matched value is of type `&[String]`\nhelp: you might want to\
    \ use `if let` to ignore the variants that aren't matched\n   |\n27 |     let\
    \ (s1, s2) = if let &[ref s1, ref s2] = &lst[..] { (s1, s2) } else { todo!() };\n\
    \   |     +++++++++++++++++                                  +++++++++++++++++++++++++++++\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0005`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() == 2 {\n        let s1 = lst[0].to_string();\n\
    \        let s2 = lst[1].to_string();\n        let s3 = s1 + &s2;\n        if\
    \ s3.starts_with(')') || s3.ends_with('(') {\n            return \"No\".to_string();\n\
    \        }\n        match count_parens(&s3) {\n            0 => \"Yes\".to_string(),\n\
    \            _ => \"No\".to_string(),\n        }\n    } else {\n        \"No\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = match_parens;\n   \
    \ assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `count_parens` in this scope\n  -->\
    \ /tmp/tmprzb7hd1s.rs:20:15\n   |\n20 |         match count_parens(&s3) {\n  \
    \ |               ^^^^^^^^^^^^ not found in this scope\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut stack = Vec::new();\n    let len = lst.len();\n   \
    \ for i in 0..len {\n        let mut s = lst[i].chars();\n        for c in s {\n\
    \            if c == '(' {\n                stack.push(c);\n            } else\
    \ {\n                if stack.is_empty() {\n                    return \"No\"\
    .to_string();\n                } else {\n                    stack.pop();\n  \
    \              }\n            }\n        }\n    }\n    if stack.is_empty() {\n\
    \        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp5y1ls43f.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    if lst.len() != 2 {\n        panic!(\"match_parens(): expected\
    \ 2 strings\")\n    }\n    let s1 = lst[0].clone();\n    let s2 = lst[1].clone();\n\
    \    let mut s1_open = s1.chars().filter(|c| *c == '(').count();\n    let mut\
    \ s1_close = s1.chars().filter(|c| *c == ')').count();\n    let mut s2_open =\
    \ s2.chars().filter(|c| *c == '(').count();\n    let mut s2_close = s2.chars().filter(|c|\
    \ *c == ')').count();\n    if s1_open == s1_close && s2_open == s2_close {\n \
    \       return String::from(\"Yes\");\n    }\n    let mut diff = s1_open - s1_close;\n\
    \    if diff > 0 {\n        s2_open += diff;\n    } else {\n        s2_close -=\
    \ diff;\n    }\n    diff = s2_open - s2_close;\n    if diff > 0 {\n        s1_open\
    \ += diff;\n    } else {\n        s1_close -= diff;\n    }\n    if s1_open ==\
    \ s1_close && s2_open == s2_close {\n        return String::from(\"Yes\");\n \
    \   }\n    String::from(\"No\")\n}\n\nfn main() {\n    let candidate = match_parens;\n\
    \    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp97qxb0f7.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut counter = 0;\n    let mut sum = 0;\n    let mut res\
    \ = String::new();\n    let mut stack = vec![];\n    for s in lst {\n        for\
    \ c in s.chars() {\n            if c == '(' {\n                counter += 1;\n\
    \            } else {\n                counter -= 1;\n            }\n        \
    \    stack.push(c);\n        }\n        sum += counter;\n    }\n    if sum >=\
    \ 0 {\n        while !stack.is_empty() {\n            if stack[0] == '(' {\n \
    \               let mut counter = 0;\n                let mut i = 0;\n       \
    \         while i < stack.len() {\n                    if stack[i] == '(' {\n\
    \                        counter += 1;\n                    } else {\n       \
    \                 counter -= 1;\n                    }\n                    if\
    \ counter == 0 {\n                        break;\n                    }\n    \
    \                i += 1;\n                }\n                res.push_str(&stack[0..=i].iter().collect::<String>());\n\
    \                stack.drain(0..=i);\n            } else {\n                res.push_str(&stack[0..1].iter().collect::<String>());\n\
    \                stack.drain(0..1);\n            }\n        }\n        for c in\
    \ res.chars() {\n            if c == '(' {\n                counter += 1;\n  \
    \          } else {\n                counter -= 1;\n            }\n        }\n\
    \        if counter == 0 {\n            \"Yes\".to_string()\n        } else {\n\
    \            \"No\".to_string()\n        }\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmp0vu_0l6v.rs:73:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut s1 = lst[0].clone();\n    let mut s2 = lst[1].clone();\n\
    \    s1.push_str(&s2);\n    if is_good_string(&s1) {\n        return \"Yes\".to_string();\n\
    \    }\n    s1 = lst[1].clone();\n    s2 = lst[0].clone();\n    s1.push_str(&s2);\n\
    \    if is_good_string(&s1) {\n        return \"Yes\".to_string();\n    }\n  \
    \  \"No\".to_string()\n}\n\nfn main() {\n    let candidate = match_parens;\n \
    \   assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\")\")]), String::from(\"\
    Yes\"));\n    assert_eq!(candidate(vec![String::from(\")\"), String::from(\")\"\
    )]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"(()(())\"\
    ), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_good_string` in this scope\n  -->\
    \ /tmp/tmp5jsm3xv9.rs:16:8\n   |\n16 |     if is_good_string(&s1) {\n   |    \
    \    ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_good_string` in this scope\n  --> /tmp/tmp5jsm3xv9.rs:22:8\n   |\n22 | \
    \    if is_good_string(&s1) {\n   |        ^^^^^^^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to 2 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut lst = lst.iter().cloned().collect::<Vec<String>>();\n\
    \    lst.sort();\n    let mut (mut open, mut close) = (0, 0);\n    for ch in lst[0].chars()\
    \ {\n        match ch {\n            '(' => open += 1,\n            ')' => {\n\
    \                if open == 0 {\n                    return \"No\".to_string();\n\
    \                }\n                open -= 1;\n            }\n            _ =>\
    \ unreachable!(),\n        }\n    }\n    for ch in lst[1].chars() {\n        match\
    \ ch {\n            '(' => {\n                if close == 0 {\n              \
    \      return \"No\".to_string();\n                }\n                close -=\
    \ 1;\n            }\n            ')' => close += 1,\n            _ => unreachable!(),\n\
    \        }\n    }\n    if open == close {\n        \"Yes\".to_string()\n    }\
    \ else {\n        \"No\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "error: `mut` must be followed by a named binding\n  --> /tmp/tmpmeo694w3.rs:15:9\n\
    \   |\n15 |     let mut (mut open, mut close) = (0, 0);\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ help: remove the `mut` prefix: `(mut open, mut close)`\n   |\n   = note: `mut`\
    \ may be followed by `variable` and `variable @ pattern`\n\nerror: aborting due\
    \ to previous error\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let string = format!(\"{}{}\", lst[0], lst[1]);\n    let count\
    \ = string.chars().fold(0, |acc, x| {\n        if x == '(' {\n            acc\
    \ + 1\n        } else {\n            acc - 1\n        }\n    });\n    if count\
    \ == 0 {\n        \"Yes\".to_string()\n    } else {\n        \"No\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = match_parens;\n    assert_eq!(candidate(vec![String::from(\"\
    ()(\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"Yes\"`,\n right: `\"No\"`', /tmp/tmp6vpxracv.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given a list of two strings, both strings consist of open\n\
    /// parentheses '(' or close parentheses ')' only.\n/// Your job is to check if\
    \ it is possible to concatenate the two strings in\n/// some order, that the resulting\
    \ string will be good.\n/// A string S is considered to be good if and only if\
    \ all parentheses in S\n/// are balanced. For example: the string '(())()' is\
    \ good, while the string\n/// '())' is not.\n/// Return 'Yes' if there's a way\
    \ to make a good string, and return 'No' otherwise.\n/// Examples:\n/// match_parens(['()(',\
    \ ')']) == 'Yes'\n/// match_parens([')', ')']) == 'No'\nfn match_parens(lst: Vec<String>)\
    \ -> String {\n    let mut counter: i32 = 0;\n    let mut result: String = String::from(\"\
    No\");\n    for s in lst {\n        for c in s.chars() {\n            if c ==\
    \ '(' {\n                counter += 1;\n            } else {\n               \
    \ counter -= 1;\n            }\n            if counter < 0 {\n               \
    \ break;\n            }\n        }\n    }\n    if counter == 0 {\n        result\
    \ = String::from(\"Yes\");\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = match_parens;\n    assert_eq!(candidate(vec![String::from(\"()(\"), String::from(\"\
    )\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\")\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(())\"), String::from(\"())())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )())\"), String::from(\"(()()(\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (())))\"), String::from(\"(()())((\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ()\"), String::from(\"())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (()(\"), String::from(\"()))()\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    ((((\"), String::from(\"((())\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(()\"), String::from(\"(()(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )(\"), String::from(\")(\")]), String::from(\"No\"));\n    assert_eq!(candidate(vec![String::from(\"\
    (\"), String::from(\")\")]), String::from(\"Yes\"));\n    assert_eq!(candidate(vec![String::from(\"\
    )\"), String::from(\"(\")]), String::from(\"Yes\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"No\"`,\n right: `\"Yes\"`', /tmp/tmpe44zcza2.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
