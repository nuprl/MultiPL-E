name: HumanEval_105_by_length
language: rust
results:
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut res =\
    \ vec![];\n    for &a in arr.iter() {\n        if a > 0 && a < 10 {\n        \
    \    res.push(num_to_name(a));\n        }\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `num_to_name` in this scope\n  --> /tmp/tmpt6tjm0i0.rs:27:22\n\
    \   |\n27 |             res.push(num_to_name(a));\n   |                      ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut ans: Vec<String> = vec![];\n  let mut map: HashMap<i32,\
    \ String> = HashMap::new();\n  map.insert(1, \"One\".to_string());\n  map.insert(2,\
    \ \"Two\".to_string());\n  map.insert(3, \"Three\".to_string());\n  map.insert(4,\
    \ \"Four\".to_string());\n  map.insert(5, \"Five\".to_string());\n  map.insert(6,\
    \ \"Six\".to_string());\n  map.insert(7, \"Seven\".to_string());\n  map.insert(8,\
    \ \"Eight\".to_string());\n  map.insert(9, \"Nine\".to_string());\n  let mut tmp:\
    \ Vec<i32> = vec![];\n  for i in arr {\n    if i >= 1 && i <= 9 {\n      tmp.push(i\
    \ as i32);\n    }\n  }\n  tmp.sort();\n  tmp.reverse();\n  for i in tmp {\n  \
    \  if let Some(x) = map.get(&i) {\n      ans.push(x.to_string());\n    }\n  }\n\
    \  ans\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpz4nub7qj.rs:19:16\n\
    \   |\n19 |   let mut map: HashMap<i32, String> = HashMap::new();\n   |      \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmpz4nub7qj.rs:19:39\n\
    \   |\n19 |   let mut map: HashMap<i32, String> = HashMap::new();\n   |      \
    \                                 ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = vec![];\n    let mut sorted\
    \ = arr.clone();\n    sorted.sort();\n    sorted.reverse();\n    for i in sorted\
    \ {\n        match i {\n            1 => res.push(\"One\".to_string()),\n    \
    \        2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"Three\"\
    .to_string()),\n            4 => res.push(\"Four\".to_string()),\n           \
    \ 5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"Six\".to_string()),\n\
    \            7 => res.push(\"Seven\".to_string()),\n            8 => res.push(\"\
    Eight\".to_string()),\n            9 => res.push(\"Nine\".to_string()),\n    \
    \        _ => continue,\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v: Vec<isize> = arr;\n    v.sort();\n    v.reverse();\n\
    \    let mut res: Vec<String> = Vec::new();\n    for i in v {\n        if i ==\
    \ 1 {\n            res.push(\"One\".to_string());\n        } else if i == 2 {\n\
    \            res.push(\"Two\".to_string());\n        } else if i == 3 {\n    \
    \        res.push(\"Three\".to_string());\n        } else if i == 4 {\n      \
    \      res.push(\"Four\".to_string());\n        } else if i == 5 {\n         \
    \   res.push(\"Five\".to_string());\n        } else if i == 6 {\n            res.push(\"\
    Six\".to_string());\n        } else if i == 7 {\n            res.push(\"Seven\"\
    .to_string());\n        } else if i == 8 {\n            res.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            res.push(\"Nine\".to_string());\n   \
    \     }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    let mut digits:\
    \ Vec<isize> = vec![];\n    for x in arr {\n        if x > 0 && x < 10 {\n   \
    \         digits.push(x);\n        }\n    }\n    digits.sort();\n    digits.reverse();\n\
    \    for x in digits {\n        result.push(to_str(x));\n    }\n    result\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `to_str` in this scope\n  --> /tmp/tmpoepxmhdz.rs:28:21\n\
    \   |\n28 |         result.push(to_str(x));\n   |                     ^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    let mut arr\
    \ = arr;\n    arr.sort();\n    arr.reverse();\n    for i in arr {\n        match\
    \ i {\n            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v = arr;\n    v.sort();\n    v.reverse();\n  \
    \  v.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\",\n\
    \        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n   \
    \     6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n      \
    \  9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut num_array = arr.clone();\n    num_array.sort();\n\
    \    num_array.reverse();\n    let mut new_string = Vec::new();\n    for num in\
    \ num_array {\n        if num > 0 && num < 10 {\n            match num {\n   \
    \             1 => new_string.push(\"One\".to_string()),\n                2 =>\
    \ new_string.push(\"Two\".to_string()),\n                3 => new_string.push(\"\
    Three\".to_string()),\n                4 => new_string.push(\"Four\".to_string()),\n\
    \                5 => new_string.push(\"Five\".to_string()),\n               \
    \ 6 => new_string.push(\"Six\".to_string()),\n                7 => new_string.push(\"\
    Seven\".to_string()),\n                8 => new_string.push(\"Eight\".to_string()),\n\
    \                9 => new_string.push(\"Nine\".to_string()),\n               \
    \ _ => panic!(\"something went wrong\"),\n            }\n        }\n    }\n  \
    \  new_string\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ret = arr.clone();\n    let m: HashMap<isize,\
    \ &str> = vec![\n        (1, \"One\"),\n        (2, \"Two\"),\n        (3, \"\
    Three\"),\n        (4, \"Four\"),\n        (5, \"Five\"),\n        (6, \"Six\"\
    ),\n        (7, \"Seven\"),\n        (8, \"Eight\"),\n        (9, \"Nine\"),\n\
    \    ]\n    .into_iter()\n    .collect();\n    ret.sort();\n    ret.reverse();\n\
    \    ret.iter()\n        .filter(|x| x > &&0 && x < &&10)\n        .map(|x| m.get(x).unwrap().to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp0ia4edn4.rs:19:12\n\
    \   |\n19 |     let m: HashMap<isize, &str> = vec![\n   |            ^^^^^^^ not\
    \ found in this scope\n   |\nhelp: consider importing this struct\n   |\n1  |\
    \ use std::collections::HashMap;\n   |\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    let mut tmp\
    \ = arr.clone();\n    tmp.sort();\n    tmp.reverse();\n    for v in tmp {\n  \
    \      match v {\n            1 => res.push(\"One\".to_string()),\n          \
    \  2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n\
    \            4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"\
    Five\".to_string()),\n            6 => res.push(\"Six\".to_string()),\n      \
    \      7 => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\"\
    .to_string()),\n            9 => res.push(\"Nine\".to_string()),\n           \
    \ _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut tmp: Vec<isize> = Vec::new();\n    for num in\
    \ arr {\n        if num > 0 && num < 10 {\n            tmp.push(num);\n      \
    \  }\n    }\n    tmp.sort();\n    tmp.reverse();\n    let mut res: Vec<String>\
    \ = Vec::new();\n    for num in tmp {\n        res.push(match num {\n        \
    \    1 => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n      \
    \      3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n \
    \           5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n\
    \            7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => \"\".to_string(),\n\
    \        });\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for i in arr {\n        if\
    \ i > 0 && i < 10 {\n            res.push(i);\n        }\n    }\n    res.sort();\n\
    \    res.reverse();\n    let mut result = vec![];\n    for i in res {\n      \
    \  if i == 1 {\n            result.push(\"One\".to_string());\n        } else\
    \ if i == 2 {\n            result.push(\"Two\".to_string());\n        } else if\
    \ i == 3 {\n            result.push(\"Three\".to_string());\n        } else if\
    \ i == 4 {\n            result.push(\"Four\".to_string());\n        } else if\
    \ i == 5 {\n            result.push(\"Five\".to_string());\n        } else if\
    \ i == 6 {\n            result.push(\"Six\".to_string());\n        } else if i\
    \ == 7 {\n            result.push(\"Seven\".to_string());\n        } else if i\
    \ == 8 {\n            result.push(\"Eight\".to_string());\n        } else if i\
    \ == 9 {\n            result.push(\"Nine\".to_string());\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut result = Vec::new();\n  for i in arr {\n    match\
    \ i {\n      1 => result.push(\"One\".to_string()),\n      2 => result.push(\"\
    Two\".to_string()),\n      3 => result.push(\"Three\".to_string()),\n      4 =>\
    \ result.push(\"Four\".to_string()),\n      5 => result.push(\"Five\".to_string()),\n\
    \      6 => result.push(\"Six\".to_string()),\n      7 => result.push(\"Seven\"\
    .to_string()),\n      8 => result.push(\"Eight\".to_string()),\n      9 => result.push(\"\
    Nine\".to_string()),\n      _ => ()\n    }\n  }\n  result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpoic080yt.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut arr: Vec<_> = arr.into_iter().filter(|&x| x > 0 && x < 10).collect();\n\
    \    arr.sort();\n    arr.reverse();\n    let mut to_string = Vec::new();\n  \
    \  for &i in arr.iter() {\n        to_string.push(match i {\n            1 =>\
    \ \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n         \
    \   4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\",\n  \
    \          7 => \"Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\"\
    ,\n            _ => \"\",\n        });\n    }\n    to_string.to_vec()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpi82lums6.rs:39:5\n   |\n\
    17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    39 |     to_string.to_vec()\n   |     ^^^^^^^^^^^^^^^^^^ expected struct `String`,\
    \ found `&str`\n   |\n   = note: expected struct `Vec<String>`\n             \
    \ found struct `Vec<&str>`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort();\n  \
    \  sorted.reverse();\n    let mut output = Vec::new();\n    for number in sorted\
    \ {\n        if number == 1 {\n            output.push(\"One\".to_string());\n\
    \        } else if number == 2 {\n            output.push(\"Two\".to_string());\n\
    \        } else if number == 3 {\n            output.push(\"Three\".to_string());\n\
    \        } else if number == 4 {\n            output.push(\"Four\".to_string());\n\
    \        } else if number == 5 {\n            output.push(\"Five\".to_string());\n\
    \        } else if number == 6 {\n            output.push(\"Six\".to_string());\n\
    \        } else if number == 7 {\n            output.push(\"Seven\".to_string());\n\
    \        } else if number == 8 {\n            output.push(\"Eight\".to_string());\n\
    \        } else if number == 9 {\n            output.push(\"Nine\".to_string());\n\
    \        }\n    }\n    output\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // your code here\n    let mut res = vec![];\n    let\
    \ mut temp = arr.iter().filter(|&x| *x>=1 && *x<=9).collect::<Vec<&isize>>();\n\
    \    temp.sort();\n    temp.reverse();\n    for x in temp {\n        match *x\
    \ {\n            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut new_arr: Vec<isize> = arr.clone();\n    let mut\
    \ new_string: Vec<String> = vec![];\n    new_arr.sort();\n    new_arr.reverse();\n\
    \    for i in new_arr {\n        if i >= 1 && i <= 9 {\n            let string\
    \ = i.to_string();\n            match string.as_ref() {\n                \"1\"\
    \ => new_string.push(\"One\".to_string()),\n                \"2\" => new_string.push(\"\
    Two\".to_string()),\n                \"3\" => new_string.push(\"Three\".to_string()),\n\
    \                \"4\" => new_string.push(\"Four\".to_string()),\n           \
    \     \"5\" => new_string.push(\"Five\".to_string()),\n                \"6\" =>\
    \ new_string.push(\"Six\".to_string()),\n                \"7\" => new_string.push(\"\
    Seven\".to_string()),\n                \"8\" => new_string.push(\"Eight\".to_string()),\n\
    \                \"9\" => new_string.push(\"Nine\".to_string()),\n           \
    \     _ => (),\n            }\n        }\n    }\n    new_string\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut nums: Vec<String> = Vec::new();\n    let mut strs:\
    \ Vec<String> = Vec::new();\n    let mut result: Vec<String> = Vec::new();\n \
    \   for n in arr {\n        match n {\n            1 => strs.push(\"One\".to_string()),\n\
    \            2 => strs.push(\"Two\".to_string()),\n            3 => strs.push(\"\
    Three\".to_string()),\n            4 => strs.push(\"Four\".to_string()),\n   \
    \         5 => strs.push(\"Five\".to_string()),\n            6 => strs.push(\"\
    Six\".to_string()),\n            7 => strs.push(\"Seven\".to_string()),\n    \
    \        8 => strs.push(\"Eight\".to_string()),\n            9 => strs.push(\"\
    Nine\".to_string()),\n            _ => nums.push(n.to_string()),\n        }\n\
    \    }\n    strs.sort();\n    strs.reverse();\n    nums.sort();\n    nums.reverse();\n\
    \    result.append(&mut strs);\n    result.append(&mut nums);\n    result\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmper3gdbfu.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut vec: Vec<isize> = arr;\n    vec.sort();\n    vec.reverse();\n\
    \    let mut result = vec![];\n    for i in vec {\n        if i == 1 {\n     \
    \       result.push(\"One\".to_string());\n        } else if i == 2 {\n      \
    \      result.push(\"Two\".to_string());\n        } else if i == 3 {\n       \
    \     result.push(\"Three\".to_string());\n        } else if i == 4 {\n      \
    \      result.push(\"Four\".to_string());\n        } else if i == 5 {\n      \
    \      result.push(\"Five\".to_string());\n        } else if i == 6 {\n      \
    \      result.push(\"Six\".to_string());\n        } else if i == 7 {\n       \
    \     result.push(\"Seven\".to_string());\n        } else if i == 8 {\n      \
    \      result.push(\"Eight\".to_string());\n        } else if i == 9 {\n     \
    \       result.push(\"Nine\".to_string());\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v: Vec<isize> = arr.iter().filter(|x| *x > &0\
    \ && *x < &10).cloned().collect();\n    v.sort();\n    v.reverse();\n    v.iter().map(|x|\
    \ number_to_string(x)).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmpa4v14vtl.rs:21:22\n   |\n21 |     v.iter().map(|x| number_to_string(x)).collect()\n\
    \   |                      ^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut digits: Vec<String> = arr.iter().filter(|&x| x\
    \ > &0 && x < &10).map(|x| x.to_string()).collect();\n    digits.sort();\n   \
    \ digits.reverse();\n    digits.iter().map(|x| match x.parse::<usize>().unwrap()\
    \ {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n \
    \       4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n      \
    \  7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _\
    \ => unreachable!(),\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut new_arr: Vec<isize> = Vec::new();\n    let mut\
    \ answer: Vec<String> = Vec::new();\n    for i in arr {\n        if i < 10 &&\
    \ i > 0 {\n            new_arr.push(i);\n        }\n    }\n    new_arr.sort();\n\
    \    new_arr.reverse();\n    for i in new_arr {\n        match i {\n         \
    \   1 => answer.push(\"One\".to_string()),\n            2 => answer.push(\"Two\"\
    .to_string()),\n            3 => answer.push(\"Three\".to_string()),\n       \
    \     4 => answer.push(\"Four\".to_string()),\n            5 => answer.push(\"\
    Five\".to_string()),\n            6 => answer.push(\"Six\".to_string()),\n   \
    \         7 => answer.push(\"Seven\".to_string()),\n            8 => answer.push(\"\
    Eight\".to_string()),\n            9 => answer.push(\"Nine\".to_string()),\n \
    \           _ => continue,\n        }\n    }\n    answer\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr;\n    let mut res: Vec<String>\
    \ = Vec::new();\n    let nums: Vec<String> = vec![\"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    arr.sort();\n\
    \    arr.reverse();\n    for n in arr {\n        if n > 0 && n < 10 {\n      \
    \      res.push(nums[n as usize - 1].to_string());\n        }\n    }\n    res\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp9jgfmh1.rs:20:34\n   |\n\
    20 |     let nums: Vec<String> = vec![\"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n   |                      \
    \            ^^^^^- help: try using a conversion method: `.to_string()`\n   |\
    \                                  |\n   |                                  expected\
    \ struct `String`, found `&str`\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut new_arr\
    \ = vec![];\n    for i in arr {\n        match i {\n            1 => new_arr.push(\"\
    One\".to_string()),\n            2 => new_arr.push(\"Two\".to_string()),\n   \
    \         3 => new_arr.push(\"Three\".to_string()),\n            4 => new_arr.push(\"\
    Four\".to_string()),\n            5 => new_arr.push(\"Five\".to_string()),\n \
    \           6 => new_arr.push(\"Six\".to_string()),\n            7 => new_arr.push(\"\
    Seven\".to_string()),\n            8 => new_arr.push(\"Eight\".to_string()),\n\
    \            9 => new_arr.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x\
    \ > 0 && *x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    let mut\
    \ arr = arr.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 =>\
    \ \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"Zero\",\n    }).collect::<Vec<&str>>();\n\
    \    arr.retain(|x| *x != \"Zero\");\n    arr.into_iter().map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut integers: Vec<isize> = arr.iter().filter(|&x|\
    \ *x >= 1 && *x <= 9).cloned().collect();\n    integers.sort();\n    integers.reverse();\n\
    \    integers.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmp81cbktrr.rs:32:8\n     |\n32 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut numbers = arr\n        .iter()\n        .filter(|n|\
    \ (1..=9).any(|i| i == **n))\n        .copied()\n        .collect::<Vec<isize>>();\n\
    \    numbers.sort();\n    numbers.reverse();\n    numbers\n        .iter()\n \
    \       .map(|n| match n {\n            1 => \"One\",\n            2 => \"Two\"\
    ,\n            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => unreachable!(),\n\
    \        })\n        .map(String::from)\n        .collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr.clone();\n    result.sort();\n  \
    \  result.reverse();\n    result.iter().filter(|&x| x >= &1 && x <= &9).map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"Zero\",\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr_mut = arr.clone();\n    let mut res: Vec<String>\
    \ = Vec::new();\n    let map: HashMap<isize, &str> = [(1, \"One\"), (2, \"Two\"\
    ), (3, \"Three\"), (4, \"Four\"), (5, \"Five\"), (6, \"Six\"), (7, \"Seven\"),\
    \ (8, \"Eight\"), (9, \"Nine\")].iter().cloned().collect();\n    arr_mut.sort();\n\
    \    arr_mut.reverse();\n    for i in arr_mut {\n        if i >= 1 && i <= 9 {\n\
    \            res.push(map[&i].to_string());\n        }\n    }\n    res\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmpl2itn3_w.rs:20:14\n\
    \   |\n20 |     let map: HashMap<isize, &str> = [(1, \"One\"), (2, \"Two\"), (3,\
    \ \"Three\"), (4, \"Four\"), (5, \"Five\"), (6, \"Six\"), (7, \"Seven\"), (8,\
    \ \"Eight...\n   |              ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut vec = vec![];\n    for v in arr {\n        if\
    \ v == 1 {\n            vec.push(\"One\".to_string());\n        } else if v ==\
    \ 2 {\n            vec.push(\"Two\".to_string());\n        } else if v == 3 {\n\
    \            vec.push(\"Three\".to_string());\n        } else if v == 4 {\n  \
    \          vec.push(\"Four\".to_string());\n        } else if v == 5 {\n     \
    \       vec.push(\"Five\".to_string());\n        } else if v == 6 {\n        \
    \    vec.push(\"Six\".to_string());\n        } else if v == 7 {\n            vec.push(\"\
    Seven\".to_string());\n        } else if v == 8 {\n            vec.push(\"Eight\"\
    .to_string());\n        } else if v == 9 {\n            vec.push(\"Nine\".to_string());\n\
    \        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp5k7mzr6t.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_and_filtered = arr.iter().filter(|x| *x\
    \ >= &1 && *x <= &9).map(|x| *x).collect::<Vec<isize>>();\n    sorted_and_filtered.sort();\n\
    \    sorted_and_filtered.reverse();\n    sorted_and_filtered.iter().map(|x| match\
    \ x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n\
    \        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n     \
    \   7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n       \
    \ _ => \"\"\n    }).map(|x| x.to_string()).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut hm = HashMap::new();\n    hm.insert(1, \"One\"\
    );\n    hm.insert(2, \"Two\");\n    hm.insert(3, \"Three\");\n    hm.insert(4,\
    \ \"Four\");\n    hm.insert(5, \"Five\");\n    hm.insert(6, \"Six\");\n    hm.insert(7,\
    \ \"Seven\");\n    hm.insert(8, \"Eight\");\n    hm.insert(9, \"Nine\");\n   \
    \ arr.into_iter()\n        .filter(|x| x > &0 && x < &10)\n        .sorted()\n\
    \        .rev()\n        .map(|x| hm.get(&x).unwrap().to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpp4mt0rjo.rs:18:18\n   |\n18 |     let mut hm = HashMap::new();\n   |\
    \                  ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0599]:\
    \ no method named `sorted` found for struct `Filter` in the current scope\n  -->\
    \ /tmp/tmpp4mt0rjo.rs:30:10\n   |\n30 |         .sorted()\n   |          ^^^^^^\
    \ method not found in `Filter<std::vec::IntoIter<isize>, [closure@/tmp/tmpp4mt0rjo.rs:29:17:\
    \ 29:38]>`\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0433, E0599.\nFor more information about an error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut a: Vec<_> = arr.into_iter().filter(|x| x > &0\
    \ && x < &10).collect();\n    a.sort();\n    a.reverse();\n    a.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| x != &\"\").map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let numbers = [\"One\", \"Two\", \"Three\", \"Four\",\
    \ \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    let mut sorted = arr.iter().filter(|x|\
    \ **x > 0 && **x < 10).cloned().collect::<Vec<isize>>();\n    sorted.sort();\n\
    \    sorted.reverse();\n    sorted.iter().map(|x| numbers[(*x-1) as usize].to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut result = vec![];\n    let mut map = std::collections::HashMap::new();\n\
    \    map.insert(1, \"One\");\n    map.insert(2, \"Two\");\n    map.insert(3, \"\
    Three\");\n    map.insert(4, \"Four\");\n    map.insert(5, \"Five\");\n    map.insert(6,\
    \ \"Six\");\n    map.insert(7, \"Seven\");\n    map.insert(8, \"Eight\");\n  \
    \  map.insert(9, \"Nine\");\n    let mut arr = arr.clone();\n    arr.sort();\n\
    \    arr.reverse();\n    for i in arr {\n        if i >= 1 && i <= 9 {\n     \
    \       result.push(map.get(&i).unwrap().to_string());\n        }\n    }\n   \
    \ result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ sorted_arr: Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    for num in sorted_arr {\n        if num == 1 {\n            result.push(\"\
    One\".to_string());\n        } else if num == 2 {\n            result.push(\"\
    Two\".to_string());\n        } else if num == 3 {\n            result.push(\"\
    Three\".to_string());\n        } else if num == 4 {\n            result.push(\"\
    Four\".to_string());\n        } else if num == 5 {\n            result.push(\"\
    Five\".to_string());\n        } else if num == 6 {\n            result.push(\"\
    Six\".to_string());\n        } else if num == 7 {\n            result.push(\"\
    Seven\".to_string());\n        } else if num == 8 {\n            result.push(\"\
    Eight\".to_string());\n        } else if num == 9 {\n            result.push(\"\
    Nine\".to_string());\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut digits = arr\n        .iter()\n        .filter(|&x|\
    \ x >= &1 && x <= &9)\n        .collect::<Vec<&isize>>();\n    digits.sort();\n\
    \    digits.reverse();\n    let mut words = digits\n        .iter()\n        .map(|&x|\
    \ {\n            let words = vec![\n                \"\", \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n      \
    \      ];\n            words[*x as usize].to_string()\n        })\n        .collect::<Vec<String>>();\n\
    \    words\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|&&x| 0 < x && x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => unreachable!()\n\
    \    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    fn by_len(s: &str) -> (usize, &str) {\n        (s.len(),\
    \ s)\n    }\n    //sort the array by lenght of string and then alphabetically,\
    \ then reverse the vector\n    let mut my_arr: Vec<String> = arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    })\n    .filter(|&x| x != \"\")\n    .map(|x| x.to_string())\n\
    \    .collect();\n    my_arr.sort_by(|a, b| a.cmp(b));\n    my_arr.reverse();\n\
    \    my_arr\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp6zgrrl_4.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v: Vec<String> = arr.iter().map(|n| match n {\n\
    \        1 => \"One\".to_string(),\n        2 => \"Two\".to_string(),\n      \
    \  3 => \"Three\".to_string(),\n        4 => \"Four\".to_string(),\n        5\
    \ => \"Five\".to_string(),\n        6 => \"Six\".to_string(),\n        7 => \"\
    Seven\".to_string(),\n        8 => \"Eight\".to_string(),\n        9 => \"Nine\"\
    .to_string(),\n        _ => \"\".to_string(),\n    }).collect();\n    v.retain(|s|\
    \ !s.is_empty());\n    v.sort();\n    v.reverse();\n    v\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp3olwqfy9.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort();\n  \
    \  sorted.reverse();\n    sorted.iter().map(|num| {\n        match num {\n   \
    \         1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => \"\"\n        }.to_string()\n    }).filter(|num|\
    \ num != \"\").collect()\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_nums = vec![];\n    for a in arr {\n  \
    \      if a > 0 && a < 10 {\n            sorted_nums.push(a);\n        }\n   \
    \ }\n    sorted_nums.sort();\n    sorted_nums.reverse();\n    sorted_nums.iter().map(|n|\
    \ match n {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).map(|s| s.to_string()).collect()\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_vec = arr.to_vec();\n    sorted_vec.sort();\n\
    \    sorted_vec.reverse();\n    let mut res = Vec::new();\n    for number in sorted_vec\
    \ {\n        match number {\n            1 => res.push(\"One\".to_string()),\n\
    \            2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"\
    Three\".to_string()),\n            4 => res.push(\"Four\".to_string()),\n    \
    \        5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"Six\"\
    .to_string()),\n            7 => res.push(\"Seven\".to_string()),\n          \
    \  8 => res.push(\"Eight\".to_string()),\n            9 => res.push(\"Nine\".to_string()),\n\
    \            _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ test_values: Vec<isize> = arr.iter().filter(|v| *v < &10 && *v > &0).cloned().collect();\n\
    \    test_values.sort();\n    test_values.reverse();\n    for value in test_values\
    \ {\n        result.push(int_to_string(value));\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `int_to_string` in this scope\n  -->\
    \ /tmp/tmpu793b9z6.rs:23:21\n   |\n23 |         result.push(int_to_string(value));\n\
    \   |                     ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut digits = [\"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    let mut result = Vec::new();\n\
    \    let mut new_arr = arr.clone();\n    new_arr.sort();\n    new_arr.reverse();\n\
    \    for i in new_arr {\n        if i >= 1 && i <= 9 {\n            result.push(digits[(i\
    \ - 1) as usize].to_string());\n        }\n    }\n    result\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut sorted = arr.clone();\n  sorted.sort();\n  sorted.reverse();\n\
    \  let mut result = Vec::new();\n  for i in sorted {\n    if i < 1 || i > 9 {\n\
    \      continue;\n    }\n    match i {\n      1 => result.push(\"One\".to_string()),\n\
    \      2 => result.push(\"Two\".to_string()),\n      3 => result.push(\"Three\"\
    .to_string()),\n      4 => result.push(\"Four\".to_string()),\n      5 => result.push(\"\
    Five\".to_string()),\n      6 => result.push(\"Six\".to_string()),\n      7 =>\
    \ result.push(\"Seven\".to_string()),\n      8 => result.push(\"Eight\".to_string()),\n\
    \      9 => result.push(\"Nine\".to_string()),\n      _ => ()\n    }\n  }\n  result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|n| **n > 0 && **n < 10).map(num_to_str).collect()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `num_to_str` in this scope\n  --> /tmp/tmp6b51mtix.rs:21:52\n\
    \   |\n21 |     arr.iter().filter(|n| **n > 0 && **n < 10).map(num_to_str).collect()\n\
    \   |                                                    ^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // your code here\n    if arr.len() == 0 { return vec![];\
    \ }\n    let mut arr: Vec<_> = arr.into_iter().map(|i| {\n        match i {\n\
    \            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => \"\",\n        }.to_string()\n    }).filter(|i|\
    \ { !i.is_empty() }).collect();\n    arr.sort();\n    arr.reverse();\n    arr\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpqzkwlpig.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // TODO: Implement\n    let mut v: Vec<isize> = arr.clone();\n\
    \    v.sort();\n    v.reverse();\n    let mut s: Vec<String> = Vec::new();\n \
    \   for i in v {\n        if i > 0 && i < 10 {\n            match i {\n      \
    \          1 => s.push(\"One\".to_string()),\n                2 => s.push(\"Two\"\
    .to_string()),\n                3 => s.push(\"Three\".to_string()),\n        \
    \        4 => s.push(\"Four\".to_string()),\n                5 => s.push(\"Five\"\
    .to_string()),\n                6 => s.push(\"Six\".to_string()),\n          \
    \      7 => s.push(\"Seven\".to_string()),\n                8 => s.push(\"Eight\"\
    .to_string()),\n                9 => s.push(\"Nine\".to_string()),\n         \
    \       _ => (),\n            }\n        }\n    }\n    s\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphp2xyd2r.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut numbers = arr.clone();\n    numbers.sort();\n\
    \    numbers.reverse();\n    numbers.iter().map(|num| num.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp9pu3qcwy.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v = arr.iter().filter(|i| **i > 0 && **i < 10).map(|i|\
    \ *i as usize).collect::<Vec<usize>>();\n    v.sort();\n    v.reverse();\n   \
    \ let s = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\"];\n    v.iter().map(|i| s[*i - 1].to_string()).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        if i == 1 {\n \
    \           result.push(\"One\".to_string());\n        } else if i == 2 {\n  \
    \          result.push(\"Two\".to_string());\n        } else if i == 3 {\n   \
    \         result.push(\"Three\".to_string());\n        } else if i == 4 {\n  \
    \          result.push(\"Four\".to_string());\n        } else if i == 5 {\n  \
    \          result.push(\"Five\".to_string());\n        } else if i == 6 {\n  \
    \          result.push(\"Six\".to_string());\n        } else if i == 7 {\n   \
    \         result.push(\"Seven\".to_string());\n        } else if i == 8 {\n  \
    \          result.push(\"Eight\".to_string());\n        } else if i == 9 {\n \
    \           result.push(\"Nine\".to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.iter()\n        .filter(|x| *x > 0 && *x < 10)\n \
    \       .map(|x| *x as usize)\n        .collect::<Vec<usize>>()\n        .sort_by(|a,\
    \ b| b.cmp(a))\n        .iter()\n        .map(|x| match x {\n            1 =>\
    \ \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n         \
    \   4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\",\n  \
    \          7 => \"Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\"\
    ,\n            _ => panic!(\"Bad value\"),\n        })\n        .map(|x| x.to_string())\n\
    \        .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpc549ft_c.rs:19:26\n   |\n\
    19 |         .filter(|x| *x > 0 && *x < 10)\n   |                          ^\n\
    \   |                          |\n   |                          expected `&isize`,\
    \ found integer\n   |                          help: consider borrowing here:\
    \ `&0`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmpc549ft_c.rs:19:36\n  \
    \ |\n19 |         .filter(|x| *x > 0 && *x < 10)\n   |                       \
    \             ^^\n   |                                    |\n   |            \
    \                        expected `&isize`, found integer\n   |              \
    \                      help: consider borrowing here: `&10`\n\nerror[E0599]: no\
    \ method named `iter` found for unit type `()` in the current scope\n  --> /tmp/tmpc549ft_c.rs:23:10\n\
    \   |\n23 |         .iter()\n   |          ^^^^ method not found in `()`\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0308, E0599.\nFor more information about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut arr: Vec<isize> = arr\n        .into_iter()\n        .filter(|x|\
    \ *x > 0 && *x < 10)\n        .collect();\n    arr.sort();\n    arr.reverse();\n\
    \    arr.into_iter()\n        .map(|x| match x {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => unreachable!(),\n        })\n        .map(|x| x.to_string())\n       \
    \ .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_nums = arr.clone();\n    sorted_nums.sort();\n\
    \    let mut reversed_nums = sorted_nums.clone();\n    reversed_nums.reverse();\n\
    \    let len = reversed_nums.len();\n    let mut translated_nums = Vec::with_capacity(len);\n\
    \    for (i, num) in reversed_nums.iter().enumerate() {\n        if *num < 0 ||\
    \ *num > 9 {\n            continue;\n        }\n        translated_nums.push(match\
    \ *num {\n            1 => \"One\",\n            2 => \"Two\",\n            3\
    \ => \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n    \
    \        6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\"\
    ,\n            9 => \"Nine\",\n            _ => \"\",\n        }.to_string());\n\
    \    }\n    translated_nums\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v = arr.iter().filter(|n| **n >= 1 && **n <= 9).cloned().collect::<Vec<isize>>();\n\
    \    v.sort();\n    v.reverse();\n    v.iter().map(|n| match n {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).cloned().collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `str: Clone` is not satisfied\n    --> /tmp/tmpb4w0o4tx.rs:32:8\n\
    \     |\n32   |     }).cloned().collect::<Vec<String>>()\n     |        ^^^^^^\
    \ the trait `Clone` is not implemented for `str`\n     |\n     = help: the trait\
    \ `Clone` is implemented for `String`\nnote: required by a bound in `cloned`\n\
    \nerror[E0599]: the method `collect` exists for struct `Cloned<Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpb4w0o4tx.rs:21:18: 32:6]>>`, but its trait bounds were\
    \ not satisfied\n  --> /tmp/tmpb4w0o4tx.rs:32:17\n   |\n32 |       }).cloned().collect::<Vec<String>>()\n\
    \   |                   ^^^^^^^ method cannot be called on `Cloned<Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpb4w0o4tx.rs:21:18: 32:6]>>` due to unsatisfied trait\
    \ bounds\n   |\n   = note: the following trait bounds were not satisfied:\n  \
    \         `Cloned<Map<std::slice::Iter<'_, isize>, [closure@/tmp/tmpb4w0o4tx.rs:21:18:\
    \ 32:6]>>: Iterator`\n           which is required by `&mut Cloned<Map<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpb4w0o4tx.rs:21:18: 32:6]>>: Iterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nSome errors have detailed explanations: E0277, E0599.\n\
    For more information about an error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v: Vec<String> = Vec::new();\n    if arr.len()\
    \ == 0 {\n        return v;\n    }\n    let mut arr2: Vec<isize> = arr.clone();\n\
    \    arr2.sort();\n    arr2.reverse();\n    for &x in arr2.iter() {\n        match\
    \ x {\n            1 => v.push(\"One\".to_string()),\n            2 => v.push(\"\
    Two\".to_string()),\n            3 => v.push(\"Three\".to_string()),\n       \
    \     4 => v.push(\"Four\".to_string()),\n            5 => v.push(\"Five\".to_string()),\n\
    \            6 => v.push(\"Six\".to_string()),\n            7 => v.push(\"Seven\"\
    .to_string()),\n            8 => v.push(\"Eight\".to_string()),\n            9\
    \ => v.push(\"Nine\".to_string()),\n            _ => {},\n        }\n    }\n \
    \   v\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.iter()\n        .filter(|&x| *x >= 1 && *x <= 9)\n\
    \        .map(|&x| x.to_string())\n        .collect::<Vec<String>>()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"2\", \"1\", \"1\", \"4\", \"5\", \"8\", \"2\", \"3\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp3nkh5ulx.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmphxrknc2n.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ v = arr.clone();\n    v.sort();\n    v.reverse();\n    for i in v {\n      \
    \  if i == -1 {\n            continue;\n        }\n        let s = match i {\n\
    \            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => \"\",\n        };\n        if s != \"\" {\n\
    \            result.push(s.to_string());\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut temp = arr.clone();\n    temp.sort();\n    temp.reverse();\n\
    \    let mut result = Vec::new();\n    for i in temp {\n        if i > 0 && i\
    \ < 10 {\n            result.push(number_to_word(i));\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `number_to_word` in this scope\n  -->\
    \ /tmp/tmp2libax1h.rs:24:25\n   |\n24 |             result.push(number_to_word(i));\n\
    \   |                         ^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let len = arr.len();\n    let mut str_list: Vec<String> = Vec::with_capacity(len);\n\
    \    for i in 0..len {\n        match arr[i] {\n            1 => str_list.push(\"\
    One\".to_string()),\n            2 => str_list.push(\"Two\".to_string()),\n  \
    \          3 => str_list.push(\"Three\".to_string()),\n            4 => str_list.push(\"\
    Four\".to_string()),\n            5 => str_list.push(\"Five\".to_string()),\n\
    \            6 => str_list.push(\"Six\".to_string()),\n            7 => str_list.push(\"\
    Seven\".to_string()),\n            8 => str_list.push(\"Eight\".to_string()),\n\
    \            9 => str_list.push(\"Nine\".to_string()),\n            _ => (),\n\
    \        }\n    }\n    str_list\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut r = vec![];\n    for &v in arr.iter() {\n    \
    \    if v > 0 && v < 10 {\n            r.push(v);\n        }\n    }\n    r.sort();\n\
    \    r.reverse();\n    r.iter().map(|&v| match v {\n        1 => \"One\",\n  \
    \      2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n      \
    \  5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 =>\
    \ \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.iter()\n        .filter(|&n| *n >= 1 && *n <= 9)\n\
    \        .map(|n| match n {\n            1 => \"One\",\n            2 => \"Two\"\
    ,\n            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"unknown\
    \ digit: {}\", n),\n        })\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpupn1p816.rs:32:10\n     |\n32\
    \   |         .collect()\n     |          ^^^^^^^ value of type `Vec<String>`\
    \ cannot be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help:\
    \ the trait `FromIterator<&str>` is not implemented for `Vec<String>`\n     =\
    \ help: the trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required\
    \ by a bound in `collect`\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    for item in arr {\n\
    \        if item > 0 && item < 10 {\n            result.push(item);\n        }\n\
    \    }\n    result.sort();\n    result.reverse();\n    let mut names = Vec::new();\n\
    \    for item in result {\n        match item {\n            1 => names.push(\"\
    One\".to_string()),\n            2 => names.push(\"Two\".to_string()),\n     \
    \       3 => names.push(\"Three\".to_string()),\n            4 => names.push(\"\
    Four\".to_string()),\n            5 => names.push(\"Five\".to_string()),\n   \
    \         6 => names.push(\"Six\".to_string()),\n            7 => names.push(\"\
    Seven\".to_string()),\n            8 => names.push(\"Eight\".to_string()),\n \
    \           9 => names.push(\"Nine\".to_string()),\n            _ => {}\n    \
    \    }\n    }\n    names\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    //write your code here\n    let mut result: Vec<String>\
    \ = Vec::new();\n    let mut temp: Vec<isize> = Vec::new();\n    let mut number_names:\
    \ Vec<String> = vec![\"Zero\".to_string(),\n                                 \
    \            \"One\".to_string(),\n                                          \
    \   \"Two\".to_string(),\n                                             \"Three\"\
    .to_string(),\n                                             \"Four\".to_string(),\n\
    \                                             \"Five\".to_string(),\n        \
    \                                     \"Six\".to_string(),\n                 \
    \                            \"Seven\".to_string(),\n                        \
    \                     \"Eight\".to_string(),\n                               \
    \              \"Nine\".to_string()];\n    for i in arr {\n        if 0 < i &&\
    \ i < 10 {\n            temp.push(i);\n        }\n    }\n    temp.sort();\n  \
    \  temp.reverse();\n    for j in temp {\n        result.push(number_names[j as\
    \ usize].clone());\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ arr = arr;\n    arr.sort();\n    arr.reverse();\n    for i in arr {\n      \
    \  match i {\n            1 => result.push(\"One\".to_string()),\n           \
    \ 2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"Three\"\
    .to_string()),\n            4 => result.push(\"Four\".to_string()),\n        \
    \    5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut replace = vec![];\n    let mut numbers: Vec<isize>\
    \ = vec![];\n    for item in arr {\n        if item >= 1 && item <= 9 {\n    \
    \        numbers.push(item);\n        }\n    }\n    if numbers.len() == 0 {\n\
    \        return replace;\n    }\n    numbers.sort();\n    numbers.reverse();\n\
    \    for item in numbers {\n        let temp = match item {\n            1 =>\
    \ \"One\",\n            2 => \"Two\",\n            3 => \"Three\",\n         \
    \   4 => \"Four\",\n            5 => \"Five\",\n            6 => \"Six\",\n  \
    \          7 => \"Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\"\
    ,\n            _ => \"\",\n        };\n        replace.push(temp.to_string());\n\
    \    }\n    replace\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.iter()\n        .filter(|&e| e > &0 && e < &10)\n\
    \        .map(|e| e.to_string())\n        .collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"2\", \"1\", \"1\", \"4\", \"5\", \"8\", \"2\", \"3\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpeydmphaq.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // todo!()\n    if arr.len() == 0 {\n        Vec::new()\n\
    \    } else {\n        let mut new_arr: Vec<isize> = arr.iter().filter(|&x| *x\
    \ > 0 && *x < 10).map(|&x| x).collect();\n        new_arr.sort();\n        new_arr.reverse();\n\
    \        new_arr.iter().map(|&x| match x {\n            1 => \"One\",\n      \
    \      2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n\
    \            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\"\
    ,\n            8 => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\
    None\",\n        }).map(|&x| x.to_string()).collect()\n    }\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpjgpcquff.rs:36:18\n   |\n36 |         }).map(|&x| x.to_string()).collect()\n\
    \   |                  ^ doesn't have a size known at compile-time\n   |\n   =\
    \ help: the trait `Sized` is not implemented for `str`\n   = note: all local variables\
    \ must have a statically known size\n   = help: unsized locals are gated as an\
    \ unstable feature\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut vec: Vec<String> = Vec::new();\n    for v in arr\
    \ {\n        match v {\n            1 => vec.push(\"One\".to_string()),\n    \
    \        2 => vec.push(\"Two\".to_string()),\n            3 => vec.push(\"Three\"\
    .to_string()),\n            4 => vec.push(\"Four\".to_string()),\n           \
    \ 5 => vec.push(\"Five\".to_string()),\n            6 => vec.push(\"Six\".to_string()),\n\
    \            7 => vec.push(\"Seven\".to_string()),\n            8 => vec.push(\"\
    Eight\".to_string()),\n            9 => vec.push(\"Nine\".to_string()),\n    \
    \        _ => (),\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpcjob290a.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut clone_arr = arr.clone();\n    let mut result:\
    \ Vec<String> = Vec::new();\n    clone_arr.sort();\n    clone_arr.reverse();\n\
    \    for i in clone_arr {\n        if i > 0 && i < 10 {\n            result.push(int_to_str(i));\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `int_to_str` in this scope\n  --> /tmp/tmpcz2dytt5.rs:24:25\n\
    \   |\n24 |             result.push(int_to_str(i));\n   |                    \
    \     ^^^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for i in arr {\n        if\
    \ i == 1 {\n            res.push(\"One\".to_string());\n        } else if i ==\
    \ 2 {\n            res.push(\"Two\".to_string());\n        } else if i == 3 {\n\
    \            res.push(\"Three\".to_string());\n        } else if i == 4 {\n  \
    \          res.push(\"Four\".to_string());\n        } else if i == 5 {\n     \
    \       res.push(\"Five\".to_string());\n        } else if i == 6 {\n        \
    \    res.push(\"Six\".to_string());\n        } else if i == 7 {\n            res.push(\"\
    Seven\".to_string());\n        } else if i == 8 {\n            res.push(\"Eight\"\
    .to_string());\n        } else if i == 9 {\n            res.push(\"Nine\".to_string());\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpudgg7zr6.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut res = Vec::new();\n    for i in arr {\n        match i {\n      \
    \      1 => res.push(\"One\".to_string()),\n            2 => res.push(\"Two\"\
    .to_string()),\n            3 => res.push(\"Three\".to_string()),\n          \
    \  4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\".to_string()),\n\
    \            6 => res.push(\"Six\".to_string()),\n            7 => res.push(\"\
    Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n   \
    \         9 => res.push(\"Nine\".to_string()),\n            _ => (),\n       \
    \ }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = vec![];\n    let mut new_arr:\
    \ Vec<isize> = vec![];\n    for i in arr {\n        if i >= 1 && i <= 9 {\n  \
    \          new_arr.push(i);\n        }\n    }\n    new_arr.sort();\n    new_arr.reverse();\n\
    \    for i in new_arr {\n        if i == 1 {\n            result.push(\"One\"\
    .to_string());\n        } else if i == 2 {\n            result.push(\"Two\".to_string());\n\
    \        } else if i == 3 {\n            result.push(\"Three\".to_string());\n\
    \        } else if i == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result.push(\"Six\".to_string());\n \
    \       } else if i == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut counter = 0;\n    for n in arr.iter() {\n        if n <= &0 || n\
    \ >= &10 {\n            arr.remove(counter);\n        }\n        counter += 1;\n\
    \    }\n    arr.iter().map(|n| match n {\n        1 => \"One\",\n        2 =>\
    \ \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => unreachable!(),\n    })\n    .map(|s| s.to_string())\n\
    \    .collect()\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0502]: cannot borrow `arr` as mutable because it is also borrowed\
    \ as immutable\n  --> /tmp/tmpbth3ij75.rs:24:13\n   |\n22 |     for n in arr.iter()\
    \ {\n   |              ----------\n   |              |\n   |              immutable\
    \ borrow occurs here\n   |              immutable borrow later used here\n23 |\
    \         if n <= &0 || n >= &10 {\n24 |             arr.remove(counter);\n  \
    \ |             ^^^^^^^^^^^^^^^^^^^ mutable borrow occurs here\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0502`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    for x in arr {\n   \
    \     if x == 1 {\n            result.push(\"One\".to_string());\n        } else\
    \ if x == 2 {\n            result.push(\"Two\".to_string());\n        } else if\
    \ x == 3 {\n            result.push(\"Three\".to_string());\n        } else if\
    \ x == 4 {\n            result.push(\"Four\".to_string());\n        } else if\
    \ x == 5 {\n            result.push(\"Five\".to_string());\n        } else if\
    \ x == 6 {\n            result.push(\"Six\".to_string());\n        } else if x\
    \ == 7 {\n            result.push(\"Seven\".to_string());\n        } else if x\
    \ == 8 {\n            result.push(\"Eight\".to_string());\n        } else if x\
    \ == 9 {\n            result.push(\"Nine\".to_string());\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp1ofx7i6h.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // This doesn't work\n    // arr.sort_by(|a, b| a.cmp(b));\n\
    \    // arr.reverse();\n    // arr.iter().map(|a| a.to_string()).collect::<Vec<String>>()\n\
    \n    let mut sorted = arr.clone();\n    sorted.sort();\n    sorted.reverse();\n\
    \    sorted.iter().map(|a| a.to_string()).collect::<Vec<String>>()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpc2923rwv.rs:31:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut  sorted = arr.clone();\n    sorted.sort();\n    sorted.reverse();\n\
    \    let str_return = sorted.iter().filter(|x| **x < 10).map(|x| match x {\n \
    \       1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n      \
    \  4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 =>\
    \ \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\
    N/A\",\n    }).collect::<Vec<&str>>();\n    str_return.iter().map(|x| String::from(*x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"N/A\"]`,\n right: `[\"One\"]`', /tmp/tmp3nvvtah0.rs:43:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| **x > 0 && **x < 10).map(num_to_string).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find value `num_to_string` in this scope\n  --> /tmp/tmp7f7m48bq.rs:21:52\n\
    \   |\n21 |     arr.iter().filter(|x| **x > 0 && **x < 10).map(num_to_string).collect()\n\
    \   |                                                    ^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v: Vec<isize> = arr.clone();\n    v.sort();\n\
    \    v.reverse();\n    let mut nums = vec![];\n    for i in v {\n        if i\
    \ > 0 && i < 10 {\n            nums.push(i)\n        }\n    }\n    nums.iter().map(|&x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: a value of type `Vec<String>` cannot be built from an iterator\
    \ over elements of type `&str`\n    --> /tmp/tmpb3gjmz73.rs:38:8\n     |\n38 \
    \  |     }).collect()\n     |        ^^^^^^^ value of type `Vec<String>` cannot\
    \ be built from `std::iter::Iterator<Item=&str>`\n     |\n     = help: the trait\
    \ `FromIterator<&str>` is not implemented for `Vec<String>`\n     = help: the\
    \ trait `FromIterator<T>` is implemented for `Vec<T>`\nnote: required by a bound\
    \ in `collect`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    sorted_arr.reverse();\n    return sorted_arr.iter().filter(|&i| *i <= 9 &&\
    \ *i >= 1).map(|i| {\n        match i {\n            1 => \"One\",\n         \
    \   2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\",\n \
    \           5 => \"Five\",\n            6 => \"Six\",\n            7 => \"Seven\"\
    ,\n            8 => \"Eight\",\n            9 => \"Nine\",\n            _ => panic!(\"\
    {} is not valid\", i),\n        }\n    }).map(|s| s.to_string()).collect();\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v: Vec<usize> = arr.iter().map(|x| x.abs() as\
    \ usize).collect();\n    v.sort();\n    v.reverse();\n    // println!(\"{:?}\"\
    , v);\n    let mut res: Vec<String> = Vec::new();\n    for i in v {\n        match\
    \ i {\n            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\", \"One\"]`,\n right: `[\"One\"]`', /tmp/tmpp6_mduzh.rs:44:5\nnote:\
    \ run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for x in arr {\n        match\
    \ x {\n            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => (),\n    \
    \    }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n   \
    \ assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpqtbe7rib.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    //sorting\n    let mut arr = arr;\n    arr.sort();\n \
    \   arr.reverse();\n    let mut result = Vec::new();\n    //replace each digit\
    \ by its corresponding name\n    for number in arr {\n        if number < 1 ||\
    \ number > 9 {\n            continue;\n        }\n        match number {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => {}\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort();\n  \
    \  sorted.reverse();\n    let mut res = Vec::new();\n    for i in sorted {\n \
    \       match i {\n            1 => res.push(\"One\".to_string()),\n         \
    \   2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n\
    \            4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"\
    Five\".to_string()),\n            6 => res.push(\"Six\".to_string()),\n      \
    \      7 => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\"\
    .to_string()),\n            9 => res.push(\"Nine\".to_string()),\n           \
    \ _ => continue,\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut result = arr.clone();\n  result.sort();\n  result.reverse();\n\
    \  result.iter().filter(|&&x| x > 0 && x < 10).map(|&x| match x {\n    1 => \"\
    One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"\
    Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 =>\
    \ \"Nine\",\n    _ => unreachable!(),\n  }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut nums: Vec<isize> = arr.iter().filter(|n| **n >= 1 && **n <= 9).cloned().collect();\n\
    \    nums.sort();\n    nums.reverse();\n    let mut result: Vec<String> = Vec::new();\n\
    \    for n in nums {\n        match n {\n            1 => result.push(\"One\"\
    .to_string()),\n            2 => result.push(\"Two\".to_string()),\n         \
    \   3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => ()\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut vector: Vec<String> = Vec::new();\n    let mut\
    \ temp: Vec<isize> = Vec::new();\n    for i in arr {\n        if i >= 1 && i <=\
    \ 9 {\n            temp.push(i);\n        }\n    }\n    if temp.len() == 0 {\n\
    \        return vector;\n    }\n    temp.sort();\n    temp.reverse();\n    for\
    \ j in temp {\n        match j {\n            1 => vector.push(\"One\".to_string()),\n\
    \            2 => vector.push(\"Two\".to_string()),\n            3 => vector.push(\"\
    Three\".to_string()),\n            4 => vector.push(\"Four\".to_string()),\n \
    \           5 => vector.push(\"Five\".to_string()),\n            6 => vector.push(\"\
    Six\".to_string()),\n            7 => vector.push(\"Seven\".to_string()),\n  \
    \          8 => vector.push(\"Eight\".to_string()),\n            9 => vector.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    vector\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr.iter().filter(|n| *n > 0 && *n < 10).cloned().collect::<Vec<isize>>();\n\
    \    arr.sort();\n    arr.reverse();\n    arr.iter().map(|n| match n {\n     \
    \   1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 =>\
    \ \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\"\
    ,\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => panic!(\"This\
    \ shouldn't happen\"),\n    }).map(|s| s.to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpisqg6ddf.rs:21:46\n   |\n\
    21 |     let mut arr = arr.iter().filter(|n| *n > 0 && *n < 10).cloned().collect::<Vec<isize>>();\n\
    \   |                                              ^\n   |                   \
    \                           |\n   |                                          \
    \    expected `&isize`, found integer\n   |                                  \
    \            help: consider borrowing here: `&0`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmpisqg6ddf.rs:21:56\n   |\n21 |     let mut arr = arr.iter().filter(|n|\
    \ *n > 0 && *n < 10).cloned().collect::<Vec<isize>>();\n   |                 \
    \                                       ^^\n   |                             \
    \                           |\n   |                                          \
    \              expected `&isize`, found integer\n   |                        \
    \                                help: consider borrowing here: `&10`\n\nerror:\
    \ aborting due to 2 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    if arr.len()\
    \ == 0 {\n        return result;\n    }\n    let mut tmp = arr.clone();\n    tmp.sort();\n\
    \    tmp.reverse();\n    for i in tmp {\n        if i == 1 {\n            result.push(\"\
    One\".to_string());\n        } else if i == 2 {\n            result.push(\"Two\"\
    .to_string());\n        } else if i == 3 {\n            result.push(\"Three\"\
    .to_string());\n        } else if i == 4 {\n            result.push(\"Four\".to_string());\n\
    \        } else if i == 5 {\n            result.push(\"Five\".to_string());\n\
    \        } else if i == 6 {\n            result.push(\"Six\".to_string());\n \
    \       } else if i == 7 {\n            result.push(\"Seven\".to_string());\n\
    \        } else if i == 8 {\n            result.push(\"Eight\".to_string());\n\
    \        } else if i == 9 {\n            result.push(\"Nine\".to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&v| {\n        match v {\n            1 => \"One\",\n   \
    \         2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        }\n    }).filter(|&s| s != \"\").map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.iter()\n        .filter(|&x| *x >= 1 && *x <= 9)\n\
    \        .map(|&x| match x {\n            1 => \"One\",\n            2 => \"Two\"\
    ,\n            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\",\n        })\n\
    \        .rev()\n        .map(|x| x.to_string())\n        .collect()\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpyxwt6j5c.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    use std::cmp::Ordering;\n    let mut res = arr.iter().cloned().filter(|x|\
    \ (x >= 1) && (x <= 9)).collect::<Vec<isize>>();\n    res.sort_by(|a, b| b.cmp(a));\n\
    \    res.iter().map(|x| (*x as u8 + 48) as char).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "warning: unused import: `std::cmp::Ordering`\n  --> /tmp/tmp9mrcip9q.rs:18:9\n\
    \   |\n18 |     use std::cmp::Ordering;\n   |         ^^^^^^^^^^^^^^^^^^\n   |\n\
    \   = note: `#[warn(unused_imports)]` on by default\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp9mrcip9q.rs:19:56\n   |\n19 |     let mut res = arr.iter().cloned().filter(|x|\
    \ (x >= 1) && (x <= 9)).collect::<Vec<isize>>();\n   |                       \
    \                                 ^\n   |                                    \
    \                    |\n   |                                                 \
    \       expected `&isize`, found integer\n   |                               \
    \                         help: consider borrowing here: `&1`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmp9mrcip9q.rs:19:68\n   |\n19 |     let mut res\
    \ = arr.iter().cloned().filter(|x| (x >= 1) && (x <= 9)).collect::<Vec<isize>>();\n\
    \   |                                                                    ^\n \
    \  |                                                                    |\n  \
    \ |                                                                    expected\
    \ `&isize`, found integer\n   |                                              \
    \                      help: consider borrowing here: `&9`\n\nerror: aborting\
    \ due to 2 previous errors; 1 warning emitted\n\nFor more information about this\
    \ error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<_> = arr.into_iter().sorted().rev().collect();\n\
    \    let mut vec: Vec<String> = Vec::new();\n    let map = [(\"One\", 1), (\"\
    Two\", 2), (\"Three\", 3), (\"Four\", 4), (\"Five\", 5), (\"Six\", 6), (\"Seven\"\
    , 7), (\"Eight\", 8), (\"Nine\", 9)];\n    for i in arr {\n        for j in map.into_iter()\
    \ {\n            if i == j.1 {\n                vec.push(j.0.to_string());\n \
    \           }\n        }\n    }\n    vec\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpqq5tg_b4.rs:18:43\n   |\n18 |     let mut\
    \ arr: Vec<_> = arr.into_iter().sorted().rev().collect();\n   |              \
    \                             ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut digits: Vec<_> = arr.iter().filter(|&&x| 1 <=\
    \ x && x <= 9).map(|&x| x as usize).collect();\n    digits.sort();\n    digits.reverse();\n\
    \    digits.iter().map(|&d| {\n        match d {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        }.to_string()\n    }).collect()\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort();\n  \
    \  sorted.reverse();\n    sorted.iter().map(|x| by_length_integer_to_string(*x)).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `by_length_integer_to_string` in this\
    \ scope\n  --> /tmp/tmpz1o8t1k6.rs:21:27\n   |\n21 |     sorted.iter().map(|x|\
    \ by_length_integer_to_string(*x)).collect()\n   |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for num in arr {\n        if num < 1 ||\
    \ num > 9 {\n            continue;\n        }\n\n        result.push(match num\
    \ {\n            1 => \"One\",\n            2 => \"Two\",\n            3 => \"\
    Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n           \
    \ 6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n  \
    \          9 => \"Nine\",\n            _ => \"None\",\n        }.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let numbers = [\"One\", \"Two\", \"Three\", \"Four\",\
    \ \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    let mut output: Vec<String>\
    \ = Vec::new();\n    for num in arr {\n        if (1 <= num) && (num <= 9) {\n\
    \            output.push(numbers[(num - 1) as usize].to_string());\n        }\n\
    \    }\n    output.reverse();\n    output\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp1d8ak37g.rs:31:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut new_arr: Vec<String> = vec![];\n    for num in\
    \ arr {\n        if num < 1 || num > 9 {\n            continue;\n        }\n \
    \       match num {\n            1 => new_arr.push(\"One\".to_string()),\n   \
    \         2 => new_arr.push(\"Two\".to_string()),\n            3 => new_arr.push(\"\
    Three\".to_string()),\n            4 => new_arr.push(\"Four\".to_string()),\n\
    \            5 => new_arr.push(\"Five\".to_string()),\n            6 => new_arr.push(\"\
    Six\".to_string()),\n            7 => new_arr.push(\"Seven\".to_string()),\n \
    \           8 => new_arr.push(\"Eight\".to_string()),\n            9 => new_arr.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    new_arr.sort();\n\
    \    new_arr.reverse();\n    new_arr\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpk24oj_7l.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.iter().filter(|&&x| 0 <\
    \ x && x < 10).map(|&x| x).collect();\n    arr.sort();\n    arr.reverse();\n \
    \   arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let nums: Vec<_> = arr.iter().map(|i| match i {\n    \
    \    1 => Some(\"One\"),\n        2 => Some(\"Two\"),\n        3 => Some(\"Three\"\
    ),\n        4 => Some(\"Four\"),\n        5 => Some(\"Five\"),\n        6 => Some(\"\
    Six\"),\n        7 => Some(\"Seven\"),\n        8 => Some(\"Eight\"),\n      \
    \  9 => Some(\"Nine\"),\n        _ => None,\n    }).filter(|i| i.is_some()).map(|i|\
    \ i.unwrap()).collect();\n    let mut nums = nums;\n    nums.sort();\n    nums.reverse();\n\
    \    nums\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmpp6stfefw.rs:33:5\n   |\n\
    17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    33 |     nums\n   |     ^^^^ expected struct `String`, found `&str`\n   |\n  \
    \ = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let numbers = vec![\n        \"Zero\", \"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\",\n    ];\n    let mut sorted\
    \ = arr\n        .iter()\n        .filter(|x| **x >= 0 && **x <= 9)\n        .map(|x|\
    \ *x as usize)\n        .collect::<Vec<usize>>();\n    sorted.sort();\n    sorted.reverse();\n\
    \    sorted.iter().map(|x| numbers[*x].to_string()).collect()\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut vec = arr.clone();\n    vec.sort();\n    vec.reverse();\n\
    \    vec.iter().map(|x| x.to_string()).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp6ygzoyv6.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    for e in\
    \ arr {\n        match e {\n            1 => result.push(\"One\".to_string()),\n\
    \            2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => {},\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp7fhd0794.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // your code here\n    let mut res = arr.clone();\n  \
    \  res.sort();\n    res.reverse();\n    let mut result = vec![];\n    for i in\
    \ res {\n        match i {\n            1 => result.push(\"One\".to_string()),\n\
    \            2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut a = arr.clone();\n    let mut res = vec![];\n\
    \    a.sort();\n    a.reverse();\n    for i in a {\n        if i < 1 || i > 9\
    \ {\n            continue;\n        }\n        res.push(match i {\n          \
    \  1 => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n        \
    \    3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n   \
    \         5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n\
    \            7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => \"\".to_string(),\n\
    \        });\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // Write your code here.\n    let mut num_arr: Vec<isize>\
    \ = Vec::new();\n    for num in arr {\n        if num > 0 && num < 10 {\n    \
    \        num_arr.push(num);\n        }\n    }\n    num_arr.sort();\n    num_arr.reverse();\n\
    \    let mut name_arr: Vec<String> = Vec::new();\n    for num in num_arr {\n \
    \       match num {\n            1 => name_arr.push(\"One\".to_string()),\n  \
    \          2 => name_arr.push(\"Two\".to_string()),\n            3 => name_arr.push(\"\
    Three\".to_string()),\n            4 => name_arr.push(\"Four\".to_string()),\n\
    \            5 => name_arr.push(\"Five\".to_string()),\n            6 => name_arr.push(\"\
    Six\".to_string()),\n            7 => name_arr.push(\"Seven\".to_string()),\n\
    \            8 => name_arr.push(\"Eight\".to_string()),\n            9 => name_arr.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    name_arr\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut array = arr.clone();\n  array.sort();\n  array.reverse();\n\
    \  array.iter().map(|num| match num {\n    1 => \"One\",\n    2 => \"Two\",\n\
    \    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\"\
    ,\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 => \"Nine\",\n    _ => \"\"\
    \n  }).filter(|num| num != &\"\").map(|num| num.to_string()).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // your code\n    let mut sorted_arr = arr.clone();\n\
    \    sorted_arr.sort();\n    sorted_arr.reverse();\n    sorted_arr.iter().filter(|&&n|\
    \ n > 0 && n < 10).map(|n| get_str(*n)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_str` in this scope\n  --> /tmp/tmplfvgayvt.rs:22:61\n\
    \   |\n22 |     sorted_arr.iter().filter(|&&n| n > 0 && n < 10).map(|n| get_str(*n)).collect()\n\
    \   |                                                             ^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut tmp = arr.clone();\n\
    \    tmp.sort();\n    tmp.reverse();\n    for i in tmp {\n        match i {\n\
    \            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => {}\n        }\n    }\n    result\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_arr = arr.iter().cloned().collect::<Vec<isize>>();\n\
    \    sorted_arr.sort();\n    sorted_arr.reverse();\n    sorted_arr.iter().cloned().filter(|&x|\
    \ x > 0 && x < 10).map(|x| format!(\"{}\", match x {\n        1 => \"One\",\n\
    \        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n    \
    \    5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n        8\
    \ => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    })).collect::<Vec<String>>()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr_copy = arr.clone();\n    arr_copy.sort();\n\
    \    arr_copy.reverse();\n    arr_copy.iter().filter(|&x| *x > 0 && *x < 10).map(|x|\
    \ number_name(*x)).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `number_name` in this scope\n  --> /tmp/tmpbu2_4x_a.rs:21:60\n\
    \   |\n21 |     arr_copy.iter().filter(|&x| *x > 0 && *x < 10).map(|x| number_name(*x)).collect()\n\
    \   |                                                            ^^^^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.iter().filter(|x| x >= &&1\
    \ && x <= &&9).cloned().collect();\n    arr.sort();\n    arr.reverse();\n    arr.iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"No\",\n    }).map(|x| x.to_string()).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| **x > 0 && **x < 10).map(|x| match x {\n        1 =>\
    \ \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4 => \"Four\"\
    ,\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"Seven\",\n  \
    \      8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n    }).map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let dict = [\n        \"\",\n        \"One\",\n        \"Two\",\n       \
    \ \"Three\",\n        \"Four\",\n        \"Five\",\n        \"Six\",\n       \
    \ \"Seven\",\n        \"Eight\",\n        \"Nine\",\n    ];\n    let mut result\
    \ = Vec::new();\n    for a in arr {\n        if 0 < a && a < 10 {\n          \
    \  result.push(a);\n        }\n    }\n    result.sort();\n    result.reverse();\n\
    \    let mut res = Vec::new();\n    for r in result {\n        res.push(dict[r\
    \ as usize].to_string());\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr_filtered: Vec<isize> = arr.clone().into_iter().filter(|x|\
    \ x > &0 && x < &10).collect();\n    arr_filtered.sort();\n    arr_filtered.reverse();\n\
    \    let result: Vec<String> = arr_filtered.into_iter().map(|x| get_text_of_num(x)).collect();\n\
    \    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_text_of_num` in this scope\n  -->\
    \ /tmp/tmpzbmkay4s.rs:21:64\n   |\n21 |     let result: Vec<String> = arr_filtered.into_iter().map(|x|\
    \ get_text_of_num(x)).collect();\n   |                                       \
    \                         ^^^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort();\n  \
    \  sorted.reverse();\n    sorted.iter().map(|x| x.to_string()).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp9psk5s3i.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|&x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmpl3vfbrkj.rs:32:35\n   |\n32 |     }).filter(|&x| x != \"\
    \").map(|&x| x.to_string()).collect()\n   |                                  \
    \ ^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut strings: Vec<String> = Vec::new();\n    let mut\
    \ map = std::collections::HashMap::new();\n    map.insert(1, \"One\");\n    map.insert(2,\
    \ \"Two\");\n    map.insert(3, \"Three\");\n    map.insert(4, \"Four\");\n   \
    \ map.insert(5, \"Five\");\n    map.insert(6, \"Six\");\n    map.insert(7, \"\
    Seven\");\n    map.insert(8, \"Eight\");\n    map.insert(9, \"Nine\");\n    for\
    \ i in arr {\n        if i < 1 || i > 9 {\n            continue;\n        }\n\
    \        let i = *map.get(&i).unwrap();\n        strings.push(i.to_string());\n\
    \    }\n    strings.reverse();\n    strings\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp2ajov6ti.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let names = [\"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    let mut sorted = arr.into_iter().filter(|i|\
    \ *i > 0 && *i < 10).collect::<Vec<isize>>();\n    sorted.sort();\n    sorted.reverse();\n\
    \    sorted.into_iter().map(|i| names[(i - 1) as usize].to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut res: Vec<String> = Vec::new();\n  for i in arr {\n\
    \    match i {\n      1 => res.push(\"One\".to_string()),\n      2 => res.push(\"\
    Two\".to_string()),\n      3 => res.push(\"Three\".to_string()),\n      4 => res.push(\"\
    Four\".to_string()),\n      5 => res.push(\"Five\".to_string()),\n      6 => res.push(\"\
    Six\".to_string()),\n      7 => res.push(\"Seven\".to_string()),\n      8 => res.push(\"\
    Eight\".to_string()),\n      9 => res.push(\"Nine\".to_string()),\n      _ =>\
    \ (),\n    }\n  }\n  res\n}\n\nfn main() {\n    let candidate = by_length;\n \
    \   assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmptt4xq7ro.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n\
    \    sorted_arr.reverse();\n    let mut result: Vec<String> = vec![];\n    for\
    \ num in sorted_arr {\n        if num >= 1 && num <= 9 {\n            match num\
    \ {\n                1 => result.push(\"One\".to_string()),\n                2\
    \ => result.push(\"Two\".to_string()),\n                3 => result.push(\"Three\"\
    .to_string()),\n                4 => result.push(\"Four\".to_string()),\n    \
    \            5 => result.push(\"Five\".to_string()),\n                6 => result.push(\"\
    Six\".to_string()),\n                7 => result.push(\"Seven\".to_string()),\n\
    \                8 => result.push(\"Eight\".to_string()),\n                9 =>\
    \ result.push(\"Nine\".to_string()),\n                _ => (),\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ar = arr.clone();\n    ar.sort();\n    ar.reverse();\n\
    \    ar.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ans: Vec<String> = vec![];\n    if arr.len() ==\
    \ 0 {\n        return ans;\n    }\n    let mut arr: Vec<isize> = arr;\n    arr.sort();\n\
    \    arr.reverse();\n    for i in arr {\n        match i {\n            1 => ans.push(\"\
    One\".to_string()),\n            2 => ans.push(\"Two\".to_string()),\n       \
    \     3 => ans.push(\"Three\".to_string()),\n            4 => ans.push(\"Four\"\
    .to_string()),\n            5 => ans.push(\"Five\".to_string()),\n           \
    \ 6 => ans.push(\"Six\".to_string()),\n            7 => ans.push(\"Seven\".to_string()),\n\
    \            8 => ans.push(\"Eight\".to_string()),\n            9 => ans.push(\"\
    Nine\".to_string()),\n            _ => continue,\n        }\n    }\n    ans\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut arr = arr;\n  arr.sort();\n  arr.reverse();\n  arr.iter().filter(|&i|\
    \ *i > 0 && *i < 10).map(|&i| match i {\n    1 => \"One\",\n    2 => \"Two\",\n\
    \    3 => \"Three\",\n    4 => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\"\
    ,\n    7 => \"Seven\",\n    8 => \"Eight\",\n    9 => \"Nine\",\n    _ => unreachable!(),\n\
    \  }).map(|s| s.to_string()).collect()\n}\n\nfn main() {\n    let candidate =\
    \ by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut tmp = arr;\n    let mut result = Vec::new();\n\
    \    tmp.sort();\n    tmp.reverse();\n    for num in tmp {\n        if num ==\
    \ 1 {\n            result.push(\"One\".to_string());\n        } else if num ==\
    \ 2 {\n            result.push(\"Two\".to_string());\n        } else if num ==\
    \ 3 {\n            result.push(\"Three\".to_string());\n        } else if num\
    \ == 4 {\n            result.push(\"Four\".to_string());\n        } else if num\
    \ == 5 {\n            result.push(\"Five\".to_string());\n        } else if num\
    \ == 6 {\n            result.push(\"Six\".to_string());\n        } else if num\
    \ == 7 {\n            result.push(\"Seven\".to_string());\n        } else if num\
    \ == 8 {\n            result.push(\"Eight\".to_string());\n        } else if num\
    \ == 9 {\n            result.push(\"Nine\".to_string());\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut nums: Vec<isize> = Vec::new();\n    for i in arr\
    \ {\n        if i >= 1 && i <= 9 {\n            nums.push(i);\n        }\n   \
    \ }\n    nums.sort();\n    nums.reverse();\n    let nums = nums;\n    let mut\
    \ result: Vec<String> = Vec::new();\n    for i in nums {\n        match i {\n\
    \            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    if arr.len() > 0 {\n\
    \        let mut sorted_arr = arr.clone();\n        sorted_arr.sort();\n     \
    \   sorted_arr.reverse();\n        for num in sorted_arr {\n            if num\
    \ < 0 || num > 9 {\n                continue;\n            }\n            match\
    \ num {\n                1 => result.push(\"One\".to_string()),\n            \
    \    2 => result.push(\"Two\".to_string()),\n                3 => result.push(\"\
    Three\".to_string()),\n                4 => result.push(\"Four\".to_string()),\n\
    \                5 => result.push(\"Five\".to_string()),\n                6 =>\
    \ result.push(\"Six\".to_string()),\n                7 => result.push(\"Seven\"\
    .to_string()),\n                8 => result.push(\"Eight\".to_string()),\n   \
    \             9 => result.push(\"Nine\".to_string()),\n                _ => panic!(\"\
    Something went wrong\"),\n            }\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut result = Vec::new();\n    for i in arr {\n        match i {\n   \
    \         1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => {},\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    for i in arr {\n   \
    \     if i < 1 || i > 9 {\n            continue;\n        }\n\n        result.push(i);\n\
    \    }\n\n    result.sort();\n    result.reverse();\n\n    result.iter().map(|i|\
    \ match i {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).map(|i| i.to_string()).collect()\n}\n\nfn main() {\n  \
    \  let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res = vec![];\n    for e in arr {\n        match\
    \ e {\n            1 => res.push(\"One\".to_string()),\n            2 => res.push(\"\
    Two\".to_string()),\n            3 => res.push(\"Three\".to_string()),\n     \
    \       4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\"\
    .to_string()),\n            6 => res.push(\"Six\".to_string()),\n            7\
    \ => res.push(\"Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n\
    \            9 => res.push(\"Nine\".to_string()),\n            _ => {}\n     \
    \   }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpqr6xzwvn.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut dict = HashMap::new();\n    dict.insert(1, \"\
    One\");\n    dict.insert(2, \"Two\");\n    dict.insert(3, \"Three\");\n    dict.insert(4,\
    \ \"Four\");\n    dict.insert(5, \"Five\");\n    dict.insert(6, \"Six\");\n  \
    \  dict.insert(7, \"Seven\");\n    dict.insert(8, \"Eight\");\n    dict.insert(9,\
    \ \"Nine\");\n    let mut temp = arr.iter().filter(|&x| *x >= 1 && *x <= 9).map(|x|\
    \ *x).collect::<Vec<isize>>();\n    temp.sort();\n    temp.reverse();\n    let\
    \ output = temp.iter().map(|x| dict.get(x).unwrap().to_string()).collect::<Vec<String>>();\n\
    \    output\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpey4zyjrd.rs:18:20\n   |\n18 |     let mut dict = HashMap::new();\n \
    \  |                    ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut v = arr.clone();\n    v.sort();\n    v.reverse();\n\
    \    let mut result = Vec::new();\n    for i in v {\n        if i > 0 && i < 10\
    \ {\n            result.push(match i {\n                1 => \"One\",\n      \
    \          2 => \"Two\",\n                3 => \"Three\",\n                4 =>\
    \ \"Four\",\n                5 => \"Five\",\n                6 => \"Six\",\n \
    \               7 => \"Seven\",\n                8 => \"Eight\",\n           \
    \     9 => \"Nine\",\n                _ => \"\",\n            }.to_string());\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    for x in arr {\n   \
    \     if x == 1 {\n            result.push(\"One\".to_string());\n        } else\
    \ if x == 2 {\n            result.push(\"Two\".to_string());\n        } else if\
    \ x == 3 {\n            result.push(\"Three\".to_string());\n        } else if\
    \ x == 4 {\n            result.push(\"Four\".to_string());\n        } else if\
    \ x == 5 {\n            result.push(\"Five\".to_string());\n        } else if\
    \ x == 6 {\n            result.push(\"Six\".to_string());\n        } else if x\
    \ == 7 {\n            result.push(\"Seven\".to_string());\n        } else if x\
    \ == 8 {\n            result.push(\"Eight\".to_string());\n        } else if x\
    \ == 9 {\n            result.push(\"Nine\".to_string());\n        }\n    }\n \
    \   result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpvj325p_6.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|n| match n {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\"\n    }).filter(|&s| s != \"\").map(|s|\
    \ s.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut arr = arr;\n  arr.sort();\n  arr.reverse();\n  let\
    \ mut output = Vec::new();\n  for i in arr {\n    match i {\n      1 => output.push(\"\
    One\".to_string()),\n      2 => output.push(\"Two\".to_string()),\n      3 =>\
    \ output.push(\"Three\".to_string()),\n      4 => output.push(\"Four\".to_string()),\n\
    \      5 => output.push(\"Five\".to_string()),\n      6 => output.push(\"Six\"\
    .to_string()),\n      7 => output.push(\"Seven\".to_string()),\n      8 => output.push(\"\
    Eight\".to_string()),\n      9 => output.push(\"Nine\".to_string()),\n      _\
    \ => continue,\n    }\n  }\n  output\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let filter = arr.iter().filter(|&x| *x > 0 && *x < 10).collect::<Vec<_>>();\n\
    \    let mut sorted_filter = filter.clone();\n    sorted_filter.sort();\n    sorted_filter.reverse();\n\
    \    let mut result = Vec::new();\n    for num in sorted_filter {\n        result.push(name_finder(num));\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `name_finder` in this scope\n  --> /tmp/tmp0at_eirq.rs:24:21\n\
    \   |\n24 |         result.push(name_finder(num));\n   |                     ^^^^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut mutable_arr = arr.clone();\n  mutable_arr.sort();\n\
    \  mutable_arr.reverse();\n  let mut string_array: Vec<String> = Vec::new();\n\
    \  for i in mutable_arr {\n    match i {\n      1 => string_array.push(\"One\"\
    .to_string()),\n      2 => string_array.push(\"Two\".to_string()),\n      3 =>\
    \ string_array.push(\"Three\".to_string()),\n      4 => string_array.push(\"Four\"\
    .to_string()),\n      5 => string_array.push(\"Five\".to_string()),\n      6 =>\
    \ string_array.push(\"Six\".to_string()),\n      7 => string_array.push(\"Seven\"\
    .to_string()),\n      8 => string_array.push(\"Eight\".to_string()),\n      9\
    \ => string_array.push(\"Nine\".to_string()),\n      _ => continue,\n    }\n \
    \ }\n  string_array\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = vec![];\n    if arr.len() ==\
    \ 0 {\n        return res;\n    }\n    let mut sorted_arr = arr.clone();\n   \
    \ sorted_arr.sort();\n    sorted_arr.reverse();\n    for n in sorted_arr {\n \
    \       if n == -1 {\n            continue;\n        }\n        res.push(match\
    \ n {\n            1 => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n\
    \            3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n\
    \            5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n\
    \            7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => \"\".to_string(),\n\
    \        });\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"One\"]`,\n right: `[\"One\"]`', /tmp/tmphs1pk31o.rs:49:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        vec![]\n    } else {\n  \
    \      let sorted_arr = sort(arr);\n        let mut new_arr = Vec::new();\n  \
    \      for n in sorted_arr {\n            if n >= 1 && n <= 9 {\n            \
    \    new_arr.push(match n {\n                    1 => \"One\",\n             \
    \       2 => \"Two\",\n                    3 => \"Three\",\n                 \
    \   4 => \"Four\",\n                    5 => \"Five\",\n                    6\
    \ => \"Six\",\n                    7 => \"Seven\",\n                    8 => \"\
    Eight\",\n                    9 => \"Nine\",\n                    _ => \"\",\n\
    \                }.to_string());\n            }\n        }\n        new_arr.reverse();\n\
    \        new_arr\n    }\n}\n\nfn main() {\n    let candidate = by_length;\n  \
    \  assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"\
    ), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"One\")]);\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n    assert_eq!(candidate(vec![1,\
    \ -1, 55]), vec![String::from(\"One\")]);\n    assert_eq!(candidate(vec![1, -1,\
    \ 3, 2]), vec![String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"Nine\"\
    ), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort` in this scope\n  --> /tmp/tmpf04n6t3a.rs:21:26\n\
    \   |\n21 |         let sorted_arr = sort(arr);\n   |                        \
    \  ^^^^ not found in this scope\n\nerror: aborting due to previous error\n\nFor\
    \ more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut sorted_arr = arr.clone();\n  sorted_arr.sort();\n\
    \  sorted_arr.reverse();\n  // TODO: implement it\n  return sorted_arr.iter().filter(|x|\
    \ *x >= &1 && *x <= &9).map(|x|x.to_string()).collect();\n}\n\nfn main() {\n \
    \   let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpwdrdit4y.rs:27:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.iter().filter(|x| *x >=\
    \ &1 && *x <= &9).cloned().collect();\n    arr.sort();\n    arr.reverse();\n \
    \   arr.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => panic!(\"No such name\"),\n    }).map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ temp_vec: Vec<isize> = Vec::new();\n    if arr.len() == 0 {\n        return\
    \ result;\n    }\n    for i in 0..arr.len() {\n        if arr[i] > 0 && arr[i]\
    \ < 10 {\n            temp_vec.push(arr[i]);\n        }\n    }\n    temp_vec.sort();\n\
    \    temp_vec.reverse();\n    for i in 0..temp_vec.len() {\n        match temp_vec[i]\
    \ {\n            1 => result.push(\"One\".to_string()),\n            2 => result.push(\"\
    Two\".to_string()),\n            3 => result.push(\"Three\".to_string()),\n  \
    \          4 => result.push(\"Four\".to_string()),\n            5 => result.push(\"\
    Five\".to_string()),\n            6 => result.push(\"Six\".to_string()),\n   \
    \         7 => result.push(\"Seven\".to_string()),\n            8 => result.push(\"\
    Eight\".to_string()),\n            9 => result.push(\"Nine\".to_string()),\n \
    \           _ => (),\n        }\n    }\n    result\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut vec: Vec<String> = vec![];\n    if arr.len() ==\
    \ 0 {\n        return vec![];\n    }\n\n    let mut v = arr.clone();\n    v.sort();\n\
    \    v.reverse();\n\n    for i in v {\n        match i {\n            1 => vec.push(\"\
    One\".to_string()),\n            2 => vec.push(\"Two\".to_string()),\n       \
    \     3 => vec.push(\"Three\".to_string()),\n            4 => vec.push(\"Four\"\
    .to_string()),\n            5 => vec.push(\"Five\".to_string()),\n           \
    \ 6 => vec.push(\"Six\".to_string()),\n            7 => vec.push(\"Seven\".to_string()),\n\
    \            8 => vec.push(\"Eight\".to_string()),\n            9 => vec.push(\"\
    Nine\".to_string()),\n            _ => {},\n        }\n    }\n    vec\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    for i in arr {\n   \
    \     match i {\n            1 => result.push(\"One\".to_string()),\n        \
    \    2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"Three\"\
    .to_string()),\n            4 => result.push(\"Four\".to_string()),\n        \
    \    5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\", \"Two\", \"Three\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmp99qfe14o.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut numbers = arr.clone();\n\
    \    numbers.sort();\n    numbers.reverse();\n    for v in numbers {\n       \
    \ if v == 1 {\n            result.push(\"One\".to_string());\n        } else if\
    \ v == 2 {\n            result.push(\"Two\".to_string());\n        } else if v\
    \ == 3 {\n            result.push(\"Three\".to_string());\n        } else if v\
    \ == 4 {\n            result.push(\"Four\".to_string());\n        } else if v\
    \ == 5 {\n            result.push(\"Five\".to_string());\n        } else if v\
    \ == 6 {\n            result.push(\"Six\".to_string());\n        } else if v ==\
    \ 7 {\n            result.push(\"Seven\".to_string());\n        } else if v ==\
    \ 8 {\n            result.push(\"Eight\".to_string());\n        } else if v ==\
    \ 9 {\n            result.push(\"Nine\".to_string());\n        }\n    }\n    result\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut map = HashMap::new();\n    map.insert(0, \"Zero\"\
    );\n    map.insert(1, \"One\");\n    map.insert(2, \"Two\");\n    map.insert(3,\
    \ \"Three\");\n    map.insert(4, \"Four\");\n    map.insert(5, \"Five\");\n  \
    \  map.insert(6, \"Six\");\n    map.insert(7, \"Seven\");\n    map.insert(8, \"\
    Eight\");\n    map.insert(9, \"Nine\");\n\n    let mut result = Vec::new();\n\
    \    for n in arr {\n        if n >= 0 && n <= 9 {\n            result.push(n);\n\
    \        }\n    }\n    result.sort();\n    result.reverse();\n    let mut res\
    \ = Vec::new();\n    for n in result {\n        let x = map.get(&n).unwrap();\n\
    \        res.push(x.to_string());\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpwzkgk07l.rs:18:19\n   |\n18 |     let mut map = HashMap::new();\n  \
    \ |                   ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n    let mut strings\
    \ = Vec::new();\n    for i in arr {\n        match i {\n            1 => strings.push(\"\
    One\".to_string()),\n            2 => strings.push(\"Two\".to_string()),\n   \
    \         3 => strings.push(\"Three\".to_string()),\n            4 => strings.push(\"\
    Four\".to_string()),\n            5 => strings.push(\"Five\".to_string()),\n \
    \           6 => strings.push(\"Six\".to_string()),\n            7 => strings.push(\"\
    Seven\".to_string()),\n            8 => strings.push(\"Eight\".to_string()),\n\
    \            9 => strings.push(\"Nine\".to_string()),\n            _ => {}\n \
    \       }\n    }\n    strings\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr;\n    let mut result: Vec<String>\
    \ = Vec::new();\n    arr.sort();\n    arr.reverse();\n    for item in arr {\n\
    \        match item {\n            1 => result.push(\"One\".to_string()),\n  \
    \          2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => {},\n        }\n    }\n    result\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut numbers = arr.clone();\n    numbers.sort();\n\
    \    numbers.reverse();\n    let mut result = vec![];\n    for number in numbers\
    \ {\n        if 1 <= number && number <= 9 {\n            result.push(match number\
    \ {\n                1 => \"One\",\n                2 => \"Two\",\n          \
    \      3 => \"Three\",\n                4 => \"Four\",\n                5 => \"\
    Five\",\n                6 => \"Six\",\n                7 => \"Seven\",\n    \
    \            8 => \"Eight\",\n                9 => \"Nine\",\n               \
    \ _ => unreachable!(),\n            });\n        }\n    }\n    result\n}\n\nfn\
    \ main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1,\
    \ 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp5lrsie82.rs:38:5\n   |\n\
    17 | fn by_length(arr: Vec<isize>) -> Vec<String> {\n   |                    \
    \              ----------- expected `Vec<String>` because of return type\n...\n\
    38 |     result\n   |     ^^^^^^ expected struct `String`, found `&str`\n   |\n\
    \   = note: expected struct `Vec<String>`\n              found struct `Vec<&str>`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|num| {\n        match num {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        }\n    }).filter(|str| str.len() > 0).map(|str| str.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut arr = arr;\n  arr.sort();\n  arr.reverse();\n  arr.iter().map(|n|\
    \ match n {\n    1 => \"One\",\n    2 => \"Two\",\n    3 => \"Three\",\n    4\
    \ => \"Four\",\n    5 => \"Five\",\n    6 => \"Six\",\n    7 => \"Seven\",\n \
    \   8 => \"Eight\",\n    9 => \"Nine\",\n    _ => \"\"\n  }).filter(|s| !s.is_empty()).map(|s|\
    \ s.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = Vec::new();\n    let mut sorted_arr:\
    \ Vec<isize> = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    for i in sorted_arr {\n        match i {\n            1 => res.push(\"One\"\
    .to_string()),\n            2 => res.push(\"Two\".to_string()),\n            3\
    \ => res.push(\"Three\".to_string()),\n            4 => res.push(\"Four\".to_string()),\n\
    \            5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"\
    Six\".to_string()),\n            7 => res.push(\"Seven\".to_string()),\n     \
    \       8 => res.push(\"Eight\".to_string()),\n            9 => res.push(\"Nine\"\
    .to_string()),\n            _ => (),\n        }\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ordered = arr.clone();\n    ordered.sort();\n\
    \    ordered.reverse();\n    ordered.iter().map(|&x| {\n        match x {\n  \
    \          1 => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n\
    \            3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n\
    \            5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n\
    \            7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => \"\".to_string(),\n\
    \        }\n    }).filter(|s| !s.is_empty()).collect()\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return Vec::new();\n    }\n\
    \    let mut array = arr;\n    array.sort();\n    array.reverse();\n    array.iter().filter(|x|\
    \ *x > &0 && *x < 10).map(|n| match n {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"Invalid number\",\n    }).map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp7g4fjnzi.rs:24:45\n   |\n\
    24 |     array.iter().filter(|x| *x > &0 && *x < 10).map(|n| match n {\n   | \
    \                                            ^^\n   |                        \
    \                     |\n   |                                             expected\
    \ `&isize`, found integer\n   |                                             help:\
    \ consider borrowing here: `&10`\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ar: Vec<isize> = arr.clone();\n    let mut result:\
    \ Vec<String> = Vec::new();\n    ar.sort();\n    ar.reverse();\n    for i in ar\
    \ {\n        if i == 1 {\n            result.push(\"One\".to_string());\n    \
    \    } else if i == 2 {\n            result.push(\"Two\".to_string());\n     \
    \   } else if i == 3 {\n            result.push(\"Three\".to_string());\n    \
    \    } else if i == 4 {\n            result.push(\"Four\".to_string());\n    \
    \    } else if i == 5 {\n            result.push(\"Five\".to_string());\n    \
    \    } else if i == 6 {\n            result.push(\"Six\".to_string());\n     \
    \   } else if i == 7 {\n            result.push(\"Seven\".to_string());\n    \
    \    } else if i == 8 {\n            result.push(\"Eight\".to_string());\n   \
    \     } else if i == 9 {\n            result.push(\"Nine\".to_string());\n   \
    \     }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr.into_iter().filter(|x| *x\
    \ > 0 && *x < 10).collect();\n    arr.sort();\n    arr.reverse();\n    arr.into_iter().map(|x|\
    \ match x {\n        1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\"\
    ,\n        4 => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n   \
    \     7 => \"Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n     \
    \   _ => \"\",\n    }).filter(|x| !x.is_empty()).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut arr = arr;\n    let mut digits = vec![];\n    arr.sort();\n    arr.reverse();\n\
    \    for i in arr {\n        if i < 1 || i > 9 {\n            continue;\n    \
    \    }\n        match i {\n            1 => digits.push(\"One\".to_string()),\n\
    \            2 => digits.push(\"Two\".to_string()),\n            3 => digits.push(\"\
    Three\".to_string()),\n            4 => digits.push(\"Four\".to_string()),\n \
    \           5 => digits.push(\"Five\".to_string()),\n            6 => digits.push(\"\
    Six\".to_string()),\n            7 => digits.push(\"Seven\".to_string()),\n  \
    \          8 => digits.push(\"Eight\".to_string()),\n            9 => digits.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    }\n    digits\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = vec![];\n    let mut words\
    \ = vec![\"Zero\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\"];\n    for i in arr {\n        if i >= 1 && i <=\
    \ 9 {\n            res.push(words[i as usize].to_string());\n        }\n    }\n\
    \    res.sort();\n    res.reverse();\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpco6b43it.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut res: Vec<String> = vec![];\n    let mut i = arr.len()\
    \ - 1;\n    while i >= 0 {\n        if arr[i] == 1 {\n            res.push(\"\
    One\".to_string());\n        } else if arr[i] == 2 {\n            res.push(\"\
    Two\".to_string());\n        } else if arr[i] == 3 {\n            res.push(\"\
    Three\".to_string());\n        } else if arr[i] == 4 {\n            res.push(\"\
    Four\".to_string());\n        } else if arr[i] == 5 {\n            res.push(\"\
    Five\".to_string());\n        } else if arr[i] == 6 {\n            res.push(\"\
    Six\".to_string());\n        } else if arr[i] == 7 {\n            res.push(\"\
    Seven\".to_string());\n        } else if arr[i] == 8 {\n            res.push(\"\
    Eight\".to_string());\n        } else if arr[i] == 9 {\n            res.push(\"\
    Nine\".to_string());\n        }\n        i -= 1;\n    }\n    res\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to subtract with overflow', /tmp/tmpzmi8bd2d.rs:40:9\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut values = arr.clone();\n    let mut result = Vec::new();\n\
    \    values.sort();\n    values.reverse();\n    values.into_iter().for_each(|v|\
    \ {\n        match v {\n            1 => result.push(\"One\".to_string()),\n \
    \           2 => result.push(\"Two\".to_string()),\n            3 => result.push(\"\
    Three\".to_string()),\n            4 => result.push(\"Four\".to_string()),\n \
    \           5 => result.push(\"Five\".to_string()),\n            6 => result.push(\"\
    Six\".to_string()),\n            7 => result.push(\"Seven\".to_string()),\n  \
    \          8 => result.push(\"Eight\".to_string()),\n            9 => result.push(\"\
    Nine\".to_string()),\n            _ => (),\n        }\n    });\n    result\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut text: Vec<String> = vec![];\n    if arr.len()\
    \ == 0 {\n        return text;\n    }\n    if arr.iter().any(|&x| x < 1 || x >\
    \ 9) {\n        return vec![\"One\".to_string()];\n    }\n    let mut arr = arr.clone();\n\
    \    arr.sort();\n    arr.reverse();\n    for i in arr {\n        text.push(match\
    \ i {\n            1 => \"One\".to_string(),\n            2 => \"Two\".to_string(),\n\
    \            3 => \"Three\".to_string(),\n            4 => \"Four\".to_string(),\n\
    \            5 => \"Five\".to_string(),\n            6 => \"Six\".to_string(),\n\
    \            7 => \"Seven\".to_string(),\n            8 => \"Eight\".to_string(),\n\
    \            9 => \"Nine\".to_string(),\n            _ => \"One\".to_string(),\n\
    \        });\n    }\n    text\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"One\"]`,\n right: `[\"Three\", \"Two\", \"One\"]`', /tmp/tmpr9komn2r.rs:50:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut map = BTreeMap::new();\n    let mut res = Vec::new();\n\
    \    for i in arr {\n        if i > 0 && i < 10 {\n            *map.entry(i).or_insert(0)\
    \ += 1;\n        }\n    }\n    for (k, v) in map.iter().rev() {\n        let s\
    \ = if k == &1 {\n            \"One\".to_string()\n        } else if k == &2 {\n\
    \            \"Two\".to_string()\n        } else if k == &3 {\n            \"\
    Three\".to_string()\n        } else if k == &4 {\n            \"Four\".to_string()\n\
    \        } else if k == &5 {\n            \"Five\".to_string()\n        } else\
    \ if k == &6 {\n            \"Six\".to_string()\n        } else if k == &7 {\n\
    \            \"Seven\".to_string()\n        } else if k == &8 {\n            \"\
    Eight\".to_string()\n        } else if k == &9 {\n            \"Nine\".to_string()\n\
    \        } else {\n            panic!(\"key {} should not happen\", k);\n    \
    \    };\n        for _ in 0..*v {\n            res.push(s.clone());\n        }\n\
    \    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `BTreeMap`\n  -->\
    \ /tmp/tmpd82qwg53.rs:18:19\n   |\n18 |     let mut map = BTreeMap::new();\n \
    \  |                   ^^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::BTreeMap;\n   |\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = arr\n        .iter()\n        .filter(|x|\
    \ 0 < **x && **x < 10)\n        .map(|x| x.to_string())\n        .collect::<Vec<String>>();\n\
    \    result.sort();\n    result.reverse();\n    result\n}\n\nfn main() {\n   \
    \ let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8,\
    \ 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmpo0gy8e6g.rs:30:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    let mut sorted = arr.clone();\n\
    \    sorted.sort();\n    sorted.reverse();\n    for x in sorted {\n        if\
    \ x == -1 {\n            continue;\n        }\n        let name = match x {\n\
    \            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => \"\",\n        };\n        result.push(name.to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"\", \"One\"]`,\n right: `[\"One\"]`', /tmp/tmpx096ed2v.rs:47:5\nnote: run\
    \ with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4tz7wp8k.rs:18:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result = Vec::new();\n    for x in arr {\n   \
    \     if x < 0 || x > 9 {\n            continue;\n        }\n        result.push(match\
    \ x {\n            1 => \"One\",\n            2 => \"Two\",\n            3 =>\
    \ \"Three\",\n            4 => \"Four\",\n            5 => \"Five\",\n       \
    \     6 => \"Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n\
    \            9 => \"Nine\",\n            _ => \"Zero\",\n        }.to_string());\n\
    \    }\n    result.sort();\n    result.reverse();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpowvq2qur.rs:43:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut numbers: Vec<usize> = arr.iter().filter(|&x| *x\
    \ > 0 && *x < 10).map(|x| *x as usize).collect();\n    numbers.sort();\n    numbers.reverse();\n\
    \    let names = vec![\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\"];\n    let mut result: Vec<String> = Vec::new();\n\
    \    for num in numbers {\n        result.push(names[num - 1].to_string());\n\
    \    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr;\n    sorted.sort();\n    sorted.reverse();\n\
    \    sorted.iter().map(|&n| number_to_string(n)).collect()\n}\n\nfn main() {\n\
    \    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5,\
    \ 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `number_to_string` in this scope\n \
    \ --> /tmp/tmp9zmczio7.rs:21:28\n   |\n21 |     sorted.iter().map(|&n| number_to_string(n)).collect()\n\
    \   |                            ^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut vec = vec![];\n    for v in arr {\n        match\
    \ v {\n            1 => vec.push(\"One\".to_string()),\n            2 => vec.push(\"\
    Two\".to_string()),\n            3 => vec.push(\"Three\".to_string()),\n     \
    \       4 => vec.push(\"Four\".to_string()),\n            5 => vec.push(\"Five\"\
    .to_string()),\n            6 => vec.push(\"Six\".to_string()),\n            7\
    \ => vec.push(\"Seven\".to_string()),\n            8 => vec.push(\"Eight\".to_string()),\n\
    \            9 => vec.push(\"Nine\".to_string()),\n            _ => continue,\n\
    \        }\n    }\n    vec.sort();\n    vec.reverse();\n    vec\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Two\", \"Two\", \"Three\", \"One\", \"One\", \"Four\", \"Five\", \"Eight\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpegjvhh8r.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.iter().filter(|&&x| x < 10 && x >\
    \ 0).cloned().collect::<Vec<isize>>();\n    sorted.sort();\n    sorted.reverse();\n\
    \    sorted.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => unreachable!()\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    arr.iter()\n        .filter(|&x| *x >= 1 && *x <= 9)\n\
    \        .sorted()\n        .rev()\n        .map(|x| String::from(match x {\n\
    \            1 => \"One\",\n            2 => \"Two\",\n            3 => \"Three\"\
    ,\n            4 => \"Four\",\n            5 => \"Five\",\n            6 => \"\
    Six\",\n            7 => \"Seven\",\n            8 => \"Eight\",\n           \
    \ 9 => \"Nine\",\n            _ => \"?\",\n        }))\n        .collect()\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `Filter` in the\
    \ current scope\n  --> /tmp/tmp9gw0f1ey.rs:20:10\n   |\n20 |         .sorted()\n\
    \   |          ^^^^^^ method not found in `Filter<std::slice::Iter<'_, isize>,\
    \ [closure@/tmp/tmp9gw0f1ey.rs:19:17: 19:40]>`\n\nerror: aborting due to previous\
    \ error\n\nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut result: Vec<String> = Vec::new();\n    let mut\
    \ arr_sorted = arr.clone();\n    arr_sorted.sort();\n    for i in arr_sorted.iter().rev()\
    \ {\n        if *i > 0 && *i < 10 {\n            match *i {\n                1\
    \ => result.push(\"One\".to_string()),\n                2 => result.push(\"Two\"\
    .to_string()),\n                3 => result.push(\"Three\".to_string()),\n   \
    \             4 => result.push(\"Four\".to_string()),\n                5 => result.push(\"\
    Five\".to_string()),\n                6 => result.push(\"Six\".to_string()),\n\
    \                7 => result.push(\"Seven\".to_string()),\n                8 =>\
    \ result.push(\"Eight\".to_string()),\n                9 => result.push(\"Nine\"\
    .to_string()),\n                _ => println!(\"no match\"),\n            }\n\
    \        }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut m: HashMap<isize, &str> = HashMap::new();\n  \
    \  m.insert(1, \"One\");\n    m.insert(2, \"Two\");\n    m.insert(3, \"Three\"\
    );\n    m.insert(4, \"Four\");\n    m.insert(5, \"Five\");\n    m.insert(6, \"\
    Six\");\n    m.insert(7, \"Seven\");\n    m.insert(8, \"Eight\");\n    m.insert(9,\
    \ \"Nine\");\n    let mut res: Vec<String> = Vec::new();\n    for v in arr {\n\
    \        match m.get(&v) {\n            Some(s) => res.push(s.to_string()),\n\
    \            None => {}\n        }\n    }\n    res\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp_w5vd0y6.rs:18:16\n\
    \   |\n18 |     let mut m: HashMap<isize, &str> = HashMap::new();\n   |      \
    \          ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared type `HashMap`\n  --> /tmp/tmp_w5vd0y6.rs:18:39\n\
    \   |\n18 |     let mut m: HashMap<isize, &str> = HashMap::new();\n   |      \
    \                                 ^^^^^^^ not found in this scope\n   |\nhelp:\
    \ consider importing this struct\n   |\n1  | use std::collections::HashMap;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0412, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut result: Vec<String> = Vec::new();\n  if arr.len()\
    \ == 0 {\n    return result;\n  }\n  let mut v: Vec<isize> = arr.clone();\n  v.sort();\n\
    \  v.reverse();\n  for x in v {\n    if x > 0 && x < 10 {\n      match x {\n \
    \       1 => result.push(\"One\".to_string()),\n        2 => result.push(\"Two\"\
    .to_string()),\n        3 => result.push(\"Three\".to_string()),\n        4 =>\
    \ result.push(\"Four\".to_string()),\n        5 => result.push(\"Five\".to_string()),\n\
    \        6 => result.push(\"Six\".to_string()),\n        7 => result.push(\"Seven\"\
    .to_string()),\n        8 => result.push(\"Eight\".to_string()),\n        9 =>\
    \ result.push(\"Nine\".to_string()),\n        _ => {}\n      }\n    }\n  }\n \
    \ result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut nums: Vec<isize> = arr.iter().filter(|&&n| n >\
    \ 0 && n < 10).cloned().collect();\n    nums.sort();\n    nums.reverse();\n  \
    \  nums.iter().map(|&n| match n {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => unreachable!()\n    }).map(|s| s.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ret: Vec<String> = vec![];\n    let mut sorted\
    \ = arr.clone();\n    sorted.sort();\n    sorted.reverse();\n    for v in sorted\
    \ {\n        match v {\n            1 => ret.push(\"One\".to_string()),\n    \
    \        2 => ret.push(\"Two\".to_string()),\n            3 => ret.push(\"Three\"\
    .to_string()),\n            4 => ret.push(\"Four\".to_string()),\n           \
    \ 5 => ret.push(\"Five\".to_string()),\n            6 => ret.push(\"Six\".to_string()),\n\
    \            7 => ret.push(\"Seven\".to_string()),\n            8 => ret.push(\"\
    Eight\".to_string()),\n            9 => ret.push(\"Nine\".to_string()),\n    \
    \        _ => continue,\n        }\n    }\n    ret\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    use std::collections::HashMap;\n    let map = [(\"One\"\
    , 1), (\"Two\", 2), (\"Three\", 3), (\"Four\", 4), (\"Five\", 5), (\"Six\", 6),\
    \ (\"Seven\", 7), (\"Eight\", 8), (\"Nine\", 9)];\n    let map = map.iter().cloned().collect::<HashMap<_,\
    \ _>>();\n    arr.into_iter().filter(|&x| x > 0 && x < 10).collect::<Vec<_>>().sort();\n\
    \    arr.into_iter().filter(|&x| x > 0 && x < 10).collect::<Vec<_>>().reverse();\n\
    \    arr.into_iter().filter(|&x| x > 0 && x < 10).collect::<Vec<_>>().iter().map(|&x|\
    \ map[&x].to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the trait bound `&str: Borrow<isize>` is not satisfied\n\
    \  --> /tmp/tmpsqyxubap.rs:23:86\n   |\n23 |     arr.into_iter().filter(|&x| x\
    \ > 0 && x < 10).collect::<Vec<_>>().iter().map(|&x| map[&x].to_string()).collect()\n\
    \   |                                                                        \
    \              ^^^^^^^ the trait `Borrow<isize>` is not implemented for `&str`\n\
    \   |\n   = help: the trait `Borrow<str>` is implemented for `String`\n   = note:\
    \ required because of the requirements on the impl of `Index<&isize>` for `HashMap<&str,\
    \ {integer}>`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let map: HashMap<isize, &str> = [(1, \"One\"), (2, \"\
    Two\"), (3, \"Three\"), (4, \"Four\"), (5, \"Five\"), (6, \"Six\"), (7, \"Seven\"\
    ), (8, \"Eight\"), (9, \"Nine\")].iter().cloned().collect();\n    let mut result:\
    \ Vec<String> = Vec::new();\n    for num in arr {\n        if num < 1 || num >\
    \ 9 {\n            continue;\n        }\n        result.push(map.get(&num).unwrap().to_string());\n\
    \    }\n    result.sort();\n    result.reverse();\n    result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashMap` in this scope\n  --> /tmp/tmp_vlw4u_s.rs:18:14\n\
    \   |\n18 |     let map: HashMap<isize, &str> = [(1, \"One\"), (2, \"Two\"), (3,\
    \ \"Three\"), (4, \"Four\"), (5, \"Five\"), (6, \"Six\"), (7, \"Seven\"), (8,\
    \ \"Eight...\n   |              ^^^^^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut ret: Vec<String> = Vec::new();\n    for i in arr\
    \ {\n        let mut string = String::new();\n        match i {\n            1\
    \ => string.push_str(\"One\"),\n            2 => string.push_str(\"Two\"),\n \
    \           3 => string.push_str(\"Three\"),\n            4 => string.push_str(\"\
    Four\"),\n            5 => string.push_str(\"Five\"),\n            6 => string.push_str(\"\
    Six\"),\n            7 => string.push_str(\"Seven\"),\n            8 => string.push_str(\"\
    Eight\"),\n            9 => string.push_str(\"Nine\"),\n            _ => continue,\n\
    \        }\n        ret.push(string);\n    }\n    ret.reverse();\n    ret\n}\n\
    \nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"Three\", \"Two\", \"Eight\", \"Five\", \"Four\", \"One\", \"One\", \"Two\"\
    ]`,\n right: `[\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"\
    One\", \"One\"]`', /tmp/tmpi4zqqbx6.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // your code here\n    if arr.len() == 0 {\n        vec![]\n\
    \    } else {\n        arr.iter().filter(|&n| *n >= 1 && *n <= 9).map(|n| n.to_string()).collect::<Vec<String>>()\n\
    \    }\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"2\", \"1\", \"1\", \"4\", \"5\", \"8\", \"2\", \"3\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp7nua_mh8.rs:28:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut sorted_arr = arr.clone();\n    sorted_arr.sort();\n    sorted_arr.reverse();\n\
    \    let mut filtered_arr = vec![];\n    for num in sorted_arr {\n        if num\
    \ > 0 && num < 10 {\n            filtered_arr.push(num);\n        }\n    }\n \
    \   let mut ret = vec![];\n    for num in filtered_arr {\n        ret.push(num_to_string(num));\n\
    \    }\n    ret\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `num_to_string` in this scope\n  -->\
    \ /tmp/tmpv24sr5vv.rs:32:18\n   |\n32 |         ret.push(num_to_string(num));\n\
    \   |                  ^^^^^^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let num_names = [\"\", \"One\", \"Two\", \"Three\", \"\
    Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"];\n    let mut result:\
    \ Vec<String> = vec![];\n    arr.iter().filter(|&x| *x >= 1 && *x <= 9).sorted_by(|a,\
    \ b| b.cmp(a)).for_each(|n| {\n        result.push(num_names[*n as usize].to_string());\n\
    \    });\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted_by` found for struct `Filter` in\
    \ the current scope\n  --> /tmp/tmpdixrtwg_.rs:20:48\n   |\n20 |     arr.iter().filter(|&x|\
    \ *x >= 1 && *x <= 9).sorted_by(|a, b| b.cmp(a)).for_each(|n| {\n   |        \
    \                                        ^^^^^^^^^ method not found in `Filter<std::slice::Iter<'_,\
    \ isize>, [closure@/tmp/tmpdixrtwg_.rs:20:23: 20:46]>`\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sarr = arr.clone();\n    sarr.sort();\n    sarr.reverse();\n\
    \    sarr.iter().map(|num| match num {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).filter(|num| *num != \"\").map(|num|\
    \ String::from(num)).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut nums = arr\n        .into_iter()\n        .filter(|&x|\
    \ x > 0 && x < 10)\n        .collect::<Vec<isize>>();\n    nums.sort();\n    nums.reverse();\n\
    \    nums.into_iter()\n        .map(|x| match x {\n            1 => \"One\",\n\
    \            2 => \"Two\",\n            3 => \"Three\",\n            4 => \"Four\"\
    ,\n            5 => \"Five\",\n            6 => \"Six\",\n            7 => \"\
    Seven\",\n            8 => \"Eight\",\n            9 => \"Nine\",\n          \
    \  _ => \"\",\n        })\n        .map(|x| x.to_string())\n        .collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut vec = arr.clone();\n    vec.sort();\n    vec.reverse();\n    let mut\
    \ result = vec![];\n    for i in vec {\n        match i {\n            1 => result.push(\"\
    One\".to_string()),\n            2 => result.push(\"Two\".to_string()),\n    \
    \        3 => result.push(\"Three\".to_string()),\n            4 => result.push(\"\
    Four\".to_string()),\n            5 => result.push(\"Five\".to_string()),\n  \
    \          6 => result.push(\"Six\".to_string()),\n            7 => result.push(\"\
    Seven\".to_string()),\n            8 => result.push(\"Eight\".to_string()),\n\
    \            9 => result.push(\"Nine\".to_string()),\n            _ => {}\n  \
    \      }\n    }\n    result\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut v: Vec<isize> = arr\n        .into_iter()\n        .filter(|x| *x\
    \ > 0 && *x < 10)\n        .collect();\n    v.sort();\n    v.reverse();\n    v.into_iter()\n\
    \        .map(|x| match x {\n            1 => \"One\",\n            2 => \"Two\"\
    ,\n            3 => \"Three\",\n            4 => \"Four\",\n            5 => \"\
    Five\",\n            6 => \"Six\",\n            7 => \"Seven\",\n            8\
    \ => \"Eight\",\n            9 => \"Nine\",\n            _ => \"\",\n        })\n\
    \        .map(|x| x.to_string())\n        .collect()\n}\n\nfn main() {\n    let\
    \ candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]),\
    \ vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"Four\"\
    ), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"), String::from(\"\
    One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().map(|&x| match x {\n        1 => \"One\",\n        2 => \"Two\"\
    ,\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\",\n \
    \       6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n    \
    \    9 => \"Nine\",\n        _ => \"\",\n    }).filter(|&x| x != \"\").map(|&x|\
    \ x.to_string()).collect()\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0277]: the size for values of type `str` cannot be known at compilation\
    \ time\n  --> /tmp/tmprien6bvq.rs:32:35\n   |\n32 |     }).filter(|&x| x != \"\
    \").map(|&x| x.to_string()).collect()\n   |                                  \
    \ ^ doesn't have a size known at compile-time\n   |\n   = help: the trait `Sized`\
    \ is not implemented for `str`\n   = note: all local variables must have a statically\
    \ known size\n   = help: unsized locals are gated as an unstable feature\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0277`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut sorted = arr.clone();\n    sorted.sort();\n  \
    \  sorted.reverse();\n    sorted.iter().filter(|&n| n > &0 && n < &10).map(|n|\
    \ number_to_word(*n as usize)).collect()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `number_to_word` in this scope\n  -->\
    \ /tmp/tmpf24cwqkv.rs:21:58\n   |\n21 |     sorted.iter().filter(|&n| n > &0 &&\
    \ n < &10).map(|n| number_to_word(*n as usize)).collect()\n   |              \
    \                                            ^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().cloned().filter(|&x| x < 10 && x > 0).map(|x| match x {\n    \
    \    1 => \"One\",\n        2 => \"Two\",\n        3 => \"Three\",\n        4\
    \ => \"Four\",\n        5 => \"Five\",\n        6 => \"Six\",\n        7 => \"\
    Seven\",\n        8 => \"Eight\",\n        9 => \"Nine\",\n        _ => \"\",\n\
    \    }).collect::<Vec<&str>>().iter().map(|&x| x.to_string()).collect()\n}\n\n\
    fn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    let mut res = Vec::new();\n    for i in arr {\n        match i {\n      \
    \      1 => res.push(\"One\".to_string()),\n            2 => res.push(\"Two\"\
    .to_string()),\n            3 => res.push(\"Three\".to_string()),\n          \
    \  4 => res.push(\"Four\".to_string()),\n            5 => res.push(\"Five\".to_string()),\n\
    \            6 => res.push(\"Six\".to_string()),\n            7 => res.push(\"\
    Seven\".to_string()),\n            8 => res.push(\"Eight\".to_string()),\n   \
    \         9 => res.push(\"Nine\".to_string()),\n            _ => continue,\n \
    \       }\n    }\n    res\n}\n\nfn main() {\n    let candidate = by_length;\n\
    \    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    if arr.is_empty() {\n        return vec![];\n    }\n \
    \   let mut sorted = arr;\n    sorted.sort();\n    sorted.reverse();\n    let\
    \ mut filtered = sorted.into_iter().filter(|x| *x >= 1 && *x <= 9).collect::<Vec<isize>>();\n\
    \    filtered.iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => \"\",\n    }).collect::<Vec<&str>>().iter().map(|x|\
    \ x.to_string()).collect::<Vec<String>>()\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr: Vec<isize> = arr;\n    arr.sort();\n    arr.reverse();\n\
    \    arr.iter().filter(|x| **x > 0 && **x < 10).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `[\"8\", \"5\", \"4\", \"3\", \"2\", \"2\", \"1\", \"1\"]`,\n right: `[\"Eight\"\
    , \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]`', /tmp/tmp1vpdq9fs.rs:26:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    let mut arr_cloned = arr.clone();\n    arr_cloned.sort();\n\
    \    arr_cloned.reverse();\n    let mut res = Vec::new();\n    for num in arr_cloned\
    \ {\n        match num {\n            1 => res.push(\"One\".to_string()),\n  \
    \          2 => res.push(\"Two\".to_string()),\n            3 => res.push(\"Three\"\
    .to_string()),\n            4 => res.push(\"Four\".to_string()),\n           \
    \ 5 => res.push(\"Five\".to_string()),\n            6 => res.push(\"Six\".to_string()),\n\
    \            7 => res.push(\"Seven\".to_string()),\n            8 => res.push(\"\
    Eight\".to_string()),\n            9 => res.push(\"Nine\".to_string()),\n    \
    \        _ => (),\n        }\n    }\n    res\n}\n\nfn main() {\n    let candidate\
    \ = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"\
    Eight\"), String::from(\"Five\"), String::from(\"Four\"), String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"Two\"), String::from(\"One\"), String::from(\"\
    One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()), Vec::<String>::new());\n\
    \    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"One\")]);\n  \
    \  assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"), String::from(\"\
    Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9, 4, 8]), vec![String::from(\"\
    Nine\"), String::from(\"Eight\"), String::from(\"Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n  let mut new_arr: Vec<isize> = Vec::new();\n  let mut result:\
    \ Vec<String> = Vec::new();\n  for i in arr {\n    if i > 0 && i < 10 {\n    \
    \  new_arr.push(i);\n    }\n  }\n  new_arr.sort();\n  new_arr.reverse();\n  for\
    \ i in new_arr {\n    result.push(String::from(match i {\n      1 => \"One\",\n\
    \      2 => \"Two\",\n      3 => \"Three\",\n      4 => \"Four\",\n      5 =>\
    \ \"Five\",\n      6 => \"Six\",\n      7 => \"Seven\",\n      8 => \"Eight\"\
    ,\n      9 => \"Nine\",\n      _ => \"\",\n    }));\n  }\n  result\n}\n\nfn main()\
    \ {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2, 1, 1, 4,\
    \ 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"), String::from(\"\
    Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"Two\"\
    ), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// Given an array of integers, sort the integers that are between 1 and\
    \ 9 inclusive,\n/// reverse the resulting array, and then replace each digit by\
    \ its corresponding name from\n/// \"One\", \"Two\", \"Three\", \"Four\", \"Five\"\
    , \"Six\", \"Seven\", \"Eight\", \"Nine\".\n/// For example:\n/// arr = [2, 1,\
    \ 1, 4, 5, 8, 2, 3]   \n/// -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n/// -> reverse\
    \ arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n/// return [\"Eight\", \"Five\", \"Four\",\
    \ \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n/// If the array is empty, return\
    \ an empty array:\n/// arr = []\n/// return []\n/// If the array has any strange\
    \ number ignore it:\n/// arr = [1, -1 , 55] \n/// -> sort arr -> [-1, 1, 55]\n\
    /// -> reverse arr -> [55, 1, -1]\n/// return = ['One']\nfn by_length(arr: Vec<isize>)\
    \ -> Vec<String> {\n    // your code\n    let mut arr: Vec<usize> = arr.into_iter().filter(|x|\
    \ *x > 0 && *x < 10).map(|x| x as usize).collect();\n    arr.sort();\n    arr.reverse();\n\
    \    arr.into_iter().map(|x| match x {\n        1 => \"One\",\n        2 => \"\
    Two\",\n        3 => \"Three\",\n        4 => \"Four\",\n        5 => \"Five\"\
    ,\n        6 => \"Six\",\n        7 => \"Seven\",\n        8 => \"Eight\",\n \
    \       9 => \"Nine\",\n        _ => unreachable!(),\n    }).map(|x| x.to_string()).collect()\n\
    }\n\nfn main() {\n    let candidate = by_length;\n    assert_eq!(candidate(vec![2,\
    \ 1, 1, 4, 5, 8, 2, 3]), vec![String::from(\"Eight\"), String::from(\"Five\"),\
    \ String::from(\"Four\"), String::from(\"Three\"), String::from(\"Two\"), String::from(\"\
    Two\"), String::from(\"One\"), String::from(\"One\")]);\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ Vec::<String>::new());\n    assert_eq!(candidate(vec![1, -1, 55]), vec![String::from(\"\
    One\")]);\n    assert_eq!(candidate(vec![1, -1, 3, 2]), vec![String::from(\"Three\"\
    ), String::from(\"Two\"), String::from(\"One\")]);\n    assert_eq!(candidate(vec![9,\
    \ 4, 8]), vec![String::from(\"Nine\"), String::from(\"Eight\"), String::from(\"\
    Four\")]);\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
