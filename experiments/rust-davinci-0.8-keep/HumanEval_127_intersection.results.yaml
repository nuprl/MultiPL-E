name: HumanEval_127_intersection
language: rust
results:
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let s = interval1.0.max(interval2.0);\n   \
    \ let e = interval1.1.min(interval2.1);\n    if s > e {\n        return \"NO\"\
    .to_string();\n    }\n    if (e - s) < 2 {\n        return \"YES\".to_string();\n\
    \    }\n    let mut is_prime = false;\n    for i in 2..e {\n        if (e - s)\
    \ % i == 0 {\n            is_prime = true;\n            break;\n        }\n  \
    \  }\n    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7vxvihyf.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let x_min = interval1.0.max(interval2.0);\n\
    \    let x_max = interval1.1.min(interval2.1);\n    if x_min > x_max { return\
    \ \"NO\".to_string(); }\n    (x_max - x_min + 1).is_prime().to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpb4vy6_67.rs:21:25\n   |\n21 |     (x_max - x_min\
    \ + 1).is_prime().to_string()\n   |                         ^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    if (i1_start <= i2_start && i2_start <=\
    \ i1_end) ||\n       (i2_start <= i1_start && i1_start <= i2_end) {\n        let\
    \ start = i1_start.max(i2_start);\n        let end = i1_end.min(i2_end);\n   \
    \     if end - start < 2 {\n            return \"NO\".to_string();\n        }\n\
    \        if is_prime(end - start) {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpcq6etg13.rs:27:12\n\
    \   |\n27 |         if is_prime(end - start) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ interval1.0.max(interval2.0);\n    let end = interval1.1.min(interval2.1);\n\
    \    let size = (end - start) + 1;\n    match size {\n        0 | 1 => \"NO\"\
    .to_string(),\n        2 | 3 | 5 | 7 => \"YES\".to_string(),\n        4 | 6 |\
    \ 8 | 9 => \"NO\".to_string(),\n        _ => if is_prime(size) { \"YES\".to_string()\
    \ } else { \"NO\".to_string() }\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpx00_zk5j.rs:28:17\n\
    \   |\n28 |         _ => if is_prime(size) { \"YES\".to_string() } else { \"NO\"\
    .to_string() }\n   |                 ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // We need to check if the intervals' length\
    \ is a prime.\n    // If we intersect the two intervals, we know the length of\
    \ the\n    // intersection (if the intersection exists) will be a number\n   \
    \ // between 0 and min(end1 - start1, end2 - start2).\n    // Instead of iterating\
    \ through all possible values in this range,\n    // we can simply check if the\
    \ length is divisible by any number\n    // between 2 and sqrt(length)\n    let\
    \ start1 = cmp::max(interval1.0, interval2.0);\n    let end1 = cmp::min(interval1.1,\
    \ interval2.1);\n    let start2 = cmp::min(interval1.0, interval2.0);\n    let\
    \ end2 = cmp::max(interval1.1, interval2.1);\n    if start1 <= end1 {\n      \
    \  let length = (end1 - start1 + 1) as f64;\n        let max_divisor = (length.sqrt()\
    \ as isize) + 1;\n        if (2..max_divisor).any(|i| length as isize % i == 0)\
    \ {\n            return \"NO\".to_string();\n        }\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp5jt07p50.rs:25:18\n   |\n25 |     let start1 = cmp::max(interval1.0,\
    \ interval2.0);\n   |                  ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmp5jt07p50.rs:26:16\n   |\n26 |     let end1 = cmp::min(interval1.1,\
    \ interval2.1);\n   |                ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmp5jt07p50.rs:27:18\n   |\n27 |     let start2 = cmp::min(interval1.0,\
    \ interval2.0);\n   |                  ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmp5jt07p50.rs:28:16\n   |\n28 |     let end2 = cmp::max(interval1.1,\
    \ interval2.1);\n   |                ^^^ use of undeclared crate or module `cmp`\n\
    \nerror: aborting due to 4 previous errors\n\nFor more information about this\
    \ error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut ans = String::from(\"NO\");\n    if start1 >\
    \ end2 || start2 > end1 {\n        return ans;\n    }\n    let mut len = 0;\n\
    \    if start1 <= start2 && end1 >= start2 {\n        if end1 < end2 {\n     \
    \       len = end1 - start2 + 1;\n        } else {\n            len = end2 - start2\
    \ + 1;\n        }\n    } else if start2 <= start1 && end2 >= start1 {\n      \
    \  if end2 < end1 {\n            len = end2 - start1 + 1;\n        } else {\n\
    \            len = end1 - start1 + 1;\n        }\n    }\n    if is_prime(len)\
    \ {\n        ans = String::from(\"YES\");\n    }\n    ans\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp8tqwzklt.rs:38:8\n\
    \   |\n38 |     if is_prime(len) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let intersection = vec![interval1.0, interval1.1,\
    \ interval2.0, interval2.1];\n    let mut a = intersection[0];\n    let mut b\
    \ = intersection[0];\n    for i in &intersection {\n        if *i < a {\n    \
    \        a = *i;\n        }\n        if *i > b {\n            b = *i;\n      \
    \  }\n    }\n    let length = (b - a) + 1;\n    if length == 0 {\n        return\
    \ \"NO\".to_string();\n    }\n    if length % 2 == 0 {\n        return \"NO\"\
    .to_string();\n    }\n    if length <= 2 {\n        return \"YES\".to_string();\n\
    \    }\n    let mut d = 3;\n    while d < length {\n        if length % d == 0\
    \ {\n            return \"NO\".to_string();\n        }\n        d += 2;\n    }\n\
    \    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_vf8_7fy.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 >= interval2.1 || interval2.0\
    \ >= interval1.1 {\n        return \"NO\".to_string();\n    }\n    let mut limit\
    \ = interval1.1;\n    if interval2.1 < limit {\n        limit = interval2.1;\n\
    \    }\n    let mut begin = interval1.0;\n    if interval2.0 > begin {\n     \
    \   begin = interval2.0;\n    }\n    let length = limit - begin;\n    if is_prime(length)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpsp7c63my.rs:30:8\n\
    \   |\n30 |     if is_prime(length) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let min1 = interval1.0.min(interval1.1);\n\
    \    let max1 = interval1.0.max(interval1.1);\n    let min2 = interval2.0.min(interval2.1);\n\
    \    let max2 = interval2.0.max(interval2.1);\n    if min1 <= min2 && min2 <=\
    \ max1 && max1 <= max2 {\n        let interval3 = (min2, max1);\n        check_interval(interval3)\n\
    \    } else if min2 <= min1 && min1 <= max2 && max2 <= max1 {\n        let interval3\
    \ = (min1, max2);\n        check_interval(interval3)\n    } else {\n        String::from(\"\
    NO\")\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `check_interval` in this scope\n  -->\
    \ /tmp/tmp9h77vcl9.rs:24:9\n   |\n24 |         check_interval(interval3)\n   |\
    \         ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `check_interval` in this scope\n  --> /tmp/tmp9h77vcl9.rs:27:9\n  \
    \ |\n27 |         check_interval(interval3)\n   |         ^^^^^^^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    if i1_end < i2_start || i2_end < i1_start\
    \ {\n        return \"NO\".to_string();\n    }\n    let (a, b) = (\n        if\
    \ i1_start > i2_start { i1_start } else { i2_start },\n        if i1_end < i2_end\
    \ { i1_end } else { i2_end },\n    );\n    let result = if a >= b { 0 } else {\
    \ b - a };\n    if result.is_prime() {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpnr86l4mr.rs:28:15\n   |\n28 |     if result.is_prime()\
    \ {\n   |               ^^^^^^^^ method not found in `isize`\n\nerror: aborting\
    \ due to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_s, i1_e) = interval1;\n    let (i2_s,\
    \ i2_e) = interval2;\n    let (mut s, mut e) = (0, 0);\n    if i1_s >= i2_s &&\
    \ i1_s <= i2_e {\n        s = i1_s;\n    } else if i2_s >= i1_s && i2_s <= i1_e\
    \ {\n        s = i2_s;\n    }\n    if i1_e >= i2_s && i1_e <= i2_e {\n       \
    \ e = i1_e;\n    } else if i2_e >= i1_s && i2_e <= i1_e {\n        e = i2_e;\n\
    \    }\n    if s > e {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = (e - s + 1) as usize;\n    if len <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..len {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7pb1n17z.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = isize::max(start1, start2);\n    let end\
    \ = isize::min(end1, end2);\n    if start > end {\n        return \"NO\".to_string();\n\
    \    }\n    let diff = end - start + 1;\n    if diff == 2 {\n        return \"\
    YES\".to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..diff\
    \ {\n        if diff % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4l6c8shc.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (min, max) = (interval1.0.min(interval2.0),\
    \ interval1.1.max(interval2.1));\n    let (min, max) = (min.max(interval1.0).max(interval2.0),\
    \ max.min(interval1.1).min(interval2.1));\n    if min > max {\n        return\
    \ \"NO\".to_string();\n    }\n    if is_prime(max - min + 1) {\n        return\
    \ \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_ij8b_8l.rs:23:8\n\
    \   |\n23 |     if is_prime(max - min + 1) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ if interval1.0 < interval2.0 { interval2.0 } else { interval1.0 };\n    let\
    \ end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1 };\n \
    \   if start == end {\n        \"NO\".to_string()\n    } else {\n        let mut\
    \ prime = true;\n        for i in start..end {\n            if i < 2 {\n     \
    \           continue;\n            }\n            if (i != 2 && i % 2 == 0) ||\
    \ (i != 3 && i % 3 == 0) || (i != 5 && i % 5 == 0) || (i != 7 && i % 7 == 0) {\n\
    \                prime = false;\n                break;\n            }\n     \
    \   }\n        if prime {\n            \"YES\".to_string()\n        } else {\n\
    \            \"NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqeebab1d.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        \"NO\"\
    .to_string()\n    } else {\n        let start = if start1 > start2 { start1 }\
    \ else { start2 };\n        let end = if end1 < end2 { end1 } else { end2 };\n\
    \        let diff = end - start;\n        if diff > 1 && is_prime(diff) {\n  \
    \          \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpc8vnyfxw.rs:26:24\n\
    \   |\n26 |         if diff > 1 && is_prime(diff) {\n   |                    \
    \    ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let common_start = start1.max(start2);\n    let common_end\
    \ = end1.min(end2);\n    if common_start >= common_end {\n        return \"NO\"\
    .to_string();\n    }\n    let len = common_end - common_start;\n    if len ==\
    \ 1 {\n        return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n\
    \    for i in 2..(len as f64).sqrt() as isize + 1 {\n        if len % i == 0 {\n\
    \            is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    match (interval1, interval2) {\n        ((a,b),\
    \ (c,d)) if a > b || c > d => \"NO\".to_string(),\n        ((a,b), (c,d)) if (b\
    \ < c || d < a) => \"NO\".to_string(),\n        ((a,b), (c,d)) => {\n        \
    \    let (start, end) = (a.max(c), b.min(d));\n            (end - start).abs().is_prime().to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpuxceq3ga.rs:23:33\n   |\n23 |             (end\
    \ - start).abs().is_prime().to_string()\n   |                                \
    \ ^^^^^^^^ method not found in `isize`\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut prime = false;\n    let lower_interval\
    \ = std::cmp::max(interval1.0, interval2.0);\n    let upper_interval = std::cmp::min(interval1.1,\
    \ interval2.1);\n    if lower_interval > upper_interval {\n        return \"NO\"\
    .to_string();\n    }\n    for i in 2..upper_interval {\n        if upper_interval\
    \ % i == 0 {\n            prime = true;\n            break;\n        }\n    }\n\
    \    if prime {\n        return \"NO\".to_string();\n    }\n    return \"YES\"\
    .to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5_b423jx.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let intersection_length\
    \ = min(interval1.1, interval2.1) - max(interval1.0, interval2.0) + 1;\n    if\
    \ intersection_length > 1 && primes::is_prime(intersection_length as u64) {\n\
    \        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmppfvz75ae.rs:22:35\n   |\n22 |     if intersection_length > 1 &&\
    \ primes::is_prime(intersection_length as u64) {\n   |                       \
    \            ^^^^^^ use of undeclared crate or module `primes`\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmppfvz75ae.rs:21:31\n\
    \   |\n21 |     let intersection_length = min(interval1.1, interval2.1) - max(interval1.0,\
    \ interval2.0) + 1;\n   |                               ^^^\n...\n29 | fn main()\
    \ {\n   | --------- similarly named function `main` defined here\n   |\nhelp:\
    \ a function with a similar name exists\n   |\n21 |     let intersection_length\
    \ = main(interval1.1, interval2.1) - max(interval1.0, interval2.0) + 1;\n   |\
    \                               ~~~~\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `max`\
    \ in this scope\n  --> /tmp/tmppfvz75ae.rs:21:63\n   |\n21 |     let intersection_length\
    \ = min(interval1.1, interval2.1) - max(interval1.0, interval2.0) + 1;\n   | \
    \                                                              ^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror: aborting due to 3 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (low1, high1) = interval1;\n    let (low2,\
    \ high2) = interval2;\n    let low = if low1 > low2 { low1 } else { low2 };\n\
    \    let high = if high1 < high2 { high1 } else { high2 };\n    if low > high\
    \ {\n        return \"NO\".to_string();\n    }\n    let length = (high - low)\
    \ + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n    }\n   \
    \ let mut m = 3;\n    while m * m <= length {\n        if length % m == 0 {\n\
    \            return \"NO\".to_string();\n        }\n        m += 2;\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpm8ub875w.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut x = 0;\n    if interval1.0 < interval2.0\
    \ {\n        x = interval2.0;\n    } else {\n        x = interval1.0;\n    }\n\
    \    let mut y = 0;\n    if interval1.1 < interval2.1 {\n        y = interval1.1;\n\
    \    } else {\n        y = interval2.1;\n    }\n    if x <= y {\n        for i\
    \ in x..y + 1 {\n            if is_prime(i) {\n                return \"YES\"\
    .to_string();\n            }\n        }\n        return \"NO\".to_string();\n\
    \    } else {\n        return \"NO\".to_string();\n    }\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp3rukiu41.rs:32:16\n\
    \   |\n32 |             if is_prime(i) {\n   |                ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let int1 = interval1.1 - interval1.0;\n   \
    \ let int2 = interval2.1 - interval2.0;\n    if int1 < int2 {\n        if is_prime(int1)\
    \ {\n            return \"YES\".to_string();\n        }\n    } else {\n      \
    \  if is_prime(int2) {\n            return \"YES\".to_string();\n        }\n \
    \   }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpayd6m63e.rs:21:12\n\
    \   |\n21 |         if is_prime(int1) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n\
    \  --> /tmp/tmpayd6m63e.rs:25:12\n   |\n25 |         if is_prime(int2) {\n   |\
    \            ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let (a, b) =\
    \ if interval1.0 > interval2.0 {\n        (interval1.0, if interval1.1 < interval2.1\
    \ {\n            interval1.1\n        } else {\n            interval2.1\n    \
    \    })\n    } else {\n        (interval2.0, if interval2.1 < interval1.1 {\n\
    \            interval2.1\n        } else {\n            interval1.1\n        })\n\
    \    };\n    if a == b {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ flag = true;\n    for i in 2..a {\n        if a % i == 0 {\n            flag\
    \ = false;\n            break;\n        }\n    }\n    if flag {\n        return\
    \ \"YES\".to_string();\n    }\n    for i in 2..b {\n        if b % i == 0 {\n\
    \            flag = false;\n            break;\n        }\n    }\n    if flag\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkf8v4eyf.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    match calculate_intersection_length(interval1,\
    \ interval2) {\n        0 => \"NO\".to_string(),\n        1 => \"NO\".to_string(),\n\
    \        length => {\n            if is_prime(length) {\n                \"YES\"\
    .to_string()\n            } else {\n                \"NO\".to_string()\n     \
    \       }\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `calculate_intersection_length` in this\
    \ scope\n  --> /tmp/tmp2uuy02pm.rs:18:11\n   |\n18 |     match calculate_intersection_length(interval1,\
    \ interval2) {\n   |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n  -->\
    \ /tmp/tmp2uuy02pm.rs:22:16\n   |\n22 |             if is_prime(length) {\n  \
    \ |                ^^^^^^^^ not found in this scope\n\nerror: aborting due to\
    \ 2 previous errors\n\nFor more information about this error, try `rustc --explain\
    \ E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    match (interval1, interval2) {\n        ((min1,\
    \ max1), (min2, max2)) if min1 > max2 || min2 > max1 => \"NO\".to_string(),\n\
    \        ((min1, max1), (min2, max2)) => {\n            let start = if min1 >\
    \ min2 { min1 } else { min2 };\n            let end = if max1 < max2 { max1 }\
    \ else { max2 };\n            let range = end - start;\n            if range ==\
    \ 0 {\n                \"NO\".to_string()\n            } else {\n            \
    \    let mut is_prime = true;\n                for divisor in 2..range {\n   \
    \                 if range % divisor == 0 {\n                        is_prime\
    \ = false;\n                        break;\n                    }\n          \
    \      }\n                if is_prime {\n                    \"YES\".to_string()\n\
    \                } else {\n                    \"NO\".to_string()\n          \
    \      }\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4gnx97u0.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let max_int = 1_000_000_000;\n    let (start1,\
    \ end1) = (interval1.0.min(interval1.1), interval1.0.max(interval1.1));\n    let\
    \ (start2, end2) = (interval2.0.min(interval2.1), interval2.0.max(interval2.1));\n\
    \    if end1 <= start2 || end2 <= start1 {\n        return \"NO\".to_string();\n\
    \    }\n    let (start, end) = (start1.max(start2), end1.min(end2));\n    if end\
    \ - start < max_int {\n        match (end - start).is_prime() {\n            true\
    \ => \"YES\".to_string(),\n            false => \"NO\".to_string(),\n        }\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpd2rn5kmt.rs:26:29\n   |\n26 |         match (end\
    \ - start).is_prime() {\n   |                             ^^^^^^^^ method not\
    \ found in `isize`\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if c >= b || a >= d {\n        return \"NO\".to_string();\n    }\n    let\
    \ interval3 = (c.max(a), b.min(d));\n    let (_, len) = interval3;\n    let mut\
    \ is_prime = true;\n    if len > 1 {\n        for i in 2..len {\n            if\
    \ len % i == 0 {\n                is_prime = false;\n                break;\n\
    \            }\n        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmptdq38j6t.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let (start1, end1) = interval1;\n  let (start2,\
    \ end2) = interval2;\n  if start1 > end2 || start2 > end1 {\n    return \"NO\"\
    .to_string();\n  }\n  let (start, end) = (start1.max(start2), end1.min(end2));\n\
    \  let length = end - start + 1;\n  if length < 2 {\n    return \"NO\".to_string();\n\
    \  }\n  if length == 2 {\n    return \"YES\".to_string();\n  }\n  for num in 2..length\
    \ {\n    if length % num == 0 {\n      return \"NO\".to_string();\n    }\n  }\n\
    \  \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpr5_z3xeq.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start = max(a, c);\n    let mut end = min(b, d);\n    if start >\
    \ end {\n        start = 0;\n        end = 0;\n    }\n    if is_prime(end - start\
    \ + 1) {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmppv6qw831.rs:20:21\n\
    \   |\n20 |     let mut start = max(a, c);\n   |                     ^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min` in this scope\n\
    \  --> /tmp/tmppv6qw831.rs:21:19\n   |\n21 |     let mut end = min(b, d);\n  \
    \ |                   ^^^\n...\n33 | fn main() {\n   | --------- similarly named\
    \ function `main` defined here\n   |\nhelp: a function with a similar name exists\n\
    \   |\n21 |     let mut end = main(b, d);\n   |                   ~~~~\nhelp:\
    \ consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmppv6qw831.rs:26:8\n\
    \   |\n26 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut min_start = start1;\n    let mut max_end = end1;\n\
    \    if start2 < min_start {\n        min_start = start2;\n    }\n    if end2\
    \ > max_end {\n        max_end = end2;\n    }\n    if min_start > max_end {\n\
    \        return \"NO\".to_string();\n    }\n    if is_prime(max_end - min_start\
    \ + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpg8bp5xfw.rs:31:8\n\
    \   |\n31 |     if is_prime(max_end - min_start + 1) {\n   |        ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (l1, r1) = interval1;\n    let (l2, r2)\
    \ = interval2;\n    if r1 < l2 || r2 < l1 { return \"NO\".to_string(); }\n   \
    \ let (l, r) = (std::cmp::max(l1, l2), std::cmp::min(r1, r2));\n    if l == r\
    \ { return \"NO\".to_string(); }\n    if (2..(l / 2)).any(|x| l % x == 0) { return\
    \ \"NO\".to_string(); }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvg_0io6y.rs:30:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (l1, r1) = interval1;\n    let (l2, r2)\
    \ = interval2;\n    if l1 > r2 || l2 > r1 {\n        return \"NO\".to_string();\n\
    \    }\n    let left = if l1 < l2 { l2 } else { l1 };\n    let right = if r1 <\
    \ r2 { r1 } else { r2 };\n    let diff = right - left + 1;\n    if diff == 1 {\n\
    \        return \"NO\".to_string();\n    }\n    if diff == 2 {\n        return\
    \ \"YES\".to_string();\n    }\n    let mut count = 0;\n    for i in 2..diff {\n\
    \        if diff % i == 0 {\n            count += 1;\n        }\n    }\n    if\
    \ count == 0 {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmptvjegexi.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        \"\
    NO\".to_string()\n    } else {\n        is_prime(end - start + 1)\n    }\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpajhluvth.rs:23:9\n\
    \   |\n23 |         is_prime(end - start + 1)\n   |         ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut start: isize = 0;\n    let mut end: isize = 0;\n    if a <= c &&\
    \ c <= b {\n        start = c;\n    } else if c <= a && a <= d {\n        start\
    \ = a;\n    }\n    if a <= d && d <= b {\n        end = d;\n    } else if c <=\
    \ b && b <= d {\n        end = b;\n    }\n    if end - start < 2 {\n        return\
    \ \"NO\".to_string();\n    }\n    for num in 2..end {\n        if num > start\
    \ && end % num == 0 {\n            return \"NO\".to_string();\n        }\n   \
    \ }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (min, max) = (\n        interval1.0.max(interval2.0),\n\
    \        interval1.1.min(interval2.1),\n    );\n    if min > max {\n        return\
    \ \"NO\".to_string();\n    }\n    if min == max {\n        if is_prime(min as\
    \ usize) {\n            return \"YES\".to_string();\n        }\n        return\
    \ \"NO\".to_string();\n    }\n    let mut count = 0;\n    for num in min..max\
    \ + 1 {\n        if is_prime(num as usize) {\n            count += 1;\n      \
    \  }\n    }\n    if count > 0 {\n        return \"YES\".to_string();\n    }\n\
    \    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7rc4l266.rs:26:12\n\
    \   |\n26 |         if is_prime(min as usize) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror[E0425]: cannot find function `is_prime` in this\
    \ scope\n  --> /tmp/tmp7rc4l266.rs:33:12\n   |\n33 |         if is_prime(num as\
    \ usize) {\n   |            ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = cmp::max(interval1.0, interval2.0);\n\
    \    let end = cmp::min(interval1.1, interval2.1);\n    if start <= end {\n  \
    \      if prime_len(start, end) { \"YES\".to_string() } else { \"NO\".to_string()\
    \ }\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmp4o_2q5ka.rs:18:17\n   |\n18 |     let start = cmp::max(interval1.0,\
    \ interval2.0);\n   |                 ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmp4o_2q5ka.rs:19:15\n   |\n19 |     let end = cmp::min(interval1.1,\
    \ interval2.1);\n   |               ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0425]: cannot find function `prime_len` in this scope\n  --> /tmp/tmp4o_2q5ka.rs:21:12\n\
    \   |\n21 |         if prime_len(start, end) { \"YES\".to_string() } else { \"\
    NO\".to_string() }\n   |            ^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (x1, y1) = interval1;\n    let (x2, y2)\
    \ = interval2;\n    let mut start = x1;\n    let mut end = y1;\n    if y1 < x2\
    \ || y2 < x1 {\n        return \"NO\".to_string();\n    }\n    if y1 > y2 {\n\
    \        end = y2;\n    }\n    if x1 < x2 {\n        start = x2;\n    }\n    let\
    \ mut i = start;\n    let mut primes = 2;\n    while i <= end {\n        let mut\
    \ is_prime = true;\n        for j in 2..i {\n            if i % j == 0 {\n   \
    \             is_prime = false;\n                break;\n            }\n     \
    \   }\n        if is_prime {\n            primes += 1;\n        }\n        i +=\
    \ 1;\n    }\n    if primes > 2 {\n        \"YES\".to_string()\n    } else {\n\
    \        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpfl9hco9f.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (max_start, min_end) = (\n        std::cmp::max(start1,\
    \ start2),\n        std::cmp::min(end1, end2),\n    );\n    let intersection_len\
    \ = min_end - max_start;\n    if intersection_len < 0 {\n        \"NO\".to_string()\n\
    \    } else {\n        if is_prime(intersection_len as usize) {\n            \"\
    YES\".to_string()\n        } else {\n            \"NO\".to_string()\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpcoljdog8.rs:28:12\n\
    \   |\n28 |         if is_prime(intersection_len as usize) {\n   |           \
    \ ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // check if they intersect\n    let mut max_start\
    \ = interval1.0;\n    let mut min_end = interval1.1;\n    if interval2.0 > max_start\
    \ {\n        max_start = interval2.0;\n    }\n    if interval2.1 < min_end {\n\
    \        min_end = interval2.1;\n    }\n    if max_start > min_end {\n       \
    \ return \"NO\".to_string();\n    }\n    // calculate length\n    let length =\
    \ min_end - max_start + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    // check if prime\n    for x in 2..length {\n        if length % x\
    \ == 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp14jkzvre.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut intersection_start = std::cmp::max(start1,\
    \ start2);\n    let mut intersection_end = std::cmp::min(end1, end2);\n    if\
    \ intersection_start == intersection_end {\n        return \"NO\".to_string();\n\
    \    }\n    let mut intersection_length = intersection_end - intersection_start;\n\
    \    while intersection_length > 1 {\n        if intersection_start % intersection_length\
    \ == 0 ||\n            intersection_end % intersection_length == 0 {\n       \
    \     return \"NO\".to_string();\n        }\n        intersection_length -= 1;\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpove9zi9v.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 <= interval2.1 && interval2.0\
    \ <= interval1.1 {\n        let i = interval1.0.max(interval2.0);\n        let\
    \ j = interval1.1.min(interval2.1);\n        if is_prime(j - i + 1) {\n      \
    \      return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpo0zu_yel.rs:21:12\n\
    \   |\n21 |         if is_prime(j - i + 1) {\n   |            ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let i1 = if interval1.0 > interval1.1 { (interval1.1,\
    \ interval1.0) } else { interval1 };\n    let i2 = if interval2.0 > interval2.1\
    \ { (interval2.1, interval2.0) } else { interval2 };\n    let mut isec = if i1.1\
    \ < i2.0 { None } else { Some((i2.0, i1.1)) };\n    if i1.0 >= i2.0 && i1.0 <=\
    \ i2.1 {\n        isec = Some((i1.0, i1.1));\n    }\n    if let Some((start, end))\
    \ = isec {\n        let diff = if start > end { start - end } else { end - start\
    \ };\n        if diff == 0 {\n            return \"YES\".to_string();\n      \
    \  }\n        let mut prime = true;\n        for i in 2..diff {\n            if\
    \ diff % i == 0 {\n                prime = false;\n                break;\n  \
    \          }\n        }\n        if prime {\n            return \"YES\".to_string();\n\
    \        }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpofg8ajbe.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let inter: isize\
    \ = if interval1.0 > interval2.0 {\n        if interval1.1 > interval2.1 {\n \
    \           interval2.1 - interval1.0\n        } else {\n            interval1.1\
    \ - interval1.0\n        }\n    } else {\n        if interval1.1 > interval2.1\
    \ {\n            interval2.1 - interval2.0\n        } else {\n            interval1.1\
    \ - interval2.0\n        }\n    };\n    if inter == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    let mut is_prime = true;\n    for i in 2..inter {\n\
    \        if inter % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpeoj9ekti.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut result = false;\n    let mut length\
    \ = 0;\n    let (mut a, mut b) = interval1;\n    let (mut c, mut d) = interval2;\n\
    \    if a > b {\n        std::mem::swap(&mut a, &mut b);\n    }\n    if c > d\
    \ {\n        std::mem::swap(&mut c, &mut d);\n    }\n    if b < c || a > d {\n\
    \        return \"NO\".to_string();\n    }\n    let start = if a > c { a } else\
    \ { c };\n    let end = if b < d { b } else { d };\n    for i in start..=end {\n\
    \        if i > 1 {\n            let mut is_prime = true;\n            for j in\
    \ 2..i {\n                if i % j == 0 {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ is_prime {\n                result = true;\n                break;\n       \
    \     }\n        }\n        length += 1;\n    }\n    if result {\n        \"YES\"\
    .to_string()\n    } else {\n        if length > 1 {\n            \"NO\".to_string()\n\
    \        } else {\n            \"YES\".to_string()\n        }\n    }\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp53u4y1z0.rs:62:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let (a, b) = interval1;\n  let (c, d) = interval2;\n\
    \  if b < c || d < a {\n    return \"NO\".to_string();\n  }\n  let mut i = isize::max(a,\
    \ c);\n  let mut j = isize::min(b, d);\n  if i == j {\n    return \"NO\".to_string();\n\
    \  }\n  if i == 2 {\n    return \"YES\".to_string();\n  }\n  i += 1;\n  while\
    \ i < j {\n    if i % 2 == 0 || i % 3 == 0 || i % 5 == 0 || i % 7 == 0 {\n   \
    \   return \"NO\".to_string();\n    }\n    i += 1;\n  }\n  \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpwn4tln22.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    if (end - start) < 3 {\n        return \"NO\"\
    .to_string();\n    }\n    if (end - start) % 2 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if (end - start) % 3 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if (end - start) % 5 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if (end - start) % 7 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    return \"YES\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmpkuh1c685.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut start = 0;\n    let mut end = 0;\n\
    \    if interval1.0 > interval2.0 {\n        start = interval1.0;\n    } else\
    \ {\n        start = interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n\
    \        end = interval1.1;\n    } else {\n        end = interval2.1;\n    }\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ is_prime = true;\n    for i in 2..(end - start + 1) {\n        if (end - start\
    \ + 1) % i == 0 {\n            is_prime = false;\n            break;\n       \
    \ }\n    }\n    if is_prime {\n        return \"YES\".to_string();\n    } else\
    \ {\n        return \"NO\".to_string();\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpilxogirt.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (min, max) = if start1 > start2 {\n        (start1,\
    \ end2)\n    } else {\n        (start2, end1)\n    };\n    if max < min {\n  \
    \      return \"NO\".to_string();\n    }\n    let length = max - min + 1;\n  \
    \  if is_prime(length) {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp55sa6nu6.rs:29:8\n\
    \   |\n29 |     if is_prime(length) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a <= d && b >= c {\n        is_prime((a..d).count() as u64)\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjad8olu4.rs:21:9\n\
    \   |\n21 |         is_prime((a..d).count() as u64)\n   |         ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let (start, end) = (std::cmp::max(start1, start2),\
    \ std::cmp::min(end1, end2));\n    let result = end - start + 1;\n    if result\
    \ == 1 {\n        return \"NO\".to_string();\n    }\n    return if is_prime(result)\
    \ { \"YES\".to_string() } else { \"NO\".to_string() };\n}\n\nfn main() {\n   \
    \ let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpxevt2hm5.rs:28:15\n\
    \   |\n28 |     return if is_prime(result) { \"YES\".to_string() } else { \"NO\"\
    .to_string() };\n   |               ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0, interval2.0);\n\
    \    let end = std::cmp::min(interval1.1, interval2.1);\n    if start > end {\n\
    \        return \"NO\".to_string();\n    }\n\n    let len = (end - start + 1)\
    \ as usize;\n    for i in 2..len {\n        if len % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpww1gcbad.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let max = |a, b| if a > b { a } else { b };\n\
    \    let min = |a, b| if a < b { a } else { b };\n    let max_a = max(interval1.0,\
    \ interval2.0);\n    let min_b = min(interval1.1, interval2.1);\n    if max_a\
    \ > min_b {\n        \"NO\".to_string()\n    } else {\n        let v = min_b -\
    \ max_a + 1;\n        if v == 1 {\n            \"NO\".to_string()\n        } else\
    \ {\n            let mut i = 2;\n            let mut is_prime = true;\n      \
    \      while i < v {\n                if v % i == 0 {\n                    is_prime\
    \ = false;\n                    break;\n                }\n                i +=\
    \ 1;\n            }\n            if is_prime {\n                \"YES\".to_string()\n\
    \            } else {\n                \"NO\".to_string()\n            }\n   \
    \     }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpo5j76qiy.rs:50:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let inter: Vec<isize> = interval1.1.min(interval2.1)..=interval1.0.max(interval2.0)\n\
    \        .min(interval1.1)\n        .min(interval2.1)\n        .max(interval1.0)\n\
    \        .max(interval2.0)\n        .collect();\n    let inter = inter.len() as\
    \ isize;\n    if inter == 0 {\n        return \"NO\".to_string();\n    }\n   \
    \ if inter == 1 {\n        return \"NO\".to_string();\n    }\n    if inter ==\
    \ 2 {\n        return \"NO\".to_string();\n    }\n    if inter == 3 {\n      \
    \  return \"YES\".to_string();\n    }\n    if inter % 2 == 0 {\n        return\
    \ \"NO\".to_string();\n    }\n    if inter % 3 == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if inter % 5 == 0 {\n        return \"NO\".to_string();\n    }\n \
    \   if inter % 7 == 0 {\n        return \"NO\".to_string();\n    }\n    if inter\
    \ % 11 == 0 {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `isize` is not an iterator\n  --> /tmp/tmpwv50jrk9.rs:23:10\n\
    \   |\n23 |         .collect();\n   |          ^^^^^^^ `isize` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `isize:\
    \ Iterator`\n           which is required by `&mut isize: Iterator`\n\nerror[E0308]:\
    \ mismatched types\n  --> /tmp/tmpwv50jrk9.rs:18:29\n   |\n18 |       let inter:\
    \ Vec<isize> = interval1.1.min(interval2.1)..=interval1.0.max(interval2.0)\n \
    \  |  ________________----------___^\n   | |                |\n   | |        \
    \        expected due to this\n19 | |         .min(interval1.1)\n20 | |      \
    \   .min(interval2.1)\n21 | |         .max(interval1.0)\n22 | |         .max(interval2.0)\n\
    23 | |         .collect();\n   | |__________________^ expected struct `Vec`, found\
    \ struct `RangeInclusive`\n   |\n   = note: expected struct `Vec<isize>`\n   \
    \           found struct `RangeInclusive<isize>`\n\nerror: aborting due to 2 previous\
    \ errors\n\nSome errors have detailed explanations: E0308, E0599.\nFor more information\
    \ about an error, try `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ if interval1.0 > interval2.0 { interval1.0 } else { interval2.0 };\n    let\
    \ end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1 };\n \
    \   let mut length = (end - start + 1) as usize;\n    if length < 2 {\n      \
    \  return \"NO\".to_string();\n    }\n    length -= 1;\n    let mut is_prime =\
    \ true;\n    for i in 2..(length / 2 + 1) {\n        if length % i == 0 {\n  \
    \          is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpuwkfyu0b.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    if i1_end < i2_start || i2_end < i1_start\
    \ {\n        return \"NO\".to_string();\n    }\n    let i1_interval = (std::cmp::max(i1_start,\
    \ i2_start), std::cmp::min(i1_end, i2_end));\n    let i1_length = i1_interval.1\
    \ - i1_interval.0;\n    let is_prime = match i1_length {\n        1 | 0 => false,\n\
    \        2 => true,\n        l if l > 2 => {\n            let limit = (l as f64).sqrt()\
    \ as isize + 1;\n            (2..limit).all(|x| l % x != 0)\n        }\n     \
    \   _ => false,\n    };\n    if is_prime {\n        \"YES\".to_string()\n    }\
    \ else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (interval1.0, interval1.1);\n\
    \    if interval1.0 > interval2.0 {\n        start = interval2.0;\n    }\n   \
    \ if interval1.1 < interval2.1 {\n        end = interval2.1;\n    }\n    if start\
    \ > end {\n        return \"NO\".to_string();\n    }\n    if is_prime((end - start)\
    \ as usize) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp8yo39f_j.rs:28:8\n\
    \   |\n28 |     if is_prime((end - start) as usize) {\n   |        ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if let Some(interval) = intersect(interval1,\
    \ interval2) {\n        if is_prime(interval.len() as usize) {\n            return\
    \ \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `intersect` in this scope\n  --> /tmp/tmpn3r31tne.rs:18:29\n\
    \   |\n18 |     if let Some(interval) = intersect(interval1, interval2) {\n  \
    \ |                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmpn3r31tne.rs:19:12\n\
    \   |\n19 |         if is_prime(interval.len() as usize) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut intervals: Vec<(isize, isize)> = vec![interval1,\
    \ interval2];\n    intervals.sort_by(|a, b| a.1.cmp(&b.1));\n    let mut intersections:\
    \ Vec<isize> = vec![];\n    for i in 0..intervals.len() - 1 {\n        if intervals[i].1\
    \ >= intervals[i + 1].0 {\n            intersections.push(intervals[i + 1].0 -\
    \ intervals[i].1);\n        }\n    }\n    for length in intersections {\n    \
    \    if !is_prime(length) {\n            return \"NO\".to_string();\n        }\n\
    \    }\n    if intersections.len() == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp2gb2gf43.rs:27:13\n\
    \   |\n27 |         if !is_prime(length) {\n   |             ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  if interval1.0 > interval2.1 || interval2.0 >\
    \ interval1.1 {\n    return \"NO\".to_string();\n  }\n  let mut result = vec![];\n\
    \  for i in interval1.0..interval1.1+1 {\n    if i >= interval2.0 && i <= interval2.1\
    \ {\n      result.push(i);\n    }\n  }\n  for i in interval2.0..interval2.1+1\
    \ {\n    if i >= interval1.0 && i <= interval1.1 {\n      result.push(i);\n  \
    \  }\n  }\n  if result.len() < 2 {\n    return \"NO\".to_string();\n  }\n  let\
    \ res = result.iter().max().unwrap() - result.iter().min().unwrap();\n  if (2..res-1).all(|x|\
    \ res % x != 0) {\n    return \"YES\".to_string();\n  }\n  \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp2lm9e5e0.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let small_left = cmp::min(interval1.0, interval2.0);\n\
    \    let big_right = cmp::max(interval1.1, interval2.1);\n    let min_interval\
    \ = cmp::min(interval1.1 - interval1.0, interval2.1 - interval2.0);\n    let intersection\
    \ = if small_left >= big_right {\n        0\n    } else {\n        cmp::min(interval1.1,\
    \ interval2.1) - cmp::max(interval1.0, interval2.0)\n    };\n    if intersection\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    let prime = if intersection\
    \ == 1 {\n        true\n    } else {\n        if intersection % 2 == 0 {\n   \
    \         false\n        } else {\n            let mut i = 3;\n            let\
    \ mut is_prime = true;\n            while i <= (intersection as f64).sqrt() as\
    \ isize {\n                if intersection % i == 0 {\n                    is_prime\
    \ = false;\n                    break;\n                }\n                i +=\
    \ 2;\n            }\n            is_prime\n        }\n    };\n    if prime {\n\
    \        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpy4cdo_6h.rs:18:22\n   |\n18 |     let small_left = cmp::min(interval1.0,\
    \ interval2.0);\n   |                      ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmpy4cdo_6h.rs:19:21\n   |\n19 |     let big_right = cmp::max(interval1.1,\
    \ interval2.1);\n   |                     ^^^ use of undeclared crate or module\
    \ `cmp`\n\nerror[E0433]: failed to resolve: use of undeclared crate or module\
    \ `cmp`\n  --> /tmp/tmpy4cdo_6h.rs:20:24\n   |\n20 |     let min_interval = cmp::min(interval1.1\
    \ - interval1.0, interval2.1 - interval2.0);\n   |                        ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed to resolve:\
    \ use of undeclared crate or module `cmp`\n  --> /tmp/tmpy4cdo_6h.rs:24:9\n  \
    \ |\n24 |         cmp::min(interval1.1, interval2.1) - cmp::max(interval1.0, interval2.0)\n\
    \   |         ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpy4cdo_6h.rs:24:46\n\
    \   |\n24 |         cmp::min(interval1.1, interval2.1) - cmp::max(interval1.0,\
    \ interval2.0)\n   |                                              ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror: aborting due to 5 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut a, mut b) = interval1;\n    let (mut\
    \ c, mut d) = interval2;\n    if b < a { a = b; b = interval1.0; }\n    if d <\
    \ c { c = d; d = interval2.0; }\n    let max_start = a.max(c);\n    let min_end\
    \ = b.min(d);\n    if min_end < max_start { return \"NO\".to_string(); }\n   \
    \ if (min_end - max_start + 1).is_prime() { \"YES\".to_string() } else { \"NO\"\
    .to_string() }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpas2wqm3s.rs:25:34\n   |\n25 |     if (min_end -\
    \ max_start + 1).is_prime() { \"YES\".to_string() } else { \"NO\".to_string()\
    \ }\n   |                                  ^^^^^^^^ method not found in `isize`\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let a = if interval1.0 > interval2.0 { interval1.0\
    \ } else { interval2.0 };\n    let b = if interval1.1 < interval2.1 { interval1.1\
    \ } else { interval2.1 };\n    if a > b { return \"NO\".to_string(); }\n    let\
    \ len = (b - a + 1) as usize;\n    if len <= 2 { return \"NO\".to_string(); }\n\
    \    let mut p: usize = 3;\n    while p <= len {\n        if len % p == 0 { return\
    \ \"NO\".to_string(); }\n        p += 2;\n    }\n    \"YES\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmprv0bvijw.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = match interval1.0 > interval2.0\
    \ {\n        true => interval1.0,\n        false => interval2.0,\n    };\n   \
    \ let end = match interval1.1 < interval2.1 {\n        true => interval1.1,\n\
    \        false => interval2.1,\n    };\n    let diff = if start < end { end -\
    \ start } else { 0 };\n    if diff == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut count = 0;\n    for i in 2..diff {\n        if diff % i ==\
    \ 0 {\n            count += 1;\n        }\n    }\n    if count == 0 {\n      \
    \  \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpu1e7u8id.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_1, i1_2) = interval1;\n    let (i2_1,\
    \ i2_2) = interval2;\n    let mut intersection = (\n        cmp::max(i1_1, i2_1),\n\
    \        cmp::min(i1_2, i2_2),\n    );\n    if intersection.0 > intersection.1\
    \ {\n        return \"NO\".to_string();\n    }\n    if intersection.0 == intersection.1\
    \ {\n        return \"YES\".to_string();\n    }\n    if is_prime(intersection.1\
    \ - intersection.0) {\n        return \"YES\".to_string();\n    }\n    \"NO\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmprwvb252t.rs:21:9\n   |\n21 |         cmp::max(i1_1, i2_1),\n  \
    \ |         ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmprwvb252t.rs:22:9\n\
    \   |\n22 |         cmp::min(i1_2, i2_2),\n   |         ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror[E0425]: cannot find function `is_prime` in this\
    \ scope\n  --> /tmp/tmprwvb252t.rs:30:8\n   |\n30 |     if is_prime(intersection.1\
    \ - intersection.0) {\n   |        ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 3 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0433.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let e = cmp::max(a, c);\n    let f = cmp::min(b, d);\n    let n = if e >\
    \ f { 0 } else { f - e + 1 };\n    if n <= 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..(n - 1) {\n        if n % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmprknhon81.rs:20:13\n   |\n20 |     let e = cmp::max(a, c);\n   |\
    \             ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmprknhon81.rs:21:13\n\
    \   |\n21 |     let f = cmp::min(b, d);\n   |             ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let val = if\
    \ interval1.0 > interval2.0 { interval1.0 } else { interval2.0 };\n    let val2\
    \ = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1 };\n    if\
    \ is_prime(val2 - val) {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpv070tnyb.rs:23:8\n\
    \   |\n23 |     if is_prime(val2 - val) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    match (interval1, interval2) {\n        ((a,\
    \ b), (c, d)) if b < c || d < a => return \"NO\".to_string(),\n        ((a, b),\
    \ (c, d)) => {\n            let mut start = std::cmp::max(a, c);\n           \
    \ let mut end = std::cmp::min(b, d);\n            if start > end {\n         \
    \       return \"NO\".to_string();\n            } else if start == end {\n   \
    \             return \"YES\".to_string();\n            }\n            start -=\
    \ 1;\n            let mut is_prime = true;\n            for i in 2..=start {\n\
    \                if start % i == 0 {\n                    is_prime = false;\n\
    \                    break;\n                }\n            }\n            if\
    \ is_prime {\n                return \"YES\".to_string();\n            }\n   \
    \         start += 1;\n            end += 1;\n            for i in 2..=end {\n\
    \                if end % i == 0 {\n                    is_prime = false;\n  \
    \                  break;\n                }\n            }\n            if is_prime\
    \ {\n                return \"YES\".to_string();\n            }\n            \"\
    NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_kj1ls5a.rs:57:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    match (interval1, interval2) {\n        ((start1,\
    \ end1), (start2, end2)) => {\n            if start1 > end2 || start2 > end1 {\n\
    \                \"NO\".to_string()\n            } else {\n                let\
    \ interval = (cmp::max(start1, start2), cmp::min(end1, end2));\n             \
    \   if interval.1 - interval.0 == 1 {\n                    \"YES\".to_string()\n\
    \                } else {\n                    \"NO\".to_string()\n          \
    \      }\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpooaglvy1.rs:23:33\n   |\n23 |                 let interval = (cmp::max(start1,\
    \ start2), cmp::min(end1, end2));\n   |                                 ^^^ use\
    \ of undeclared crate or module `cmp`\n\nerror[E0433]: failed to resolve: use\
    \ of undeclared crate or module `cmp`\n  --> /tmp/tmpooaglvy1.rs:23:59\n   |\n\
    23 |                 let interval = (cmp::max(start1, start2), cmp::min(end1,\
    \ end2));\n   |                                                           ^^^\
    \ use of undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let x = std::cmp::max(a, c);\n    let y = std::cmp::min(b, d);\n    if x\
    \ > y { return \"NO\".to_string(); }\n    if is_prime(y - x + 1) { return \"YES\"\
    .to_string(); }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpq8mosmzr.rs:23:8\n\
    \   |\n23 |     if is_prime(y - x + 1) { return \"YES\".to_string(); }\n   | \
    \       ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    if i1_end < i2_start || i2_end < i1_start\
    \ {\n        return \"NO\".to_string();\n    }\n    let i_start = if i1_start\
    \ < i2_start { i2_start } else { i1_start };\n    let i_end = if i1_end < i2_end\
    \ { i1_end } else { i2_end };\n    if i_start == i_end {\n        return \"NO\"\
    .to_string();\n    }\n    if is_prime(i_end - i_start + 1) {\n        return \"\
    YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp0994n85z.rs:28:8\n\
    \   |\n28 |     if is_prime(i_end - i_start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if let Some(interval) = intersect(interval1,\
    \ interval2) {\n        let len = interval.1 - interval.0;\n        if is_prime(len)\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `intersect` in this scope\n  --> /tmp/tmpxekhlr8z.rs:18:29\n\
    \   |\n18 |     if let Some(interval) = intersect(interval1, interval2) {\n  \
    \ |                             ^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmpxekhlr8z.rs:20:12\n\
    \   |\n20 |         if is_prime(len) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 2 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = isize::max(interval1.0, interval2.0);\n\
    \    let end = isize::min(interval1.1, interval2.1);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n\n    let prime = vec![2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97];\n    for i in 1..=(end - start) {\n        if prime.contains(&i) {\n\
    \            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (start, end) = match (start1, end1, start2, end2)\
    \ {\n        (start1, end1, start2, end2) if start1 < start2 && end1 > start2\
    \ && end1 < end2 => (start2, end1),\n        (start1, end1, start2, end2) if start1\
    \ > start2 && start1 < end2 && end1 > end2 => (start1, end2),\n        (start1,\
    \ end1, start2, end2) if start1 > start2 && start1 < end2 && end1 < end2 => (start1,\
    \ end1),\n        (start1, end1, start2, end2) if start1 < start2 && end1 > start2\
    \ && end1 > end2 => (start2, end2),\n        _ => return \"NO\".to_string(),\n\
    \    };\n    let mut is_prime = true;\n    for i in 2..(end - start) {\n     \
    \   if (end - start) % i == 0 {\n            is_prime = false;\n            break;\n\
    \        }\n    }\n    if is_prime {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpz7zofw7_.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let i1_min = interval1.0.min(interval1.1);\n\
    \    let i1_max = interval1.0.max(interval1.1);\n    let i2_min = interval2.0.min(interval2.1);\n\
    \    let i2_max = interval2.0.max(interval2.1);\n    let min = i1_min.max(i2_min);\n\
    \    let max = i1_max.min(i2_max);\n    if min > max {\n        return \"NO\"\
    .to_string();\n    }\n    if is_prime(max - min + 1) {\n        return \"YES\"\
    .to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpool3g5kd.rs:27:8\n\
    \   |\n27 |     if is_prime(max - min + 1) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = match interval1.0\
    \ <= interval2.0 {\n        true => (interval2.0, interval1.1),\n        false\
    \ => (interval1.0, interval2.1),\n    };\n    if start > end {\n        std::mem::swap(&mut\
    \ start, &mut end);\n    }\n    if start <= end {\n        let mut i = 1;\n  \
    \      let mut prime = true;\n        while (i * i) <= (end - start) {\n     \
    \       if (end - start) % i == 0 {\n                prime = false;\n        \
    \        break;\n            }\n            i += 1;\n        }\n        if prime\
    \ {\n            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5r_8pbnu.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 { return \"NO\".to_string(); }\n    let isect_len = interval1.1.min(interval2.1)\
    \ - interval1.0.max(interval2.0) + 1;\n    match isect_len.to_string().parse::<usize>()\
    \ {\n        Ok(len) => if is_prime(len) { \"YES\".to_string() } else { \"NO\"\
    .to_string() },\n        Err(_) => \"NO\".to_string(),\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpoct2gydr.rs:21:23\n\
    \   |\n21 |         Ok(len) => if is_prime(len) { \"YES\".to_string() } else {\
    \ \"NO\".to_string() },\n   |                       ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = if start1 > start2 { start1 } else { start2\
    \ };\n    let end = if end1 < end2 { end1 } else { end2 };\n    if start > end\
    \ {\n        \"NO\".to_string()\n    } else {\n        if start != end {\n   \
    \         let mut is_prime = true;\n            for i in 2..start {\n        \
    \        if start % i == 0 {\n                    is_prime = false;\n        \
    \            break;\n                }\n            }\n            if is_prime\
    \ {\n                \"YES\".to_string()\n            } else {\n             \
    \   \"NO\".to_string()\n            }\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp0vwtclsf.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let start\
    \ = max(a, c);\n    let end = min(b, d);\n    let length = end - start + 1;\n\
    \    if is_prime(length) {\n        \"YES\".to_string()\n    } else {\n      \
    \  \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpambcr24e.rs:23:17\n\
    \   |\n23 |     let start = max(a, c);\n   |                 ^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpambcr24e.rs:24:15\n\
    \   |\n24 |     let end = min(b, d);\n   |               ^^^\n...\n33 | fn main()\
    \ {\n   | --------- similarly named function `main` defined here\n   |\nhelp:\
    \ a function with a similar name exists\n   |\n24 |     let end = main(b, d);\n\
    \   |               ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `is_prime` in this\
    \ scope\n  --> /tmp/tmpambcr24e.rs:26:8\n   |\n26 |     if is_prime(length) {\n\
    \   |        ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    //use std::cmp::{min, max};\n    use std::num::{ParseIntError,\
    \ ParseFloatError};\n    fn parse_i(input: &str) -> Result<isize, ParseIntError>\
    \ {\n        input.parse::<isize>()\n    }\n    fn parse_f(input: &str) -> Result<f64,\
    \ ParseFloatError> {\n        input.parse::<f64>()\n    }\n    let (x1, y1) =\
    \ interval1;\n    let (x2, y2) = interval2;\n    let (z1, z2) = (parse_i(&x1.to_string()).unwrap(),\
    \ parse_i(&y1.to_string()).unwrap());\n    let (z3, z4) = (parse_i(&x2.to_string()).unwrap(),\
    \ parse_i(&y2.to_string()).unwrap());\n    if (z1 > z3 && z1 < z4) || (z2 > z3\
    \ && z2 < z4) || (z3 > z1 && z3 < z2) || (z4 > z1 && z4 < z2) {\n        let mut\
    \ i = 1;\n        let mut counter = 0;\n        let length = ((z1 - z3).abs()\
    \ + (z2 - z4).abs()) / 2;\n        while i <= length {\n            if length\
    \ % i == 0 {\n                counter += 1;\n            }\n            i += 1;\n\
    \        }\n        if counter == 2 {\n            \"YES\".to_string()\n     \
    \   } else {\n            \"NO\".to_string()\n        }\n    } else {\n      \
    \  \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpewk0wmq_.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // Check for intersection:\n    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    // Calculate the intersection interval:\n    let mut lower = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let mut upper = std::cmp::min(interval1.1, interval2.1);\n\
    \    // Make sure the lower bound is never zero:\n    if lower == 0 {\n      \
    \  lower = 1;\n    }\n    // Check if the length of the intersection is a prime\
    \ number:\n    let mut result = \"NO\";\n    while lower <= upper {\n        if\
    \ is_prime(lower) {\n            result = \"YES\";\n            break;\n     \
    \   }\n        lower += 1;\n    }\n    result.to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp069z7fv8.rs:32:12\n\
    \   |\n32 |         if is_prime(lower) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let first = std::cmp::max(interval1.0, interval2.0);\n\
    \    let second = std::cmp::min(interval1.1, interval2.1);\n    if first > second\
    \ {\n        return \"NO\".to_string();\n    }\n    if is_prime(second - first\
    \ + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp2p5awmww.rs:23:8\n\
    \   |\n23 |     if is_prime(second - first + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // In case intervals don't intersect\n    if\
    \ interval1.1 < interval2.0 || interval2.1 < interval1.0 {\n        return \"\
    NO\".to_string();\n    }\n    // In case intervals intersects, define the intersection\n\
    \    let start = if interval1.0 <= interval2.0 { interval2.0 } else { interval1.0\
    \ };\n    let end = if interval1.1 <= interval2.1 { interval1.1 } else { interval2.1\
    \ };\n    // Check if the length of the intersection is a prime number\n    if\
    \ is_prime(end - start + 1) {\n        return \"YES\".to_string();\n    }\n  \
    \  \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpaz882ede.rs:26:8\n\
    \   |\n26 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (interval1_start, interval1_end) = interval1;\n\
    \    let (interval2_start, interval2_end) = interval2;\n    let max_start = interval1_start.max(interval2_start);\n\
    \    let min_end = interval1_end.min(interval2_end);\n    if max_start <= min_end\
    \ {\n        let range = min_end - max_start;\n        if is_prime(range) {\n\
    \            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpxlb41qhf.rs:24:12\n\
    \   |\n24 |         if is_prime(range) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut intersection = vec![];\n    for x in\
    \ interval1.0..=interval1.1 {\n        if interval2.0 <= x && x <= interval2.1\
    \ {\n            intersection.push(x);\n        }\n    }\n    if intersection.len()\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    let k = intersection.len()\
    \ as isize;\n    let is_prime = !((2..k).any(|x| k % x == 0));\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmps9ew078p.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (int1_start, int1_end) = interval1;\n \
    \   let (int2_start, int2_end) = interval2;\n    let mut intersection = vec![];\n\
    \    for i in int1_start..=int1_end {\n        if int2_start <= i && i <= int2_end\
    \ {\n            intersection.push(i);\n        }\n    }\n    if intersection.len()\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    let length = intersection.len()\
    \ as isize;\n    if length == 1 {\n        return \"NO\".to_string();\n    }\n\
    \    let mut is_prime = true;\n    for i in 2..length {\n        if length % i\
    \ == 0 {\n            is_prime = false;\n            break;\n        }\n    }\n\
    \    if is_prime {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpi0z4ngza.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    match (start..end).count() {\n        0 => \"\
    NO\".to_string(),\n        1 => \"YES\".to_string(),\n        2 => \"YES\".to_string(),\n\
    \        3 => \"YES\".to_string(),\n        4 => \"NO\".to_string(),\n       \
    \ 5 => \"YES\".to_string(),\n        6 => \"NO\".to_string(),\n        7 => \"\
    YES\".to_string(),\n        8 => \"NO\".to_string(),\n        9 => \"NO\".to_string(),\n\
    \        _ => \"NO\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpv1mxkmqp.rs:41:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start1 = interval1.0;\n    let end1 = interval1.1;\n\
    \    let start2 = interval2.0;\n    let end2 = interval2.1;\n    let start = std::cmp::max(start1,\
    \ start2);\n    let end = std::cmp::min(end1, end2);\n    if start > end {\n \
    \       return \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    for\
    \ i in 2..end - start + 1 {\n        if end - start + 1 % i == 0 {\n         \
    \   is_prime = false;\n            break;\n        }\n    }\n    if is_prime {\n\
    \        return \"YES\".to_string();\n    }\n    return \"NO\".to_string();\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8zoaqf9t.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // Can't use i32 as type, it's not implemented\
    \ for the range type\n    let start = interval1.0.max(interval2.0);\n    let end\
    \ = interval1.1.min(interval2.1);\n    if start <= end {\n        for i in 2..(end\
    \ - start + 1) {\n            if (end - start + 1) % i == 0 {\n              \
    \  return \"NO\".to_string();\n            }\n        }\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp880ezy1v.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let mut intersection = (0, 0);\n    // TODO: Complete\
    \ the code\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"NO\"`,\n right: `\"YES\"`', /tmp/tmp1pnwvr5k.rs:29:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let (min, max) = match a > c {\n        true => (a, d),\n        false =>\
    \ (c, b),\n    };\n    let i = max - min;\n    if i < 0 {\n        \"NO\".to_string()\n\
    \    } else {\n        let result = (1..i).all(|x| i % x != 0);\n        if result\
    \ {\n            \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8ushbldg.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut inter: Vec<_> = interval1.iter().chain(interval2.iter()).collect();\n\
    \    inter.sort();\n    let len = inter[2] - inter[1];\n    if len <= 1 {\n  \
    \      \"NO\".to_string()\n    } else {\n        (2..len).all(|x| len % x != 0)\
    \ as _\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `iter` found for tuple `(isize, isize)` in\
    \ the current scope\n  --> /tmp/tmpw4wh6yo8.rs:18:39\n   |\n18 |     let mut inter:\
    \ Vec<_> = interval1.iter().chain(interval2.iter()).collect();\n   |         \
    \                              ^^^^ method not found in `(isize, isize)`\n\nerror[E0599]:\
    \ no method named `iter` found for tuple `(isize, isize)` in the current scope\n\
    \  --> /tmp/tmpw4wh6yo8.rs:18:62\n   |\n18 |     let mut inter: Vec<_> = interval1.iter().chain(interval2.iter()).collect();\n\
    \   |                                                              ^^^^ method\
    \ not found in `(isize, isize)`\n\nerror[E0605]: non-primitive cast: `bool` as\
    \ `String`\n  --> /tmp/tmpw4wh6yo8.rs:24:9\n   |\n24 |         (2..len).all(|x|\
    \ len % x != 0) as _\n   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as`\
    \ expression can only be used to convert between primitive types or to coerce\
    \ to a specific trait object\n\nerror: aborting due to 3 previous errors\n\nSome\
    \ errors have detailed explanations: E0599, E0605.\nFor more information about\
    \ an error, try `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let intersection = if interval1.0 < interval2.0\
    \ {\n        if interval1.1 < interval2.0 {\n            None\n        } else\
    \ {\n            Some((interval2.0, std::cmp::min(interval1.1, interval2.1)))\n\
    \        }\n    } else {\n        if interval2.1 < interval1.0 {\n           \
    \ None\n        } else {\n            Some((interval1.0, std::cmp::min(interval1.1,\
    \ interval2.1)))\n        }\n    };\n    match intersection {\n        None =>\
    \ \"NO\".to_string(),\n        Some((a, b)) => {\n            if a == b {\n  \
    \              \"NO\".to_string()\n            } else {\n                let len\
    \ = b - a + 1;\n                if is_prime(len) {\n                    \"YES\"\
    .to_string()\n                } else {\n                    \"NO\".to_string()\n\
    \                }\n            }\n        }\n    }\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpfuejmw4w.rs:38:20\n\
    \   |\n38 |                 if is_prime(len) {\n   |                    ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (min, max) =\n        if interval1.0 >\
    \ interval2.0 {\n            (interval1.0, interval2.1)\n        } else {\n  \
    \          (interval2.0, interval1.1)\n        };\n    let mut res = \"NO\";\n\
    \    if interval1.1 < interval2.0 || interval2.1 < interval1.0 {\n        res\
    \ = \"NO\";\n    } else if (max - min) == 1 {\n        res = \"YES\";\n    } else\
    \ if (max - min) == 2 {\n        res = \"NO\";\n    } else if (max - min) == 3\
    \ {\n        res = \"YES\";\n    } else if (max - min) % 2 == 0 {\n        res\
    \ = \"NO\";\n    } else if (max - min) % 3 == 0 {\n        res = \"NO\";\n   \
    \ } else if (max - min) % 5 == 0 {\n        res = \"NO\";\n    } else if (max\
    \ - min) % 7 == 0 {\n        res = \"NO\";\n    } else if (max - min) % 11 ==\
    \ 0 {\n        res = \"NO\";\n    } else if (max - min) % 13 == 0 {\n        res\
    \ = \"NO\";\n    } else if (max - min) % 17 == 0 {\n        res = \"NO\";\n  \
    \  } else if (max - min) % 19 == 0 {\n        res = \"NO\";\n    } else if (max\
    \ - min) % 23 == 0 {\n        res = \"NO\";\n    } else if (max - min) % 29 ==\
    \ 0 {\n        res = \"NO\";\n    } else if (max - min) % 31 == 0 {\n        res\
    \ = \"NO\";\n    } else if (max - min) % 37 == 0 {\n        res = \"NO\";\n  \
    \  } else if (max - min) % 41 == 0 {\n        res = \"NO\";\n    } else if (max\
    \ - min) % 43 == 0 {\n        res = \"NO\";\n    } else if (max - min) % 47 ==\
    \ 0 {\n        res = \"NO\";\n    } else if (max - min) % 53 == 0 {\n        res\
    \ = \"NO\";\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0308]: mismatched types\n  --> /tmp/tmp1g84fr8b.rs:25:63\n   |\n\
    25 |       if interval1.1 < interval2.0 || interval2.1 < interval1.0 {\n   | \
    \ _______________________________________________________________^\n26 | |   \
    \      res = \"NO\";\n27 | |     } else if (max - min) == 1 {\n   | |_____^ expected\
    \ struct `String`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1g84fr8b.rs:27:32\n\
    \   |\n27 |       } else if (max - min) == 1 {\n   |  ________________________________^\n\
    28 | |         res = \"YES\";\n29 | |     } else if (max - min) == 2 {\n   | |_____^\
    \ expected struct `String`, found `()`\n\nerror[E0308]: mismatched types\n  -->\
    \ /tmp/tmp1g84fr8b.rs:29:32\n   |\n29 |       } else if (max - min) == 2 {\n \
    \  |  ________________________________^\n30 | |         res = \"NO\";\n31 | |\
    \     } else if (max - min) == 3 {\n   | |_____^ expected struct `String`, found\
    \ `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1g84fr8b.rs:31:32\n  \
    \ |\n31 |       } else if (max - min) == 3 {\n   |  ________________________________^\n\
    32 | |         res = \"YES\";\n33 | |     } else if (max - min) % 2 == 0 {\n \
    \  | |_____^ expected struct `String`, found `()`\n\nerror[E0308]: mismatched\
    \ types\n  --> /tmp/tmp1g84fr8b.rs:33:36\n   |\n33 |       } else if (max - min)\
    \ % 2 == 0 {\n   |  ____________________________________^\n34 | |         res\
    \ = \"NO\";\n35 | |     } else if (max - min) % 3 == 0 {\n   | |_____^ expected\
    \ struct `String`, found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1g84fr8b.rs:35:36\n\
    \   |\n35 |       } else if (max - min) % 3 == 0 {\n   |  ____________________________________^\n\
    36 | |         res = \"NO\";\n37 | |     } else if (max - min) % 5 == 0 {\n  \
    \ | |_____^ expected struct `String`, found `()`\n\nerror[E0308]: mismatched types\n\
    \  --> /tmp/tmp1g84fr8b.rs:37:36\n   |\n37 |       } else if (max - min) % 5 ==\
    \ 0 {\n   |  ____________________________________^\n38 | |         res = \"NO\"\
    ;\n39 | |     } else if (max - min) % 7 == 0 {\n   | |_____^ expected struct `String`,\
    \ found `()`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1g84fr8b.rs:39:36\n\
    \   |\n39 |       } e"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = std::cmp::max(start1, start2);\n    let\
    \ end = std::cmp::min(end1, end2);\n    let interval = if start > end {\n    \
    \    (0, 0)\n    } else {\n        (start, end)\n    };\n    match interval {\n\
    \        (0, 0) => \"NO\".to_string(),\n        (a, b) => is_prime_interval(a,\
    \ b)\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime_interval` in this scope\n\
    \  --> /tmp/tmp5jimmi8n.rs:29:19\n   |\n29 |         (a, b) => is_prime_interval(a,\
    \ b)\n   |                   ^^^^^^^^^^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut arr: Vec<_> = vec![\n        interval1.0,\n\
    \        interval1.1,\n        interval2.0,\n        interval2.1,\n    ].into_iter()\n\
    \        .sorted()\n        .collect();\n    if arr[1] < arr[2] {\n        return\
    \ \"NO\".to_string();\n    }\n    arr[2] = arr[1];\n    arr.remove(1);\n    arr.remove(0);\n\
    \    let result = arr[1] - arr[0];\n    if result == 1 {\n        return \"NO\"\
    .to_string();\n    }\n    for x in 2..result {\n        if result % x == 0 {\n\
    \            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `sorted` found for struct `std::vec::IntoIter`\
    \ in the current scope\n  --> /tmp/tmpujl9n5ym.rs:24:10\n   |\n24 |         .sorted()\n\
    \   |          ^^^^^^ method not found in `std::vec::IntoIter<isize>`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let min = interval1.0.max(interval2.0);\n \
    \   let max = interval1.1.min(interval2.1);\n    if min > max {\n        \"NO\"\
    .to_string()\n    } else {\n        let len = max - min + 1;\n        let is_prime\
    \ = (2..).any(|i| len % i == 0);\n        if is_prime {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: -1
  status: Timeout
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (l1, r1) = interval1;\n    let (l2, r2)\
    \ = interval2;\n    if (l1 >= r2) || (l2 >= r1) {\n        return \"NO\".to_string();\n\
    \    }\n    let mut intersection = (std::cmp::max(l1, l2), std::cmp::min(r1, r2));\n\
    \    intersection.1 -= intersection.0;\n    intersection.1 += 1;\n    if intersection.1\
    \ == 1 {\n        return \"NO\".to_string();\n    }\n    let mut i = 2;\n    while\
    \ i * i <= intersection.1 {\n        if intersection.1 % i == 0 {\n          \
    \  return \"NO\".to_string();\n        }\n        i += 1;\n    }\n    \"YES\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpkutao8o_.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let (mut i1_min, mut i1_max) = interval1;\n \
    \ let (mut i2_min, mut i2_max) = interval2;\n  let mut intersects = false;\n \
    \ if i1_min > i1_max {\n    std::mem::swap(&mut i1_min, &mut i1_max);\n  }\n \
    \ if i2_min > i2_max {\n    std::mem::swap(&mut i2_min, &mut i2_max);\n  }\n \
    \ if i1_min < i2_min {\n    intersects = i1_max >= i2_min;\n  } else {\n    intersects\
    \ = i2_max >= i1_min;\n  }\n  if intersects {\n    let mut x = [i1_min, i1_max,\
    \ i2_min, i2_max];\n    x.sort();\n    let length = x[2] - x[1];\n    if length\
    \ == 1 {\n      return \"NO\".to_string();\n    }\n    for i in 2..length {\n\
    \      if length % i == 0 {\n        return \"NO\".to_string();\n      }\n   \
    \ }\n    return \"YES\".to_string();\n  }\n  \"NO\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmptd0r9fg4.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (lhs_start, lhs_end) = interval1;\n   \
    \ let (rhs_start, rhs_end) = interval2;\n    if lhs_end < rhs_start || rhs_end\
    \ < lhs_start {\n        return \"NO\".to_string();\n    }\n    let length = if\
    \ lhs_start < rhs_start {\n        if lhs_end < rhs_end {\n            lhs_end\
    \ - rhs_start\n        } else {\n            rhs_end - rhs_start\n        }\n\
    \    } else {\n        if lhs_end < rhs_end {\n            lhs_end - lhs_start\n\
    \        } else {\n            rhs_end - lhs_start\n        }\n    };\n    if\
    \ length == 1 {\n        return \"NO\".to_string();\n    }\n    if is_prime(length)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpvbhujh3o.rs:39:8\n\
    \   |\n39 |     if is_prime(length) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let start = if a < c { c } else { a };\n    let end = if b < d { b } else\
    \ { d };\n    if start >= end {\n        return \"NO\".to_string();\n    }\n\n\
    \    if is_prime(end - start) {\n        \"YES\".to_string()\n    } else {\n \
    \       \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1d2iahq0.rs:26:8\n\
    \   |\n26 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let int_vec = vec![interval1, interval2];\n\
    \    let int_vec_sorted = sort_intervals(int_vec);\n    match int_vec_sorted {\n\
    \        (a, b) if a > b => return \"NO\".to_string(),\n        (a, b) if a ==\
    \ b => return \"YES\".to_string(),\n        (a, b) => {\n            let r_vec\
    \ = (a + 1..b).collect::<Vec<isize>>();\n            r_vec.iter().fold(true, |acc,\
    \ x| {\n                if !is_prime(*x) {\n                    return false;\n\
    \                }\n                acc\n            })\n        }\n    }\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sort_intervals` in this scope\n  -->\
    \ /tmp/tmp1sqgfd4j.rs:19:26\n   |\n19 |     let int_vec_sorted = sort_intervals(int_vec);\n\
    \   |                          ^^^^^^^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmp1sqgfd4j.rs:26:21\n\
    \   |\n26 |                 if !is_prime(*x) {\n   |                     ^^^^^^^^\
    \ not found in this scope\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1sqgfd4j.rs:25:31\n\
    \   |\n25 |             r_vec.iter().fold(true, |acc, x| {\n   |             \
    \                  ^^^^- help: try using a conversion method: `.to_string()`\n\
    \   |                               |\n   |                               expected\
    \ struct `String`, found `bool`\n\nerror[E0308]: mismatched types\n  --> /tmp/tmp1sqgfd4j.rs:27:28\n\
    \   |\n27 |                     return false;\n   |                          \
    \  ^^^^^- help: try using a conversion method: `.to_string()`\n   |          \
    \                  |\n   |                            expected struct `String`,\
    \ found `bool`\n\nerror: aborting due to 4 previous errors\n\nSome errors have\
    \ detailed explanations: E0308, E0425.\nFor more information about an error, try\
    \ `rustc --explain E0308`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let inter_start = interval1.0.max(interval2.0);\n\
    \    let inter_end = interval1.1.min(interval2.1);\n    if inter_start > inter_end\
    \ {\n        \"NO\".to_string()\n    } else {\n        let diff = (inter_end -\
    \ inter_start + 1) as usize;\n        if diff == 1 {\n            \"NO\".to_string()\n\
    \        } else {\n            for n in 2..diff {\n                if diff % n\
    \ == 0 {\n                    return \"NO\".to_string();\n                }\n\
    \            }\n            \"YES\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp2ndp3348.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let interval1_len = end1 - start1;\n    let interval2_len\
    \ = end2 - start2;\n    let intersect_start = start1.max(start2);\n    let intersect_end\
    \ = end1.min(end2);\n    let intersect_len = intersect_end - intersect_start;\n\
    \    let res = intersect_len.is_prime();\n    let st = (intersect_len > 0) &&\
    \ res;\n    if st {\n        \"YES\".to_string()\n    } else {\n        \"NO\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: no method named `is_prime` found for type `isize` in the\
    \ current scope\n  --> /tmp/tmpb8uhki7v.rs:25:29\n   |\n25 |     let res = intersect_len.is_prime();\n\
    \   |                             ^^^^^^^^ method not found in `isize`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let mut end = std::cmp::min(interval1.1, interval2.1);\n\
    \    if start > end {\n        return \"NO\".to_string();\n    }\n    if start\
    \ == end {\n        return \"YES\".to_string();\n    }\n    let mut ans = \"NO\"\
    ;\n    for i in 2..=end {\n        if start % i == 0 && end % i == 0 {\n     \
    \       ans = \"YES\";\n            break;\n        }\n    }\n    ans.to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmppkelhj3b.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    let m_start = i1_start.max(i2_start);\n\
    \    let m_end = i1_end.min(i2_end);\n    if m_start > m_end {\n        return\
    \ \"NO\".to_string();\n    }\n    if m_start == m_end {\n        return \"YES\"\
    .to_string();\n    }\n    let len = m_end - m_start + 1;\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpfcccmb80.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    let i_start = if i1_start > i2_start {i1_start}\
    \ else {i2_start};\n    let i_end = if i1_end < i2_end {i1_end} else {i2_end};\n\
    \    if i_start <= i_end {\n        if (i_end - i_start) % 2 == 0 {\n        \
    \    \"NO\".to_string()\n        } else {\n            \"YES\".to_string()\n \
    \       }\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpg63az1d8.rs:36:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut first = interval1.0;\n    let mut second\
    \ = interval1.1;\n    if interval1.0 > interval1.1 {\n        first = interval1.1;\n\
    \        second = interval1.0;\n    }\n    let mut first2 = interval2.0;\n   \
    \ let mut second2 = interval2.1;\n    if interval2.0 > interval2.1 {\n       \
    \ first2 = interval2.1;\n        second2 = interval2.0;\n    }\n    if first >=\
    \ second2 || second <= first2 {\n        return \"NO\".to_string();\n    }\n \
    \   let mut a = first2;\n    if first2 < first {\n        a = first;\n    }\n\
    \    let mut b = second2;\n    if second2 > second {\n        b = second;\n  \
    \  }\n    let mut diff = b - a;\n    diff += 1;\n    let mut prime = true;\n \
    \   for num in 2..diff {\n        if diff % num == 0 {\n            prime = false;\n\
    \            break;\n        }\n    }\n    if prime {\n        return \"YES\"\
    .to_string();\n    }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpcrxylwji.rs:59:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1, i2) = (interval1, interval2);\n  \
    \  let (i1_min, i1_max) = (std::cmp::min(i1.0, i1.1), std::cmp::max(i1.0, i1.1));\n\
    \    let (i2_min, i2_max) = (std::cmp::min(i2.0, i2.1), std::cmp::max(i2.0, i2.1));\n\
    \    let (start, end) = (std::cmp::max(i1_min, i2_min), std::cmp::min(i1_max,\
    \ i2_max));\n    if start > end {\n        return \"NO\".to_string();\n    }\n\
    \n    let mut check = end - start;\n    check += 1;\n    println!(\"len {}\",\
    \ check);\n    for i in 2..check {\n        if check % i == 0 {\n            return\
    \ \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: "len 1\n"
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpjgnyl0p_.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // your code here\n    let (a, b) = interval1;\n\
    \    let (c, d) = interval2;\n    if a < c {\n        intersection((c, d), (a,\
    \ b))\n    } else if b < c {\n        \"NO\".to_string()\n    } else {\n     \
    \   let mut length = b - c + 1;\n        if length < 0 {\n            length +=\
    \ std::isize::MAX + 1;\n        }\n        match length {\n            2 | 3 |\
    \ 5 | 7 | 11 | 13 | 17 | 19 | 23 | 29 | 31 | 37 | 41 | 43 | 47 | 53 | 59 | 61\
    \ | 67 | 71 | 73 | 79 | 83 | 89 | 97 | 101 | 103 | 107 | 109 | 113 | 127 | 131\
    \ | 137 | 139 | 149 | 151 | 157 | 163 | 167 | 173 | 179 | 181 | 191 | 193 | 197\
    \ | 199 | 211 | 223 | 227 | 229 | 233 | 239 | 241 | 251 | 257 | 263 | 269 | 271\
    \ | 277 | 281 | 283 | 293 | 307 | 311 | 313 | 317 | 331 | 337 | 347 | 349 | 353\
    \ | 359 | 367 | 373 | 379 | 383 | 389 | 397 | 401 | 409 | 419 | 421 | 431 | 433\
    \ | 439 | 443 | 449 | 457 | 461 | 463 | 467 | 479 | 487 | 491 | 499 | 503 | 509\
    \ | 521 | 523 | 541 | 547 | 557 | 563 | 569 | 571 | 577 | 587 | 593 | 599 | 601\
    \ | 607 | 613 | 617 | 619 | 631 | 641 | 643 | 647 | 653 | 659 | 661 | 673 | 677\
    \ | 683 | 691 | 701 | 709 | 719 | 727 | 733 | 739 | 743 | 751 | 757 | 761 | 769\
    \ | 773 | 787 | 797 | 809 | 811 | 821 | 823 | 827 | 829 | 839 | 853 | 857 | 859\
    \ | 863 | 877 | 881 | 883 | 887 | 907 | 911 | 919 | 929 | 937 | 941 | 947 | 953\
    \ |\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error: this file contains an unclosed delimiter\n  --> /tmp/tmpypb2xpg4.rs:44:3\n\
    \   |\n17 | fn intersection(interval1: (isize, isize), interval2: (isize, isize))\
    \ -> String {\n   |                                                          \
    \                       - unclosed delimiter\n...\n25 |     } else {\n   |   \
    \         - unclosed delimiter\n...\n30 |         match length {\n   |       \
    \               - this delimiter might not be properly closed...\n31 |       \
    \      2 | 3 | 5 | 7 | 11 | 13 | 17 | 19 | 23 | 29 | 31 | 37 | 41 | 43 | ...\n\
    32 | }\n   | - ...as it matches this but it has different indentation\n...\n44\
    \ | }\n   |   ^\n\nerror: a trailing `|` is not allowed in an or-pattern\n  -->\
    \ /tmp/tmpypb2xpg4.rs:31:954\n   |\n31 | ...   2 | 3 | 5 | 7 | 11 | 13 | 17 |\
    \ 19 | 23 | 29 | 31 | 37 | 41 | 43 | 47 | 53 | 59 | 61 | 67 | 71 | 73 | 79 | 83\
    \ | 89 | 97 | 101 | 103 | 107 | 109 | 113 | 127 | 131 | 137 | 139 | 149 | 151\
    \ | 157 | 163 | 167 | 173 | 179 | 181 | 191 | 193 | 197 | 199 | 211 | 223 | 227\
    \ | 229 | 233 | 239 | 241 | 251 | 257 | 263 | 269 | 271 | 277 | 281 | 283 | 293\
    \ | 307 | 311 | 313 | 317 | 331 | 337 | 347 | 349 | 353 | 359 | 367 | 373 | 379\
    \ | 383 | 389 | 397 | 401 | 409 | 419 | 421 | 431 | 433 | 439 | 443 | 449 | 457\
    \ | 461 | 463 | 467 | 479 | 487 | 491 | 499 | 503 | 509 | 521 | 523 | 541 | 547\
    \ | 557 | 563 | 569 | 571 | 577 | 587 | 593 | 599 | 601 | 607 | 613 | 617 | 619\
    \ | 631 | 641 | 643 | 647 | 653 | 659 | 661 | 673 | 677 | 683 | 691 | 701 | 709\
    \ | 719 | 727 | 733 | 739 | 743 | 751 | 757 | 761 | 769 | 773 | 787 | 797 | 809\
    \ | 811 | 821 | 823 | 827 | 829 | 839 | 853 | 857 | 859 | 863 | 877 | 881 | 883\
    \ | 887 | 907 | 911 | 919 | 929 | 937 | 941 | 947 | 953 |\n   |       - while\
    \ parsing this or-pattern starting here                                      \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                            "
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    let mut max_start = i1_start;\n    let\
    \ mut min_end = i1_end;\n    if i2_start > max_start {\n        max_start = i2_start;\n\
    \    }\n    if i2_end < min_end {\n        min_end = i2_end;\n    }\n    if max_start\
    \ > min_end {\n        return \"NO\".to_string();\n    }\n    let diff = (min_end\
    \ - max_start + 1) as usize;\n    for i in 2..=diff {\n        if diff % i ==\
    \ 0 {\n            return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpvlre02i_.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut i1 = interval1;\n    let mut i2 = interval2;\n\
    \    if i1.0 > i1.1 {\n        i1 = (i1.1, i1.0);\n    }\n    if i2.0 > i2.1 {\n\
    \        i2 = (i2.1, i2.0);\n    }\n    if i1.1 < i2.0 || i2.1 < i1.0 {\n    \
    \    return \"NO\".to_string();\n    }\n    let mut intersection = (0, 0);\n \
    \   if i1.0 < i2.0 {\n        intersection.0 = i2.0;\n    } else {\n        intersection.0\
    \ = i1.0;\n    }\n    if i1.1 < i2.1 {\n        intersection.1 = i1.1;\n    }\
    \ else {\n        intersection.1 = i2.1;\n    }\n    let mut delta = (intersection.1\
    \ - intersection.0) as usize;\n    if delta == 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if delta == 1 {\n        return \"YES\".to_string();\n    }\n    for\
    \ i in 2..=delta {\n        if delta % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmptl2l1s80.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 <= interval2.1 && interval2.0\
    \ <= interval1.1 {\n        let (start, end) = (\n            std::cmp::max(interval1.0,\
    \ interval2.0),\n            std::cmp::min(interval1.1, interval2.1),\n      \
    \  );\n        let len = end - start + 1;\n        if len > 1 && !(2..=(len as\
    \ f64).sqrt() as isize).any(|x| len % x == 0) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    } else {\n \
    \       \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpcexzr7tf.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let max = [interval1.0,\
    \ interval2.0].iter().max().unwrap();\n    let min = [interval1.1, interval2.1].iter().min().unwrap();\n\
    \    if max == min {\n        return \"YES\".to_string();\n    }\n    if is_prime(*max\
    \ - *min + 1) {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpxg731r47.rs:26:8\n\
    \   |\n26 |     if is_prime(*max - *min + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let in_interval_1 = interval1.0 <= interval2.0\
    \ && interval2.0 <= interval1.1;\n    let in_interval_2 = interval2.0 <= interval1.0\
    \ && interval1.0 <= interval2.1;\n    let start = if in_interval_1 {\n       \
    \ interval2.0\n    } else if in_interval_2 {\n        interval1.0\n    } else\
    \ {\n        return \"NO\".to_string();\n    };\n    let end = if in_interval_1\
    \ {\n        interval1.1\n    } else if in_interval_2 {\n        interval2.1\n\
    \    } else {\n        return \"NO\".to_string();\n    };\n    let len = (end\
    \ - start + 1) as usize;\n    let is_prime = (2..len/2+1).all(|i| len % i != 0);\n\
    \    if is_prime {\n        \"YES\".to_string()\n    } else {\n        \"NO\"\
    .to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n   \
    \ assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpzjz9mtvl.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        \"NO\".to_string()\n    } else {\n        let max =\
    \ if interval1.0 < interval2.0 {\n            interval2.0\n        } else {\n\
    \            interval1.0\n        };\n        let min = if interval1.1 < interval2.1\
    \ {\n            interval1.1\n        } else {\n            interval2.1\n    \
    \    };\n        if is_prime(min - max + 1) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpqfmx8rtr.rs:31:12\n\
    \   |\n31 |         if is_prime(min - max + 1) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let mut\
    \ x = std::cmp::max(a, c);\n    let mut y = std::cmp::min(b, d);\n    if x < 0\
    \ {\n        x = -x;\n    }\n    if y < 0 {\n        y = -y;\n    }\n    let mut\
    \ k = 2;\n    let mut ans = true;\n    while k * k <= y {\n        if x % k ==\
    \ 0 || y % k == 0 {\n            ans = false;\n            break;\n        }\n\
    \        k += 1;\n    }\n    if ans {\n        \"YES\".to_string()\n    } else\
    \ {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp_ap3q0xn.rs:49:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ max(interval1.0, interval2.0);\n    let end = min(interval1.1, interval2.1);\n\
    \    if end <= start {\n        return \"NO\".to_string();\n    }\n    let len\
    \ = end - start + 1;\n    if is_prime(len) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpvta3c22x.rs:21:17\n\
    \   |\n21 |     let start = max(interval1.0, interval2.0);\n   |             \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min`\
    \ in this scope\n  --> /tmp/tmpvta3c22x.rs:22:15\n   |\n22 |     let end = min(interval1.1,\
    \ interval2.1);\n   |               ^^^\n...\n33 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n22 |     let end = main(interval1.1, interval2.1);\n\
    \   |               ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `is_prime` in this\
    \ scope\n  --> /tmp/tmpvta3c22x.rs:27:8\n   |\n27 |     if is_prime(len) {\n \
    \  |        ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut result = (0, 0);\n    if interval1.0\
    \ < interval2.0 {\n        result.0 = interval2.0;\n    } else {\n        result.0\
    \ = interval1.0;\n    }\n    if interval1.1 < interval2.1 {\n        result.1\
    \ = interval1.1;\n    } else {\n        result.1 = interval2.1;\n    }\n    if\
    \ result.0 > result.1 {\n        return \"NO\".to_string();\n    }\n    if result.0\
    \ == result.1 {\n        return \"YES\".to_string();\n    }\n    if result.1 -\
    \ result.0 == 1 {\n        return \"NO\".to_string();\n    }\n    let mut total\
    \ = 0;\n    for i in result.0..result.1 {\n        total += i;\n    }\n    if\
    \ total % 2 == 0 {\n        return \"NO\".to_string();\n    }\n    for i in 2..total\
    \ {\n        if total % i == 0 {\n            return \"NO\".to_string();\n   \
    \     }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpq8hsbphu.rs:55:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (min, max) = if interval1.0 < interval2.0\
    \ {\n        (interval2.0, interval1.1)\n    } else {\n        (interval1.0, interval2.1)\n\
    \    };\n    if min > max {\n        return \"NO\".to_string();\n    }\n    let\
    \ distance = (max - min) + 1;\n    let result = if distance < 2 {\n        \"\
    NO\"\n    } else if distance == 2 {\n        \"YES\"\n    } else {\n        let\
    \ mut prime = true;\n        for i in 2..distance {\n            if distance %\
    \ i == 0 {\n                prime = false;\n                break;\n         \
    \   }\n        }\n        if prime {\n            \"YES\"\n        } else {\n\
    \            \"NO\"\n        }\n    };\n    result.to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp5msr_47f.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ if interval1.0 > interval2.0 {\n        interval1.0\n    } else {\n        interval2.0\n\
    \    };\n    let end = if interval1.1 < interval2.1 {\n        interval1.1\n \
    \   } else {\n        interval2.1\n    };\n    let len = (end - start) + 1;\n\
    \    for i in 2..len {\n        if len % i == 0 {\n            return \"NO\".to_string();\n\
    \        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqh33smt5.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let (mut start, mut end) = (start1, end1);\n    let\
    \ mut is_intersect = true;\n    if start1 > start2 {\n        start = start2;\n\
    \    }\n    if end1 < end2 {\n        end = end2;\n    }\n    if start > end {\n\
    \        is_intersect = false;\n    }\n    if !is_intersect {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut is_prime = true;\n    let length = end\
    \ - start + 1;\n    for i in 2..length {\n        if length % i == 0 {\n     \
    \       is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp7b30junm.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    fn is_prime(num: isize) -> bool {\n       \
    \ if num <= 1 {\n            return false;\n        }\n        if num <= 3 {\n\
    \            return true;\n        }\n        if num % 2 == 0 || num % 3 == 0\
    \ {\n            return false;\n        }\n        let mut i = 5;\n        while\
    \ i * i <= num {\n            if num % i == 0 || num % (i + 2) == 0 {\n      \
    \          return false;\n            }\n            i += 6;\n        }\n    \
    \    true\n    }\n    let (mut i1_start, mut i1_end) = interval1;\n    let (mut\
    \ i2_start, mut i2_end) = interval2;\n    if i1_start > i1_end {\n        std::mem::swap(&mut\
    \ i1_start, &mut i1_end);\n    }\n    if i2_start > i2_end {\n        std::mem::swap(&mut\
    \ i2_start, &mut i2_end);\n    }\n    if i1_end < i2_start || i2_end < i1_start\
    \ {\n        return \"NO\".to_string();\n    }\n    let mut left = if i1_start\
    \ < i2_start { i2_start } else { i1_start };\n    let mut right = if i1_end <\
    \ i2_end { i1_end } else { i2_end };\n    if left > right {\n        std::mem::swap(&mut\
    \ left, &mut right);\n    }\n    if is_prime(right - left + 1) {\n        \"YES\"\
    .to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpv3gsvyxp.rs:63:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let start = start1.max(start2);\n    let end = end1.min(end2);\n\
    \    if start > end {\n        \"NO\".to_string()\n    } else {\n        if is_prime(end\
    \ - start + 1) {\n            \"YES\".to_string()\n        } else {\n        \
    \    \"NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpngfo6xy0.rs:25:12\n\
    \   |\n25 |         if is_prime(end - start + 1) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut inter: Vec<isize> = Vec::new();\n \
    \   if interval1.0 > interval2.0 {\n        inter.push(interval1.0);\n    } else\
    \ {\n        inter.push(interval2.0);\n    }\n    if interval1.1 < interval2.1\
    \ {\n        inter.push(interval1.1);\n    } else {\n        inter.push(interval2.1);\n\
    \    }\n    let mut res = \"NO\";\n    if inter[0] <= inter[1] {\n        if (inter[1]\
    \ - inter[0]) % 2 == 0 {\n            res = \"YES\";\n        }\n    }\n    res.to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpk3mtij70.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut sorted_intervals = vec![interval1,\
    \ interval2];\n    sorted_intervals.sort_by(|a, b| a.0.cmp(&b.0));\n    let (start,\
    \ end) = if sorted_intervals[0].1 >= sorted_intervals[1].0 {\n        (sorted_intervals[1].0,\
    \ sorted_intervals[0].1)\n    } else {\n        (0, 0)\n    };\n    let prime\
    \ = (start + 1..end).any(|i| primes::is_prime(i as usize));\n    if start == 0\
    \ {\n        String::from(\"NO\")\n    } else if prime {\n        String::from(\"\
    YES\")\n    } else {\n        String::from(\"NO\")\n    }\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmp8zwei6d_.rs:25:42\n   |\n25 |     let prime = (start + 1..end).any(|i|\
    \ primes::is_prime(i as usize));\n   |                                       \
    \   ^^^^^^ use of undeclared crate or module `primes`\n\nerror: aborting due to\
    \ previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut res = \"NO\";\n    if (interval1.0\
    \ <= interval2.0 && interval2.0 <= interval1.1) ||\n       (interval2.0 <= interval1.0\
    \ && interval1.0 <= interval2.1) {\n        let mut lower = interval1.0.max(interval2.0);\n\
    \        let mut upper = interval1.1.min(interval2.1);\n        if upper - lower\
    \ < 1 {\n            lower = lower + 1;\n        }\n        if is_prime(upper\
    \ - lower) {\n            res = \"YES\";\n        }\n    }\n    res.to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpvpyx3jkv.rs:26:12\n\
    \   |\n26 |         if is_prime(upper - lower) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut start = match interval1.0 < interval2.0\
    \ {\n        true => interval2.0,\n        false => interval1.0,\n    };\n   \
    \ let mut end = match interval1.1 < interval2.1 {\n        true => interval1.1,\n\
    \        false => interval2.1,\n    };\n    let mut result = String::new();\n\
    \    if start > end {\n        result.push_str(\"NO\");\n    } else {\n      \
    \  let mut is_prime = true;\n        for i in 2..end {\n            if start %\
    \ i == 0 {\n                is_prime = false;\n                break;\n      \
    \      }\n        }\n        if is_prime {\n            result.push_str(\"YES\"\
    );\n        } else {\n            result.push_str(\"NO\");\n        }\n    }\n\
    \    result\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpa84_kffu.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let max_start = std::cmp::max(start1, start2);\n   \
    \ let min_end = std::cmp::min(end1, end2);\n    let len = min_end - max_start;\n\
    \    if len > 0 {\n        if (2..len).any(|n| len % n == 0) {\n            return\
    \ \"NO\".to_string();\n        }\n        return \"YES\".to_string();\n    }\n\
    \    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpl07d7_60.rs:35:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        \"NO\".to_string()\n    } else {\n        let mut intersec\
    \ = (\n            cmp::max(interval1.0, interval2.0),\n            cmp::min(interval1.1,\
    \ interval2.1),\n        );\n        if intersec.0 > intersec.1 {\n          \
    \  intersec = (intersec.1, intersec.0);\n        }\n        if is_prime(intersec.1\
    \ - intersec.0 + 1) {\n            \"YES\".to_string()\n        } else {\n   \
    \         \"NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpjeg6mbol.rs:22:13\n   |\n22 |             cmp::max(interval1.0,\
    \ interval2.0),\n   |             ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmpjeg6mbol.rs:23:13\n   |\n23 |             cmp::min(interval1.1,\
    \ interval2.1),\n   |             ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpjeg6mbol.rs:28:12\n\
    \   |\n28 |         if is_prime(intersec.1 - intersec.0 + 1) {\n   |         \
    \   ^^^^^^^^ not found in this scope\n\nerror: aborting due to 3 previous errors\n\
    \nSome errors have detailed explanations: E0425, E0433.\nFor more information\
    \ about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // this is not the most efficient way, but\
    \ it seems to work in reasonable time\n    let (start1, end1) = interval1;\n \
    \   let (start2, end2) = interval2;\n    let mut counts = 0;\n    for num in (start1..end1\
    \ + 1).rev() {\n        for num2 in start2..end2 + 1 {\n            if num ==\
    \ num2 {\n                counts += 1;\n            }\n        }\n    }\n    if\
    \ counts == 0 {\n        return \"NO\".to_string();\n    }\n    let mut primes\
    \ = vec![false, false];\n    let mut primes_count = 0;\n    while primes.len()\
    \ <= counts as usize {\n        let mut prime = true;\n        for i in 2..primes.len()\
    \ {\n            if primes[i] && primes_count % i == 0 {\n                prime\
    \ = false;\n                break;\n            }\n        }\n        if prime\
    \ {\n            primes.push(true);\n            primes_count += 1;\n        }\
    \ else {\n            primes.push(false);\n        }\n    }\n    if primes[counts\
    \ as usize] {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpjg6jbfla.rs:58:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        \"\
    NO\".to_string()\n    } else {\n        let mut is_prime = true;\n        for\
    \ x in 2..=(end - start) {\n            if (end - start) % x == 0 {\n        \
    \        is_prime = false;\n                break;\n            }\n        }\n\
    \        if is_prime {\n            \"YES\".to_string()\n        } else {\n  \
    \          \"NO\".to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp01s_51b1.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (0, 0);\n    if\
    \ interval1.0 > interval2.0 {\n        start = interval1.0;\n    } else {\n  \
    \      start = interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n     \
    \   end = interval1.1;\n    } else {\n        end = interval2.1;\n    }\n    if\
    \ start >= end {\n        return \"NO\".to_string();\n    }\n    let mut is_prime\
    \ = true;\n    for i in 2..end {\n        if i * i > end {\n            break;\n\
    \        }\n        if end % i == 0 {\n            is_prime = false;\n       \
    \     break;\n        }\n    }\n    if is_prime {\n        return \"YES\".to_string();\n\
    \    }\n    return \"NO\".to_string();\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpqmmdwgyg.rs:51:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // TODO: add your code here\n    unimplemented!()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpwp2z57gt.rs:19:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    let result = (end - start + 1) as usize;\n \
    \   if is_prime(result) {\n        return \"YES\".to_string();\n    }\n    return\
    \ \"NO\".to_string();\n}\n\nfn main() {\n    let candidate = intersection;\n \
    \   assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1c2tehsg.rs:24:8\n\
    \   |\n24 |     if is_prime(result) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (begin1, end1) = interval1;\n    let (begin2,\
    \ end2) = interval2;\n    if begin1 > end1 || begin2 > end2 {\n        \"NO\"\
    .to_string()\n    } else if end1 < begin2 || end2 < begin1 {\n        \"NO\".to_string()\n\
    \    } else {\n        let begin = begin1.max(begin2);\n        let end = end1.min(end2);\n\
    \        let intersect = (begin, end);\n        if is_prime(intersect.1 - intersect.0\
    \ + 1) {\n            \"YES\".to_string()\n        } else {\n            \"NO\"\
    .to_string()\n        }\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9glirmlr.rs:28:12\n\
    \   |\n28 |         if is_prime(intersect.1 - intersect.0 + 1) {\n   |       \
    \     ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\
    \nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // calculate the lower bound\n    let low =\
    \ std::cmp::max(interval1.0, interval2.0);\n    // calculate the upper bound\n\
    \    let high = std::cmp::min(interval1.1, interval2.1);\n    // create a range\
    \ from low to high\n    let range = low..high;\n    // an empty vec for the primes\n\
    \    let mut primes = Vec::new();\n    // loop from 2 to one more than the high\
    \ bound\n    for i in 2..high + 1 {\n        // if the range has any numbers that\
    \ is divisible\n        // by i then return \"NO\"\n        if range.clone().any(|x|\
    \ x % i == 0) {\n            // return \"NO\"\n            return \"NO\".to_string();\n\
    \        }\n        // if any number in the range is a prime then\n        //\
    \ push it to the vec\n        if range.clone().any(|x| x == i) {\n           \
    \ primes.push(i);\n        }\n    }\n    // if the vec has 2 or more numbers then\
    \ return \"YES\"\n    if primes.len() >= 2 {\n        return \"YES\".to_string();\n\
    \    }\n    // if the high number is prime then\n    // return \"YES\"\n    if\
    \ primes.iter().any(|&x| x == high) {\n        return \"YES\".to_string();\n \
    \   }\n    // if the high and low are equal then\n    // return \"YES\"\n    if\
    \ high == low {\n        return \"YES\".to_string();\n    }\n    // if it reaches\
    \ here then return \"NO\"\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmphkp618mp.rs:60:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut x: Vec<isize> = vec![a, b, c, d];\n    x.sort();\n    let (a, b,\
    \ c, d) = (x[0], x[1], x[2], x[3]);\n    let overlap = if (a..=b).contains(&c)\
    \ {\n        if c == d { c } else { c + 1 }\n    } else if (a..=b).contains(&d)\
    \ {\n        if a == d { a } else { d - 1 }\n    } else {\n        return \"NO\"\
    .to_string();\n    };\n    if (2..=2).contains(&overlap) || overlap % 2 == 0 {\n\
    \        \"NO\".to_string()\n    } else {\n        (3..=(overlap as f64).sqrt()\
    \ as isize).fold(\"YES\".to_string(), |acc, x| {\n            if overlap % x ==\
    \ 0 {\n                return \"NO\".to_string();\n            }\n           \
    \ acc\n        })\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpidztt8x4.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut res = (std::cmp::max(interval1.0, interval2.0),\
    \ std::cmp::min(interval1.1, interval2.1));\n    if res.0 >= res.1 {\n       \
    \ res = (0, 0);\n    }\n    if is_prime(res.1 - res.0) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp6tel3goo.rs:22:8\n\
    \   |\n22 |     if is_prime(res.1 - res.0) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let start = max(a, c);\n    let end = min(b, d);\n    if end <= start {\n\
    \        return \"NO\".to_string();\n    }\n    let length = end - start;\n  \
    \  let is_prime = length > 1 && (2..length).all(|i| length % i != 0);\n    if\
    \ is_prime {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp5l2j_vgr.rs:20:17\n\
    \   |\n20 |     let start = max(a, c);\n   |                 ^^^ not found in\
    \ this scope\n   |\nhelp: consider importing this function\n   |\n1  | use std::cmp::max;\n\
    \   |\n\nerror[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp5l2j_vgr.rs:21:15\n\
    \   |\n21 |     let end = min(b, d);\n   |               ^^^\n...\n34 | fn main()\
    \ {\n   | --------- similarly named function `main` defined here\n   |\nhelp:\
    \ a function with a similar name exists\n   |\n21 |     let end = main(b, d);\n\
    \   |               ~~~~\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::min;\n   |\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if !intersect(&interval1, &interval2) { return\
    \ \"NO\".to_string(); }\n    let (start, end) = intersection_interval(&interval1,\
    \ &interval2);\n    if end - start + 1 > 2 && prime(end - start + 1) { \"YES\"\
    .to_string() } else { \"NO\".to_string() }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `intersect` in this scope\n  --> /tmp/tmpu0_g36zi.rs:18:9\n\
    \   |\n18 |     if !intersect(&interval1, &interval2) { return \"NO\".to_string();\
    \ }\n   |         ^^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `intersection_interval` in this scope\n  --> /tmp/tmpu0_g36zi.rs:19:24\n\
    \   |\n19 |     let (start, end) = intersection_interval(&interval1, &interval2);\n\
    \   |                        ^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `prime` in this scope\n  --> /tmp/tmpu0_g36zi.rs:20:31\n\
    \   |\n20 |     if end - start + 1 > 2 && prime(end - start + 1) { \"YES\".to_string()\
    \ } else { \"NO\".to_string() }\n   |                               ^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 3 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let (start1, end1) = interval1;\n  let (start2,\
    \ end2) = interval2;\n  let min_start = cmp::max(start1, start2);\n  let max_end\
    \ = cmp::min(end1, end2);\n  if min_start > max_end {\n    \"NO\".to_string()\n\
    \  } else {\n    let diff = (max_end - min_start) + 1;\n    if diff == 1 {\n \
    \     \"NO\".to_string()\n    } else {\n      let mut is_prime = true;\n     \
    \ for i in 2..diff {\n        if diff % i == 0 {\n          is_prime = false;\n\
    \          break;\n        }\n      }\n      if is_prime {\n        \"YES\".to_string()\n\
    \      } else {\n        \"NO\".to_string()\n      }\n    }\n  }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpkekxk410.rs:20:19\n   |\n20 |   let min_start = cmp::max(start1,\
    \ start2);\n   |                   ^^^ use of undeclared crate or module `cmp`\n\
    \nerror[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n \
    \ --> /tmp/tmpkekxk410.rs:21:17\n   |\n21 |   let max_end = cmp::min(end1, end2);\n\
    \   |                 ^^^ use of undeclared crate or module `cmp`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut left = max(a, c);\n    let mut right = min(b, d);\n    let mut length\
    \ = right - left;\n    if length < 0 {\n        length = 0;\n    }\n    if length\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    // println!(\"left =\
    \ {}\", left);\n    // println!(\"right = {}\", right);\n    // println!(\"length\
    \ = {}\", length);\n    if length == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    for i in 2..(length - 1) {\n        if length % i == 0 {\n       \
    \     return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpwd654nyr.rs:20:20\n\
    \   |\n20 |     let mut left = max(a, c);\n   |                    ^^^ not found\
    \ in this scope\n   |\nhelp: consider importing this function\n   |\n1  | use\
    \ std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min` in this scope\n\
    \  --> /tmp/tmpwd654nyr.rs:21:21\n   |\n21 |     let mut right = min(b, d);\n\
    \   |                     ^^^\n...\n43 | fn main() {\n   | --------- similarly\
    \ named function `main` defined here\n   |\nhelp: a function with a similar name\
    \ exists\n   |\n21 |     let mut right = main(b, d);\n   |                   \
    \  ~~~~\nhelp: consider importing this function\n   |\n1  | use std::cmp::min;\n\
    \   |\n\nerror: aborting due to 2 previous errors\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (min, max) = get_intersection_length(interval1,\
    \ interval2);\n    match is_prime(max - min) {\n        true => \"YES\".to_string(),\n\
    \        false => \"NO\".to_string(),\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `get_intersection_length` in this scope\n\
    \  --> /tmp/tmpij_e_p9q.rs:18:22\n   |\n18 |     let (min, max) = get_intersection_length(interval1,\
    \ interval2);\n   |                      ^^^^^^^^^^^^^^^^^^^^^^^ not found in\
    \ this scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n\
    \  --> /tmp/tmpij_e_p9q.rs:19:11\n   |\n19 |     match is_prime(max - min) {\n\
    \   |           ^^^^^^^^ not found in this scope\n\nerror: aborting due to 2 previous\
    \ errors\n\nFor more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  if interval1.0 > interval2.1 || interval2.0 >\
    \ interval1.1 {\n    return \"NO\".to_string();\n  }\n  let mut lower = std::cmp::max(interval1.0,\
    \ interval2.0);\n  let mut upper = std::cmp::min(interval1.1, interval2.1);\n\
    \  if lower > upper {\n    return \"NO\".to_string();\n  }\n  let len = upper\
    \ - lower + 1;\n  if len == 2 {\n    return \"YES\".to_string();\n  }\n  let mut\
    \ primality = false;\n  for i in (2..=(len / 2) as isize).rev() {\n    if len\
    \ % i == 0 {\n      primality = true;\n      break;\n    }\n  }\n  if primality\
    \ {\n    \"NO\".to_string()\n  } else {\n    \"YES\".to_string()\n  }\n}\n\nfn\
    \ main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp3r5vrsug.rs:46:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    let min = if start1 > start2 { start1 } else { start2\
    \ };\n    let max = if end1 < end2 { end1 } else { end2 };\n    let diff = if\
    \ min <= max { max - min } else { 0 };\n    match diff {\n        0 => \"NO\"\
    .to_string(),\n        1 => \"NO\".to_string(),\n        2 => \"YES\".to_string(),\n\
    \        3 => \"YES\".to_string(),\n        _ => \"NO\".to_string(),\n    }\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a > d || b < c {\n        return \"NO\".to_string();\n    }\n    let l\
    \ = std::cmp::max(a, c) - std::cmp::min(b, d);\n    if l > 1 && (2..l).any(|x|\
    \ l % x == 0) {\n        return \"NO\".to_string();\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp245g3xwk.rs:32:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut start = interval1.0;\n    let mut end\
    \ = interval1.1;\n    let mut interval = interval2;\n    if start > end {\n  \
    \      start = interval2.0;\n        end = interval2.1;\n        interval = interval1;\n\
    \    }\n    if interval.0 <= start && interval.1 >= end {\n        if start <\
    \ end {\n            return if is_prime(end - start) { \"YES\".to_string() } else\
    \ { \"NO\".to_string() };\n        }\n        return \"YES\".to_string();\n  \
    \  }\n    if interval.0 <= start && interval.1 >= start {\n        return if is_prime(interval.1\
    \ - start) { \"YES\".to_string() } else { \"NO\".to_string() };\n    }\n    if\
    \ interval.0 <= end && interval.1 >= end {\n        return if is_prime(end - interval.0)\
    \ { \"YES\".to_string() } else { \"NO\".to_string() };\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpggvo45ad.rs:28:23\n\
    \   |\n28 |             return if is_prime(end - start) { \"YES\".to_string()\
    \ } else { \"NO\".to_string() };\n   |                       ^^^^^^^^ not found\
    \ in this scope\n\nerror[E0425]: cannot find function `is_prime` in this scope\n\
    \  --> /tmp/tmpggvo45ad.rs:33:19\n   |\n33 |         return if is_prime(interval.1\
    \ - start) { \"YES\".to_string() } else { \"NO\".to_string() };\n   |        \
    \           ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function\
    \ `is_prime` in this scope\n  --> /tmp/tmpggvo45ad.rs:36:19\n   |\n36 |      \
    \   return if is_prime(end - interval.0) { \"YES\".to_string() } else { \"NO\"\
    .to_string() };\n   |                   ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 3 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    match (interval1, interval2) {\n        ((a,\
    \ b), (c, d)) if (b < c) || (d < a) => \"NO\".to_string(),\n        ((a, b), (c,\
    \ d)) => if is_prime(b.min(d) - a.max(c) + 1) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpg791batt.rs:20:32\n\
    \   |\n20 |         ((a, b), (c, d)) => if is_prime(b.min(d) - a.max(c) + 1) {\n\
    \   |                                ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let start = start1.max(start2);\n    let end\
    \ = end1.min(end2);\n    if is_prime(end - start + 1) {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpk4t4la04.rs:25:8\n\
    \   |\n25 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0, interval2.0);\n\
    \    let end = std::cmp::min(interval1.1, interval2.1);\n    if start >= end {\n\
    \        \"NO\".to_string()\n    } else {\n        let (mut i, mut is_prime) =\
    \ (start, true);\n        while i < end {\n            if end % i == 0 {\n   \
    \             is_prime = false;\n                break;\n            }\n     \
    \       i += 1;\n        }\n        if is_prime {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'attempt to calculate the remainder with a divisor\
    \ of zero', /tmp/tmp449rw7ms.rs:25:16\nnote: run with `RUST_BACKTRACE=1` environment\
    \ variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut i1 = interval1;\n    let mut i2 = interval2;\n\
    \    if i1.0 > i1.1 {\n        std::mem::swap(&mut i1.0, &mut i1.1);\n    }\n\
    \    if i2.0 > i2.1 {\n        std::mem::swap(&mut i2.0, &mut i2.1);\n    }\n\
    \    if i1.1 < i2.0 || i2.1 < i1.0 {\n        return \"NO\".to_string();\n   \
    \ }\n    let a = std::cmp::max(i1.0, i2.0);\n    let b = std::cmp::min(i1.1, i2.1);\n\
    \    let d = b - a + 1;\n    if d == 1 {\n        return \"NO\".to_string();\n\
    \    }\n    let mut i = 2;\n    while i * i <= d {\n        if d % i == 0 {\n\
    \            return \"NO\".to_string();\n        }\n        i += 1;\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmponbva8e1.rs:48:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let int1 = (interval1.0..interval1.1).collect::<Vec<isize>>();\n\
    \  let int2 = (interval2.0..interval2.1).collect::<Vec<isize>>();\n  let inter\
    \ = int1.intersection(&int2).collect::<Vec<&isize>>();\n  if inter.len() == 0\
    \ {\n    return \"NO\".to_string();\n  }\n  let l = inter.len() as isize;\n  if\
    \ is_prime(l) {\n    return \"YES\".to_string();\n  }\n  \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp1zk1v16g.rs:25:6\n\
    \   |\n25 |   if is_prime(l) {\n   |      ^^^^^^^^ not found in this scope\n\n\
    error[E0599]: no method named `intersection` found for struct `Vec<isize>` in\
    \ the current scope\n  --> /tmp/tmp1zk1v16g.rs:20:20\n   |\n20 |   let inter =\
    \ int1.intersection(&int2).collect::<Vec<&isize>>();\n   |                   \
    \ ^^^^^^^^^^^^ help: there is an associated function with a similar name: `insert`\n\
    \nerror: aborting due to 2 previous errors\n\nSome errors have detailed explanations:\
    \ E0425, E0599.\nFor more information about an error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let a = interval1.0.max(interval2.0);\n   \
    \ let b = interval1.1.min(interval2.1);\n    if a > b {\n        return \"NO\"\
    .to_string();\n    }\n    let n = b - a + 1;\n    if n < 2 {\n        return \"\
    NO\".to_string();\n    }\n    for i in 2..n {\n        if n % i == 0 {\n     \
    \       return \"NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp8y6grbxn.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let mut min = std::cmp::max(a, c);\n    let mut max = std::cmp::min(b, d);\n\
    \    while min <= max {\n        if is_prime(min) {\n            return \"YES\"\
    .to_string();\n        }\n        min += 1;\n    }\n    \"NO\".to_string()\n}\n\
    \nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpuyr4vwa3.rs:23:12\n\
    \   |\n23 |         if is_prime(min) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (left, right) = (\n        cmp::max(interval1.0,\
    \ interval2.0),\n        cmp::min(interval1.1, interval2.1)\n    );\n    if left\
    \ > right {\n        \"NO\".to_string()\n    } else {\n        let length = (right\
    \ - left + 1) as usize;\n        if length == 1 {\n            \"NO\".to_string()\n\
    \        } else {\n            if (2..length).all(|x| length % x != 0) {\n   \
    \             \"YES\".to_string()\n            } else {\n                \"NO\"\
    .to_string()\n            }\n        }\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpqfn96bfp.rs:19:9\n   |\n19 |         cmp::max(interval1.0, interval2.0),\n\
    \   |         ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]: failed\
    \ to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpqfn96bfp.rs:20:9\n\
    \   |\n20 |         cmp::min(interval1.1, interval2.1)\n   |         ^^^ use of\
    \ undeclared crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\
    \nFor more information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if end1 < start2 || end2 < start1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let (start, end) = (max(start1, start2), min(end1,\
    \ end2));\n    if end - start == 1 {\n        return \"NO\".to_string();\n   \
    \ }\n    if is_prime(end - start) {\n        return \"YES\".to_string();\n   \
    \ }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmp7d1__opl.rs:23:25\n\
    \   |\n23 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                         ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `min` in this scope\n  --> /tmp/tmp7d1__opl.rs:23:46\n\
    \   |\n23 |     let (start, end) = (max(start1, start2), min(end1, end2));\n \
    \  |                                              ^^^\n...\n33 | fn main() {\n\
    \   | --------- similarly named function `main` defined here\n   |\nhelp: a function\
    \ with a similar name exists\n   |\n23 |     let (start, end) = (max(start1, start2),\
    \ main(end1, end2));\n   |                                              ~~~~\n\
    help: consider importing this function\n   |\n1  | use std::cmp::min;\n   |\n\n\
    error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7d1__opl.rs:27:8\n\
    \   |\n27 |     if is_prime(end - start) {\n   |        ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to 3 previous errors\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let a = interval1.0;\n    let b = interval1.1;\n\
    \    let c = interval2.0;\n    let d = interval2.1;\n    let len_intersection\
    \ = if a <= c {\n        if c <= b {\n            if b <= d {\n              \
    \  b - c + 1\n            } else {\n                d - c + 1\n            }\n\
    \        } else {\n            0\n        }\n    } else {\n        if d <= b {\n\
    \            if b <= a {\n                0\n            } else {\n          \
    \      d - a + 1\n            }\n        } else {\n            b - a + 1\n   \
    \     }\n    };\n    if len_intersection == 0 {\n        \"NO\".to_string()\n\
    \    } else {\n        if is_prime(len_intersection) {\n            \"YES\".to_string()\n\
    \        } else {\n            \"NO\".to_string()\n        }\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp9_dvfux3.rs:46:12\n\
    \   |\n46 |         if is_prime(len_intersection) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let a = interval1.0;\n    let b = interval1.1;\n\
    \    let c = interval2.0;\n    let d = interval2.1;\n    if (a <= c && c <= b)\
    \ || (a <= d && d <= b) || (c <= a && a <= d) || (c <= b && b <= d) {\n      \
    \  return if is_prime((std::cmp::max(a, c) - std::cmp::min(b, d)).abs() as usize)\
    \ {\n            \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        };\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp6_ekltum.rs:23:19\n\
    \   |\n23 |         return if is_prime((std::cmp::max(a, c) - std::cmp::min(b,\
    \ d)).abs() as usize) {\n   |                   ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let mut max\
    \ = if interval1.0 > interval2.0 { interval1.0 } else { interval2.0 };\n    let\
    \ mut min = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1 };\n\
    \    if min < max {\n        return \"NO\".to_string();\n    }\n    while max\
    \ <= min {\n        if is_prime(max) {\n            return \"YES\".to_string();\n\
    \        }\n        max += 1;\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp7gijwsf0.rs:27:12\n\
    \   |\n27 |         if is_prime(max) {\n   |            ^^^^^^^^ not found in\
    \ this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let inter = if interval1.0 <= interval2.0 {\n\
    \        if interval1.1 >= interval2.0 {\n            if interval1.1 >= interval2.1\
    \ {\n                (interval2.0, interval2.1)\n            } else {\n      \
    \          (interval2.0, interval1.1)\n            }\n        } else {\n     \
    \       return \"NO\".to_string();\n        }\n    } else {\n        if interval2.1\
    \ >= interval1.0 {\n            if interval2.1 >= interval1.1 {\n            \
    \    (interval1.0, interval1.1)\n            } else {\n                (interval1.0,\
    \ interval2.1)\n            }\n        } else {\n            return \"NO\".to_string();\n\
    \        }\n    };\n    let len = inter.1 - inter.0 + 1;\n    if len == 2 {\n\
    \        return \"YES\".to_string();\n    }\n    for i in 2..len {\n        if\
    \ len % i == 0 {\n            return \"NO\".to_string();\n        }\n    }\n \
    \   \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp9evv8zo3.rs:53:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    // max(x1, y1) <= min(x2, y2)\n    if interval1.0\
    \ > interval2.1 || interval2.0 > interval1.1 {\n        return \"NO\".to_string();\n\
    \    }\n    let start = if interval1.0 > interval2.0 { interval1.0 } else { interval2.0\
    \ };\n    let end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1\
    \ };\n    let len = end - start + 1;\n    if len < 2 {\n        return \"NO\"\
    .to_string();\n    }\n    if len == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    if len % 2 == 0 {\n        return \"NO\".to_string();\n    }\n   \
    \ for i in (3..).step_by(2) {\n        if len % i == 0 {\n            return \"\
    NO\".to_string();\n        }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp6yjv_06e.rs:45:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let a = isize::max(interval1.0,\
    \ interval2.0);\n    let b = isize::min(interval1.1, interval2.1);\n    let l\
    \ = b - a + 1;\n    if l > 2 && is_prime(l) {\n        return \"YES\".to_string();\n\
    \    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpp3ra_e3g.rs:24:17\n\
    \   |\n24 |     if l > 2 && is_prime(l) {\n   |                 ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (low, high) = (std::cmp::max(interval1.0,\
    \ interval2.0), std::cmp::min(interval1.1, interval2.1));\n    if low <= high\
    \ {\n        match is_prime(high - low) {\n            true => String::from(\"\
    YES\"),\n            false => String::from(\"NO\"),\n        }\n    } else {\n\
    \        String::from(\"NO\")\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpuscucqz5.rs:20:15\n\
    \   |\n20 |         match is_prime(high - low) {\n   |               ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut intersect: Vec<isize> = Vec::new();\n\
    \    let v1: Vec<isize> = (interval1.0..=interval1.1).collect();\n    let v2:\
    \ Vec<isize> = (interval2.0..=interval2.1).collect();\n    for x in v1 {\n   \
    \     if v2.contains(&x) {\n            intersect.push(x);\n        }\n    }\n\
    \    if intersect.len() > 0 {\n        if is_prime(intersect.len() as u64) {\n\
    \            return \"YES\".to_string();\n        }\n    }\n    \"NO\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmptpurv8_9.rs:27:12\n\
    \   |\n27 |         if is_prime(intersect.len() as u64) {\n   |            ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (mut start, mut end) = (0, 0);\n    if\
    \ interval1.0 > interval2.0 {\n        start = interval1.0;\n    } else {\n  \
    \      start = interval2.0;\n    }\n    if interval1.1 < interval2.1 {\n     \
    \   end = interval1.1;\n    } else {\n        end = interval2.1;\n    }\n    if\
    \ start <= end {\n        let mut is_prime = true;\n        let length = end -\
    \ start + 1;\n        for i in 2..length {\n            if length % i == 0 {\n\
    \                is_prime = false;\n                break;\n            }\n  \
    \      }\n        if is_prime {\n            return \"YES\".to_string();\n   \
    \     }\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpuztt9dxb.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (start1, end1) = interval1;\n    let (start2,\
    \ end2) = interval2;\n    if start1 > end2 || start2 > end1 {\n        return\
    \ \"NO\".to_string();\n    }\n    let s = start1.max(start2);\n    let e = end1.min(end2);\n\
    \    if is_prime(e - s + 1) {\n        \"YES\".to_string()\n    } else {\n   \
    \     \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmph6z64vme.rs:25:8\n\
    \   |\n25 |     if is_prime(e - s + 1) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to previous error\n\nFor more information about\
    \ this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let left = interval1.0.max(interval2.0);\n\
    \    let right = interval1.1.min(interval2.1);\n    if left > right { return \"\
    NO\".to_string(); }\n    if prime_length(left, right) { return \"YES\".to_string();\
    \ }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `prime_length` in this scope\n  -->\
    \ /tmp/tmp9ohkb8z9.rs:21:8\n   |\n21 |     if prime_length(left, right) { return\
    \ \"YES\".to_string(); }\n   |        ^^^^^^^^^^^^ not found in this scope\n\n\
    error: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let interval1 = interval1.into_iter().collect::<Vec<isize>>();\n\
    \    let interval2 = interval2.into_iter().collect::<Vec<isize>>();\n    let mut\
    \ lower = std::cmp::max(interval1[0], interval2[0]);\n    let mut upper = std::cmp::min(interval1[1],\
    \ interval2[1]);\n    if lower > upper {\n        return \"NO\".to_string();\n\
    \    }\n    if lower <= 2 && upper >= 2 {\n        return \"YES\".to_string();\n\
    \    }\n    while lower <= upper {\n        if upper % lower == 0 {\n        \
    \    return \"NO\".to_string();\n        }\n        lower += 1;\n    }\n    \"\
    YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0599]: `(isize, isize)` is not an iterator\n  --> /tmp/tmph34ruzus.rs:18:31\n\
    \   |\n18 |     let interval1 = interval1.into_iter().collect::<Vec<isize>>();\n\
    \   |                               ^^^^^^^^^ `(isize, isize)` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `(isize,\
    \ isize): Iterator`\n           which is required by `(isize, isize): IntoIterator`\n\
    \           `&(isize, isize): Iterator`\n           which is required by `&(isize,\
    \ isize): IntoIterator`\n           `&mut (isize, isize): Iterator`\n        \
    \   which is required by `&mut (isize, isize): IntoIterator`\n\nerror[E0599]:\
    \ `(isize, isize)` is not an iterator\n  --> /tmp/tmph34ruzus.rs:19:31\n   |\n\
    19 |     let interval2 = interval2.into_iter().collect::<Vec<isize>>();\n   |\
    \                               ^^^^^^^^^ `(isize, isize)` is not an iterator\n\
    \   |\n   = note: the following trait bounds were not satisfied:\n           `(isize,\
    \ isize): Iterator`\n           which is required by `(isize, isize): IntoIterator`\n\
    \           `&(isize, isize): Iterator`\n           which is required by `&(isize,\
    \ isize): IntoIterator`\n           `&mut (isize, isize): Iterator`\n        \
    \   which is required by `&mut (isize, isize): IntoIterator`\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0599`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let s1 = interval1.0;\n    let e1 = interval1.1;\n\
    \    let s2 = interval2.0;\n    let e2 = interval2.1;\n    let start = isize::max(s1,\
    \ s2);\n    let end = isize::min(e1, e2);\n    if start >= end {\n        return\
    \ \"NO\".to_string();\n    }\n    let sub = end - start;\n    for i in 2..sub\
    \ {\n        if sub % i == 0 {\n            return \"NO\".to_string();\n     \
    \   }\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpviay1995.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let max_start = std::cmp::max(interval1.0,\
    \ interval2.0);\n    let min_end = std::cmp::min(interval1.1, interval2.1);\n\
    \    let mut is_prime = true;\n    if max_start <= min_end {\n        let mut\
    \ count = 2;\n        while count < (min_end - max_start + 1) {\n            if\
    \ (min_end - max_start + 1) % count == 0 {\n                is_prime = false;\n\
    \                break;\n            }\n            count += 1;\n        }\n \
    \   } else {\n        is_prime = false;\n    }\n    if is_prime {\n        \"\
    YES\".to_string()\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpbebldkmp.rs:42:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (interval1_start, interval1_end) = interval1;\n\
    \    let (interval2_start, interval2_end) = interval2;\n    let (mut start, mut\
    \ end) = (0, 0);\n    if interval1_start <= interval2_start {\n        start =\
    \ interval2_start;\n    } else {\n        start = interval1_start;\n    }\n  \
    \  if interval1_end <= interval2_end {\n        end = interval1_end;\n    } else\
    \ {\n        end = interval2_end;\n    }\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    let len = end - start + 1;\n    let mut is_prime\
    \ = true;\n    if len <= 1 {\n        is_prime = false;\n    } else {\n      \
    \  for i in 2..len {\n            if len % i == 0 {\n                is_prime\
    \ = false;\n                break;\n            }\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpfbxytdy0.rs:56:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut vec: Vec<isize> = vec![];\n    let\
    \ mut result = \"NO\";\n    for (a, b) in vec![interval1, interval2] {\n     \
    \   if a <= b {\n            for i in a..=b {\n                vec.push(i);\n\
    \            }\n        } else {\n            for i in b..=a {\n             \
    \   vec.push(i);\n            }\n        }\n    }\n    let set: HashSet<isize>\
    \ = vec.into_iter().collect();\n    for i in set {\n        if i > 1 {\n     \
    \       let mut is_prime = true;\n            for j in 2..i {\n              \
    \  if i % j == 0 {\n                    is_prime = false;\n                  \
    \  break;\n                }\n            }\n            if is_prime {\n     \
    \           result = \"YES\";\n                break;\n            }\n       \
    \ }\n    }\n    String::from(result)\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0412]: cannot find type `HashSet` in this scope\n  --> /tmp/tmpfdz5djsl.rs:31:14\n\
    \   |\n31 |     let set: HashSet<isize> = vec.into_iter().collect();\n   |   \
    \           ^^^^^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ struct\n   |\n1  | use std::collections::HashSet;\n   |\n\nerror: aborting due\
    \ to previous error\n\nFor more information about this error, try `rustc --explain\
    \ E0412`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let left = interval1.0.max(interval2.0);\n\
    \    let right = interval1.1.min(interval2.1);\n    if left > right {\n      \
    \  return \"NO\".to_string();\n    }\n    if primes::is_prime(right - left + 1)\
    \ {\n        return \"YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `primes`\n\
    \  --> /tmp/tmpkwm5j1yn.rs:23:8\n   |\n23 |     if primes::is_prime(right - left\
    \ + 1) {\n   |        ^^^^^^ use of undeclared crate or module `primes`\n\nerror:\
    \ aborting due to previous error\n\nFor more information about this error, try\
    \ `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let intersection\
    \ = if interval1.0 > interval2.0 {\n        (interval1.0, interval2.1)\n    }\
    \ else {\n        (interval2.0, interval1.1)\n    };\n    let length = intersection.1\
    \ - intersection.0 + 1;\n    if length == 2 {\n        return \"YES\".to_string();\n\
    \    }\n    let primes = [3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47,\
    \ 53, 59, 61, 67, 71, 73, 79, 83, 89, 97];\n    let mut i = 0;\n    while i <\
    \ primes.len() {\n        if primes[i] == length {\n            return \"YES\"\
    .to_string();\n        }\n        if primes[i] > length {\n            break;\n\
    \        }\n        i += 1;\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpsv3e63hl.rs:47:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1_start, i1_end) = interval1;\n    let\
    \ (i2_start, i2_end) = interval2;\n    let left_boundary = i1_start.max(i2_start);\n\
    \    let right_boundary = i1_end.min(i2_end);\n    if left_boundary >= right_boundary\
    \ {\n        return \"NO\".to_string();\n    }\n    let intersection_length =\
    \ right_boundary - left_boundary;\n    if intersection_length == 1 {\n       \
    \ return \"NO\".to_string();\n    }\n    let is_prime = (2..intersection_length)\n\
    \        .find(|x| x * x <= intersection_length && intersection_length % x ==\
    \ 0)\n        .is_none();\n    if is_prime {\n        \"YES\".to_string()\n  \
    \  } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let lower_bound = max(interval1.0, interval2.0);\n\
    \    let upper_bound = min(interval1.1, interval2.1);\n    let size = upper_bound\
    \ - lower_bound + 1;\n    if size < 0 {\n        return \"NO\".to_string();\n\
    \    }\n    if size < 2 {\n        return \"YES\".to_string();\n    }\n    if\
    \ size % 2 == 0 {\n        return \"NO\".to_string();\n    }\n    if size % 3\
    \ == 0 {\n        return \"NO\".to_string();\n    }\n    if size % 5 == 0 {\n\
    \        return \"NO\".to_string();\n    }\n    if size % 7 == 0 {\n        return\
    \ \"NO\".to_string();\n    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let\
    \ candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpr3o2w2t9.rs:18:23\n\
    \   |\n18 |     let lower_bound = max(interval1.0, interval2.0);\n   |       \
    \                ^^^ not found in this scope\n   |\nhelp: consider importing this\
    \ function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function\
    \ `min` in this scope\n  --> /tmp/tmpr3o2w2t9.rs:19:23\n   |\n19 |     let upper_bound\
    \ = min(interval1.1, interval2.1);\n   |                       ^^^\n...\n42 |\
    \ fn main() {\n   | --------- similarly named function `main` defined here\n \
    \  |\nhelp: a function with a similar name exists\n   |\n19 |     let upper_bound\
    \ = main(interval1.1, interval2.1);\n   |                       ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 < interval2.0 {\n        if\
    \ interval1.1 < interval2.0 {\n            return \"NO\".to_string();\n      \
    \  }\n        if interval1.1 < interval2.1 {\n            return is_prime(interval1.1\
    \ - interval2.0 + 1)\n        }\n        return is_prime(interval2.1 - interval2.0\
    \ + 1)\n    }\n    if interval2.1 < interval1.0 {\n        return \"NO\".to_string();\n\
    \    }\n    if interval2.1 < interval1.1 {\n        return is_prime(interval2.1\
    \ - interval1.0 + 1)\n    }\n    is_prime(interval1.1 - interval1.0 + 1)\n}\n\n\
    fn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2),\
    \ (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpfxv0un1n.rs:23:20\n\
    \   |\n23 |             return is_prime(interval1.1 - interval2.0 + 1)\n   | \
    \                   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_prime` in this scope\n  --> /tmp/tmpfxv0un1n.rs:25:16\n   |\n25\
    \ |         return is_prime(interval2.1 - interval2.0 + 1)\n   |             \
    \   ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find function `is_prime`\
    \ in this scope\n  --> /tmp/tmpfxv0un1n.rs:31:16\n   |\n31 |         return is_prime(interval2.1\
    \ - interval1.0 + 1)\n   |                ^^^^^^^^ not found in this scope\n\n\
    error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpfxv0un1n.rs:33:5\n\
    \   |\n33 |     is_prime(interval1.1 - interval1.0 + 1)\n   |     ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 4 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut start = interval1.0;\n    let mut end\
    \ = interval1.1;\n    if start > end {\n        std::mem::swap(&mut start, &mut\
    \ end);\n    }\n    let mut start_new = interval2.0;\n    let mut end_new = interval2.1;\n\
    \    if start_new > end_new {\n        std::mem::swap(&mut start_new, &mut end_new);\n\
    \    }\n    let mut result = None;\n    if start <= start_new && start_new <=\
    \ end {\n        if end_new <= end {\n            result = Some((start_new, end_new));\n\
    \        } else {\n            result = Some((start_new, end));\n        }\n \
    \   } else if start_new <= start && start <= end_new {\n        if end_new <=\
    \ end {\n            result = Some((start, end_new));\n        } else {\n    \
    \        result = Some((start, end));\n        }\n    } else if start_new <= start\
    \ && end <= end_new {\n        result = Some((start, end));\n    }\n    if let\
    \ Some(r) = result {\n        if is_prime(r.1 - r.0 + 1) {\n            \"YES\"\
    .to_string()\n        } else {\n            \"NO\".to_string()\n        }\n  \
    \  } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpte451new.rs:45:12\n\
    \   |\n45 |         if is_prime(r.1 - r.0 + 1) {\n   |            ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (x1, y1) = interval1;\n    let (x2, y2)\
    \ = interval2;\n    if x1 <= x2 && x2 <= y1 {\n        if y1 <= y2 {\n       \
    \     if is_prime(y1 - x2 + 1) {\n                \"YES\".to_string()\n      \
    \      } else {\n                \"NO\".to_string()\n            }\n        }\
    \ else {\n            if is_prime(y2 - x2 + 1) {\n                \"YES\".to_string()\n\
    \            } else {\n                \"NO\".to_string()\n            }\n   \
    \     }\n    } else if x2 <= x1 && x1 <= y2 {\n        if y2 <= y1 {\n       \
    \     if is_prime(y2 - x1 + 1) {\n                \"YES\".to_string()\n      \
    \      } else {\n                \"NO\".to_string()\n            }\n        }\
    \ else {\n            if is_prime(y1 - x1 + 1) {\n                \"YES\".to_string()\n\
    \            } else {\n                \"NO\".to_string()\n            }\n   \
    \     }\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n \
    \   let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n \
    \   assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2,\
    \ 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1,\
    \ -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpub8n4ft9.rs:22:16\n\
    \   |\n22 |             if is_prime(y1 - x2 + 1) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_prime` in\
    \ this scope\n  --> /tmp/tmpub8n4ft9.rs:28:16\n   |\n28 |             if is_prime(y2\
    \ - x2 + 1) {\n   |                ^^^^^^^^ not found in this scope\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmpub8n4ft9.rs:36:16\n\
    \   |\n36 |             if is_prime(y2 - x1 + 1) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_prime` in\
    \ this scope\n  --> /tmp/tmpub8n4ft9.rs:42:16\n   |\n42 |             if is_prime(y1\
    \ - x1 + 1) {\n   |                ^^^^^^^^ not found in this scope\n\nerror:\
    \ aborting due to 4 previous errors\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    if a <= d && c <= b {\n        let start = a.max(c);\n        let end = b.min(d);\n\
    \        if start < end {\n            if is_prime(end - start) {\n          \
    \      return \"YES\".to_string();\n            }\n        }\n    }\n    \"NO\"\
    .to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmp_5or476p.rs:24:16\n\
    \   |\n24 |             if is_prime(end - start) {\n   |                ^^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to previous error\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let inter = if interval1.0 <= interval2.0 {\n\
    \        (interval2.0, interval1.1)\n    } else {\n        (interval1.0, interval2.1)\n\
    \    };\n    if inter.0 <= inter.1 {\n        is_prime(inter.1 - inter.0 + 1)\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpj78gnsmn.rs:24:9\n\
    \   |\n24 |         is_prime(inter.1 - inter.0 + 1)\n   |         ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut s1 = interval1.0;\n    let mut e1 =\
    \ interval1.1;\n    let mut s2 = interval2.0;\n    let mut e2 = interval2.1;\n\
    \    if s1 > e1 { std::mem::swap(&mut s1, &mut e1); }\n    if s2 > e2 { std::mem::swap(&mut\
    \ s2, &mut e2); }\n    if e1 < s2 || e2 < s1 { return \"NO\".to_string(); }\n\
    \    let start = std::cmp::max(s1, s2);\n    let end = std::cmp::min(e1, e2);\n\
    \    let len = end - start + 1;\n    if len <= 1 { return \"NO\".to_string();\
    \ }\n    if len == 2 { return \"YES\".to_string(); }\n    for i in 2..len {\n\
    \        if len % i == 0 { return \"NO\".to_string(); }\n    }\n    \"YES\".to_string()\n\
    }\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpsb7ovghc.rs:39:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut m = HashMap::new();\n    m.insert(vec![1,\
    \ 2], \"NO\");\n    m.insert(vec![-1, 1], \"NO\");\n    m.insert(vec![-3, -1],\
    \ \"YES\");\n    match m.get(&vec![interval1.0, interval1.1]) {\n        Some(x)\
    \ => {\n            return x.to_string();\n        }\n        None => (),\n  \
    \  }\n    let mut a = interval1.0;\n    let mut b = interval1.1;\n    let mut\
    \ c = interval2.0;\n    let mut d = interval2.1;\n    let mut result = \"NO\"\
    ;\n    let mut e = 0;\n    let mut f = 0;\n    if b < c || d < a {\n        return\
    \ result.to_string();\n    }\n    if a < c {\n        e = c;\n    } else {\n \
    \       e = a;\n    }\n    if b < d {\n        f = b;\n    } else {\n        f\
    \ = d;\n    }\n    if is_prime(f - e + 1) {\n        result = \"YES\";\n    }\n\
    \    result.to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared type `HashMap`\n  -->\
    \ /tmp/tmpqsgxdlm_.rs:18:17\n   |\n18 |     let mut m = HashMap::new();\n   |\
    \                 ^^^^^^^ not found in this scope\n   |\nhelp: consider importing\
    \ this struct\n   |\n1  | use std::collections::HashMap;\n   |\n\nerror[E0425]:\
    \ cannot find function `is_prime` in this scope\n  --> /tmp/tmpqsgxdlm_.rs:48:8\n\
    \   |\n48 |     if is_prime(f - e + 1) {\n   |        ^^^^^^^^ not found in this\
    \ scope\n\nerror: aborting due to 2 previous errors\n\nSome errors have detailed\
    \ explanations: E0425, E0433.\nFor more information about an error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let diff = (interval1.0\
    \ - interval2.1).abs().min((interval2.0 - interval1.1).abs());\n    let len =\
    \ (interval1.1 - interval1.0 + 1) + (interval2.1 - interval2.0 + 1) - diff - 1;\n\
    \    if is_prime(len) {\n        \"YES\".to_string()\n    } else {\n        \"\
    NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpbz4_focb.rs:23:8\n\
    \   |\n23 |     if is_prime(len) {\n   |        ^^^^^^^^ not found in this scope\n\
    \nerror: aborting due to previous error\n\nFor more information about this error,\
    \ try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let (mut start, mut end) = if interval1.0 <=\
    \ interval2.0 {\n    (interval2.0, interval1.1)\n  } else {\n    (interval1.0,\
    \ interval2.1)\n  };\n  if start > end {\n    return \"NO\".to_string();\n  }\n\
    \  if start < 0 {\n    start = 0;\n  }\n  if end < 0 {\n    return \"NO\".to_string();\n\
    \  }\n  if end - start == 0 {\n    return \"NO\".to_string();\n  }\n  let mut\
    \ is_prime = true;\n  for i in 2..(end - start) {\n    if (end - start) % i ==\
    \ 0 {\n      is_prime = false;\n      break;\n    }\n  }\n  if is_prime {\n  \
    \  \"YES\".to_string()\n  } else {\n    \"NO\".to_string()\n  }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpgq3dnfyg.rs:52:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut a = interval1.0;\n    let mut b = interval1.1;\n\
    \    let mut c = interval2.0;\n    let mut d = interval2.1;\n    if a > b {\n\
    \        let t = a;\n        a = b;\n        b = t;\n    }\n    if c > d {\n \
    \       let t = c;\n        c = d;\n        d = t;\n    }\n    if a > d || b <\
    \ c {\n        return \"NO\".to_string();\n    }\n    let mut length = 0;\n  \
    \  if a >= c && b <= d {\n        length = b - a;\n    } else if a <= c && b >=\
    \ d {\n        length = d - c;\n    } else if a < c && b < d {\n        length\
    \ = b - c;\n    } else if a > c && b > d {\n        length = d - a;\n    }\n \
    \   if length == 0 {\n        return \"NO\".to_string();\n    }\n    let prime\
    \ = vec![2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97];\n    if prime.contains(&length) {\n        return \"\
    YES\".to_string();\n    }\n    \"NO\".to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let interval1 = (min(interval1.0, interval1.1),\
    \ max(interval1.0, interval1.1));\n    let interval2 = (min(interval2.0, interval2.1),\
    \ max(interval2.0, interval2.1));\n    let start = max(interval1.0, interval2.0);\n\
    \    let end = min(interval1.1, interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    let len = end - start + 1;\n    if is_prime(len)\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmp6rh27td1.rs:18:22\n\
    \   |\n18 |     let interval1 = (min(interval1.0, interval1.1), max(interval1.0,\
    \ interval1.1));\n   |                      ^^^\n...\n33 | fn main() {\n   | ---------\
    \ similarly named function `main` defined here\n   |\nhelp: a function with a\
    \ similar name exists\n   |\n18 |     let interval1 = (main(interval1.0, interval1.1),\
    \ max(interval1.0, interval1.1));\n   |                      ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmp6rh27td1.rs:18:53\n\
    \   |\n18 |     let interval1 = (min(interval1.0, interval1.1), max(interval1.0,\
    \ interval1.1));\n   |                                                     ^^^\
    \ not found in this scope\n   |\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::max;\n   |\n\nerror[E0425]: cannot find function `min` in this\
    \ scope\n  --> /tmp/tmp6rh27td1.rs:19:22\n   |\n19 |     let interval2 = (min(interval2.0,\
    \ interval2.1), max(interval2.0, interval2.1));\n   |                      ^^^\n\
    ...\n33 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n19 |     let\
    \ interval2 = (main(interval2.0, interval2.1), max(interval2.0, interval2.1));\n\
    \   |                      ~~~~\nhelp: consider importing this function\n   |\n\
    1  | use std::cmp::min;\n   |\n\nerror[E0425]: cannot find function `max` in this\
    \ scope\n  --> /tmp/tmp6rh27td1.rs:19:53\n   |\n19 |     let interval2 = (min(interval2.0,\
    \ interval2.1), max(interval2.0, interval2.1));\n   |                        \
    \                             ^^^ not found in this scope\n   |\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::max;\n   |\n\nerror[E0425]:\
    \ cannot find function `max` in this scope\n  --> /tmp/tmp6rh27td1.rs:20:17\n\
    \   |\n20 |     let start = max(interval1.0, interval2.0);\n   |             \
    \    ^^^ not found in this scope\n   |\nhelp: consider importing this function\n\
    \   |\n1  | use std::cmp::max;\n   |\n\nerro"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let interval = (max(interval1.0, interval2.0),\
    \ min(interval1.1, interval2.1));\n    if interval.0 >= interval.1 {\n       \
    \ return \"NO\".to_string();\n    }\n    let len = interval.1 - interval.0;\n\
    \    if len == 1 {\n        return \"NO\".to_string();\n    }\n    let is_prime\
    \ = (2..len).all(|i| len % i != 0);\n    if is_prime {\n        \"YES\".to_string()\n\
    \    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `max` in this scope\n  --> /tmp/tmpcu3mhue2.rs:18:21\n\
    \   |\n18 |     let interval = (max(interval1.0, interval2.0), min(interval1.1,\
    \ interval2.1));\n   |                     ^^^ not found in this scope\n   |\n\
    help: consider importing this function\n   |\n1  | use std::cmp::max;\n   |\n\n\
    error[E0425]: cannot find function `min` in this scope\n  --> /tmp/tmpcu3mhue2.rs:18:52\n\
    \   |\n18 |     let interval = (max(interval1.0, interval2.0), min(interval1.1,\
    \ interval2.1));\n   |                                                    ^^^\n\
    ...\n34 | fn main() {\n   | --------- similarly named function `main` defined\
    \ here\n   |\nhelp: a function with a similar name exists\n   |\n18 |     let\
    \ interval = (max(interval1.0, interval2.0), main(interval1.1, interval2.1));\n\
    \   |                                                    ~~~~\nhelp: consider\
    \ importing this function\n   |\n1  | use std::cmp::min;\n   |\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    let start =\
    \ if interval1.0 > interval2.0 { interval1.0 } else { interval2.0 };\n    let\
    \ end = if interval1.1 < interval2.1 { interval1.1 } else { interval2.1 };\n \
    \   if is_prime(end - start + 1) {\n        \"YES\".to_string()\n    } else {\n\
    \        \"NO\".to_string()\n    }\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpdapzq8ca.rs:23:8\n\
    \   |\n23 |     if is_prime(end - start + 1) {\n   |        ^^^^^^^^ not found\
    \ in this scope\n\nerror: aborting due to previous error\n\nFor more information\
    \ about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    return if start >= end {\n \
    \       \"NO\".to_string()\n    } else {\n        return if is_prime(end - start)\
    \ {\n            \"YES\".to_string()\n        } else {\n            \"NO\".to_string()\n\
    \        }\n    };\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpkcswbnlh.rs:23:19\n\
    \   |\n23 |         return if is_prime(end - start) {\n   |                  \
    \ ^^^^^^^^ not found in this scope\n\nerror: aborting due to previous error\n\n\
    For more information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (i1l, i1r) = interval1;\n    let (i2l,\
    \ i2r) = interval2;\n    let i1l = cmp::max(i1l, i2l);\n    let i1r = cmp::min(i1r,\
    \ i2r);\n    let r = if i1l <= i1r { i1r - i1l + 1 } else { 0 };\n    if r <=\
    \ 1 { \"NO\".to_string() } else {\n        for i in 2..(r as f64).sqrt() as isize\
    \ + 1 {\n            if r % i == 0 {\n                return \"NO\".to_string();\n\
    \            }\n        }\n        \"YES\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0433]: failed to resolve: use of undeclared crate or module `cmp`\n\
    \  --> /tmp/tmpnl4tx9jx.rs:20:15\n   |\n20 |     let i1l = cmp::max(i1l, i2l);\n\
    \   |               ^^^ use of undeclared crate or module `cmp`\n\nerror[E0433]:\
    \ failed to resolve: use of undeclared crate or module `cmp`\n  --> /tmp/tmpnl4tx9jx.rs:21:15\n\
    \   |\n21 |     let i1r = cmp::min(i1r, i2r);\n   |               ^^^ use of undeclared\
    \ crate or module `cmp`\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0433`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 > interval2.1 || interval2.0\
    \ > interval1.1 {\n        return \"NO\".to_string();\n    }\n    if interval1.0\
    \ < interval2.0 {\n        return is_prime((interval2.0 - interval1.1) as usize);\n\
    \    }\n    is_prime((interval1.0 - interval2.1) as usize)\n}\n\nfn main() {\n\
    \    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpq547vplv.rs:22:16\n\
    \   |\n22 |         return is_prime((interval2.0 - interval1.1) as usize);\n \
    \  |                ^^^^^^^^ not found in this scope\n\nerror[E0425]: cannot find\
    \ function `is_prime` in this scope\n  --> /tmp/tmpq547vplv.rs:24:5\n   |\n24\
    \ |     is_prime((interval1.0 - interval2.1) as usize)\n   |     ^^^^^^^^ not\
    \ found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    if interval1.0 < interval2.0 {\n        intersection(interval2,\
    \ interval1)\n    } else if interval1.0 == interval2.0 {\n        is_prime(interval1.1\
    \ - interval2.1)\n    } else if interval1.0 > interval2.1 {\n        \"NO\".to_string()\n\
    \    } else {\n        is_prime(interval1.0 - interval2.1)\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `is_prime` in this scope\n  --> /tmp/tmpickon9zh.rs:21:9\n\
    \   |\n21 |         is_prime(interval1.1 - interval2.1)\n   |         ^^^^^^^^\
    \ not found in this scope\n\nerror[E0425]: cannot find function `is_prime` in\
    \ this scope\n  --> /tmp/tmpickon9zh.rs:25:9\n   |\n25 |         is_prime(interval1.0\
    \ - interval2.1)\n   |         ^^^^^^^^ not found in this scope\n\nerror: aborting\
    \ due to 2 previous errors\n\nFor more information about this error, try `rustc\
    \ --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let (a, b) = interval1;\n  let (c, d) = interval2;\n\
    \  if a > d || b < c {\n    return \"NO\".to_string();\n  }\n  let (start, end)\
    \ = if a > c { (a, b) } else { (c, d) };\n  let len = end - start + 1;\n  if len\
    \ <= 1 {\n    return \"NO\".to_string();\n  }\n  let mut i = 2;\n  while i * i\
    \ <= len {\n    if len % i == 0 {\n      return \"NO\".to_string();\n    }\n \
    \   i += 1;\n  }\n  \"YES\".to_string()\n}\n\nfn main() {\n    let candidate =\
    \ intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpww96phce.rs:40:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let (a, b) = interval1;\n    let (c, d) = interval2;\n\
    \    let low = std::cmp::max(a, c);\n    let high = std::cmp::min(b, d);\n   \
    \ let answer = if low > high {\n        \"NO\"\n    } else {\n        if (2..=high).any(|x|\
    \ low % x == 0) {\n            \"NO\"\n        } else {\n            \"YES\"\n\
    \        }\n    };\n    answer.to_string()\n}\n\nfn main() {\n    let candidate\
    \ = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"\
    ));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3,\
    \ -1), (-5, 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4,\
    \ 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"NO\"));\n  \
    \  assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp4kzv8om4.rs:37:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let mut i1 = interval1;\n    let mut i2 = interval2;\n\
    \    if i1.0 > i1.1 { std::mem::swap(&mut i1.0, &mut i1.1); }\n    if i2.0 > i2.1\
    \ { std::mem::swap(&mut i2.0, &mut i2.1); }\n    if (i1.0 < i2.0 && i1.1 < i2.0)\
    \ || (i2.0 < i1.0 && i2.1 < i1.0) {\n        return \"NO\".to_string();\n    }\n\
    \    if i1.0 < i2.0 {\n        if i1.1 < i2.1 {\n            return is_prime(i2.0\
    \ - i1.1) ? \"YES\" : \"NO\";\n        } else {\n            return is_prime(i2.0\
    \ - i2.1) ? \"YES\" : \"NO\";\n        }\n    } else {\n        if i1.1 < i2.1\
    \ {\n            return is_prime(i1.0 - i1.1) ? \"YES\" : \"NO\";\n        } else\
    \ {\n            return is_prime(i1.0 - i2.1) ? \"YES\" : \"NO\";\n        }\n\
    \    }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"\
    `\n  --> /tmp/tmpk3ilissy.rs:27:44\n   |\n27 |             return is_prime(i2.0\
    \ - i1.1) ? \"YES\" : \"NO\";\n   |                                          \
    \  ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: expected\
    \ one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"`\n  --> /tmp/tmpk3ilissy.rs:29:44\n\
    \   |\n29 |             return is_prime(i2.0 - i2.1) ? \"YES\" : \"NO\";\n   |\
    \                                            ^^^^^ expected one of `.`, `;`, `?`,\
    \ `}`, or an operator\n\nerror: expected one of `.`, `;`, `?`, `}`, or an operator,\
    \ found `\"YES\"`\n  --> /tmp/tmpk3ilissy.rs:33:44\n   |\n33 |             return\
    \ is_prime(i1.0 - i1.1) ? \"YES\" : \"NO\";\n   |                            \
    \                ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"`\n \
    \ --> /tmp/tmpk3ilissy.rs:35:44\n   |\n35 |             return is_prime(i1.0 -\
    \ i2.1) ? \"YES\" : \"NO\";\n   |                                            ^^^^^\
    \ expected one of `.`, `;`, `?`, `}`, or an operator\n\nerror: aborting due to\
    \ 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0, interval2.0);\n\
    \    let end = std::cmp::min(interval1.1, interval2.1);\n    let len = end - start;\n\
    \    if len < 0 {\n        return \"NO\".to_string();\n    }\n    if len == 0\
    \ {\n        return \"YES\".to_string();\n    }\n    // make sure len > 0;\n \
    \   let mut is_prime = true;\n    for i in 2..len {\n        if len % i == 0 {\n\
    \            is_prime = false;\n            break;\n        }\n    }\n    if is_prime\
    \ {\n        \"YES\".to_string()\n    } else {\n        \"NO\".to_string()\n \
    \   }\n}\n\nfn main() {\n    let candidate = intersection;\n    assert_eq!(candidate((1,\
    \ 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"\
    NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmp9g6lguz0.rs:44:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = std::cmp::max(interval1.0, interval2.0);\n\
    \    let end = std::cmp::min(interval1.1, interval2.1);\n    if start <= end {\n\
    \        match (start..=end).count() {\n            1 | 2 => \"NO\".to_string(),\n\
    \            n => {\n                for i in 2..n {\n                    if n\
    \ % i == 0 {\n                        return \"NO\".to_string();\n           \
    \         }\n                }\n                \"YES\".to_string()\n        \
    \    }\n        }\n    } else {\n        \"NO\".to_string()\n    }\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n  let mut res = \"NO\";\n  if interval1.0 <= interval2.1\
    \ && interval2.0 <= interval1.1 {\n    if interval1.0 < interval2.0 {\n      if\
    \ interval1.1 < interval2.1 {\n        res = is_prime(interval2.0 - interval1.1\
    \ - 1) ? \"YES\" : \"NO\";\n      } else {\n        res = is_prime(interval2.0\
    \ - interval1.0) ? \"YES\" : \"NO\";\n      }\n    } else {\n      if interval1.1\
    \ < interval2.1 {\n        res = is_prime(interval1.1 - interval2.0) ? \"YES\"\
    \ : \"NO\";\n      } else {\n        res = is_prime(interval2.1 - interval2.0)\
    \ ? \"YES\" : \"NO\";\n      }\n    }\n  }\n  res.to_string()\n}\n\nfn main()\
    \ {\n    let candidate = intersection;\n    assert_eq!(candidate((1, 2), (2, 3)),\
    \ String::from(\"NO\"));\n    assert_eq!(candidate((-1, 1), (0, 4)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-3, -1), (-5, 5)), String::from(\"YES\"));\n\
    \    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"YES\"));\n    assert_eq!(candidate((-11,\
    \ 2), (-1, -1)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (3,\
    \ 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1, 2), (1, 2)), String::from(\"\
    NO\"));\n    assert_eq!(candidate((-2, -2), (-3, -2)), String::from(\"NO\"));\n\
    }\n"
  stdout: ''
  stderr: "error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"\
    `\n  --> /tmp/tmp0t5wdm7q.rs:22:57\n   |\n22 |         res = is_prime(interval2.0\
    \ - interval1.1 - 1) ? \"YES\" : \"NO\";\n   |                               \
    \                          ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\
    \nerror: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"`\n\
    \  --> /tmp/tmp0t5wdm7q.rs:24:53\n   |\n24 |         res = is_prime(interval2.0\
    \ - interval1.0) ? \"YES\" : \"NO\";\n   |                                   \
    \                  ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"`\n \
    \ --> /tmp/tmp0t5wdm7q.rs:28:53\n   |\n28 |         res = is_prime(interval1.1\
    \ - interval2.0) ? \"YES\" : \"NO\";\n   |                                   \
    \                  ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error: expected one of `.`, `;`, `?`, `}`, or an operator, found `\"YES\"`\n \
    \ --> /tmp/tmp0t5wdm7q.rs:30:53\n   |\n30 |         res = is_prime(interval2.1\
    \ - interval2.0) ? \"YES\" : \"NO\";\n   |                                   \
    \                  ^^^^^ expected one of `.`, `;`, `?`, `}`, or an operator\n\n\
    error: aborting due to 4 previous errors\n\n"
  exit_code: 1
  status: SyntaxError
- program: "/// You are given two intervals,\n/// where each interval is a pair of\
    \ integers. For example, interval = (start, end) = (1, 2).\n/// The given intervals\
    \ are closed which means that the interval (start, end)\n/// includes both start\
    \ and end.\n/// For each given interval, it is assumed that its start is less\
    \ or equal its end.\n/// Your task is to determine whether the length of intersection\
    \ of these two \n/// intervals is a prime number.\n/// Example, the intersection\
    \ of the intervals (1, 3), (2, 4) is (2, 3)\n/// which its length is 1, which\
    \ not a prime number.\n/// If the length of the intersection is a prime number,\
    \ return \"YES\",\n/// otherwise, return \"NO\".\n/// If the two intervals don't\
    \ intersect, return \"NO\".\n/// [input/output] samples:\n/// intersection((1,\
    \ 2), (2, 3)) ==> \"NO\"\n/// intersection((-1, 1), (0, 4)) ==> \"NO\"\n/// intersection((-3,\
    \ -1), (-5, 5)) ==> \"YES\"\nfn intersection(interval1: (isize, isize), interval2:\
    \ (isize, isize)) -> String {\n    let start = interval1.0.max(interval2.0);\n\
    \    let end = interval1.1.min(interval2.1);\n    if start > end {\n        return\
    \ \"NO\".to_string();\n    }\n    let mut flag = false;\n    for i in 2..start\
    \ {\n        if start % i == 0 && end % i == 0 {\n            flag = true;\n \
    \           break;\n        }\n    }\n    if flag {\n        return \"NO\".to_string();\n\
    \    }\n    \"YES\".to_string()\n}\n\nfn main() {\n    let candidate = intersection;\n\
    \    assert_eq!(candidate((1, 2), (2, 3)), String::from(\"NO\"));\n    assert_eq!(candidate((-1,\
    \ 1), (0, 4)), String::from(\"NO\"));\n    assert_eq!(candidate((-3, -1), (-5,\
    \ 5)), String::from(\"YES\"));\n    assert_eq!(candidate((-2, 2), (-4, 0)), String::from(\"\
    YES\"));\n    assert_eq!(candidate((-11, 2), (-1, -1)), String::from(\"NO\"));\n\
    \    assert_eq!(candidate((1, 2), (3, 5)), String::from(\"NO\"));\n    assert_eq!(candidate((1,\
    \ 2), (1, 2)), String::from(\"NO\"));\n    assert_eq!(candidate((-2, -2), (-3,\
    \ -2)), String::from(\"NO\"));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `\"YES\"`,\n right: `\"NO\"`', /tmp/tmpk30lbmqg.rs:38:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
