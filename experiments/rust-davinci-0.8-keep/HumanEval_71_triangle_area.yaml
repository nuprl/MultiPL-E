name: HumanEval_71_triangle_area
language: rust
prompt: "/// Given the lengths of the three sides of a triangle. Return the area of\n\
  /// the triangle rounded to 2 decimal points if the three sides form a valid triangle.\
  \ \n/// Otherwise return -1\n/// Three sides make a valid triangle when the sum\
  \ of any two sides is greater \n/// than the third side.\n/// Example:\n/// triangle_area(3,\
  \ 4, 5) == 6.00\n/// triangle_area(1, 2, 10) == -1\nfn triangle_area(a: isize, b:\
  \ isize, c: isize) -> f64 {\n"
tests: "}\n\nfn main() {\n    let candidate = triangle_area;\n    assert_eq!(candidate(3,\
  \ 4, 5), 6.0);\n    assert_eq!(candidate(1, 2, 10), -1.0);\n    assert_eq!(candidate(4,\
  \ 8, 5), 8.18);\n    assert_eq!(candidate(2, 2, 2), 1.73);\n    assert_eq!(candidate(1,\
  \ 2, 3), -1.0);\n    assert_eq!(candidate(10, 5, 7), 16.25);\n    assert_eq!(candidate(2,\
  \ 6, 3), -1.0);\n    assert_eq!(candidate(1, 1, 1), 0.43);\n    assert_eq!(candidate(2,\
  \ 2, 10), -1.0);\n}\n"
completions: ["  let mut sides = vec![a, b, c];\n  sides.sort();\n  if sides[0] +\
    \ sides[1] > sides[2] {\n    let h = sides[2];\n    sides.pop();\n    let area\
    \ = (sides[0] * h) as f64 / 2f64;\n    area.round() / 100f64\n  } else {\n   \
    \ -1f64\n  }", "    if a + b <= c || a + c <= b || b + c <= a {\n        return\
    \ -1.0;\n    }\n    let s = (a + b + c) as f64 / 2.0;\n    f64::sqrt(s * (s -\
    \ a as f64) * (s - b as f64) * (s - c as f64))", "    let mut arr = [a, b, c];\n\
    \    arr.sort();\n    if arr[0] + arr[1] > arr[2] {\n        0.5 * (arr[0] * arr[2]\
    \ + arr[1] * arr[2] + arr[0] * arr[1]) as f64\n    } else {\n        -1.0\n  \
    \  }", "    let x = a + b;\n    let y = b + c;\n    let z = c + a;\n    let max\
    \ = std::cmp::max(x, std::cmp::max(y, z));\n    if a <= 0 || b <= 0 || c <= 0\
    \ || max >= (a + b + c - max) {\n        -1.00\n    } else {\n        ((a * b\
    \ * c) as f64).sqrt() * 0.5\n    }", "    if a + b <= c || a + c <= b || b + c\
    \ <= a {\n        return -1.00;\n    }\n    let s = (a + b + c) as f64 / 2.0;\n\
    \    (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()", "    if (a\
    \ + b) > c && (a + c) > b && (b + c) > a {\n        let x = (a + b + c) as f64\
    \ / 2.0;\n        ((x * (x - a as f64) * (x - b as f64) * (x - c as f64)).sqrt()\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    match (a,\
    \ b, c) {\n        (x, y, z) if x + y > z && x + z > y && y + z > x => {\n   \
    \         let s = (a + b + c) as f64 / 2.0;\n            (s * (s - a as f64) *\
    \ (s - b as f64) * (s - c as f64)).sqrt()\n        },\n        _ => -1.0\n   \
    \ }", "    let s = (a + b + c) as f64 / 2.0;\n    if a + b > c && a + c > b &&\
    \ b + c > a {\n        ((s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    // Use the\
    \ area of the triangle formula.\n    let p = (a + b + c) as f64 / 2.0;\n    let\
    \ area = (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n    if\
    \ area.is_nan() { -1.0 } else { area.round() / 100.0 }", "    let (a, b, c) =\
    \ (a as f64, b as f64, c as f64);\n    if (a + b > c) && (a + c > b) && (b + c\
    \ > a) {\n        let p = (a + b + c) / 2.0;\n        (p * (p - a) * (p - b) *\
    \ (p - c)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut sides = vec![a,\
    \ b, c];\n    sides.sort();\n    let a = sides[0] as f64;\n    let b = sides[1]\
    \ as f64;\n    let c = sides[2] as f64;\n    if a + b > c {\n        let p = (a\
    \ + b + c) / 2.0;\n        ((p * (p - a) * (p - b) * (p - c)).sqrt() * 100.0).round()\
    \ / 100.0\n    } else {\n        -1.0\n    }", "    let mut sides = vec![a, b,\
    \ c];\n    sides.sort();\n    let (a, b, c) = (sides[0], sides[1], sides[2]);\n\
    \    if a + b > c {\n        let s = (a + b + c) as f64 / 2.0;\n        (s * (s\
    \ - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n      \
    \  -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n        let p\
    \ = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) *\
    \ (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut sides\
    \ = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] <= sides[2]\
    \ { return -1.0; }\n    let mut area = heron_area(sides[0], sides[1], sides[2]);\n\
    \    area = (area * 100.0).round() / 100.0;\n    area", "  let tri = vec![a, b,\
    \ c];\n  let mut edges = tri.iter().map(|&i| i as f64).collect::<Vec<f64>>();\n\
    \  edges.sort_by(|a, b| a.partial_cmp(b).unwrap());\n  let a = edges[0];\n  let\
    \ b = edges[1];\n  let c = edges[2];\n  if a + b > c {\n    let s = (a + b + c)\
    \ / 2.0;\n    (s * (s - a) * (s - b) * (s - c)).sqrt()\n  } else {\n    -1.0\n\
    \  }", "    let (a, b, c) = (a as f64, b as f64, c as f64);\n    let s = (a +\
    \ b + c) / 2.0;\n    if a + b > c && a + c > b && b + c > a {\n        (s * (s\
    \ - a) * (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n    }", "    if\
    \ a + b > c && a + c > b && b + c > a {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let sum = a + b + c;\n    if sum - a\
    \ <= 0 || sum - b <= 0 || sum - c <= 0 {\n        return -1.0;\n    }\n    let\
    \ p = (sum as f64) / 2.0;\n    ((p * (p - a as f64) * (p - b as f64) * (p - c\
    \ as f64)).sqrt() * 100.0).round() / 100.0", "    if a + b <= c || a + c <= b\
    \ || b + c <= a {\n        return -1.00;\n    }\n    let p = (a + b + c) as f64\
    \ / 2.0;\n    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()",
  "    let sides = vec![a, b, c];\n    let max = sides.iter().max().unwrap();\n  \
    \  let remaining = sides.iter().filter(|&s| s != max).sum::<isize>();\n    if\
    \ *max >= remaining {\n        -1.0\n    } else {\n        let s = (a + b + c)\
    \ as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    }", "  if (a + b <= c) || (a + c <= b) || (b + c <= a) {\n    return -1.0;\n\
    \  }\n  let p = (a + b + c) as f64 / 2.0;\n  (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()", "    if a < 1 || b < 1 || c < 1 {\n        return\
    \ -1.0;\n    }\n    let s = a as f64 + b as f64 + c as f64;\n    let area = s\
    \ * (s - a as f64) * (s - b as f64) * (s - c as f64);\n    if area <= 0.0 {\n\
    \        return -1.0;\n    }\n    area.sqrt()", "    let mut max = std::cmp::max(a,\
    \ b);\n    max = std::cmp::max(max, c);\n    let mut min = std::cmp::min(a, b);\n\
    \    min = std::cmp::min(min, c);\n    let mid = a + b + c - max - min;\n    if\
    \ max >= mid + min {\n        return -1.0;\n    }\n    let p = (max + mid + min)\
    \ as f64 / 2.0;\n    (p * (p - max as f64) * (p - mid as f64) * (p - min as f64)).sqrt()",
  '    unimplemented!()', "    // Sort the sides\n    let mut sides = [a, b, c];\n\
    \    sides.sort();\n\n    // This is a valid triangle if any two sides combined\
    \ are larger than the third\n    if sides[0] + sides[1] > sides[2] {\n       \
    \ // Heron's formula\n        let s = (sides[0] + sides[1] + sides[2]) as f64\
    \ / 2.0;\n        (s * (s - sides[0] as f64) * (s - sides[1] as f64) * (s - sides[2]\
    \ as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if a + b > c && a\
    \ + c > b && b + c > a {\n        let p = (a + b + c) as f64 / 2.0;\n        (p\
    \ * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n \
    \       -1.0\n    }", "    let mut v = vec![a, b, c];\n    v.sort();\n    if v[0]\
    \ + v[1] > v[2] {\n        ((v[0] + v[1] + v[2]) as f64 / 2.0).sqrt() * (v[2]\
    \ as f64)\n    } else {\n        -1.0\n    }", "    let s = (a + b + c) as f64\
    \ / 2.0;\n    if a + b > c && a + c > b && b + c > a {\n        return (s * (s\
    \ - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    }\n    -1.0", " \
    \   let mut sides = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1]\
    \ > sides[2] {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a\
    \ as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    if (a + b > c) && (a + c > b) && (b + c > a) {\n        (a as f64\
    \ + b as f64 + c as f64) / 2.0\n    } else {\n        -1.0\n    }", "    let s\
    \ = (a + b + c) as f64 / 2.0;\n    match s.powi(2) - (s - a as f64).powi(2) -\
    \ (s - b as f64).powi(2) - (s - c as f64).powi(2) {\n        x if x < 0.0 => -1.0,\n\
    \        x => (x * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt(),\n\
    \    }", "    let mut vec = vec![a, b, c];\n    vec.sort();\n    let &a = vec.get(0).unwrap();\n\
    \    let &b = vec.get(1).unwrap();\n    let &c = vec.get(2).unwrap();\n    if\
    \ a + b <= c {\n        return -1.0;\n    }\n    let s = (a + b + c) as f64 /\
    \ 2.0;\n    ((s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt() * 100.0).round()\
    \ / 100.0", "    if a + b > c && a + c > b && b + c > a {\n        let p = (a\
    \ + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p -\
    \ c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if a + b > c &&\
    \ a + c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n      \
    \  let area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n\
    \        return format!(\"{:.2}\", area).parse::<f64>().unwrap();\n    }\n   \
    \ -1.0", "    let perimeter = a + b + c;\n    if perimeter > 2 * c && perimeter\
    \ > 2 * b && perimeter > 2 * a {\n        let p = (perimeter as f64) / 2.0;\n\
    \        let a = (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n\
    \        return a;\n    }\n    -1.0", "    let mut v = vec![a, b, c];\n    v.sort();\n\
    \    let a = v[0] as f64;\n    let b = v[1] as f64;\n    let c = v[2] as f64;\n\
    \    if a + b <= c {\n        return -1.0;\n    }\n    let p = (a + b + c) / 2.0;\n\
    \    (p * (p - a) * (p - b) * (p - c)).sqrt()", "    if a + b > c && a + c > b\
    \ && b + c > a {\n        let p = (a + b + c) as f64 / 2f64;\n        (p * (p\
    \ - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n      \
    \  -1f64\n    }", "    if a + b > c && a + c > b && b + c > a {\n        let s\
    \ = (a + b + c) as f64 / 2.0;\n        let ans = (s * (s - a as f64) * (s - b\
    \ as f64) * (s - c as f64)).sqrt();\n        (ans * 100.0).round() / 100.0\n \
    \   } else {\n        -1.0\n    }", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let semiperimeter = (a + b + c) as f64\
    \ / 2f64;\n    let area = ((semiperimeter - a as f64) * (semiperimeter - b as\
    \ f64) * (semiperimeter - c as f64)).sqrt();\n    if semiperimeter <= 0f64 ||\
    \ area.is_nan() {\n        -1f64\n    } else {\n        area\n    }", "    match\
    \ (a, b, c) {\n        (x, y, z) if x + y <= z => -1.0,\n        (x, y, z) if\
    \ x + z <= y => -1.0,\n        (x, y, z) if y + z <= x => -1.0,\n        (x, y,\
    \ z) => {\n            let s = (x + y + z) as f64 / 2.0;\n            (s * (s\
    \ - x as f64) * (s - y as f64) * (s - z as f64)).sqrt()\n        }\n    }", " \
    \   let a = a as f64;\n    let b = b as f64;\n    let c = c as f64;\n    if a\
    \ + b > c && a + c > b && b + c > a {\n        let p = (a + b + c) / 2.0;\n  \
    \      (p * (p - a) * (p - b) * (p - c)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let s = (a + b + c) as f64 / 2.0;\n    let area = (s * (s - a as\
    \ f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if a + b > c && a + c >\
    \ b && b + c > a {\n        format!(\"{:.2}\", area).parse::<f64>().unwrap()\n\
    \    } else {\n        -1.0\n    }", "    let s = (a+b+c) as f64/2f64;\n    let\
    \ area = (s*(s-a as f64)*(s-b as f64)*(s-c as f64)).sqrt();\n    if area.is_nan()\
    \ {-1f64} else {area.trunc()/100f64}", "    let sorted = [a, b, c].iter().cloned().collect::<Vec<isize>>();\n\
    \    let a = sorted[0];\n    let b = sorted[1];\n    let c = sorted[2];\n    if\
    \ a + b > c {\n        ((a + b + c) as f64 / 2.0).sqrt() * (c as f64 / 2.0).sqrt()\
    \ * 2.0\n    } else {\n        -1.0\n    }", "    if ! is_valid_triangle(a, b,\
    \ c) {\n        return -1.0;\n    }\n    let s = (a + b + c) as f64 / 2.0;\n \
    \   (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()", '    unimplemented!()',
  "    use std::cmp::{max, min};\n    let s = (a + b + c) as f64 / 2.0;\n    let area\
    \ = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if area\
    \ < 0.0 { return -1.0; }\n    area", "    let mut x = (a + b + c) as f64;\n  \
    \  if x < 2.0 {\n        return -1.0;\n    }\n    x = x / 2.0;\n    x * (x - a\
    \ as f64) * (x - b as f64) * (x - c as f64)", "    let mut v = vec![a, b, c];\n\
    \    v.sort();\n    let (a, b, c) = (v[0], v[1], v[2]);\n    if c < a + b {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        ((p - a as f64) * (p - b as\
    \ f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if a\
    \ + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n    let\
    \ s = (a + b + c) as f64 / 2.0;\n    ((s - a as f64) * (s - b as f64) * (s - c\
    \ as f64)).sqrt()", "    if a + b > c && a + c > b && b + c > a {\n        let\
    \ p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let s = (a\
    \ + b + c) as f64 / 2.0;\n    if s == 0.0 {\n        return -1.0;\n    }\n   \
    \ let ans = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n    if ans\
    \ <= 0.0 {\n        return -1.0;\n    }\n    (ans as f64).sqrt()", "    let mut\
    \ area: f64 = 0.0;\n    if a + b > c && a + c > b && b + c > a {\n        let\
    \ p = (a + b + c) as f64 / 2.0;\n        area = (p * (p - a as f64) * (p - b as\
    \ f64) * (p - c as f64)).sqrt();\n    } else {\n        area = -1.0;\n    }\n\
    \    area", "    let sides = [a, b, c];\n    sides.iter().fold(0, |acc, x| acc\
    \ + x) as f64 / 2.0", "    // check if the sides form a valid triangle\n    if\
    \ a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 /\
    \ 2.0;\n        // heron's formula\n        let result = (s * (s - a as f64) *\
    \ (s - b as f64) * (s - c as f64)).sqrt();\n        return (result * 100.0).round()\
    \ / 100.0;\n    }\n    return -1.0;", "    let max = isize::max(a, isize::max(b,\
    \ c));\n    let sum = a + b + c - max;\n    let area = (sum as f64 * (max - sum)\
    \ as f64 * (max - sum + a + b + c - max) as f64).sqrt() / 4.0;\n    if area.is_nan()\
    \ {\n        -1.0\n    } else {\n        area\n    }", "    let mut x = vec![a,\
    \ b, c];\n    x.sort();\n    let a = x[0] as f64;\n    let b = x[1] as f64;\n\
    \    let c = x[2] as f64;\n    if a + b <= c {\n        return -1.0;\n    }\n\
    \    let s = (a + b + c) / 2.0;\n    (s * (s - a) * (s - b) * (s - c)).sqrt()",
  "    let tri_type = (a, b, c);\n    if tri_type.0 + tri_type.1 <= tri_type.2 ||\
    \ tri_type.0 + tri_type.2 <= tri_type.1 || tri_type.1 + tri_type.2 <= tri_type.0\
    \ {\n        return -1.0;\n    }\n    let p = (tri_type.0 + tri_type.1 + tri_type.2)\
    \ as f64 / 2.0;\n    (p * (p - tri_type.0 as f64) * (p - tri_type.1 as f64) *\
    \ (p - tri_type.2 as f64)).sqrt()", "    if a + b > c && a + c > b && b + c >\
    \ a {\n        let half_p = (a + b + c) as f64 / 2.0;\n        ((half_p - a as\
    \ f64) * (half_p - b as f64) * (half_p - c as f64) * half_p).sqrt()\n    } else\
    \ {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n   \
    \     let p = (a + b + c) as f64 / 2.0;\n        let area = (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt();\n        (area * 100.0).round() /\
    \ 100.0\n    } else {\n        -1.0\n    }", "    let mut s = [a, b, c];\n   \
    \ s.sort();\n    if s[0] + s[1] > s[2] {\n        let p = (s[0] + s[1] + s[2])\
    \ as f64;\n        ((p * (p - s[0] as f64) * (p - s[1] as f64) * (p - s[2] as\
    \ f64)).sqrt() / 4f64).round() / 100f64\n    } else {\n        -1f64\n    }",
  "    let mut a = a as f64;\n    let mut b = b as f64;\n    let mut c = c as f64;\n\
    \    if !(a + b > c && a + c > b && b + c > a) {\n        return -1.00;\n    }\n\
    \    let p = (a + b + c) / 2.0;\n    (p * (p - a) * (p - b) * (p - c)).sqrt()",
  "    let mut sides = vec![a, b, c];\n    sides.sort();\n    let a = sides[0] as\
    \ f64;\n    let b = sides[1] as f64;\n    let c = sides[2] as f64;\n    if a +\
    \ b <= c {\n        return -1.0;\n    }\n    let s = (a + b + c) / 2.0;\n    (s\
    \ * (s - a) * (s - b) * (s - c)).sqrt()", "    let mut sides = vec![a, b, c];\n\
    \    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n        let s = (sides[0]\
    \ + sides[1] + sides[2]) as f64 / 2.0;\n        let area = (s * (s - sides[0]\
    \ as f64) * (s - sides[1] as f64) * (s - sides[2] as f64)).sqrt();\n        (area\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    let mut vec\
    \ = vec![a, b, c];\n    vec.sort();\n    let a = vec[0] as f64;\n    let b = vec[1]\
    \ as f64;\n    let c = vec[2] as f64;\n    if a + b > c {\n        let p = (a\
    \ + b + c) / 2.0;\n        (p * (p - a) * (p - b) * (p - c)).sqrt()\n    } else\
    \ {\n        -1.0\n    }", "  let mut s = (a + b + c) as f64 / 2.0;\n  let mut\
    \ ans = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n  if ans > 0.0\
    \ {\n    ans = ans.sqrt();\n  } else {\n    ans = -1.0;\n  }\n  ans.round() /\
    \ 100.0", "    // Your code here!\n    let p = (a+b+c) as f64 / 2.0;\n    if a+b\
    \ > c && a+c > b && b+c > a {\n        (p*(p-a as f64)*(p-b as f64)*(p-c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", '    unimplemented!();', "    // Add code\
    \ here\n    if (a + b) > c && (a + c) > b && (b + c) > a {\n        let area =\
    \ (a + b + c) as f64 / 2.0;\n        (area * (area - a as f64) * (area - b as\
    \ f64) * (area - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if\
    \ a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 /\
    \ 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c >\
    \ a {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  '    unimplemented!();', "    let mut result = -1.0;\n    if (a+b) > c && (a+c)\
    \ > b && (b+c) > a {\n        let p = (a+b+c) as f64 / 2.0;\n        result =\
    \ (p*(p-a as f64)*(p-b as f64)*(p-c as f64)).sqrt();\n    }\n    result", "  \
    \  if (a + b) > c && (a + c) > b && (b + c) > a {\n        let p = (a + b + c)\
    \ as f64 / 2.0;\n        let area = p * (p - a as f64) * (p - b as f64) * (p -\
    \ c as f64);\n        return (area.sqrt() * 100.0).round() / 100.0;\n    } else\
    \ {\n        return -1.0;\n    }", "    if a < 1 || b < 1 || c < 1 {\n       \
    \ return -1.0;\n    }\n\n    let mut v = vec![a, b, c];\n    v.sort();\n\n   \
    \ if v[0] + v[1] <= v[2] {\n        return -1.0;\n    }\n\n    let p = (a + b\
    \ + c) as f64 / 2.0;\n    ((p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\
    \ * 100.0).round() / 100.0", "    let s = (a + b + c) as f64 / 2.0;\n    if s\
    \ < a as f64 || s < b as f64 || s < c as f64 {\n        return -1.0;\n    }\n\
    \    s.powf(3.0) * (s - a as f64).powf(3.0) * (s - b as f64).powf(3.0) * (s -\
    \ c as f64).powf(3.0)", "    let (a, b, c) = (a as f64, b as f64, c as f64);\n\
    \    let (x, y, z) = (a + b, b + c, c + a);\n    let s = 0.5 * z;\n    if (a <\
    \ 0.0) || (b < 0.0) || (c < 0.0) || (a >= x) || (b >= y) || (c >= z) {\n     \
    \   -1.0\n    } else {\n        (s * (s - a) * (s - b) * (s - c)).sqrt()\n   \
    \ }", "    let max_side = (a + b + c) - (vec![a, b, c].iter().min().unwrap() *\
    \ 2);\n    if max_side >= *vec![a, b, c].iter().min().unwrap() {\n        let\
    \ p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", '    unimplemented!();',
  '    unimplemented!();', "    if a + b <= c || a + c <= b || b + c <= a {\n    \
    \    return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n    ((p - a as\
    \ f64) * (p - b as f64) * (p - c as f64) * p).sqrt()", "    if a + b > c && a\
    \ + c > b && b + c > a {\n        let p = (a + b + c) as f64 / 2f64;\n       \
    \ (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n\
    \        -1f64\n    }", "    if a + b <= c || a + c <= b || b + c <= a { -1.0\
    \ }\n    else {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p -\
    \ a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    }", "    if a + b <=\
    \ c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n    let p = (a\
    \ + b + c) as f64 / 2.0;\n    ((p * (p - a as f64) * (p - b as f64) * (p - c as\
    \ f64)).sqrt() * 100.0).round() / 100.0", "    // Are the sides valid?\n    let\
    \ valid = (a + b > c) && (a + c > b) && (b + c > a);\n    // if valid, calculate\
    \ the area\n    if valid {\n        let s = (a + b + c) as f64 / 2.0;\n      \
    \  let area = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n        //\
    \ safe root of negative number\n        if area < 0.0 {\n            -1.0\n  \
    \      } else {\n            (area as f64).sqrt()\n        }\n    } else {\n \
    \       -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n        let\
    \ s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64) * (s - b as f64)\
    \ * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    if a + b\
    \ > c && a + c > b && b + c > a {\n        (a + b + c) as f64 / 2.0\n    } else\
    \ {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c > a {\n   \
    \     let s = (a + b + c) as f64 / 2.0;\n        return (s * (s - a as f64) *\
    \ (s - b as f64) * (s - c as f64)).sqrt();\n    }\n    -1.0", "  // I have no\
    \ idea what I'm doing here\n  if a + b > c && a + c > b && b + c > a {\n    let\
    \ semiperim = (a + b + c) as f64 / 2.0;\n    let area = semiperim * (semiperim\
    \ - a as f64) * (semiperim - b as f64) * (semiperim - c as f64);\n    (area.sqrt()\
    \ * 100.0).round() / 100.0\n  } else {\n    -1.0\n  }", "    if a < 1 || b < 1\
    \ || c < 1 {\n        return -1.0;\n    }\n\n    let p = (a + b + c) as f64 /\
    \ 2.0;\n    let area = (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n\
    \    area", "    // The sides length must be greater than 0\n    if a <= 0 ||\
    \ b <= 0 || c <= 0 {\n        return -1.0;\n    }\n\n    // The sum of two sides\
    \ must be greater than the third\n    if a + b <= c || a + c <= b || b + c <=\
    \ a {\n        return -1.0;\n    }\n\n    // Compute the area\n    let s = (a\
    \ + b + c) as f64 / 2.0;\n    (s * (s - a as f64) * (s - b as f64) * (s - c as\
    \ f64)).sqrt()", "    let circum_area = ((a + b + c) / 2) as f64;\n    let area\
    \ = (circum_area * (circum_area - a as f64) * (circum_area - b as f64) * (circum_area\
    \ - c as f64)).sqrt();\n    match (a, b, c) {\n        (x, y, z) if (x + y > z)\
    \ && (x + z > y) && (y + z > x) => area,\n        _ => -1.0\n    }", "    if a\
    \ + b > c && a + c > b && b + c > a {\n        ((a + b + c) as f64 / 2.0).sqrt()\
    \ * (((a + b + c) as f64 / 2.0) - a as f64).sqrt()\n            * (((a + b + c)\
    \ as f64 / 2.0) - b as f64).sqrt()\n    } else {\n        -1.0\n    }", "    if\
    \ a + b > c && a + c > b && b + c > a {\n        let p = (a + b + c) as f64 /\
    \ 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    if a+b > c && a+c > b && b+c > a {\n\
    \        let p = (a+b+c) as f64 / 2.0;\n        let area = (p*(p-a as f64)*(p-b\
    \ as f64)*(p-c as f64)).sqrt();\n        area.floor()/100.0\n    } else {\n  \
    \      -1.0\n    }", "    if a <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n\
    \    }\n    if (a + b <= c) || (a + c <= b) || (b + c <= a) {\n        return\
    \ -1.0;\n    }\n    let s = (a + b + c) as f64 / 2.0;\n    ((s - a as f64) * (s\
    \ - b as f64) * (s - c as f64)).sqrt()", "    let mut sides = vec![a, b, c];\n\
    \    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n        let p = (a\
    \ + b + c) as f64 / 2.0;\n        ((p * (p - a as f64) * (p - b as f64) * (p -\
    \ c as f64)).sqrt() * 100.0).round() / 100.0\n    } else {\n        -1.0\n   \
    \ }", "    if a + b > c && a + c > b && b + c > a {\n        let p = (a + b +\
    \ c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let s = (a + b + c) as f64 / 2.0;\n\
    \    let area = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n    if\
    \ area > 0.0 {\n        (area.sqrt() * 100.0).round() / 100.0\n    } else {\n\
    \        -1.0\n    }", "    let mut area = -1f64;\n    let mut v = vec![a, b,\
    \ c];\n    v.sort();\n    if v[0] + v[1] > v[2] {\n        let p = (a + b + c)\
    \ as f64 / 2f64;\n        area = (p * (p - a as f64) * (p - b as f64) * (p - c\
    \ as f64)).sqrt();\n    }\n    area.round() / 100f64", "    let s = (a + b + c)\
    \ as f64 / 2.0;\n    if s == 0.0 {\n        return -1.0;\n    }\n    let area\
    \ = s * (s - a as f64) * (s - b as f64) * (s - c as f64);\n    if area < 0.0 {\n\
    \        return -1.0;\n    }\n    area.sqrt()", '    unimplemented!()', "    let\
    \ mut sides = vec![a, b, c];\n    sides.sort();\n    let a = sides[0] as f64;\n\
    \    let b = sides[1] as f64;\n    let c = sides[2] as f64;\n    if a + b > c\
    \ {\n        let p = (a + b + c) / 2.0;\n        (p * (p - a) * (p - b) * (p -\
    \ c)).sqrt()\n    } else {\n        -1.0\n    }", "    // we assume that a, b,\
    \ c are the lengths of the 3 sides and that\n    // a <= b <= c so that the triangle\
    \ is oriented such that if\n    // a <= b <= c, then a is the shortest side, b\
    \ is the middle,\n    // and c is the longest side\n    //\n    // the triangle\
    \ inequality states that:\n    // a + b >= c\n    //\n    // the area of the triangle\
    \ is:\n    // area = sqrt(s * (s - a) * (s - b) * (s - c))\n    // where s = (a\
    \ + b + c) / 2\n    if a < 0 || b < 0 || c < 0 {\n        return -1.0;\n    }\n\
    \n    if a + b < c {\n        return -1.0;\n    }\n\n    let s = (a + b + c) as\
    \ f64 / 2.0;\n    let a = s - a as f64;\n    let b = s - b as f64;\n    let c\
    \ = s - c as f64;\n    let area = s * a * b * c;\n    return area.sqrt().round()\
    \ / 100.0;", "    let sum = a + b + c;\n    if sum < 2 {\n        return -1.0;\n\
    \    }\n    let s = sum as f64 / 2.0;\n    ((s - a as f64) * (s - b as f64) *\
    \ (s - c as f64) * s).sqrt()", "    // unimplemented!()\n    let area = (((a as\
    \ f64) + (b as f64) + (c as f64)) / 2.0) as f64;\n    let base = (a as f64) *\
    \ (b as f64) * (c as f64);\n    if base > 0.0 {\n        ((area * (area - (a as\
    \ f64)) * (area - (b as f64)) * (area - (c as f64))) as f64).sqrt()\n    } else\
    \ {\n        -1.0\n    }", "    // Preconditions\n    if a + b < c || a + c <\
    \ b || b + c < a {\n        return -1.0;\n    }\n\n    let p = (a + b + c) as\
    \ f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()",
  "    if a + b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n\
    \    let s = (a + b + c) as f64 / 2.0;\n    let sqrt_term = s * (s - a as f64)\
    \ * (s - b as f64) * (s - c as f64);\n    if sqrt_term < 0.0 {\n        return\
    \ -1.0;\n    }\n    (sqrt_term.sqrt() * 100.0).round() / 100.0", "    let v: [isize;\
    \ 3] = [a, b, c];\n    let mut v2: Vec<isize> = v.to_vec();\n    v2.sort();\n\
    \    let a = v2[0] as f64;\n    let b = v2[1] as f64;\n    let c = v2[2] as f64;\n\
    \    let s = (a + b + c) / 2.0;\n    let area = s * (s - a) * (s - b) * (s - c);\n\
    \    if area > 0.0 {\n        (area as f64).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let total = a as f64 + b as f64 + c as f64;\n    let p = total /\
    \ 2.0;\n    let area = (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n\
    \    match (a + b > c, a + c > b, b + c > a) {\n        (true, true, true) =>\
    \ area,\n        _ => -1.0,\n    }", "    use std::cmp::Ordering;\n    match (a.cmp(&b),\
    \ b.cmp(&c), c.cmp(&a)) {\n        (Ordering::Greater, Ordering::Greater, Ordering::Greater)\
    \ => {\n            (a as f64 + b as f64 + c as f64) / 2.0\n        },\n     \
    \   _ => { -1.0 }\n    }", "    if a + b <= c || a + c <= b || b + c <= a {\n\
    \        return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n    (p *\
    \ (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()", "    if (a + b >\
    \ c) && (a + c > b) && (b + c > a) {\n        let p = (a + b + c) as f64 / 2.0;\n\
    \        let area = ((p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\
    \ * 100.0).round() / 100.0;\n        return area;\n    }\n    -1.0", "    let\
    \ (a, b, c) = (a as f64, b as f64, c as f64);\n    let (s, p) = (0.5 * (a + b\
    \ + c), p(a, b, c));\n    let area = s * (s - a) * (s - b) * (s - c);\n    if\
    \ area > 0.0 {\n        p * area.sqrt()\n    } else {\n        -1.0\n    }", " \
    \   if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64\
    \ / 2.0;\n        let area = (s * (s - a as f64) * (s - b as f64) * (s - c as\
    \ f64)).sqrt();\n        return (area * 100.0).round() / 100.0;\n    }\n    -1.0",
  "    let s = (a + b + c) as f64 / 2.0;\n    if a + b <= c || a + c <= b || b + c\
    \ <= a {\n        -1.0\n    } else {\n        (s * (s - a as f64) * (s - b as\
    \ f64) * (s - c as f64)).sqrt()\n    }", "    if a + b > c && a + c > b && b +\
    \ c > a {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  "    let s = (a + b + c) as f64 / 2.0;\n    if a + b > c && a + c > b && b + c >\
    \ a {\n        ((s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    let (a, b,\
    \ c) = (a as f64, b as f64, c as f64);\n    if a + b > c && a + c > b && b + c\
    \ > a {\n        let p = (a + b + c) / 2.0;\n        ((p - a) * (p - b) * (p -\
    \ c) * p).sqrt()\n    } else {\n        -1.0\n    }", "    match a + b > c &&\
    \ a + c > b && b + c > a {\n        true => ((a * b * c) as f64).sqrt() * 4.0\
    \ / 3.0,\n        false => -1.0,\n    }", "    let mut v = vec![a, b, c];\n  \
    \  v.sort();\n    if v[0] + v[1] > v[2] {\n        let p = (a + b + c) as f64\
    \ / 2.0;\n        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut arr = [a, b, c];\n    arr.sort();\n\
    \    let [a, b, c] = arr;\n    if a + b > c {\n        let s = (a + b + c) as\
    \ f64 / 2.0;\n        let sq = s * (s - a as f64) * (s - b as f64) * (s - c as\
    \ f64);\n        sq.sqrt()\n    } else {\n        -1.0\n    }", "    if a <= 0\
    \ || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n    let s = (a + b + c)\
    \ as f64 / 2.0;\n    let area = (s * (s - a as f64) * (s - b as f64) * (s - c\
    \ as f64)).sqrt();\n    if area.is_nan() {\n        return -1.0;\n    }\n    return\
    \ area;", "    let s = (a+b+c) as f64 / 2f64;\n    let area = s*(s-a as f64)*(s-b\
    \ as f64)*(s-c as f64);\n    if area < 0f64 {\n        -1f64\n    } else {\n \
    \       area.sqrt()\n    }", "    if a + b <= c || a + c <= b || b + c <= a {\n\
    \        return -1.0;\n    }\n    let p = (a + b + c) as f64 / 2.0;\n    let area\
    \ = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n    (area.sqrt() *\
    \ 100.0).round() / 100.0", "    // YOUR CODE HERE\n    unimplemented!();", " \
    \ if (a + b > c) && (a + c > b) && (b + c > a) {\n    let p = (a + b + c) as f64\
    \ / 2.0;\n    let area = (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt();\n\
    \    area.trunc() * 100.0 / 100.0\n  } else {\n    -1.0\n  }", "    let sum =\
    \ a + b + c;\n    if sum > 2 * std::cmp::max(a, std::cmp::max(b, c)) && a > 0\
    \ && b > 0 && c > 0 {\n        (a * b * c) as f64 / 4.0 * (sum as f64 / 2.0).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut v = vec![a, b, c];\n    v.sort();\n\
    \    let v = v;\n    if v[0] + v[1] <= v[2] { return -1.0; }\n    let p = (v[0]\
    \ + v[1] + v[2]) as f64;\n    (p * (p - v[0] as f64) * (p - v[1] as f64) * (p\
    \ - v[2] as f64)).sqrt() / 4.0", "    let tri_sides = [a, b, c];\n    let mut\
    \ tri_sides_sorted = tri_sides.clone();\n    tri_sides_sorted.sort();\n    let\
    \ (a, b, c) = (tri_sides_sorted[0], tri_sides_sorted[1], tri_sides_sorted[2]);\n\
    \    if a + b > c {\n        let p = (a + b + c) as f64 / 2.0;\n        let area\
    \ = ((p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt() * 100.0).round()\
    \ / 100.0;\n        area\n    } else {\n        -1.0\n    }", "    if a <= 0 ||\
    \ b <= 0 || c <= 0 {\n        return -1.0;\n    }\n    let sides = [a, b, c];\n\
    \    let mut sides = sides.iter().map(|&x| x as f64).collect::<Vec<f64>>();\n\
    \    sides.sort_by(|a, b| a.partial_cmp(b).unwrap());\n    if sides[0] + sides[1]\
    \ <= sides[2] {\n        return -1.0;\n    }\n    let s = (sides[0] + sides[1]\
    \ + sides[2]) / 2.0;\n    ((s * (s - sides[0]) * (s - sides[1]) * (s - sides[2]))).sqrt()",
  "    if !(a + b > c && a + c > b && b + c > a) { return -1.0 }\n    let p = (a +\
    \ b + c) as f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()",
  "    if a <= 0 || b <= 0 || c <= 0 {\n        return -1.0;\n    }\n\n    if a +\
    \ b <= c || a + c <= b || b + c <= a {\n        return -1.0;\n    }\n\n    let\
    \ s = (a + b + c) as f64 / 2.0;\n    ((s * (s - a as f64) * (s - b as f64) * (s\
    \ - c as f64)).sqrt() * 100.0).round() / 100.0", "    let vec = vec![a, b, c];\n\
    \    let (a, b, c) = (vec[0], vec[1], vec[2]);\n    if a + b > c && a + c > b\
    \ && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n        let area\
    \ = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n        area\n\
    \    } else {\n        -1.0\n    }", "    if a + b > c && a + c > b && b + c >\
    \ a {\n        let p = (a + b + c) as f64 / 2.0;\n        let area = p * (p -\
    \ a as f64) * (p - b as f64) * (p - c as f64);\n        ((area as f64).sqrt()\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    if a > 0\
    \ && b > 0 && c > 0 && a + b > c && a + c > b && b + c > a {\n        let half_perimeter\
    \ = (a + b + c) as f64 / 2.0;\n        let area = (half_perimeter * (half_perimeter\
    \ - a as f64) * (half_perimeter - b as f64) * (half_perimeter - c as f64)).sqrt();\n\
    \        area\n    } else {\n        -1.0\n    }", "    let a: f64 = a as f64;\n\
    \    let b: f64 = b as f64;\n    let c: f64 = c as f64;\n    if a + b > c && a\
    \ + c > b && b + c > a {\n        let p = (a + b + c) / 2.0;\n        (p * (p\
    \ - a) * (p - b) * (p - c)).sqrt()\n    } else {\n        -1.0\n    }", "    let\
    \ s = (a + b + c) as f64 / 2.0;\n    if a == 0 || b == 0 || c == 0 {\n       \
    \ return -1.0;\n    }\n    if s <= a as f64 || s <= b as f64 || s <= c as f64\
    \ {\n        return -1.0;\n    }\n    let a = s - a as f64;\n    let b = s - b\
    \ as f64;\n    let c = s - c as f64;\n    (s * a * b * c).sqrt()", "    let (a,\
    \ b, c) = sort_three_numbers(a, b, c);\n    if a + b > c {\n        let s = ((a\
    \ + b + c) as f64) / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s -\
    \ c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let mut area: f64\
    \ = -1.0;\n    let sides: [isize; 3] = [a, b, c];\n    sides.sort();\n    if sides[0]\
    \ + sides[1] > sides[2] {\n        let p: f64 = (a + b + c) as f64 / 2.0;\n  \
    \      area = p * (p - a as f64) * (p - b as f64) * (p - c as f64);\n        area\
    \ = area.sqrt();\n    }\n    area", '    unimplemented!();', "    if !valid_triangle(a,\
    \ b, c) { return -1f64 }\n    triangle_area_unchecked(a, b, c)", "    let sides\
    \ = vec![a, b, c];\n    if sides.iter().any(|x| *x <= 0) {\n        return -1.0;\n\
    \    }\n    let p = sides.iter().sum::<isize>() as f64 / 2.0;\n    ((p - a as\
    \ f64) * (p - b as f64) * (p - c as f64) * p).sqrt()", '    unimplemented!();',
  "    let s = a + b + c;\n    if s <= 0 {\n        return -1.0;\n    }\n    let p\
    \ = s as f64 / 2.0;\n    (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()",
  "    let mut v: Vec<isize> = vec![a, b, c];\n    v.sort();\n    if v[0] + v[1] >\
    \ v[2] {\n        let s = (v[0] + v[1] + v[2]) as f64 / 2.0;\n        (s * (s\
    \ - v[0] as f64) * (s - v[1] as f64) * (s - v[2] as f64)).sqrt()\n    } else {\n\
    \        -1.0\n    }", "    let sides = [a, b, c];\n    if sides.iter().any(|x|\
    \ *x <= 0) {\n        return -1.0;\n    }\n    sides.iter().fold(0, |s, x| s +\
    \ x) - sides.iter().max().unwrap() > 0 && \n    sides.iter().fold(0, |s, x| s\
    \ + x) - sides.iter().min().unwrap() > sides.iter().max().unwrap() \n    && sides.iter().fold(0,\
    \ |s, x| s + x) - sides.iter().min().unwrap() > sides.iter().min().unwrap()\n\
    \    && sides.iter().fold(0, |s, x| s + x) - sides.iter().max().unwrap() > sides.iter().min().unwrap()\n\
    \    && sides.iter().fold(0, |s, x| s + x) - sides.iter().max().unwrap() > sides.iter().max().unwrap()\n\
    \    && sides.iter().fold(0, |s, x| s + x) - sides.iter().min().unwrap() > sides.iter().max().unwrap()\n\
    \    && sides.iter().fold(0, |s, x| s + x) - sides.iter().max().unwrap() > sides.iter().min().unwrap()\n\
    \    && sides.iter().fold(0, |s, x| s + x) - sides.iter().min().unwrap() > sides.iter().min().unwrap()\n\
    \    && sides.iter().fold(0, |s, x| s + x) - sides.iter().max().unwrap() > sides.iter().min().unwrap()\n\
    \    && sides.iter().fold(0, |s, x| s + x) - sides.iter().min().unwrap() > sides.iter().max().unwrap()\n\
    \    && sides.iter().fold(0, |s, x| s + x) - sides.iter().max().unwrap() > sides.iter().max().unwrap()\n\
    \    && sides.iter().fold(0, |s, x| s + x) - sides.iter().min().unwrap() > sides.iter().max().un",
  "    // TODO: Make the triangle\n    let mut sides = [a, b, c];\n    sides.sort();\n\
    \    let (a, b, c) = (sides[0], sides[1], sides[2]);\n    if a + b > c {\n   \
    \     let s = (a + b + c) as f64 / 2.0;\n        ((s * (s - a as f64) * (s - b\
    \ as f64) * (s - c as f64)).sqrt() * 100.0).round() / 100.0\n    } else {\n  \
    \      -1.0\n    }", "    let mut max = isize::max(a, isize::max(b, c));\n   \
    \ let mut s = Vec::new();\n    if a != max {\n        s.push(a);\n    }\n    if\
    \ b != max {\n        s.push(b);\n    }\n    if c != max {\n        s.push(c);\n\
    \    }\n    let sum = s.iter().sum::<isize>();\n    if sum <= max {\n        return\
    \ -1.0;\n    }\n    (a + b + c) as f64 / 2.0", "    if a <= 0 || b <= 0 || c <=\
    \ 0 {\n        return -1.0;\n    }\n    if a + b > c && a + c > b && b + c > a\
    \ {\n        let p = (a + b + c) as f64 / 2.0;\n        let mut ret = p * (p -\
    \ a as f64) * (p - b as f64) * (p - c as f64);\n        ret = ret.sqrt();\n  \
    \      ret.round() / 100.0\n    } else {\n        -1.0\n    }", "    // Your code\
    \ here\n    let mut sides: Vec<isize> = vec![a, b, c];\n    sides.sort();\n  \
    \  let c = sides[2];\n    let b = sides[1];\n    let a = sides[0];\n    if c -\
    \ a > b { -1.0 } else { 0.5 * (a as f64 * b as f64).sqrt() }", "    let mut sides\
    \ = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n\
    \        let s = (sides[0] + sides[1] + sides[2]) as f64 / 2.0;\n        ((s *\
    \ (s - sides[0] as f64) * (s - sides[1] as f64) * (s - sides[2] as f64)).sqrt()\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    if a + b\
    \ > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n\
    \        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    }\
    \ else {\n        -1.0\n    }", "    let s = (a + b + c) as f64 / 2.0;\n    let\
    \ area = (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt();\n    if\
    \ area == 0.0 { -1.0 } else { area.round() / 100.0 }", '    unimplemented!();',
  "    // Your code here\n    unimplemented!()", "    let (a, b, c) = (a as f64, b\
    \ as f64, c as f64);\n    if a + b > c && a + c > b && b + c > a {\n        ((a\
    \ + b + c) / 2.0 * (a + b + c) / 2.0 - a * a).sqrt() * ((a + b + c) / 2.0 - b)\
    \ * ((a + b + c) / 2.0 - c)\n    } else {\n        -1.00\n    }", "    if a +\
    \ b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64 / 2.0;\n\
    \        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n    }\
    \ else {\n        -1.0\n    }", "    let d = a+b+c;\n    if d <= 0 { return -1.0\
    \ };\n    let s = d as f64 / 2.0;\n    (s * (s-a as f64) * (s-b as f64) * (s-c\
    \ as f64)).sqrt()", "    let mut sides = vec![a, b, c];\n    sides.sort();\n \
    \   let [a, b, c] = sides;\n    if a + b <= c {\n        -1.\n    } else {\n \
    \       let p = (a + b + c) as f64 / 2.;\n        (p * (p - a as f64) * (p - b\
    \ as f64) * (p - c as f64)).sqrt()\n    }", "    let sides = [a, b, c];\n    let\
    \ max = *sides.iter().max().unwrap();\n    let sides = sides.iter().filter(|&&s|\
    \ s != max).collect::<Vec<_>>();\n    if max < sides.iter().sum::<isize>() {\n\
    \        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p -\
    \ b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "  \
    \  let sorted = [a, b, c].sort();\n    let [a, b, c] = sorted;\n    let p = (a\
    \ + b + c) as f64 / 2.0;\n    if p > a as f64 && p > b as f64 && p > c as f64\
    \ {\n        ((p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt() *\
    \ 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    let mut arr\
    \ = [a, b, c];\n    arr.sort();\n    if arr[0] + arr[1] > arr[2] {\n        let\
    \ p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as f64) * (p - b as f64)\
    \ * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n    }", "    let sides\
    \ = [a, b, c];\n    sides.iter().find(|&s| *s <= 0).map_or_else(\n        || {\n\
    \            let p = sides.iter().sum::<isize>() as f64 / 2.0;\n            (p\
    \ * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n        },\n   \
    \     |_| -1.0,\n    )", "    let (a, b, c) = (a as f64, b as f64, c as f64);\n\
    \    if a + b > c && a + c > b && b + c > a {\n        (a + b + c) / 2.0\n   \
    \ } else {\n        -1.0\n    }", "    if a+b <= c || a+c <= b || b+c <= a {\n\
    \        return -1.0;\n    }\n    (a as f64 + b as f64 + c as f64) / 2.0", " \
    \   let mut area: f64 = -1.0;\n    if a < 0 || b < 0 || c < 0 {\n        return\
    \ area;\n    }\n    if (a + b > c) && (a + c > b) && (b + c > a) {\n        let\
    \ half_perimeter = (a + b + c) as f64 / 2.0;\n        area = (half_perimeter *\
    \ (half_perimeter - a as f64) * (half_perimeter - b as f64) * (half_perimeter\
    \ - c as f64)).sqrt();\n    }\n    area", "    if (a + b > c) && (a + c > b) &&\
    \ (b + c > a) {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p -\
    \ a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "    let mut side = vec![a, b, c];\n    side.sort();\n    if side[0]\
    \ + side[1] > side[2] {\n        let p = (a + b + c) as f64 / 2.0;\n        (p\
    \ * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n \
    \       -1.0\n    }", "    if is_valid_triangle(a, b, c) {\n        let s = perimeter(a,\
    \ b, c) / 2;\n        (s * (s - a) * (s - b) * (s - c)).sqrt()\n    } else {\n\
    \        -1.00\n    }", "    if a + b <= c || a + c <= b || b + c <= a { -1.0\
    \ }\n    else { \n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p -\
    \ a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    }", "    if (a + b\
    \ > c) && (a + c > b) && (b + c > a) {\n        let s = (a + b + c) as f64 / 2.0;\n\
    \        return s.sqrt() * (s - a as f64) * (s - b as f64) * (s - c as f64);\n\
    \    }\n    -1.0", "    let mut x = [a, b, c];\n    x.sort();\n    if x[0] + x[1]\
    \ > x[2] {\n        let s = (x[0] + x[1] + x[2]) as f64 / 2.0;\n        s * (s\
    \ - x[0] as f64) * (s - x[1] as f64) * (s - x[2] as f64)\n    } else {\n     \
    \   -1.0\n    }.sqrt()", "    let mut area: f64 = -1.0;\n    if (a+b) > c && (a+c)\
    \ > b && (b+c) > a {\n        let p = (a+b+c) as f64 / 2.0;\n        area = (p*(p-a\
    \ as f64)*(p-b as f64)*(p-c as f64)).sqrt();\n    }\n    return area;", "    let\
    \ sorted = vec![a, b, c].iter().sorted().collect::<Vec<&isize>>();\n    if sorted[0]\
    \ + sorted[1] > *sorted[2] {\n        let p = (a + b + c) as f64;\n        ((p\
    \ / 2.0) * (p / 2.0 - a as f64) * (p / 2.0 - b as f64) * (p / 2.0 - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut sides = vec![a, b, c];\n   \
    \ sides.sort();\n    if sides[0] + sides[1] > sides[2] {\n        0.5 * (sides[0]\
    \ * sides[2] + sides[1] * sides[2]) as f64\n    } else {\n        -1.0\n    }",
  '    unimplemented!()', "    let mut arr = [a, b, c];\n    arr.sort();\n    if arr[0]\
    \ + arr[1] <= arr[2] { -1f64 } else {\n        let p = (a + b + c) as f64 / 2f64;\n\
    \        (p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    }",
  "    if a + b > c && a + c > b && b + c > a {\n        let s = (a + b + c) as f64\
    \ / 2.0;\n        (s * (s - a as f64) * (s - b as f64) * (s - c as f64)).sqrt()\n\
    \    } else {\n        -1.0\n    }", "    let mut v = vec![a, b, c];\n    v.sort();\n\
    \    let (a, b, c) = (v[0], v[1], v[2]);\n    if a + b > c {\n        (a as f64\
    \ + b as f64) * (c as f64 - a as f64 - b as f64) * (c as f64 - a as f64 - b as\
    \ f64) * 3.0_f64.sqrt() / 4.0\n    } else {\n        -1.0\n    }", "    let mut\
    \ v: Vec<isize> = vec![a, b, c];\n    v.sort();\n    let a = v[0] as f64;\n  \
    \  let b = v[1] as f64;\n    let c = v[2] as f64;\n    let s = (a + b + c) / 2.0;\n\
    \    if s <= a || s <= b || s <= c {\n        return -1.0;\n    }\n    ((s - a)\
    \ * (s - b) * (s - c) * s).sqrt()", "    let mut sides = vec![a, b, c];\n    sides.sort();\n\
    \    if sides[0] + sides[1] > sides[2] {\n        let s = 0.5 * (sides[0] + sides[1]\
    \ + sides[2]);\n        let area = (s * (s - sides[0]) * (s - sides[1]) * (s -\
    \ sides[2])).sqrt();\n        return area.round() / 100.0;\n    }\n    -1.0",
  "    // TODO: implement\n    1.0", '    unimplemented!();', "    let mut v = vec![a,\
    \ b, c];\n    v.sort();\n    if v[0] + v[1] > v[2] {\n        ((v[0] + v[1] +\
    \ v[2]) as f64 / 2.0).sqrt() *\n        (v[2] as f64 / 2.0).sqrt() *\n       \
    \ (v[2] as f64 / 2.0).sqrt()\n    } else {\n        -1.00\n    }", "    let mut\
    \ area: f64 = -1.0;\n    let a = a as f64;\n    let b = b as f64;\n    let c =\
    \ c as f64;\n    let p = (a + b + c) / 2.0;\n    if p - a > 0.0 && p - b > 0.0\
    \ && p - c > 0.0 {\n        area = (p * (p - a) * (p - b) * (p - c)).sqrt();\n\
    \    }\n    return area;", "    let valid_triangle = (a + b > c) && (a + c > b)\
    \ && (b + c > a);\n    if valid_triangle {\n        let p = (a + b + c) as f64\
    \ / 2.0;\n        ((p * (p - a as f64) * (p - b as f64) * (p - c as f64)).sqrt()\
    \ * 100.0).round() / 100.0\n    } else {\n        -1.0\n    }", "    let a = a\
    \ as f64;\n    let b = b as f64;\n    let c = c as f64;\n    if a + b > c && a\
    \ + c > b && b + c > a {\n        let s = (a + b + c) / 2.0;\n        (s * (s\
    \ - a) * (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n    }", "    let\
    \ mut sides = vec![a, b, c];\n    sides.sort();\n    if sides[0] + sides[1] >\
    \ sides[2] {\n        let p = (a + b + c) as f64 / 2.0;\n        (p * (p - a as\
    \ f64) * (p - b as f64) * (p - c as f64)).sqrt()\n    } else {\n        -1.0\n\
    \    }", "  let mut sides = [a, b, c];\n  sides.sort();\n  if sides[0] + sides[1]\
    \ > sides[2] {\n    let p = (a + b + c) as f64 / 2.0;\n    (p * (p - a as f64)\
    \ * (p - b as f64) * (p - c as f64)).sqrt()\n  } else {\n    -1.0\n  }", "  let\
    \ v: [isize; 3] = [a, b, c];\n  v.iter().min().unwrap() + v.iter().max().unwrap()\
    \ > *v.iter().min().unwrap() && \n  v.iter().min().unwrap() + v.iter().max().unwrap()\
    \ > *v.iter().max().unwrap() && \n  v.iter().min().unwrap() + *v.iter().max().unwrap()\
    \ > v.iter().min().unwrap()\n    {((v.iter().min().unwrap() + v.iter().max().unwrap())\
    \ as f64)/2.0f64.sqrt()} else {-1.0f64}", "  // \n  if (a + b > c) && (a + c >\
    \ b) && (b + c > a) {\n    let p = (a + b + c) as f64 / 2.0;\n    let s = p *\
    \ (p - a as f64) * (p - b as f64) * (p - c as f64);\n    return s.sqrt();\n  }\
    \ else {\n    return -1.0;\n  }", "    let f_a = a as f64;\n    let f_b = b as\
    \ f64;\n    let f_c = c as f64;\n    if f_a < 0.0 || f_b < 0.0 || f_c < 0.0 {\n\
    \        return -1.0;\n    }\n    if f_a + f_b <= f_c || f_a + f_c <= f_b || f_b\
    \ + f_c <= f_a {\n        return -1.0;\n    }\n    (f_a + f_b + f_c) / 2.0", " \
    \   let (a, b, c) = (a as f64, b as f64, c as f64);\n    if a + b > c && a + c\
    \ > b && b + c > a {\n        let s = (a + b + c) / 2.0;\n        (s * (s - a)\
    \ * (s - b) * (s - c)).sqrt()\n    } else {\n        -1.0\n    }", "    let len\
    \ = vec![a, b, c];\n    let mut len = len.into_iter().collect::<Vec<isize>>();\n\
    \    len.sort();\n    if len[0] + len[1] <= len[2] {\n        return -1.0;\n \
    \   }\n    let s = (len[0] + len[1] + len[2]) as f64 / 2.0;\n    let x = s * (s\
    \ - len[0] as f64) * (s - len[1] as f64) * (s - len[2] as f64);\n    (x.sqrt()\
    \ * 100.0).round() / 100.0", "    if (a + b > c) && (a + c > b) && (b + c > a)\
    \ {\n        let s = (a + b + c) as f64 / 2.0;\n        let x = s * (s - a as\
    \ f64) * (s - b as f64) * (s - c as f64);\n        return x.sqrt();\n    } else\
    \ {\n        return -1.0;\n    }", "    if a + b > c && a + c > b && b + c > a\
    \ {\n        let s = (a + b + c) as f64 / 2.0;\n        (s * (s - a as f64) *\
    \ (s - b as f64) * (s - c as f64)).sqrt()\n    } else {\n        -1.0\n    }",
  "    let sides = vec![a, b, c];\n    let max = sides.iter().max().unwrap();\n  \
    \  if sides.iter().filter(|&x| x >= max).count() > 1 {\n        return -1.0;\n\
    \    }\n\n    let other_sides: Vec<isize> = sides.iter().filter(|&x| x != max).collect();\n\
    \    let a = other_sides[0] as f64;\n    let b = other_sides[1] as f64;\n    let\
    \ c = max as f64;\n    let s = (a + b + c) / 2.0;\n    (s * (s - a) * (s - b)\
    \ * (s - c)).sqrt()", "    match (a, b, c) {\n        (x, y, z) if x + y > z &&\
    \ x + z > y && y + z > x => ((x + y + z) as f64 / 2.0).sqrt() * (x as f64 / 2.0).sqrt()\
    \ * (y as f64 / 2.0).sqrt() * (z as f64 / 2.0).sqrt(),\n        _ => -1.0\n  \
    \  }"]
stop_tokens:
- "\n}"
