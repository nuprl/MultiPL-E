name: HumanEval_8_sum_product
language: rust
results:
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp5cer7nqy.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n\n    let mut sum = 0;\n    let mut product = 1;\n\n    for number in numbers\
    \ {\n        sum += number;\n        product *= number;\n    }\n\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ number in numbers {\n        product *= number;\n        sum += number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product()\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n    for n in\
    \ numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // YOUR CODE HERE\n    (0, 0)\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp7fnqfd21.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, n| acc + n);\n\
    \    let product = numbers.iter().fold(1, |acc, n| acc * n);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpmck82u28.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpdquqxh1y.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let zero = (0, 1);\n    if numbers.len() == 0 {\n \
    \       return zero;\n    }\n    numbers.iter().fold(zero, |tuple, num| {\n  \
    \      (tuple.0 + num, tuple.1 * num)\n    })\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpppgwjkm6.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut total_sum = 0;\n    let mut total_product =\
    \ 1;\n    for number in numbers {\n        total_sum += number;\n        total_product\
    \ *= number;\n    }\n    (total_sum, total_product)\n}\n\nfn main() {\n    let\
    \ candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0,\
    \ 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut s = 0;\n    let mut p = 1;\n    for i in numbers\
    \ {\n        s += i;\n        p *= i;\n    }\n    (s, p)\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpkc9r7j61.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product()\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut prod = 1;\n    let mut sum = 0;\n    for i\
    \ in numbers {\n        prod *= i;\n        sum += i;\n    }\n    (sum, prod)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpbj84c670.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut s = 0;\n    let mut p = 1;\n    for i in numbers\
    \ {\n        s += i;\n        p *= i;\n    }\n    (s, p)\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut the_sum = 0;\n    let mut the_product = 1;\n\
    \    for number in numbers {\n        the_sum += number;\n        the_product\
    \ *= number;\n    }\n    (the_sum, the_product)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpww7b293t.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpuj6b_9ib.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(),\n     numbers.iter().fold(1,\
    \ |p, &n| p * n))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |a, b| a + b), numbers.iter().fold(1,\
    \ |a, b| a * b))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |acc, item| acc + item), numbers.iter().fold(1,\
    \ |acc, item| acc * item))\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut s: isize = 0;\n    let mut p: isize = 1;\n\
    \    for n in numbers {\n        s += n;\n        p *= n;\n    }\n    (s, p)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmp1v_7_l4g.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let product = numbers.iter().fold(1, |product, &num|\
    \ product * num);\n    let sum = numbers.iter().fold(0, |sum, &num| sum + num);\n\
    \    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n    let product\
    \ = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |a, b| a + b);\n \
    \   let product = numbers.iter().fold(1, |a, b| a * b);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, x| sum + x);\n\
    \    let product = numbers.iter().fold(1, |prod, x| prod * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpbauryyi1.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // Sum\n    let sum: isize = numbers.iter().sum();\n\
    \    // Product\n    let product: isize = numbers.iter().product();\n    // Return\
    \ tuple\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for number in numbers\
    \ {\n        sum += number;\n        product *= number;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // should be implemented\n    unimplemented!()\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp8qb8bchy.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, x| sum + x);\n\
    \    let product = numbers.iter().fold(1, |product, x| product * x);\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpgcc0nw3l.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpncztvc03.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpq8g2hndz.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |acc, &x| acc + x), numbers.iter().fold(1,\
    \ |acc, &x| acc * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n  \
    \  assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in &numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO: implement sum_product\n    (0, 1)\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmprahqxxfb.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, x| sum + x);\n\
    \    let product = numbers.iter().fold(1, |product, x| product * x);\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // YOUR CODE HERE!\n    let mut product = 1;\n    let\
    \ mut sum = 0;\n    for i in numbers {\n        product *= i;\n        sum +=\
    \ i;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpyrygfw2o.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product()\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpe9fowq8h.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let product = numbers.iter().fold(1, |acc, &x| acc\
    \ * x);\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ x in numbers {\n        sum += x;\n        product *= x;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (sum(numbers), product(numbers))\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum` in this scope\n --> /tmp/tmp3g27hmfe.rs:8:6\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |      ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `product` in this scope\n --> /tmp/tmp3g27hmfe.rs:8:20\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |                    ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (sum(numbers), product(numbers))\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum` in this scope\n --> /tmp/tmpznaovrt6.rs:8:6\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |      ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `product` in this scope\n --> /tmp/tmpznaovrt6.rs:8:20\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |                    ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (sum(numbers), product(numbers))\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum` in this scope\n --> /tmp/tmpv5mpipmw.rs:8:6\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |      ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `product` in this scope\n --> /tmp/tmpv5mpipmw.rs:8:20\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |                    ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO\n    (0, 1)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpra4tduwf.rs:15:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ x in numbers {\n        sum += x;\n        product *= x;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut res = (0, 1);\n    for i in numbers {\n   \
    \     res.0 += i;\n        res.1 *= i;\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ number in numbers {\n        product *= number;\n        sum += number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmp1fb6eo54.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7wah31e7.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp7odkwb1h.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ x in numbers {\n        sum += x;\n        product *= x;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, &x| (acc.0 + x, acc.1\
    \ * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, num| acc + num);\n\
    \    let product = numbers.iter().fold(1, |acc, num| acc * num);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpqsfrxgrm.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, num| (acc.0 + num,\
    \ acc.1 * num))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // your code here\n    let mut sum = 0;\n    let mut\
    \ product = 1;\n    for i in numbers {\n        sum += i;\n        product *=\
    \ i;\n    }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpg09k313v.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (sum(numbers), product(numbers))\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum` in this scope\n --> /tmp/tmpcm4_v67e.rs:8:6\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |      ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `product` in this scope\n --> /tmp/tmpcm4_v67e.rs:8:20\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |                    ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!();\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpswx2pyft.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    return numbers.iter().fold((0, 1), |acc, x| (acc.0\
    \ + x, acc.1 * x));\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut res = (0, 1);\n    for i in numbers {\n   \
    \     res.0 += i;\n        res.1 *= i;\n    }\n    res\n}\n\nfn main() {\n   \
    \ let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, val| sum + val);\n\
    \    let product = numbers.iter().fold(1, |prod, val| prod * val);\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (sum(numbers), product(numbers))\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "error[E0425]: cannot find function `sum` in this scope\n --> /tmp/tmphhdyadco.rs:8:6\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |      ^^^ not found in this\
    \ scope\n\nerror[E0425]: cannot find function `product` in this scope\n --> /tmp/tmphhdyadco.rs:8:20\n\
    \  |\n8 |     (sum(numbers), product(numbers))\n  |                    ^^^^^^^\
    \ not found in this scope\n\nerror: aborting due to 2 previous errors\n\nFor more\
    \ information about this error, try `rustc --explain E0425`.\n"
  exit_code: 1
  status: SyntaxError
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product()\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp3l4rxo_7.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |acc, val| (acc.0 + val,\
    \ acc.1 * val))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ i in &numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    return (numbers.iter().sum(), numbers.iter().product());\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp4dyf4yyw.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product(),\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let sum = numbers.iter().fold(0, |acc, &item| acc + item);\n    let\
    \ product = numbers.iter().fold(1, |acc, &item| acc * item);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, prod), x| (sum +\
    \ x, prod * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpd9zqcam3.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |acc, num| acc +\
    \ num),\n        numbers.iter().fold(1, |acc, num| acc * num),\n    )\n}\n\nfn\
    \ main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut res = (0, 1);\n    for num in numbers {\n \
    \       res.0 += num;\n        res.1 *= num;\n    }\n    res\n}\n\nfn main() {\n\
    \    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |a, &b| a + b);\n\
    \    let product = numbers.iter().fold(1, |a, &b| a * b);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().sum(),\n        numbers.iter().product()\n\
    \    )\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    numbers.iter().fold((0, 1), |(sum, product), &x| (sum\
    \ + x, product * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n   \
    \ assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, number| sum\
    \ + number);\n    let product = numbers.iter().fold(1, |product, number| product\
    \ * number);\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut acc = (0, 1);\n    for n in numbers {\n   \
    \     acc.0 += n;\n        acc.1 *= n;\n    }\n    acc\n}\n\nfn main() {\n   \
    \ let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO\n    unimplemented!()\n}\n\nfn main() {\n \
    \   let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpaz9dpzl1.rs:9:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, &x| sum + x);\n\
    \    let product = numbers.iter().fold(1, |product, &x| product * x);\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmpyfq8wnk6.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ x in numbers {\n        sum += x;\n        product *= x;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ n in numbers {\n        sum += n;\n        product *= n;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (\n        numbers.iter().fold(0, |sum, i| sum + i),\n\
    \        numbers.iter().fold(1, |product, i| product * i),\n    )\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let product = numbers.iter().fold(1, |acc, x| acc *\
    \ x);\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let sum = numbers.iter().fold(0, |sum, x| sum + x);\n    let product\
    \ = numbers.iter().fold(1, |product, x| product * x);\n    (sum, product)\n}\n\
    \nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().fold(0, |sum, &x| sum + x),\n     numbers.iter().fold(1,\
    \ |prod, &x| prod * x))\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    // TODO\n    (0, 0)\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 0)`,\n right: `(0, 1)`', /tmp/tmp409qgxsf.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut result = (0, 1);\n    for n in numbers {\n\
    \        result.0 += n;\n        result.1 *= n;\n    }\n    result\n}\n\nfn main()\
    \ {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    unimplemented!()\n}\n\nfn main() {\n    let candidate\
    \ = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n  \
    \  assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'not implemented', /tmp/tmp6z287x92.rs:8:5\n\
    note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    if numbers.is_empty() {\n        return (0, 1);\n \
    \   }\n    let mut sum = 0;\n    let mut product = 1;\n    for &x in numbers.iter()\
    \ {\n        sum += x;\n        product *= x;\n    }\n    (sum, product)\n}\n\n\
    fn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let (mut sum, mut product) = (0, 1);\n    for i in\
    \ numbers {\n        sum += i;\n        product *= i;\n    }\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpld1xc5nc.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ number in numbers {\n        sum += number;\n        product *= number;\n  \
    \  }\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut sum = 0;\n    let mut product = 1;\n    for\
    \ num in numbers {\n        sum += num;\n        product *= num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (0, 1)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: "thread 'main' panicked at 'assertion failed: `(left == right)`\n  left:\
    \ `(0, 1)`,\n right: `(3, 1)`', /tmp/tmpz93uhgxl.rs:14:5\nnote: run with `RUST_BACKTRACE=1`\
    \ environment variable to display a backtrace\n"
  exit_code: 101
  status: Exception
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, &x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, &x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, i| acc + i);\n\
    \    let product = numbers.iter().fold(1, |acc, i| acc * i);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let mut product = 1;\n    let mut sum = 0;\n    for\
    \ num in numbers {\n        product *= num;\n        sum += num;\n    }\n    (sum,\
    \ product)\n}\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |sum, value| sum +\
    \ value);\n    let product = numbers.iter().fold(1, |product, value| product *\
    \ value);\n    (sum, product)\n}\n\nfn main() {\n    let candidate = sum_product;\n\
    \    assert_eq!(candidate(Vec::<isize>::new()), (0, 1));\n    assert_eq!(candidate(vec![1,\
    \ 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100, 0]), (100, 0));\n    assert_eq!(candidate(vec![3,\
    \ 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]), (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    (numbers.iter().sum(), numbers.iter().product())\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
- program: "/// For a given list of integers, return a tuple consisting of a sum and\
    \ a product of all the integers in a list.\n/// Empty sum should be equal to 0\
    \ and empty product should be equal to 1.\n/// >>> sum_product([])\n/// (0, 1)\n\
    /// >>> sum_product([1, 2, 3, 4])\n/// (10, 24)\nfn sum_product(numbers: Vec<isize>)\
    \ -> (isize, isize) {\n    let sum = numbers.iter().fold(0, |acc, x| acc + x);\n\
    \    let product = numbers.iter().fold(1, |acc, x| acc * x);\n    (sum, product)\n\
    }\n\nfn main() {\n    let candidate = sum_product;\n    assert_eq!(candidate(Vec::<isize>::new()),\
    \ (0, 1));\n    assert_eq!(candidate(vec![1, 1, 1]), (3, 1));\n    assert_eq!(candidate(vec![100,\
    \ 0]), (100, 0));\n    assert_eq!(candidate(vec![3, 5, 7]), (15, 105));\n    assert_eq!(candidate(vec![10]),\
    \ (10, 10));\n}\n"
  stdout: ''
  stderr: ''
  exit_code: 0
  status: OK
