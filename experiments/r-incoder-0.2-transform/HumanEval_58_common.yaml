name: HumanEval_58_common
language: r
prompt: "# Return sorted unique common elements for two lists.\n# >>> common(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n# list(1, 5, 653)\n# >>> common(c(5,\
  \ 3, 2, 8), c(3, 2))\n# list(2, 3)\ncommon <- function(l1, l2) {"
tests: "test_humaneval <- function() {\ncandidate <- common\n    if(!identical(candidate(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), list(1, 5, 653))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(5, 3, 2, 8), c(3, 2)), list(2, 3))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 8), c(3, 2, 4)), list(2, 3, 4))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 8), c()), list())){quit('no', 1)}\n\
  }\ntest_humaneval()"
completions: ["\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 !=\
    \ u1]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,list,unique |>\n<code>\n\
    > x <- list(c(1,4,3,34,653,2,5), c(5,7,1,5,9,653,121))\n> y <- list(c(5,3,2,8),\
    \ c(3,2))\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n\
    > \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n \
    \ u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to avoid the double `unique` calls. Maybe `u1\
    \ <- unique(c(l1, l2)); u2 <- unique(c(l2, l1)); u1[u1 == u2]`?\n<|/ c |>\n<|\
    \ c |>\nYes, that would work. I'll add it to the answer.\n<|/ c |>\n<| c |>\n\
    I added a version that avoids double `unique` calls.\n<|/ c |>\n<| a tags=r,unique,list\
    \ |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have multiple common elements. For example,\
    \ `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1,\
    \ 5, 653)` instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I fixed the code by adding `u1[u1 == u2]` at the end. Now it works\
    \ as expected.\n<|/ c |>\n<| a |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\ndt <- data.table(a = c(1,4,3,34,653,2,5), b = c(5,7,1,5,9,653,121))\n\
    dt[, setdiff(unique(c(a,b)), unique(c(b,a))), by = a]\n</code>\n<|/ a tags=r,list,unique\
    \ dscore=2 |>\n<| a dscore=2 |>\nHere's a base R solution:\n<code>\na <- c(1,4,3,34,653,2,5)\n\
    b <- c(5,7,1,5,9,653,121)\na <- unique(a)\nb <- unique(b)\na[!a %in% b]\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\nHere's a solution using\
    \ dplyr and purrr.\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\na <- c(1,4,3,34,653,2,5)\n\
    b <- c(5,7,1,5,9,653,121)\n\na %>% \n  unique() %>% \n  setdiff(b) %>% \n  unique()\
    \ %>% \n  setdiff(a)\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,list,unique |>\n\
    Here's a base R solution:\n<code>\na <- c(1,4,3,34,653,2,5)\nb <- c(5,7,1,5,9,653,121)\n\
    \na <- unique(a)\nb <- unique(b)\n\na[!a %in% b]\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=r,list,unique |>\nHere's a base R solution:\n<code>\na <- c(1,4,3,34,653,2,5)\n\
    b <- c(5,7,1,5,9,653,121)\n\na <- unique(a)\nb <- unique(b)\n\na[", "\n  u1 <-\
    \ sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)),\
    \ decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,sorting |>\n<|\
    \ c |>\nThis doesn't work if you have duplicates in either list.\n<|/ c |>\n<|\
    \ c |>\nYes, it does. I added a note at the bottom of the answer.\n<|/ c |>\n\
    <| c |>\nI added a note at the bottom of the answer. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n> x <- c(1,4,3,34,653,2,5)\n> y <-\
    \ c(5,7,1,5,9,653,121)\n> sort(unique(c(x,y)))\n[1] 1 5 653\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't work if you have duplicates in either list.\n<|/ c\
    \ |>\n<| c |>\nYes, it does. I added a note at the bottom of the answer.\n<|/\
    \ c |>\n<| a |>\n<code>\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\n\
    sort(unique(c(x,y)))\n[1] 1 5 653\n</code>\n<|/ a tags=r,sorting dscore=2 |>\n\
    <| a dscore=1 |>\n<code>\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\n\
    sort(unique(c(x,y)))\n[1] 1 5 653\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\n\
    This doesn't work if you have duplicates in either list.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\nsort(unique(c(x,y)))\n\
    [1] 1 5 653\n</code>\n<|/ a tags=r,sorting |>\n<| a |>\n<code>\nx <- c(1,4,3,34,653,2,5)\n\
    y <- c(5,7,1,5,9,653,121)\nsort(unique(c(x,y)))\n[1] 1 5 653\n</code>\n<|/ a dscore=1\
    \ tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\nx <- c(1,4,3,34,653,2,5)\n\
    y <- c(5,7,1,5,9,653,121)", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if there\
    \ are duplicates in either list. For example: `common(c(1,2,3), c(1,2,3))` returns\
    \ `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nYes, I realized that after I posted it. I added\
    \ a fix to my answer.\n<|/ c |>\n<| c |>\nI added a fix to my answer. Thanks for\
    \ pointing that out.\n<|/ c |>\n<| c |>\nI added a fix to my answer. Thanks for\
    \ pointing that out.\n<|/ c |>\n<| c |>\nI added a fix to my answer. Thanks for\
    \ pointing that out.\n<|/ c |>\n<| a dscore=4 |>\nA simple solution that doesn't\
    \ require any packages:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis doesn't work if there are duplicates in either list. For example:\
    \ `common(c(1,2,3), c(1,2,3))` returns `[1] 1 2 3`.\n<|/ c |>\n<| a tags=r |>\n\
    Here's a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1=c(1,2,3),\
    \ l2=c(1,2,3)))\nsetDT(list(l1=c(1,2,3), l2=c(1,2,3)))\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2,3))), l1, l2)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3))), l2, l1)\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in either list. For example: `setDT(list(l1=c(1,2,3), l2=c(1,2,3)))` returns\
    \ `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nI added a fix to my answer. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| a dscore=3 |>\nA solution using dplyr and purrr packages:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ncommon <- function(l1, l2) {\n  l1 %>%\
    \ \n    map(unique) ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nI like this\
    \ solution, but I believe it can be improved. For example, `common(c(1,2,3), c(1,2,3))`\
    \ returns `[1]  1  2  3` instead of `[1]  1  2  3`. I think it can be fixed by\
    \ replacing `u1[u1 == u2]` with `u1[!duplicated(u1)]`.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing that out. I fixed the code accordingly.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\nA simple and efficient solution is to use setdiff:\n<code>\nsetdiff(c(1,2,3),\
    \ c(1,2,3))", "\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks for the answer.\
    \ I'm still trying to understand how this works. I understand that `common` returns\
    \ all common elements, but how does it know which elements to return? It seems\
    \ like it just returns all common elements. How does it know which elements to\
    \ return?\n<|/ c |>\n<| c |>\nIt just returns all common elements. I added a little\
    \ explanation to the answer.\n<|/ c |>\n<| c |>\nThanks for the explanation. I'm\
    \ still trying to understand how this works. I understand that `common` returns\
    \ all common elements, but how does it know which elements to return? It seems\
    \ like it just returns all common elements. How does it know which elements to\
    \ return?\n<|/ c |>\n<| c |>\nIt just returns all common elements. I added a little\
    \ explanation to the answer.\n<|/ c |>\n<| c |>\nThanks for the explanation. I'm\
    \ still trying to understand how this works. I understand that `common` returns\
    \ all common elements, but how does it know which elements to return? It seems\
    \ like it just returns all common elements. How does it know which elements to\
    \ return?\n<|/ c |>\n<| a dscore=1 |>\nHere is a simple solution that uses setdiff\
    \ and intersect to find the common elements and then removes them from the original\
    \ vectors.\n<code>\ncommon <- function(l1, l2) {\n  setdiff(sort(unique(c(l1,\
    \ l2))), sort(unique(c(l2, l1))))\n}\n\ncommon(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work\
    \ if you have two lists with different lengths.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting it.\n<|/ c |>\n<| c |>\nIt doesn't work if you have\
    \ two lists with different lengths. Try `common(c(1,2,3), c(1,2,3,4,5))`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. I tested it before posting it. The OP didn't specify\
    \ that lists had different lengths. I added a note to my answer.\n<|/ c |>\n<|\
    \ c |>\nYes, it does. I tested it before posting it. The OP didn't specify that\
    \ lists had different lengths. I added a note to my answer.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a solution that doesn't require any packages:\n<code>\ncommon <-\
    \ function(l1, l2) {\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2,\
    \ l1)))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work\
    \ if you have two lists with different lengths.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting it.\n<|/ c |>\n<| c |>\nYes, it does. I tested it\
    \ before posting it. The OP didn't specify that lists had different lengths. I\
    \ added a note to my answer.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1 = c(1,2,3), l2 = c(1,2,3,4,5)))\n\
    setDT(list(l1 = c(1,2,3), l2 = c(1,2,3,4,5,6)))\n\nsetkey(setDT(list(l1 = c(1,2,3),\
    \ l2 = c(1,2,3,4,5,6))), l1, l2)\nsetkey(setDT(list(l1 = c(1,2,3), l2 = c(1,2,3,4,5,6))),\
    \ l2, l1)\n\nsetkey(setDT(list(l1 = c(1,2,3), l2 = c(1,2,3,4,5,6))), l1, l2)\n\
    setkey(setDT(list(l1 = c(1,2,3), l2 = c(", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n \
    \ u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c |>\n\
    <| c |>\nYes, it does. I added a test case to my answer.\n<|/ c |>\n<| c |>\n\
    I added a test case to my answer. Your solution doesn't work if there are repeated\
    \ elements in the lists.\n<|/ c |>\n<| c |>\nI added a test case to my answer.\
    \ Your solution doesn't work if there are repeated elements in the lists.\n<|/\
    \ c |>\n<| c |>\nI added a test case to my answer. Your solution doesn't work\
    \ if there are repeated elements in the lists.\n<|/ c |>\n<| a tags=r |>\n<code>\n\
    library(dplyr)\nlibrary(purrr)\n\ncommon_elements <- function(...) {\n  args <-\
    \ list(...)\n  map(args, ~sort(unique(c(...))))\n}\n\ncommon_elements(c(1, 4,\
    \ 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ you have repeated values in either of the lists.\n<|/ c |>\n<| c |>\nIt does\
    \ work if you use the `unique` function on both lists. I've edited my answer to\
    \ show this.\n<|/ c |>\n<| c |>\nThis doesn't work if you have repeated values\
    \ in either of the lists.\n<|/ c |>\n<| c |>\nIt does work if you use the `unique`\
    \ function on both lists. I've edited my answer to show this.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if you have repeated values in either of the lists.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\nsetDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5,\
    \ 9, 653, 121)))\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1,\
    \ 5, 9, 653, 121))), l1, l2)\nunique(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5),\
    \ l2=c(5, 7, 1, 5, 9, 653, 121))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ doesn't work if you have repeated values in either of the lists.\n<|/ c |>\n\
    <| c |>\nIt does work if you use the `unique` function on both lists. I've edited\
    \ my answer to show this.\n<|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution\
    \ using base R:\n<code>\nl1 <- c(1, 4, 3, 34, 653, 2, 5)\nl2 <- c(5, 7, 1, 5,\
    \ 9, 653, 121)\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n \
    \ u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if you\
    \ have two lists with different lengths.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works with different lengths.\n<|/ c |>\n<| a tags=r |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1=c(1,4,3,34,653,2,5),\
    \ l2=c(5,7,1,5,9,653,121)))\nsetkey(setDT(list(l2=c(5,7,1,5,9,653,121))), l2)\n\
    setkey(setDT(list(l1=c(1,4,3,34,653,2,5))), l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5),\
    \ l2=c(5,7,1,5,9,653,121))), l2)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))),\
    \ l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))), l2)\n\
    setkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))), l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5),\
    \ l2=c(5,7,1,5,9,653,121))), l2)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))),\
    \ l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))), l2)\n\
    setkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))), l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5),\
    \ l2=c(5,7,1,5,9,653,121))), l2)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))),\
    \ l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), ", "\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work if there\
    \ are duplicates in the lists.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting.\n<|/ c |>\n<| c |>\nIt doesn't work if there are duplicates in the\
    \ lists.\n<|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists.\
    \ Try it yourself.\n<|/ c |>\n<| c |>\nI tested it before posting. It doesn't\
    \ work if there are duplicates in the lists.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n\
    library(dplyr)\nlibrary(purrr)\n\nlist1 <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n\
    list2 <- list(c(4,5,6), c(7,8,9), c(1,2,3))\n\nlist1 %>% \n  map(setNames(list2,\
    \ names(list1))) %>% \n  reduce(inner_join, by = \"name\") %>% \n  select(-name)\n\
    \n[[1]]\n[[1]]$`1`\n[1] 1 2 3\n\n[[1]]$`2`\n[1] 4 5 6\n\n[[1]]$`3`\n[1] 7 8 9\n\
    \n[[2]]\n[[2]]$`4`\n[1] 4 5 6\n\n[[2]]$`5`\n[1] 7 8 9\n\n[[3]]\n[[3]]$`7`\n[1]\
    \ 1 2 3\n\n[[3]]$`8`\n[1] 4 5 6\n\n[[3]]$`9`\n[1] 7 8 9\n</code>\n<|/ a tags=r\
    \ |>\n<| a dscore=2 |>\nHere's a solution using base R:\n<code>\nlist1 <- list(c(1,2,3),\
    \ c(4,5,6), c(7,8,9))\nlist2 <- list(c(4,5,6), c(7,8,9), c(1,2,3))\n\nlist1 <-\
    \ lapply(list1, function(x) setNames(list2, names(list1)))\nlist1 <- lapply(list1,\
    \ function(x) Reduce(function(x, y) merge(x, y, all = TRUE), x))\nlist1 <- lapply(list1,\
    \ function(x) x[!is.na(x$V1), ])\nlist1 <- lapply(list1, function(x) x[!is.na(x$V2), ",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like your use of setdiff and setdiff to find the\
    \ common elements. I wonder if there is a way to do this without using setdiff?\n\
    <|/ c |>\n<| c |>\nI guess you could use `intersect` but that would give you the\
    \ common elements. I guess you could use `setdiff` but that would give you the\
    \ elements that are in one but not the other. Not sure how you want the output\
    \ to look.\n<|/ c |>\n<| c |>\nI want the output to look like `list(1, 5, 653)`\n\
    <|/ c |>\n<| c |>\nI guess I misunderstood your question. Do you want the output\
    \ to be a list with all the common elements?\n<|/ c |>\n<| c |>\nYes, that is\
    \ correct. I want the output to be a list with all the common elements.\n<|/ c\
    \ |>\n<| a |>\n<code>\ncommonElements <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\ncommonElements <- function(l1, l2) {\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/\
    \ a tags=r |>\n<| a dscore=1 |>\n<code>\ncommonElements <- function(l1, l2) {\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nPlease add some explanation to your answer such that\
    \ others can learn from it\n<|/ c |>\n<| a dscore=1 |>\n<code>\ncommonElements\
    \ <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=0 |>\n<code>\ncommonElements\
    \ <- function(l1, l2) {\n  u1 <- unique(c(l1, ", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nI added a version that works with repeated elements.\n<|/ c\
    \ |>\n<| a tags=r,list,unique |>\nHere's a solution using base R:\n<code>", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThanks for your answer! I tested it and\
    \ it works fine. However I noticed that my original question was a bit unclear.\
    \ I've edited it now. Sorry for that!\n<|/ c |>\n<| c |>\nI edited my answer to\
    \ include a solution that should work for your new question.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer! I tested it and it works fine. However I noticed that\
    \ my original question was a bit unclear. I've edited it now. Sorry for that!\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a solution that should work for\
    \ your new question.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nlibrary(data.table)\n\
    library(magrittr)\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,list,subset |>\n<code>\n\
    > x <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n> y <- list(c(1,2,3), c(4,5,6), c(7,8,9),\
    \ c(10,11,12))\n> z <- list(c(1,2,3), c(4,5,6), c(7,8,9), c(10,11,12), c(13,14,15))\n\
    > \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a function\
    \ that does this in R:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ncommon_elements\
    \ <- function(x, y) {\n  x <- as.character(x)\n  y <- as.character(y)\n  x <-\
    \ x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n\
    \  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in%\
    \ x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y\
    \ %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y\
    \ <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in%\
    \ y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x\
    \ %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x\
    \ <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in%\
    \ x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y\
    \ %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y\
    \ <- y[!y %in% ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2\
    \ != u1]\n}\n", "\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <-\
    \ sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n", "\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/\
    \ a tags=r |>\n<| c |>\nI like your use of setdiff to find the unique common elements.\
    \ I wonder if there is a way to do this without setdiff. Maybe with some sort\
    \ of merge?\n<|/ c |>\n<| c |>\nI added a solution without `setdiff`.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  i <- 0\n \
    \ j <- 1\n  res <- list()\n  while((i < length(l1) && j < length(l2)) && (l1[i]\
    \ == l2[j])) {\n    res[[i]] <- l1[i]\n    i <- i + 1\n    j <- j + 1\n  }\n \
    \ if(i < length(l1)) {\n    while(j < length(l2)) {\n      res[[i]] <- l2[j]\n\
    \      i <- i + 1\n      j <- j + 1\n    }\n  }\n  if(j < length(l2)) {\n    while(i\
    \ < length(l1)) {\n      res[[i]] <- l1[j]\n      i <- i + 1\n      j <- j + 1\n\
    \    }\n  }\n  return(res)\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't\
    \ work if there are duplicates in the lists.\n<|/ c |>\n<| c |>\nIt does work\
    \ if there are duplicates in the lists. Try it yourself.\n<|/ c |>\n<| c |>\n\
    It doesn't work if there are duplicates in the lists. Try it yourself.\n<|/ c\
    \ |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| a dscore=3 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l2=c(5,\
    \ 7, 1, 5, 9, 653, 121))), l2)\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5))),\
    \ l1)\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653,\
    \ 121))), l1, l2)\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7,\
    \ 1, 5, 9, 653, 121))), l1, l2, l1)\n</code>\n<|/ a tags=r,list,unique |>\n<|\
    \ c |>\nThis doesn't work if there are duplicates in the lists.\n<|/ c |>\n<|\
    \ c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution using base R:\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\n<code>", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't seem to work if you have two lists with different\
    \ lengths.\n<|/ c |>\n<| c |>\nYes, it does. Try it out with `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n<|/ c |>\n<| c |>\nI see what\
    \ you mean. My bad. Thanks for pointing that out.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work\
    \ if there are repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt works with\
    \ repeated elements. Try `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))`\n<|/ c |>\n<| c |>\nI see what you mean. Yes, it works with repeated\
    \ elements. But it doesn't work with repeated elements in the same list as well.\n\
    <|/ c |>\n<| c |>\nYes, it works with repeated elements in the same list as well.\n\
    <|/ c |>\n<| c |>\nI see what you mean. Yes, it works with repeated elements.\
    \ But it doesn't work with repeated elements in the same list as well.\n<|/ c\
    \ |>\n<| a tags=r,list,unique |>\nThis should work:\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis doesn't work if there are repeated elements in\
    \ the lists.\n<|/ c |>\n<| a dscore=2 |>\n<code>\ncommon<-function(l1,l2){\n \
    \ u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if there are repeated elements\
    \ in the lists.\n<|/ c |>\n<| a dscore=2 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| c |>\nThis ", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| c |>\nThanks for your answer. Your solution is very similar to mine, except\
    \ that yours does not preserve the order of the elements. I prefer my solution\
    \ as it preserves the order of the elements. I guess your solution also has some\
    \ advantages over mine.\n<|/ c |>\n<| c |>\nI added a solution that preserves\
    \ the order of the elements. I guess yours is more efficient than mine.\n<|/ c\
    \ |>\n<| c |>\nI added a solution that preserves the order of the elements. I\
    \ guess yours is more efficient than mine.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1 = c(1,\
    \ 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\nunique(unlist(.SD))",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n\
    \  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 |>\nHere is a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(df)[, list(common = sort(unique(unlist(.SD))), .SDcols = c(\"A\", \"B\"\
    )) ]\n</code>\nResult:\n<code>\n   A  B  common\n1: 1 10      1\n2: 2 20     \
    \ 2\n3: 3 30      3\n4: 4 40      4\n5: 5 50      5\n6: 6 60      6\n7: 7 70 \
    \     7\n8: 8 80      8\n9: 9 90      9\n</code>\n<|/ a tags=r,dataframe |>\n\
    <| a tags=r,dataframe |>\nA base R solution:\n<code>\ndf <- data.frame(A=c(1,4,3,34,653,2),\n\
    \                 B=c(5,7,1,5,9,653,121))\n\ndf$common <- apply(df[,2:3], 1, function(x)\
    \ sort(unique(x)))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nUsing dplyr\
    \ and purrr you could do:\n<code>\ndf %>%\n mutate(common = map(.x = .[,2:3],\
    \ .f = function(x) sort(unique(x))))\n</code>\nWhich gives:\n<code>\n  A  B common\n\
    1 1 10      1\n2 4 20      2\n3 3 30      3\n4 6 40      4\n5 7 50      5\n6 9\
    \ 60      6\n7 1 70      7\n8 5 80      8\n9 9 90      9\n</code>\n<|/ a tags=r,dataframe\
    \ |>\n<| a tags=r,dataframe |>\nHere is a base R solution:\n<code>\ndf$common\
    \ <- apply(df[,2:3], 1, function(x) sort(unique(x)))\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=r,dataframe |>\n<code>\ndf <- data.frame(A=c(1,4,3,34,653,2),\n\
    \                 B=c(5,7,1,5,9,653,121))\n\ndf$common <- apply(df[,2:3], 1, function(x)\
    \ sort(unique(x)))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nWe can use tidyverse\n\
    <code>\nlibrary(dplyr)\nlibrary(", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer.\
    \ Your code works well for small lists, but for larger lists it takes too long\
    \ to compute. Do you know a faster way to compute this?\n<|/ c |>\n<| c |>\nI\
    \ added a faster version. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ Your code works well for small lists, but for larger lists it takes too long\
    \ to compute. Do you know a faster way to compute this?\n<|/ c |>\n<| c |>\nI\
    \ added a faster version. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ Your code works well for small lists, but for larger lists it takes too long\
    \ to compute. Do you know a faster way to compute this?\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere is a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(x = c(1,4,3,34,653,2,5), y = c(5,7,1,5,9,653,121))\ndt[, list(z =\
    \ x[y == min(y)])]\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThanks for\
    \ your answer. Your code works well for small lists, but for larger lists it takes\
    \ too long to compute. Do you know a faster way to compute this?\n<|/ c |>\n<|\
    \ c |>\nI added a faster version. Hope it helps.\n<|/ c |>\n<| a dscore=1 |>\n\
    Here is a solution using dplyr and purrr:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\n\ndf <- data.frame(x, y)\n\
    \ndf %>% \n  mutate(z = map2_dbl(x, y, ~.x[.y == min(.y)]))\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThanks for your answer. Your code works well for small lists, but\
    \ for larger lists it takes too long to compute. Do you know a faster way to compute\
    \ this?\n<|/ c |>\n<| a tags=r,list,unique |>\nHere is a solution using base R:\n\
    <code>\nx <- c(1,4,3,34,653,2,5)\ny ", "\n  u1 <- sort(unique(c(l1, l2)), decreasing\
    \ = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r |>\n<| a dscore=1 |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    library(stringr)\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u2 %in% u1]\n}\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  common1 <- intersect(l1,\
    \ l2)\n  common2 <- intersect(l2, l1)\n  common1 <- common1[!common1 %in% common2]\n\
    \  common2 <- common2[!common2 %in% common1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to make it more efficient. My actual data set\
    \ is about 10 million rows and I run this on a laptop with 4 GB of RAM and it\
    \ takes about 15 minutes to run. Do you know if there is a way to speed it up?\n\
    <|/ c |>\n<| c |>\nI added a more efficient solution that uses `data.table` instead\
    \ of `data.frame`.\n<|/ c |>\n<| c |>\nI ran your new code on my laptop with 4\
    \ GB of RAM and it took about 15 minutes to run. Do you know if there is a way\
    \ to speed it up?\n<|/ c |>\n<| c |>\nI added a more efficient solution that uses\
    \ `data.table` instead of `data.frame`.\n<|/ c |>\n<| c |>\nI ran your new code\
    \ on my laptop with 4 GB of RAM and it took about 15 minutes to run. Do you know\
    \ if there is a way to speed it up?\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\ndf[, common := Reduce(intersect,\
    \ lapply(.SD, unique)), by = .(id, date)]\n</code>\n<|/ a tags=r,dataframe,list\
    \ |>\n<| c |>\nI ran your new code on my laptop with 4 GB of RAM and it took about\
    \ 15 minutes to run. Do you know if there is a way to speed it up?\n<|/ c |>\n\
    <| c |>\nI added a more efficient solution that uses `data.table` instead of `data.frame`.\n\
    <|/ c |>\n<| a tags=r,dataframe,list |>\nHere's a solution using dplyr and purrr:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf %>%\n  group_by(id, date) %>%\n \
    \ summarise(common = map(.x, unique)) %>%\n  unnest(common)\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI ran your new code on my laptop with 4 GB of RAM and it took about\
    \ 15 minutes to run. Do you know if there is a way to speed it up?\n<|/ c |>\n\
    <| c |>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if\
    \ you have two lists with different lengths.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works with lists with different lengths.\n<|/ c |>\n<| a dscore=5 |>\n\
    I like using Reduce for these types of problems:\n<code>\nReduce(intersect, list1,\
    \ list2)\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nI like this solution\
    \ as it also works with lists with different lengths.\n<|/ c |>\n<| c |>\nThis\
    \ should be the accepted answer. `Reduce` is designed for these types of problems.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `Reduce` is designed for\
    \ these types of problems.\n<|/ c |>\n<| c |>\nI like this solution as it also\
    \ works with lists with different lengths.\n<|/ c |>\n<| c |>\nThis should be\
    \ the accepted answer. `Reduce` is designed for these types of problems.\n<|/\
    \ c |>\n<| a dscore=5 |>\n<code>\n> x <- list(c(\"a\", \"b\", \"c\"), c(\"a\"\
    , \"b\", \"d\"), c(\"a\", \"b\", \"e\"))\n> y <- list(c(\"a\", \"b\", \"c\"),\
    \ c(\"a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))\n> z <- list(c(\"a\", \"b\"\
    , \"c\"), c(\"a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))\n> x <- unique(x)\n\
    > y <- unique(y)\n> z <- unique(z)\n> x\n[[1]]\n[1] \"a\" \"b\" \"c\"\n\n[[2]]\n\
    [1] \"a\" \"b\" \"d\"\n\n[[3]]\n[1] \"a\" \"b\" \"e\"\n\n> y\n[[1]]\n[1] \"a\"\
    \ \"b\" \"c\"\n\n[[2]]\n[1] \"a\" \"b\" \"d\"\n\n[[3]]\n[1] \"a\" \"b\" \"e\"\n\
    \n> z\n[[1]]\n[1] \"a\" \"b\" \"c\"\n\n[[2]]\n[1] \"a\" \"b\" \"d\"\n\n[[3]]\n\
    [1] \"a\" \"b\" \"e\"\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't\
    \ work if you have two lists with different lengths.\n<|/ c |>\n<|", "\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you have a list with\
    \ duplicates, e.g. `c(1, 4, 3, 34, 653, 2, 5)` and `c(5, 7, 1, 5, 9, 653, 121)`\n\
    <|/ c |>\n<| c |>\n, good point. I added a solution that should handle that case.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n> x <- c(1, 4, 3, 34, 653, 2, 5)\n> y <- c(5,\
    \ 7, 1, 5, 9, 653, 121)\n> x <- sort(x)\n> y <- sort(y)\n> x\n[1] 1 2 3 4 5 6\
    \ 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\
    \ 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59\
    \ 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85\
    \ 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108\
    \ 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127\
    \ 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146\
    \ 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165\
    \ 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184\
    \ 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 ", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem to work if you have a\
    \ list with two identical elements. `common(c(1,2,2,3), c(1,2,2,3))` returns `[1]\
    \ 1 2 3` instead of `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nI added a fix for that case\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution using base R:\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a dscore=2 |>\n<code>\nlibrary(data.table)\nsetDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\n</code>\nThis\
    \ gives you a data.table with two columns: l1 and l2. You can then use unique.\n\
    <code>\nunique(data.table(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9,\
    \ 653, 121)))\n</code>\n<|/ a tags=r,list,unique |>\n<| a dscore=2 |>\n<code>\n\
    > x <- list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> x <- unique(x)\n> y <-\
    \ unique(y)\n> x\n[[1]]\n[1] 1 4 3 34 653 2 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n\
    </code>\n<|/ a tags=r,list,unique |>\n<| a dscore=1 |>\n<code>\n> x <- list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(c(1, 4, 3, 34,\
    \ 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> x <- unique(x)\n> y <- unique(y)\n\
    > x\n[[1]]\n[1] 1 4 3 34 653 2 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| a dscore=1 |>\n<code>\nx <- list(c(1, 4, 3, 34,\
    \ 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\ny <- list(c(1, 4, 3, 34, 653, 2, 5),\
    \ c(5, 7, 1, 5, 9, 653, 121))\nx <- unique(x)\ny <- unique(y)\nx\n[[1]]\n[1] 1\
    \ 4 3 34 653 2 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a tags=r,list,unique |>\n<code>\nx <- list(c(1, 4, 3, 34, 653, 2, 5),\
    \ c(5, 7, 1, 5, 9, 653, 121))\ny <- list(c(1, 4, 3, ", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis doesn't seem to work if the lists are of different lengths.\n<|/ c\
    \ |>\n<| c |>\nIt does work, try it out. `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<| c |>\nAh, I\
    \ see what you mean. Yes, it does work, but only if the lists are the same length.\
    \ Try it with `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121, 3))`\n\
    <|/ c |>\n<| c |>\nYes, I see what you mean. Yes, it does work, but only if the\
    \ lists are the same length. Try it with `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121, 3))`\n<|/ c |>\n<| c |>\nI see what you mean. Yes, it\
    \ does work, but only if the lists are the same length. Try it with `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121, 3))`\n<|/ c |>\n<| a |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1 = c(1,\
    \ 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l2\
    \ = c(5, 7, 1, 5, 9, 653, 121))), l2)\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653,\
    \ 2, 5))), l1)\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7,\
    \ 1, 5, 9, 653, 121))), l1, l2)\n</code>\nThis gives:\n<code>\n   l1 l2\n1:  1\
    \  5\n2:  4  7\n3:  3  1\n4: 34  5\n5: 653 653\n6:  2  9\n7:  5 121\n</code>\n\
    <|/ a tags=r,list dscore=2 |>\n<| a dscore=2 |>\nHere's a solution using base\
    \ R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2\
    \ %in% u1]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis solution works well for\
    \ small lists, but for large lists, it becomes very slow. For example, `common(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,24",
  "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2, l1)))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a tags=r,list,merge |>\n<| c |>\nThis doesn't work if there\
    \ are duplicates in either list.\n<|/ c |>\n<| c |>\nIt does work if there are\
    \ duplicates in either list. Try it yourself.\n<|/ c |>\n<| c |>\nIt does work\
    \ if there are duplicates in either list. Try it yourself. `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/\
    \ c |>\n<| c |>\nIt does work if there are duplicates in either list. Try it yourself.\
    \ `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1,\
    \ 5, 653)`\n<|/ c |>\n<| c |>\nIt does work if there are duplicates in either\
    \ list. Try it yourself. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<| a dscore=5 |>\nThe data.table\
    \ package has some nice functions for this:\n<code>\nlibrary(data.table)\ndt1\
    \ <- data.table(a = c(1,2,3), b = c(4,5,6))\ndt2 <- data.table(a = c(4,5,6), b\
    \ = c(7,8,9))\ndt1[dt2, on = \"a\"]\n</code>\n<|/ a tags=r,list,merge |>\n<| c\
    \ |>\nThis should be the accepted answer. data.table is very efficient and easy\
    \ to use.\n<|/ c |>\n<| c |>\nI agree. data.table is very efficient and easy to\
    \ use.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. data.table is very\
    \ efficient and easy to use.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ data.table is very efficient and easy to use.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. data.table is very efficient and easy to use.\n<|/ c\
    \ |>\n<| a tags=r,list,merge |>\nA simple base R solution:\n<code>\n> x <- list(c(1,4,3,34,653,2),\
    \ c(5,7,1,5,9,653,121))\n> y <- list(c(5,3,2,8), c(3,", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  l1 <- unique(l1)\n  l2 <- unique(l2)\n  l1[l1 == l2] <- NA\n\
    \  return(l1)\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,sorting |>\n<code>",
  "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the lists. For example, `common(c(1,2,3), c(1,2,3))` returns `[1] 1 2`, which\
    \ is not the correct answer.\n<|/ c |>\n<| c |>\nI added a fix for that case.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for `common(c(1,2,3), c(1,2,3))` which returns\
    \ `[1] 1 2`\n<|/ c |>\n<| c |>\nI added a fix for that case.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(a = c(1,2,3), b = c(1,2,3))\ndt[, setdiff(unique(c(a, b)), c(a, b)),\
    \ by = a]$V1", "\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <-\
    \ sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work if there are duplicates in either list.\n<|/\
    \ c |>\n<| c |>\nIt does work if there are duplicates in either list. Try it out\
    \ and see.\n<|/ c |>\n<| c |>\nIt doesn't work if there are duplicates in either\
    \ list. Try it out and see.\n<|/ c |>\n<| c |>\nIt does work if there are duplicates\
    \ in either list. Try it out and see.\n<|/ c |>\n<| c |>\nIt does work if there\
    \ are duplicates in either list. Try it out and see.\n<|/ c |>\n<| a tags=r |>\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(stringr)\n", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  i <- 1\n  result <- list()\n  while(i <= length(l1) && i\
    \ <= length(l2)) {\n    if(l1[i] == l2[i]) {\n      result[i] <- l1[i]\n     \
    \ i <- i + 1\n    } else {\n      if(l1[i] > l2[i]) {\n        i <- i + 1\n  \
    \    } else {\n        i <- i + 1\n      }\n    }\n  }\n  return(result)\n}\n",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to do this without having to create a temporary variable `u1`?\n<|/\
    \ c |>\n<| c |>\nI guess you could do `u1 <- unique(c(l1, l2)); u2 <- unique(c(l2,\
    \ l1)); u1[u1 == u2]`\n<|/ c |>\n<| c |>\nYes, that works. I guess I was just\
    \ hoping there was a way to do it without having to create a temporary variable.\
    \ Thanks!\n<|/ c |>\n<| a tags=r,list,unique |>\nI came up with this solution:\n\
    <code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to do this without having to create a temporary\
    \ variable `u1`?\n<|/ c |>\n<| c |>\nI guess you could do `u1 <- unique(c(l1,\
    \ l2)); u2 <- unique(c(l2, l1)); u1[u1 == u2]`\n<|/ c |>\n<| c |>\nYes, that works.\
    \ I guess I was just hoping there was a way to do it without having to create\
    \ a temporary variable. Thanks!\n<|/ c |>\n<| a dscore=3 |>\nI came up with this\
    \ solution:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without having to create a temporary variable `u1`?\n<|/ c |>\n<| c |>\nI guess\
    \ you could do `u1 <- unique(c(l1, l2)); u2 <- unique(c(l2, l1)); u1[u1 == u2]`\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nI came up with this solution:\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, ", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  common1 <- intersect(l1, l2)\n  common2 <- intersect(l2,\
    \ l1)\n  common1 <- common1[!common1 %in% common2]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n\
    \  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n\
    \  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[", "\n  l1\
    \ <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  l1[duplicated(l1) | duplicated(l2,\
    \ fromLast = TRUE)] <- NA\n  l2[duplicated(l2) | duplicated(l1, fromLast = TRUE)]\
    \ <- NA\n  l1[!is.na(l1)] <- l2[!is.na(l2)]\n  l2[!is.na(l2)] <- l1[!is.na(l1)]\n\
    \  return(l1)\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting,list |>\nA solution\
    \ using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't\
    \ seem to work if there are repeated elements in the list. For example, `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\
    \ instead of `list(1, 5, 653, 653)`.\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out. I fixed the code so that it works with repeated elements.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a tags=r,list,unique |>\nA simple and fast solution is to use setdiff\
    \ and union:\n<code>\nsetdiff(union(l1, l2), union(l2, l1))\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis should be the accepted answer. Much faster than the other\
    \ solutions.\n<|/ c |>\n<| c |>\nThis is actually the fastest solution. `setdiff`\
    \ takes O(n) time while `union` takes O(n^2). `setdiff` takes O(n) time because\
    \ `setdiff` only needs to compare the two lists once, while `union` needs to compare\
    \ each element of both lists twice. `union` takes O(n^2) because `union` needs\
    \ to compare each element of both lists twice. `setdiff` takes O(n) time because\
    \ `setdiff` only needs to compare the two lists once, while `union` needs to compare\
    \ each element of both lists twice.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. Much faster than the other solutions.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. Much faster than the other solutions.\n<|/ c |>\n<|\
    \ c |>\nThis should be the accepted answer. Much faster than the other solutions.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\n<code>\n> unique(c(l1,l2))\n[1] 1 2 3 4\
    \ 5 6 7 8 9\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if l1 and\
    \ l2 have different lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if l1 and l2\
    \ have different lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if l1 and l2 have\
    \ different lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if l1 and l2 have different\
    \ lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if l1 and l2 have different lengths.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\nl1 <- list(1, 2, 3, 4, 5)\nl2 <- list(1, 2,\
    \ 3, 4, 5)\nl", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem\
    \ to work when there are duplicates in either of the lists.\n<|/ c |>\n<| c |>\n\
    It does work. Try `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n\
    <|/ c |>\n<| c |>\nI see. Thanks for your help.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>\n> x <- list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n>\
    \ y <- list(c(5, 3, 2, 8), c(3, 2))\n> \n> x <- unlist(x)\n> y <- unlist(y)\n\
    > \n> x <- sort(x)\n> y <- sort(y)\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- unique(x)\n\
    > y <- unique(y)\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n\
    > x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to make it more efficient by not sorting the lists first?\n\
    <|/ c |>\n<| c |>\n: I doubt that sorting is going to be the bottleneck here,\
    \ but I added a version that doesn't sort the lists first. Maybe it's faster,\
    \ but I don't know.\n<|/ c |>\n<| c |>\n: I added a version that doesn't sort\
    \ the lists first. Maybe it's faster, but I don't know.\n<|/ c |>\n<| c |>\n:\
    \ I added a version that doesn't sort the lists first. Maybe it's faster, but\
    \ I don't know.\n<|/ c |>\n<| c |>\n: I added a version that doesn't sort the\
    \ lists first. Maybe it's faster, but I don't know.\n<|/ c |>\n<| a tags=r,list\
    \ |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n\
    <| c |>\nThis doesn't seem to work if you have a list with duplicates. For example,\
    \ `common(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1] 1 2 3`\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. I fixed the code by adding `unique`\
    \ to the `common` function.\n<|/ c |>\n<| a tags=r,list |>\nI wrote a function\
    \ that does this for you:\n<code>\ncommon2 <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis doesn't seem to work if you have a list with duplicates. For\
    \ example, `common2(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1]\
    \ 1 2 3`\n<|/ c |>\n<| c |>\nThis doesn't seem to work if you have a list with\
    \ duplicates. For example, `common2(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3`\
    \ instead of `[1] 1 2 3`\n<|/ c |>\n<| c |>\nThis doesn't seem to work if you\
    \ have a list with duplicates. For example, `common2(c(1,2,2,3), c(1,2,3))` returns\
    \ `[1] 1 2 3` instead of `[1] 1 2 3`\n<|/ c |>\n<| a tags=r,list |>\nI wrote a\
    \ function that does this for you:\n<code>\ncommon2 <- function(l1, l2) {\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't seem to work if you have a list with\
    \ duplicates. For example, `common2(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3`\
    \ instead of `[1] 1 2 3`\n<|/ c |>\n<| a |>\nI wrote a function that does this\
    \ for you:\n<code>\ncommon2 <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u", "\n  u1 <- sort(unique(c(l1, l2)),\
    \ decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to avoid the sorting step. I wonder if there\
    \ is a way to do this without sorting the lists.\n<|/ c |>\n<| c |>\nI added a\
    \ solution without sorting the lists.\n<|/ c |>\n<| c |>\nI added a solution without\
    \ sorting the lists.\n<|/ c |>\n<| a tags=r,sorting |>\nHere's a solution without\
    \ sorting the lists:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,sorting |>\nHere's\
    \ a solution without sorting the lists:\n<code>\ncommon <- function(l1, l2) {\n\
    \  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a tags=r,sorting |>\nHere is a solution without sorting the lists:\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,sorting |>\n\
    Here's a solution without sorting the lists:\n<code>\ncommon <- function(l1, l2)\
    \ {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nHere's a solution without sorting\
    \ the lists:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,sorting |>\n\
    <| a dscore=2 |>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n \
    \ u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't seem to work\
    \ if there are repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt does. Try\
    \ it with `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n<|/\
    \ c |>\n<| c |>\nAh, I see what you mean. Yes, this works. I misunderstood your\
    \ question at first. Thanks!\n<|/ c |>\n<| c |>\nThis doesn't work if there are\
    \ repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt does. Try it with `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n<|/ c |>\n<| a dscore=5\
    \ |>\nA simple solution:\n<code>\nintersect(list1, list2)\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nIt does. Try it with `intersect(list1, list2)`\n<|/ c |>\n\
    <| c |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c\
    \ |>\n<| c |>\nIt does. Try it with `intersect(list1, list2)`\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c |>\n\
    <| a tags=r |>\n<code>\n> intersect(list1, list2)\n[1] 1 5 653\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nThis doesn't work if there are repeated elements in the\
    \ lists.\n<|/ c |>\n<| c |>\nIt does. Try it with `intersect(list1, list2)`\n\
    <|/ c |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nIt does. Try it with `intersect(list1, list2)`\n<|/ c |>\n\
    <| a tags=r |>\n<code>\n> intersect(list1, list2)\n[1] 1 5 653\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nThis doesn't ", "\n  u1 <- unique(c(l1, l2))\n  u2 <-\
    \ unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks\
    \ for your answer. I've tried your solution and it works perfectly for my case.\
    \ I've also added my own solution to the question for future reference.\n<|/ c\
    \ |>\n<| a tags=r |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThanks for your answer! I tested your function and I got this error\
    \ `Error in unique(c(l1, l2)) : invalid 'length' argument`\n<|/ c |>\n<| c |>\n\
    I tested it again and it worked for me. Maybe you have a different version of\
    \ R? What does `unique(c(l1, l2))` return?\n<|/ c |>\n<| c |>\nI tested it again\
    \ and it worked for me. Maybe you have a different version of R? What does `unique(c(l1,\
    \ l2))` return?\n<|/ c |>\n<| c |>\nI tested it again and it worked for me. Maybe\
    \ you have a different version of R? What does `unique(c(l1, l2))` return?\n<|/\
    \ c |>\n<| c |>\nI tested it again and it worked for me. Maybe you have a different\
    \ version of R? What does `unique(c(l1, l2))` return?\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\nHere is a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have repeated values in either list.\n\
    <|/ c |>\n<| c |>\nI added a version that works with repeated values.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have repeated values in either list.\n<|/ c\
    \ |>\n<| c |>\nI added a version that works with repeated values.\n<|/ c |>\n\
    <| a dscore=4 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt1 <- data.table(a = c(1,4,3,34,653,2), b = c(5,7,1,5,9,653,121))\ndt2 <- data.table(a\
    \ = c(5,3,2,8), b = c(3,2,1))\n\ndt1[dt2, on = \"a\"]\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have repeated values in either list.\n\
    <|/ c |>\n<| c |>\nI added a version that works with repeated values.\n<|/ c |>\n\
    <| a dscore=4 |>\nHere's a solution using base R:\n<code>\n> x <- c(1,4,3,34,653,2)\n\
    > y <- c(5,7,1,5,9,653,121)\n> x <- unique(x)\n> y <- unique(y)\n> x\n[1] 1 4\
    \ 3 34 653 2\n> y\n[1] 5 7 1 5 9 653 121\n> x <- x[x %in% y]\n> x\n[1] 1 5 653\n\
    </code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you have repeated\
    \ values in either list.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ repeated values.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution using dplyr\
    \ and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\nx <- c(1,4,3,34,653,2)\n\
    y <- c(5,7,1,5,9,653,121)\n\nx <- unique(x)\ny <- unique(y)\n\nx %>% \n  map(~.x[.x\
    \ %in% y]) %>% \n  reduce(`+`)\n</code>\n<|/ a tags=r,list,unique |>\n<| a |>\n\
    Here's a solution ", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1,\
    \ l2))\n  u[order(u, decreasing = TRUE)]\n}\n</code>\n<|/ a tags=r,sorting |>\n\
    <| a |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt\
    \ <- data.table(x = c(1,4,3,34,653,2,5), y = c(5,7,1,5,9,653,121))\ndt[, list(z\
    \ = x[which.min(y)]), by = y]\n</code>\n<|/ a tags=r,sorting dscore=1 |>\n<| a\
    \ tags=r,sorting |>\nHere's a solution using dplyr and tidyr:\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\n\ndf <- data.frame(x = c(1,4,3,34,653,2,5), y = c(5,7,1,5,9,653,121))\n\
    \ndf %>%\n  group_by(y) %>%\n  mutate(z = min(x)) %>%\n  ungroup() %>%\n  select(-y)\
    \ %>%\n  arrange(z)\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nHere's a solution\
    \ using base R:\n<code>\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\n\
    xy <- data.frame(x,y)\nxy$z <- apply(xy, 1, function(x) min(x[order(x)]))\nxy\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(x = c(1,4,3,34,653,2,5),\
    \ y = c(5,7,1,5,9,653,121))\ndt[, list(z = x[which.min(y)]), by = y]\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=r,sorting |>\nHere's a solution using dplyr and tidyr:\n\
    <code>\nlibrary(dplyr)\nlibrary(tidyr)\n\ndf <- data.frame(x = c(1,4,3,34,653,2,5),\
    \ y = c(5,7,1,5,9,653,121))\n\ndf %>%\n  group_by(y) %>%\n  mutate(z = min(x))\
    \ %>%\n  ungroup() %>%\n  select(-y) %>%\n  arrange(z)\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=r,sorting |>\nHere's a solution using data.table:\n<code>\nlibrary(data.",
  "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2, l1)))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem to\
    \ work if you have a list with duplicates. For example, `common(c(1,2,2,3), c(1,2,3))`\
    \ returns `[1] 1 2 3`, but `common(c(1,2,2,3), c(1,2,2,3))` returns `[1] 1 2 3`.\n\
    <|/ c |>\n<| c |>\nYes, I realized that after I posted my comment. I've edited\
    \ my answer to fix the problem.\n<|/ c |>\n<| c |>\nThis doesn't seem to work\
    \ if you have a list with duplicates. For example, `common(c(1,2,2,3), c(1,2,3))`\
    \ returns `[1] 1 2 3`, but `common(c(1,2,2,3), c(1,2,2,3))` returns `[1] 1 2 3`.\n\
    <|/ c |>\n<| c |>\nIt works fine for me. `common(c(1,2,2,3), c(1,2,3))` returns\
    \ `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nYes, it works fine for me. `common(c(1,2,2,3),\
    \ c(1,2,3))` returns `[1] 1 2 3`.\n<|/ c |>\n<| a tags=r,list,unique |>\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to avoid the double `unique`?\n<|/ c |>\n<| c |>\nI added a solution\
    \ without `unique`\n<|/ c |>\n<| a tags=r,list,unique |>\n<code>\n> x <- list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(c(5, 3, 2, 8),\
    \ c(3, 2))\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n",
  "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  common1 <- intersect(l1, l2)\n  common2\
    \ <- intersect(l2, l1)\n  common1 <- common1[!common1 %in% common2]\n  common1\
    \ <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2,\
    \ l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n\
    \  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n\
    \  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThanks for the answer.\
    \ I'm getting an error when I try to use this code: `Error in unique(c(l1, l2))\
    \ : \n  no non-missing arguments to min; returning -Inf`\n<|/ c |>\n<| c |>\n\
    I added a line to my answer to handle that case.\n<|/ c |>\n<| c |>\nThanks for\
    \ the answer. I'm getting an error when I try to use this code: `Error in unique(c(l1,\
    \ l2)) : \n  no non-missing arguments to min; returning -Inf`\n<|/ c |>\n<| c\
    \ |>\nI added a line to my answer to handle that case.\n<|/ c |>\n<| c |>\nThanks\
    \ for the answer. I'm getting an error when I try to use this code: `Error in\
    \ unique(c(l1, l2)) : \n  no non-missing arguments to min; returning -Inf`\n<|/\
    \ c |>\n<| a |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(list1 = c(1, 4, 3, 34, 653, 2, 5), list2 = c(5, 7, 1, 5, 9, 653,\
    \ 121))\ndt[, list1 := list1[list2]]\ndt[, list2 := list2[list1]]\ndt[, list1\
    \ := NULL]\ndt[, list2 := NULL]\ndt", "\n  u1 <- sort(unique(c(l1, l2)), decreasing\
    \ = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work if the two lists\
    \ have different lengths. For example, `common(c(1,2,3), c(1,2))` returns `[1]\
    \ 1 2` instead of `[1] 1 3`.\n<|/ c |>\n<| c |>\n: I fixed the bug. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| c |>\n: I added a faster version that doesn't\
    \ require sorting.\n<|/ c |>\n<| c |>\n: I added a version that doesn't require\
    \ sorting.\n<|/ c |>\n<| c |>\n: I added a version that doesn't require sorting.\n\
    <|/ c |>\n<| a |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(list(l1=c(1,2,3), l2=c(1,2)))\nsetkey(setDT(list(l2=c(1,2))), l2)\nsetkey(setDT(list(l1=c(1,2,3))),\
    \ l1)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2)\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2))), l1, l2, key=\"l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))),\
    \ l1, l2, key=\"l1\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2, key=\"\
    l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2, key=\"l1\")\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2))), l1, l2, key=\"l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))),\
    \ l1, l2, key=\"l1\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2, key=\"\
    l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2, key=\"l1\")\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2))), l1, l2, key=\"l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2, l1)))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThanks for your answer!\
    \ I tested your function and it works perfectly. However I noticed that when I\
    \ run it on a list of lists, it returns me a list with only one element. Do you\
    \ know why this happens?\n<|/ c |>\n<| c |>\nI tested it on a list with two elements\
    \ and it returned me a list with two elements. I tested it on a list with three\
    \ elements and it returned me a list with three elements. I tested it on a list\
    \ with four elements and it returned me a list with four elements. I tested it\
    \ on a list with five elements and it returned me a list with five elements. I\
    \ tested it on a list with six elements and it returned me a list with six elements.\
    \ I tested it on a list with seven elements and it returned me a list with seven\
    \ elements. I tested it on a list with eight elements and it returned me a list\
    \ with eight elements. I tested it on a list with nine elements and it returned\
    \ me a list with nine elements. I tested it on a list with ten elements and it\
    \ returned me a list with ten elements. I tested it on a list with eleven elements\
    \ and it returned me a list with eleven elements. I tested it on a list with twelve\
    \ elements and it returned me a list with twelve elements. I tested it on a list\
    \ with thirteen elements and it returned me a list with thirteen elements. I tested\
    \ it on a list with fourteen elements and it returned me a list with fourteen\
    \ elements. I tested it on a list with fifteen elements and it returned me a list\
    \ with fifteen elements.\n<|/ c |>\n<| c |>\nI tested it on a list with sixteen\
    \ elements and it returned me a list with sixteen elements. I tested it on a list\
    \ with thirty-one elements and it returned me a list with thirty-one elements.\
    \ I tested it on a list with thirty-two elements and it returned me a list with\
    \ thirty-two elements. I tested it on a list with thirty-three elements and it\
    \ returned me a list with thirty-three elements. I tested it on a list with thirty-four\
    \ elements and it returned me a list with thirty-four ", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThanks for your answer. I'm sorry I didn't mention this in my question,\
    \ but I do have another constraint in my problem: I cannot use any packages. I\
    \ must implement this using only base R.\n<|/ c |>\n<| c |>\n: I added a solution\
    \ using only base R.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm sorry I didn't\
    \ mention this in my question, but I do have another constraint in my problem:\
    \ I cannot use any packages. I must implement this using only base R.\n<|/ c |>\n\
    <| c |>\n: I added a solution using only base R.\n<|/ c |>\n<| a dscore=2 |>\n\
    Here's a solution using only base R:\n<code>\ncommon <- function(l1, l2) {\n \
    \ u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r |>\n<| a tags=r |>\nHere is a solution using only base R:\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere\
    \ is a solution using only base R:\n<code>\ncommon <- function(l1, l2) {\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r |>\n<| a tags=r |>\nHere is a solution using only base R:\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\nHere is\
    \ a solution using only base R:\n<code>\ncommon <- function(l1, l2) {\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != ", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks for your answer. Your solution works perfectly\
    \ for my example but when I try to use it on my real data set it gives me this\
    \ error `Error in sort.list(y) : 'x' must be atomic for 'sort.list'\nHave you\
    \ called 'sort' on a list?`\n<|/ c |>\n<| c |>\nI added a reproducible example\
    \ to my question. Maybe you can help me with that?\n<|/ c |>\n<| c |>\nI added\
    \ a reproducible example to my question. Maybe you can help me with that?\n<|/\
    \ c |>\n<| c |>\nI added a reproducible example to my question. Maybe you can\
    \ help me with that?\n<|/ c |>\n<| c |>\nI added a reproducible example to my\
    \ question. Maybe you can help me with that?\n<|/ c |>\n<| a dscore=1 |>\nHere\
    \ is a solution using data.table:\n<code>\nlibrary(data.table)", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis doesn't seem to work if there are repeated elements in the lists.\
    \ For example, `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\
    \ returns `list(1, 5, 653)`\n<|/ c |>\n<| c |>\nYes, I realized that after I posted\
    \ my comment. I've updated my answer to account for repeated elements.\n<|/ c\
    \ |>\n<| a tags=r |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\n\
    setkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))),\
    \ l1, l2)\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5,\
    \ 9, 653, 121))), l2, l1)\n</code>\nThe setkey function sorts the data.table by\
    \ l1 and l2 and then by l2, l1 so that the first two lines of the code above are\
    \ equivalent to:\n<code>\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2\
    \ = c(5, 7, 1, 5, 9, 653, 121))), l2, l1)\nsetkey(setDT(list(l1 = c(1, 4, 3, 34,\
    \ 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=r |>\nHere's a solution using dplyr and purrr packages:\n<code>\n\
    library(dplyr)\nlibrary(purrr)\n\nl1 <- c(1, 4, 3, 34, 653, 2, 5)\nl2 <- c(5,\
    \ 7, 1, 5, 9, 653, 121)\n\ncommon_elements <- function(l1, l2) {\n  l1 <- sort(unique(l1))\n\
    \  l2 <- sort(unique(l2))\n  l1[l1 == l2]\n}\n\ncommon_elements(l1, l2)\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nHere's a solution using base R:\n<code>\n\
    l1 <- c(1, 4, 3, 34, 653, 2, 5)\nl2 <- c(5, 7, 1, 5, 9, 653, 121)", "\n  l1 <-\
    \ sort(l1)\n  l2 <- sort(l2)\n  i <- 0\n  j <- 1\n  res <- list()\n  while(i <\
    \ length(l1) && j < length(l2)) {\n    if(l1[i] == l2[j]) {\n      res[[i]] <-\
    \ l1[i]\n      i <- i + 1\n      j <- j + 1\n    }\n    else if(l1[i] < l2[j])\
    \ {\n      i <- i + 1\n    }\n    else {\n      j <- j + 1\n    }\n  }\n  if(i\
    \ < length(l1)) {\n    res[[i]] <- l1[i]\n  }\n  if(j < length(l2)) {\n    res[[i]]\
    \ <- l2[j]\n  }\n  return(res)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks\
    \ for your answer. Your code works perfectly for small lists, but for large lists\
    \ it takes too long to run. Do you know any way to make it faster?\n<|/ c |>\n\
    <| c |>\nI added a faster version to my answer. Hope it helps.\n<|/ c |>\n<| c\
    \ |>\nThanks again! Your code works perfectly for small lists, but for large lists\
    \ it takes too long to run. Do you know any way to make it faster?\n<|/ c |>\n\
    <| c |>\nI added a faster version to my answer. Hope it helps.\n<|/ c |>\n<| c\
    \ |>\nThanks again! Your code works perfectly for small lists, but for large lists\
    \ it takes too long to run. Do you know any way to make it faster?\n<|/ c |>\n\
    <| a tags=r |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(df)\ndf[, i := .I]\ndf[, j := .I]\ndf[, j := j - i, by = i]\ndf[, j := j\
    \ - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j :=\
    \ j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j :=\
    \ j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j :=\
    \ j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j := j", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without having to sort the lists.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ doesn't require sorting.\n<|/ c |>\n<| c |>\nI like the `common` function but\
    \ I don't think it works. Try `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5,\
    \ 9, 653, 121))`\n<|/ c |>\n<| c |>\nI added a version that doesn't require sorting.\n\
    <|/ c |>\n<| c |>\nI like your `common` function, but I wonder if there is a way\
    \ to do this without having to sort the lists.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThanks for the answer! I didn't know about `intersect` before.\
    \ Unfortunately, it seems that `intersect` doesn't work on lists containing `NA`s.\
    \ I edited my question to include a reproducible example.\n<|/ c |>\n<| c |>\n\
    I edited my answer to include a function that should work for your updated example.\n\
    <|/ c |>\n<| c |>\nThanks for the edit! I tested it and it works for the example\
    \ I gave, but when I apply it to my actual data, it returns `list()` instead of\
    \ `list(1, 5, 653)`. Any idea why this might be?\n<|/ c |>\n<| c |>\nIt works\
    \ for me with the example you gave. Maybe you can post a reproducible example\
    \ that doesn't work for you?\n<|/ c |>\n<| c |>\nI edited my question to include\
    \ a reproducible example that doesn't work for me.\n<|/ c |>\n<| a dscore=1 |>\n\
    Here is a solution using dplyr and purrr:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n",
  "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThanks for your answer. I'm\
    \ getting an error when I try to use your code. `Error in sort(l1) : object 'l1'\
    \ not found`\n<|/ c |>\n<| c |>\nSorry, I forgot to add `l1 <- sort(l1)`. I edited\
    \ my answer.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm getting an error\
    \ when I try to use your code. `Error in sort(l1) : object 'l1' not found`\n<|/\
    \ c |>\n<| c |>\nSorry, I forgot to add `l1 <- sort(l1)`. I edited my answer.\n\
    <|/ c |>\n<| c |>\nThanks for your answer. I'm getting an error when I try to\
    \ use your code. `Error in sort(l1) : object 'l1' not found`\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list,unique,intersection |>\n<| c |>\nThis\
    \ doesn't work for me. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))` returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`\n<|/ c |>\n\
    <| c |>\nI see what you mean. I've updated the answer to account for this.\n<|/\
    \ c |>\n<| c |>\nI see what you mean. I've updated the answer to account for this.\n\
    <|/ c |>\n<| a tags=r,list,unique,intersection |>\n<code>\nintersect(list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), list(c(5, 3, 2, 8), c(3,\
    \ 2)))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI like using Reduce for\
    \ this sort of thing:\n<code>\nReduce(intersect, list(c(1, 4, 3, 34, 653, 2, 5),\
    \ c(5, 7, 1, 5, 9, 653, 121)))", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not work if there\
    \ are duplicates in either list.\n<|/ c |>\n<| c |>\nYes, it does. I tested it\
    \ before posting it. The OP did not specify what should happen if there are duplicates\
    \ in either list.\n<|/ c |>\n<| c |>\nI tested it again and it does work. Try\
    \ it yourself.\n<|/ c |>\n<| c |>\nI tested it again and it does work. Try it\
    \ yourself. It returns `list(1, 5, 653)` as expected.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. I tested it before posting it. The OP did not specify what should happen\
    \ if there are duplicates in either list.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1 = c(1,\
    \ 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\nsetkey(setDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l2, l1)\n</code>\n\
    This gives:\n<code>\n   l1 l2\n1:  1  5\n2:  4  7\n3:  3  1\n4: 34 653\n5: 653\
    \ 121\n</code>\n<|/ a tags=r,list |>\n<| c |>\nThis does not work if there are\
    \ duplicates in either list.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting it. The OP did not specify what should happen if there are duplicates\
    \ in either list.\n<|/ c |>\n<| c |>\nI tested it again and it does work. Try\
    \ it yourself.\n<|/ c |>\n<| c |>\nI tested it again and it does work. Try it\
    \ yourself. It returns `list(1, 5, 653)` as expected.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. I tested it before posting it. The OP did not specify what should happen\
    \ if there are duplicates in either list.\n<|/ c ", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a |>\nI came up with a solution using purrr::map2\n<code>\nlibrary(purrr)\n",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem to work if there are repeated\
    \ elements in the lists. For example, `common(c(1,4,3,34,653,5,7,1,5,9,653,121),\
    \ c(5,7,1,5,9,653,121))` returns `list(1, 5, 653)` instead of `list(1, 5, 653,\
    \ 121)`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it before I saw your\
    \ comment. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1=c(1, 4, 3, 34,\
    \ 653, 5), l2=c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1=c(1, 4, 3, 34,\
    \ 653, 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\nunique(setDT(list(l1=c(1,\
    \ 4, 3, 34, 653, 5), l2=c(5, 7, 1, 5, 9, 653, 121))))\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't seem to work if there are repeated elements in the\
    \ lists. For example, `setDT(list(l1=c(1, 4, 3, 34, 653, 5), l2=c(5, 7, 1, 5,\
    \ 9, 653, 121)))` returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`.\n\
    <|/ c |>\n<| c |>\nYes, I noticed that and fixed it before I saw your comment.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a dscore=3 |>\n<code>\n> x <- list(c(1,\
    \ 4, 3, 34, 653, 5), c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(c(1, 4, 3, 34, 653,\
    \ 5), c(5, 7, 1, 5, 9, 653, 121))\n> x <- unique(x)\n> y <- unique(y)\n> x\n[[1]]\n\
    [1] 1 4 3 34 653 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n> y\n[[1]]\n[1] 1 4 3 34 653\
    \ 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n> \n</code>\n<|/ a tags=r,list,unique |>\n\
    <|", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n\
    }\n</code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 %in% u1]\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThis doesn't seem to work if there are duplicates in\
    \ either list.\n<|/ c |>\n<| c |>\nIt does work if there are duplicates in either\
    \ list. Try it yourself.\n<|/ c |>\n<| c |>\nI did. `common(c(1, 4, 3, 34, 653,\
    \ 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<|\
    \ c |>\nI see what you mean. My bad.\n<|/ c |>\n<| a dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u2%in%u1]\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThis doesn't seem to work if there are duplicates in\
    \ either list.\n<|/ c |>\n<| a |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n\
    \  u2<-unique(c(l2,l1))\n  u1[u2%in%u1]\n}\n</code>\n<|/ a tags=r dscore=0 |>\n\
    <| c |>\nThis doesn't seem to work if there are duplicates in either list.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n\
    \  u2<-unique(c(l2,l1))\n  u1[u2%in%u1]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    This doesn't seem to work if there are duplicates in either list.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n \
    \ u2<-unique(c(l2,l1))\n  u1[u2%in%u1]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    This doesn't seem to work if there are duplicates in either list.\n<|/ c |>\n\
    <| a |>\n<code>\ncommon<-function(l", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis\
    \ does not give the correct answer for `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))`\n<|/ c |>\n<| c |>\nI believe that is the correct answer\
    \ for the example given in the question. `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<| c |>\nYes, but\
    \ `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1,\
    \ 5, 653)` not `list(1, 5, 653, 121)`\n<|/ c |>\n<| c |>\nAh I see what you mean.\
    \ I'll update my answer.\n<|/ c |>\n<| c |>\nI believe that is the correct answer\
    \ for the example given in the question. `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nWhile\
    \ this code may answer the question, providing additional context regarding why\
    \ and/or how this code answers the question improves its long-term value.\n<|/\
    \ c |>\n<| c |>\nThis does not give the correct answer for `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nWhile\
    \ this code may answer the question, providing additional context regarding why\
    \ and/or how this code answers the question improves its long-term value.\n<|/\
    \ c |>\n<| c |>\nThis does not give the correct answer for `common(c", "\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are duplicates in the lists.\
    \ For example, `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\
    \ returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c\
    \ |>\n, you're right. I fixed the code. Thanks!\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\n<code>\nlibrary(data.table)\nlibrary(magrittr)\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks for the answer! I tested it and it works great! However,\
    \ I still don't understand why my code doesn't work. Could you please explain\
    \ it to me?\n<|/ c |>\n<| c |>\nI added an explanation to the answer.\n<|/ c |>\n\
    <| c |>\nThank you very much! I understand it now!\n<|/ c |>\n<| a dscore=1 |>\n\
    The problem is that the function common is called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicate", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I like your solution, but I believe it can be optimized a bit. For example, `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\
    \ instead of `list(1, 5, 653, 121)`. Also, `common(c(5, 3, 2, 8), c(3, 2))` returns\
    \ `list(2, 3)` instead of `list(2, 3)`. You can see my answer for a more optimized\
    \ version.\n<|/ c |>\n<| c |>\nThanks for the comment. I've updated my answer\
    \ to include your suggestions.\n<|/ c |>\n<| a tags=r,unique,intersection,list\
    \ |>\nHere is a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c\
    \ |>\n<| c |>\nI added a version that works with repeated elements.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c\
    \ |>\n<| c |>\nI added a version that works with repeated elements.\n<|/ c |>\n\
    <| a tags=r |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n\
    \  u1[u1==u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there\
    \ are repeated elements in the lists.\n<|/ c |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a tags=r |>\n<| a |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n\
    \  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/ a tags=r dscore=0 |>\n\
    <| c |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n\
    \  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    This doesn't work if there are repeated elements in the lists.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n\
    \  u1[", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r,list |>\n<| c |>\nI like your answer but I think it can\
    \ be simplified a bit. `common` can be simplified to `u1 <- unique(c(l1, l2));\
    \ u2 <- unique(c(l2, l1)); u1[u1 == u2]`\n<|/ c |>\n<| c |>\nThanks, I didn't\
    \ know that `unique` could take two vectors as inputs. I updated my answer.\n\
    <|/ c |>\n<| a tags=r,list |>\nI like using Reduce:\n<code>\nReduce(intersect,\
    \ list1, list2)\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted\
    \ answer. `Reduce` is designed for this.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `Reduce` is designed for this.\n<|/ c |>\n<| a tags=r,list\
    \ |>\n<code>\n> list1 <- list(a = 1, b = 2, c = 3)\n> list2 <- list(a = 2, b =\
    \ 2, c = 4)\n> list3 <- list(a = 1, b = 2, c = 4)\n> list4 <- list(a = 2, b =\
    \ 2, c = 4)\n> list5 <- list(a = 1, b = 2, c = 4)\n> list6 <- list(a = 1, b =\
    \ 2, c = 4)\n> list7 <- list(a = 1, b = 2, c = 4)\n> list8 <- list(a = 1, b =\
    \ 2, c = 4)\n> list9 <- list(a = 1, b = 2, c = 4)\n> list10 <- list(a = 1, b =\
    \ 2, c = 4)\n> list11 <- list(a = 1, b = 2, c = 4)\n> list12 <- list(a = 1, b\
    \ = 2, c = 4)\n> list13 <- list(a = 1, b = 2, c = 4)\n> list14 <- list(a = 1,\
    \ b = 2, c = 4)\n> list15 <- list(a = 1, b = 2, c = 4)\n> list16 <- list(a = 1,\
    \ b = 2, c = 4)\n> list17 <- list(a = 1, b = 2, c = 4)\n> list18 <- list(a = 1,\
    \ b = 2, c = 4)\n> list19 <- list(a = 1, b = 2, c = 4)\n> list20 <- list(a = 1,\
    \ b = 2, c = 4)\n> list21 <- list(a = 1, b = 2, c = 4)", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\
    \ For example: `common(c(1,2,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1]\
    \ 1 3`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it now. Thanks.\n<|/\
    \ c |>\n<| a |>\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(c(l1,l2)))\n\
    \  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n</code>\n<|/ a tags=r dscore=2\
    \ |>\n<| a tags=r |>\nI like using %in% for this:\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1%in%u2]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n\
    </code>\n<|/ a tags=r |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n\
    </code>\n<|/ a tags=r |>\n<| a tags=r |>\n<code>\ncommon<-function(l1,l2){\n \
    \ u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n\
    </code>\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 !=\
    \ u1]\n}\n</code>\n<|/ a tags=r,list,merge |>\n<| a tags=r,list,merge |>\nHere's\
    \ a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like your solution,\
    \ but I believe it can be simplified a little bit more. `common` can be written\
    \ as `common <- function(l1, l2) unique(c(l1, l2))[unique(c(l2, l1))]`\n<|/ c\
    \ |>\n<| c |>\nI like your solution, but I believe it can be simplified a little\
    \ bit more. `common` can be written as `common <- function(l1, l2) unique(c(l1,\
    \ l2))[unique(c(l2, l1))]`\n<|/ c |>\n<| c |>\nI like your solution, but I believe\
    \ it can be simplified a little bit more. `common` can be written as `common <-\
    \ function(l1, l2) unique(c(l1, l2))[unique(c(l2, l1))]`\n<|/ c |>\n<| c |>\n\
    I like your solution, but I believe it can be simplified a little bit more. `common`\
    \ can be written as `common <- function(l1, l2) unique(c(l1, l2))[unique(c(l2,\
    \ l1))]`\n<|/ c |>\n<| c |>\nI like your solution, but I believe it can be simplified\
    \ a little bit more. `common` can be written as `common <- function(l1, l2) unique(c(l1,\
    \ l2))[unique(c(l2, l1))]`\n<|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution\
    \ that doesn't require any packages:\n<code>\ncommon <- function(l1, l2) {\n \
    \ u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer. No packages, no\
    \ loops, no unnecessary copies, no unnecessary `if` statements.\n<|/ c |>\n<|\
    \ c |>\nI like your solution, but I believe it can be simplified a little bit\
    \ more. `common` can be written as `common <- function(l1, l2) unique(c(l1, l2))[unique(c(l2,\
    \ l1))]`\n<|/ c |>\n<| c |>\nI like your solution, but I believe it can be simplified\
    \ a little bit more. `common", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  common1\
    \ <- intersect(l1, l2)\n  common2 <- intersect(l2, l1)\n  common3 <- intersect(l1,\
    \ l2)\n  common4 <- intersect(l2, l1)\n  common5 <- intersect(l1, l2)\n  common6\
    \ <- intersect(l2, l1)\n  common7 <- intersect(l1, l2)\n  common8 <- intersect(l2,\
    \ l1)\n  common9 <- intersect(l1, l2)\n  common10 <- intersect(l2, l1)\n  common11\
    \ <- intersect(l1, l2)\n  common12 <- intersect(l2, l1)\n  common13 <- intersect(l1,\
    \ l2)\n  common14 <- intersect(l2, l1)\n  common15 <- intersect(l1, l2)\n  common16\
    \ <- intersect(l2, l1)\n  common17 <- intersect(l1, l2)\n  common18 <- intersect(l2,\
    \ l1)\n  common19 <- intersect(l1, l2)\n  common20 <- intersect(l2, l1)\n  common21\
    \ <- intersect(l1, l2)\n  common22 <- intersect(l2, l1)\n  common23 <- intersect(l1,\
    \ l2)\n  common24 <- intersect(l2, l1)\n  common25 <- intersect(l1, l2)\n  common26\
    \ <- intersect(l2, l1)\n  common27 <- intersect(l1, l2)\n  common28 <- intersect(l2,\
    \ l1)\n  common29 <- intersect(l1, l2)\n  common30 <- intersect(l2, l1)\n  common31\
    \ <- intersect(l1, l2)\n  common32 <- intersect(l2, l1)\n  common33 <- intersect(l1,\
    \ l2)\n  common34 <- intersect(l2, l1)\n  common35 <- intersect(l1, l2)\n  common36\
    \ <- intersect(l2, l1)\n  common37 <- intersect(l1, l2)\n  common38 <- intersect(l2,\
    \ l1)\n  common39 <- intersect(l1, l2)\n  ", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a dscore=2 |>\n<| c\
    \ |>\nThis doesn't seem to work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nI added a solution that should work if there are repeated elements.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nI added a solution that should work if there are repeated elements.\n\
    <|/ c |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| a tags=r,list |>\n<code>\n> x <- list(c(1,4,3,34,653,2),c(5,7,1,5,9,653,121))\n\
    > y <- list(c(5,3,2,8),c(3,2))\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ c |>\nThis doesn't work for me. `common(c(1,2,3), c(1,2,3))` returns `[1] 1\
    \ 2 3` instead of `[1] 1 3`\n<|/ c |>\n<| c |>\nI tested it on RStudio and R 3.6.3\n\
    <|/ c |>\n<| c |>\nI tested it on RStudio and R 3.6.3\n<|/ c |>\n<| c |>\nI tested\
    \ it on RStudio and R 3.6.3\n<|/ c |>\n<| c |>\nI tested it on RStudio and R 3.6.3\n\
    <|/ c |>\n<| a tags=r,sorting |>\nI came up with this solution:\n<code>\ncommon\
    \ <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work for\
    \ me. `common(c(1,2,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1] 1 3`\n\
    <|/ c |>\n<| c |>\nI tested it on RStudio and R 3.6.3\n<|/ c |>\n<| c |>\nI tested\
    \ it on RStudio and R 3.6.3\n<|/ c |>\n<| c |>\nI tested it on RStudio and R 3.6.3\n\
    <|/ c |>\n<| c |>\nI tested it on RStudio and R 3.6.3\n<|/ c |>\n<| a dscore=3\
    \ |>\nA simple solution using setdiff and intersect from base R:\n<code>\ncommon\
    \ <- function(l1, l2) {\n  setdiff(unique(c(l1, l2)), unique(c(l2, l1)))\n}\n\
    </code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't work for me. `common(c(1,2,3),\
    \ c(1,2,3))` returns `[1] 1 2 3` instead of `[1] 1 3`\n<|/ c |>\n<| c |>\nI tested\
    \ it on RStudio and R 3.6.3\n<|/ c |>\n<| c |>\nI tested it on RStudio and R 3.6.3\n\
    <|/ c |>\n<|", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2\
    \ %in% u1]\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted\
    \ answer. `intersect` doesn't preserve order, and `setdiff` doesn't preserve duplicates.\n\
    <|/ c |>\n<| c |>\n`setdiff` doesn't preserve duplicates, but `setdiff` does preserve\
    \ order. `setdiff(sort(unique(c(l1, l2))), sort(unique(c(l2, l1))))`\n<|/ c |>\n\
    <| c |>\n`setdiff` doesn't preserve duplicates, but `setdiff` does preserve order.\
    \ `setdiff(sort(unique(c(l1, l2))), sort(unique(c(l2, l1))))`\n<|/ c |>\n<| c\
    \ |>\n`setdiff` doesn't preserve duplicates, but `setdiff` does preserve order.\
    \ `setdiff(sort(unique(c(l1, l2))), sort(unique(c(l2, l1))))`\n<|/ c |>\n<| c\
    \ |>\n`setdiff` doesn't preserve duplicates, but `setdiff` does preserve order.\
    \ `setdiff(sort(unique(c(l1, l2))), sort(unique(c(l2, l1))))`\n<|/ c |>\n<| a\
    \ dscore=5 |>\nA simple solution is to use setdiff:\n<code>\nsetdiff(l1, l2)\n\
    </code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't preserve the order\
    \ of the elements.\n<|/ c |>\n<| c |>\nThis doesn't preserve the order of the\
    \ elements.\n<|/ c |>\n<| c |>\nThis doesn't preserve the order of the elements.\n\
    <|/ c |>\n<| c |>\nThis doesn't preserve the order of the elements.\n<|/ c |>\n\
    <| c |>\nThis doesn't preserve the order of the elements.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\n<code>\nl1 <- list(c(1,2,3), c(4,5,6), c(7,8,9))\nl2 <- list(c(1,2,3), c(4,5,6),\
    \ c(7,8,9))\nl3 <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n\n> l3\n[[1]]\n[1] 1 2\
    \ 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n\n> unique(l3)\n[[1]]\n[1] 1 2 3\n\
    \n[[2]]\n[1] 4 5 6\n\n[", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1,\
    \ l2))\n  u[!duplicated(u)]\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this\
    \ solution, but I wonder if it could be made more efficient by avoiding sorting\
    \ and using binary search instead. Would that be possible?\n<|/ c |>\n<| c |>\n\
    : Yes, it would be possible. Binary search is O(log n), so you could do it in\
    \ O(n log n) by sorting the lists and then doing a binary search on the sorted\
    \ lists.\n<|/ c |>\n<| c |>\n: I added a binary search version to my answer.\n\
    <|/ c |>\n<| c |>\nI like this solution, but I wonder if it could be made more\
    \ efficient by avoiding sorting and using binary search instead. Would that be\
    \ possible?\n<|/ c |>\n<| c |>\n: Yes, it would be possible. Binary search is\
    \ O(log n), so you could do it in O(n log n) by sorting the lists and then doing\
    \ a binary search on the sorted lists.\n<|/ c |>\n<| a dscore=5 |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1=c(1, 4, 3, 34,\
    \ 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(DT, l1, l2)\nDT[J(l1, l2)]\n\
    </code>\n<|/ a tags=r,list |>\n<| c |>\nThis should be the accepted answer. `data.table`\
    \ has many useful features that make it very easy to do things like this and much\
    \ faster than base R.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ `data.table` has many useful features that make it very easy to do things like\
    \ this and much faster than base R.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. `data.table` has many useful features that make it very easy to do things\
    \ like this and much faster than base R.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `data.table` has many useful features that make it very easy\
    \ to do things like this and much faster than base R.\n<|/ c |>\n<| c |>\nThis\
    \ should be the accepted answer. `data.table` has many useful features that make\
    \ it very easy to do things like this and much ", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\nI like this solution, but I wonder if there is a way to make it more efficient.\
    \ For example, `common(c(1,2,3), c(1,2,3))` returns `[1]` but `common(c(1,2,3),\
    \ c(1,2,4,5))` returns `[1] 1 2 3`. Is there a way to make it return `[1] 1 2\
    \ 3 4 5`?\n<|/ c |>\n<| c |>\nI added a solution that uses `intersect` instead\
    \ of `setdiff`.\n<|/ c |>\n<| c |>\nI added a solution that uses `intersect` instead\
    \ of `setdiff`.\n<|/ c |>\n<| c |>\nI added a solution that uses `intersect` instead\
    \ of `setdiff`.\n<|/ c |>\n<| c |>\nI added a solution that uses `intersect` instead\
    \ of `setdiff`.\n<|/ c |>\n<| a tags=r |>\nThe solution using intersect instead\
    \ of setdiff is very elegant, but unfortunately it won't work if you have duplicate\
    \ elements in the lists.\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\nFor example, common(c(1,2,3),\
    \ c(1,2,3)) returns [1] but common(c(1,2,3), c(1,2,4,5)) returns [1] 1 2 3 4 5\n\
    To fix this, you can use the following function:\n<code>\ncommon <- function(l1,\
    \ l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[intersect(u1,\
    \ u2)]\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to make it more efficient. For example, `common(c(1,2,3),\
    \ c(1,2,3))` returns `[1]` but `common(c(1,2,3), c(1,2,4,5))` returns `[1] 1 2\
    \ 3`. Is there a way to make it return `[1] 1 2 3 4 5`?\n<|/ c |>\n<| c |>\nI\
    \ added a solution that uses `intersect` instead of `setdiff`.\n<|/ c |>\n<| a\
    \ dscore=5 |>\nA simple solution using setdiff and intersect functions:\n<code>\n\
    common ", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  common1 <- intersect(l1, l2)\n\
    \  common2 <- intersect(l2, l1)\n  common1 <- c(common1, rep(NA, ncol(common2)\
    \ - length(common1)))\n  common2 <- c(common2, rep(NA, ncol(common1) - length(common2)))\n\
    \  common1 <- common1[order(common1)]\n  common2 <- common2[order(common2)]\n\
    \  common1 <- common1[!is.na(common1)]\n  common2 <- common2[!is.na(common2)]\n\
    \  common1 <- common1[!duplicated(common1)]\n  common2 <- common2[!duplicated(common2)]\n\
    \  common1 <- common1[!is.na(common1)]\n  common2 <- common2[!is.na(common2)]\n\
    \  common1 <- common1[!duplicated(common1)]\n  common2 <- common2[!duplicated(common2)]\n\
    \  common1 <- common1[!is.na(common1)]\n  common2 <- common2[!is.na(common2)]\n\
    \  common1 <- common1[!duplicated(common1)]\n  common2 <- common2[!duplicated(common2)]\n\
    \  common1 <- common1[!is.na(common1)]\n  common2 <- common2[!is.na(common2)]\n\
    \  common1 <- common1[!duplicated(common1)]\n  common2 <- common2[!duplicated(common2)]\n\
    \  common1 <- common1[!is.na(common1)]\n  common2 <- common2[!is.na(common2)]\n\
    \  common1 <- common1[!duplicated(common1)]\n  common2 <- common2[!duplicated(common2)]\n\
    \  common1 <- common1[!is.na(common1)]\n  common2 <- common2[!is.na(common2)]\n\
    \  common1 <- common1[!duplicated(common1)]\n  common2 <- common2[!duplicated(common2)]\n\
    \  common1 <- common1[!is.na(common1)]\n  common2 <- common2[!is.na(common2)]\n\
    \  common1 <- common1[!duplicated(common1)]\n  common2 <- common2[!duplicated(common2)]\n\
    \  common1 <- common1[!is.na(common1)]\n  common2 <- common2[!is.na(common2)]\n\
    \  common1 <- common1[!duplicated(common1)]\n  common2 <- common2[!duplicated(common2)]\n\
    \  common1 <- common1[!is.na(common1)]\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n\
    \  i <- 0\n  j <- 0\n  res <- list()\n  while(i < length(l1) && j < length(l2))\
    \ {\n    if(l1[i] == l2[j]) {\n      res[[i]] <- l1[i]\n      i <- i + 1\n   \
    \   j <- j + 1\n    }\n    else if(l1[i] > l2[j]) {\n      j <- j + 1\n    }\n\
    \    else {\n      i <- i + 1\n    }\n  }\n  if(i < length(l1)) {\n    while(i\
    \ < length(l1)) {\n      res[[i]] <- l1[i]\n      i <- i + 1\n    }\n  }\n  if(j\
    \ < length(l2)) {\n    while(j < length(l2)) {\n      res[[i]] <- l2[j]\n    \
    \  j <- j + 1\n    }\n  }\n  return(res)\n}\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n\
    \  l1[duplicated(l1) | duplicated(l2, fromLast = TRUE)]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't seem to work if there are duplicate elements in the\
    \ list. For example, `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<| c |>\nI added a fix for that\
    \ case.\n<|/ c |>\n<| c |>\nThanks for your answer! I added a fix for that case\
    \ and also added a comment to explain why I used `common` instead of `intersect`.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere is a solution using base R:\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if there are repeated\
    \ elements in the lists.\n<|/ c |>\n<| c |>\nIt works if you use `u1 <- unique(c(l1,\
    \ l2))` instead of `u1 <- unique(c(l1, l2, l2))`\n<|/ c |>\n<| c |>\nThanks, I\
    \ fixed the typo.\n<|/ c |>\n<| c |>\nThis doesn't work if there are repeated\
    \ elements in the lists.\n<|/ c |>\n<| c |>\nIt works if you use `u1 <- unique(c(l1,\
    \ l2))` instead of `u1 <- unique(c(l1, l2, l2))`\n<|/ c |>\n<| a dscore=5 |>\n\
    The function unique is very useful to remove duplicates from a list. \n<code>\n\
    > x <- list(c(1,2,3), c(1,2,3), c(1,2,3))\n> unique(x)\n[[1]]\n[1] 1 2 3\n\n[[2]]\n\
    [1] 1 2 3\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if\
    \ there are repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt works if you\
    \ use `u1 <- unique(c(l1, l2))` instead of `u1 <- unique(c(l1, l2, l2))`\n<|/\
    \ c |>\n<| a tags=r,list,unique |>\n<code>\nx <- list(c(1,2,3), c(1,2,3), c(1,2,3))\n\
    unique(x)\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if there are\
    \ repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt works if you use `u1\
    \ <- unique(c(l1, l2))` instead of `u1 <- unique(c(l1, l2, l2))`\n<|/ c |>\n<|\
    \ a dscore=5 |>\n<code>\nx <- list(c(1,2,3), c(1,2,3), c(1,2,3))\nunique(x)\n\
    </code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if there are\
    \ repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt works if you use `u1\
    \ <- unique(c(l1, l2))` instead of `u1 <- unique(c(l1, l2, l2))`\n<|/ c ", "\n\
    \  l1 <- sort(l1)\n  l2 <- sort(l2)\n  i <- 0\n  j <- 1\n  res <- list()\n  while\
    \ (i < length(l1) && j < length(l2)) {\n    if (l1[i] == l2[j]) {\n      res[[i]]\
    \ <- l1[i]\n      i <- i + 1\n      j <- j + 1\n    } else if (l1[i] < l2[j])\
    \ {\n      res[[i]] <- l1[i]\n      i <- i + 1\n    } else {\n      res[[i]] <-\
    \ l2[j]\n      j <- j + 1\n    }\n  }\n  res\n}\n", "\n  l1 <- sort(l1)\n  l2\
    \ <- sort(l2)\n  i <- 0\n  j <- 0\n  res <- list()\n  while (i < length(l1) &&\
    \ j < length(l2)) {\n    if (l1[i] == l2[j]) {\n      res[[i]] <- l1[i]\n    \
    \  i <- i + 1\n      j <- j + 1\n    } else if (l1[i] > l2[j]) {\n      j <- j\
    \ + 1\n    } else {\n      i <- i + 1\n    }\n  }\n  return(res)\n}\n</code>\n\
    <|/ a tags=r,sorting |>\n<| c |>\nThis doesn't seem to work. `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)` instead\
    \ of `list(1, 5, 653, 121)`\n<|/ c |>\n<| c |>\nI missed the requirement for duplicates.\
    \ I updated the answer to include a solution for that case.\n<|/ c |>\n<| c |>\n\
    Thanks for the update. I'm still getting a weird result though. `common(c(1, 4,\
    \ 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)` instead\
    \ of `list(1, 5, 653, 121)`\n<|/ c |>\n<| c |>\nI updated the answer again. Sorry\
    \ for the mistake.\n<|/ c |>\n<| c |>\nThanks for the update. I'm still getting\
    \ a weird result though. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))` returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n  l1<-sort(l1)\n  l2<-sort(l2)\n\
    \  l3<-list()\n  for(i in 1:length(l1)){\n    for(j in 1:length(l2)){\n      if(l1[i]==l2[j]){\n\
    \        l3[[i]]<-l1[i]\n      }\n    }\n  }\n  return(l3)\n}\n</code>\n<|/ a\
    \ tags=r,sorting |>\n<| c |>\nWhile this code may answer the question, providing\
    \ additional context regarding why and/or how this code answers the question improves\
    \ its long-term value.\n<|/ c |>\n<| c |>\nThis doesn't seem to work. `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nI like\
    \ this solution, but I wonder if there is a way to make it more efficient. For\
    \ example, `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns\
    \ `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`\n<|/ c |>\n<| c |>\nI added\
    \ a more efficient solution that doesn't require sorting.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(x = c(list(1, 4, 3, 34, 653, 2, 5), list(1, 5, 653, 121)))\ndt[,\
    \ y := unique(x)]\ndt[, y := y[order(y)]]\ndt[, y := y[!duplicated(y)]]\ndt[,\
    \ y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y\
    \ := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y :=\
    \ y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\n\
    dt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[,\
    \ y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y\
    \ := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y :=\
    \ y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\n\
    dt[, ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,list,unique |>\n<code>\n> x <- list(c(1,2,3),\
    \ c(4,5,6), c(7,8,9))\n> y <- list(c(4,5,6), c(7,8,9), c(1,2,3))\n> \n> x <- unlist(x)\n\
    > y <- unlist(y)\n> \n> x <- unique(x)\n> y <- unique(y)\n> \n> x <- sort(x)\n\
    > y <- sort(y)\n> \n> x\n[1] 1 2 3 4 5 6 7 8 9\n> y\n[1] 4 5 6 7 8 9\n> \n> x\
    \ <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x\n[1] 1 2 3 4 5 6 7 8\
    \ 9\n> y\n[1] 4 5 6 7 8 9\n</code>\n<|/ a dscore=1 |>\n<| a |>\n<code>\nx <- list(c(1,2,3),\
    \ c(4,5,6), c(7,8,9))\ny <- list(c(4,5,6), c(7,8,9), c(1,2,3))\n\nx <- unlist(x)\n\
    y <- unlist(y)\n\nx <- unique(x)\ny <- unique(y)\n\nx <- sort(x)\ny <- sort(y)\n\
    \nx <- x[!duplicated(x)]\ny <- y[!duplicated(y)]\n\nx\n[1] 1 2 3 4 5 6 7 8 9\n\
    y\n[1] 4 5 6 7 8 9\n</code>\n<|/ a dscore=1 tags=r,list,unique |>\n<| a dscore=1\
    \ |>\n<code>\nx <- list(c(1,2,3), c(4,5,6), c(7,8,9))\ny <- list(c(4,5,6), c(7,8,9),\
    \ c(1,2,3))\n\nx <- unlist(x)\ny <- unlist(y)\n\nx <- unique(x)\ny <- unique(y)\n\
    \nx <- sort(x)\ny <- sort(y)\n\nx <- x[!duplicated(x)]\ny <- y[!duplicated(y)]\n\
    \nx\n[1] 1 2 3 4 5 6 7 8 9\ny\n[1] 4 5 6 7 8 9\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a |>\n<code>\nx <- list(c(1,2,3), c(4,5,6), c(7,8,9))\ny <- list(c(4,5,6),\
    \ c(7,8,9), ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list |>\n<| c |>\nThis doesn't work for me.\
    \ `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1,\
    \ 5, 653)` instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\nI see what you\
    \ mean. I've updated the answer with a new function that should work.\n<|/ c |>\n\
    <| c |>\nThanks, this works great. I've added a little bit of extra code to make\
    \ it work for my purposes.\n<|/ c |>\n<| a dscore=0 |>\nHere is a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\nsetDT(list(list(1, 4, 3, 34, 653,\
    \ 2, 5), list(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(list(1, 4, 3, 34,\
    \ 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V1)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V2)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V3)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V4)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V5)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V6)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V7)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V8)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V9)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V10)\nsetkey(setDT(list(list(1,\
    \ 4, 3, 34, 653, 2, 5), list(5, 7, 1, 5, 9, 653, 121))), V11)\nsetkey(setDT(list(",
  "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if there are\
    \ duplicates in the lists.\n<|/ c |>\n<| c |>\nYes, it does. `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5,\
    \ 9, 653, 121))` returns `list(1, 5, 653)`.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1,\
    \ 5, 653)`.\n<|/ c |>\n<| c |>\nYes, it does. `common(c(1, 4, 3, 34, 653, 2, 5),\
    \ c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`.\n<|/ c |>\n<| a dscore=5\
    \ tags=r,list,unique |>\n<code>\n> x <- list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7,\
    \ 1, 5, 9, 653, 121))\n> y <- list(c(5, 3, 2, 8), c(3, 2))\n> \n> x <- sort(x)\n\
    > y <- sort(y)\n> \n> x <- unique(x)\n> y <- unique(y)\n> \n> x <- x[order(x)]\n\
    > y <- y[order(y)]\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n>\
    \ \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicate", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u2 %in% u1]\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  i <- 0\n  j <- 0\n\
    \  res <- list()\n  while (i < length(l1) && j < length(l2)) {\n    if (l1[i]\
    \ == l2[j]) {\n      res[[i]] <- l1[i]\n      i <- i + 1\n      j <- j + 1\n \
    \   } else if (l1[i] > l2[j]) {\n      j <- j + 1\n    } else {\n      i <- i\
    \ + 1\n    }\n  }\n  res\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThanks for your\
    \ answer. Your code works but it is very slow. My dataset has about 3000 rows\
    \ and about 20 columns. I used your function and I got this error \"Error in if\
    \ (l1[i] == l2[j]) { :\n  missing value where TRUE/FALSE needed\". Do you know\
    \ what is the problem?\n<|/ c |>\n<| c |>\nI added a faster version to my answer.\
    \ Hope it helps.\n<|/ c |>\n<| a tags=r,dataframe,list |>\nI used the code below\
    \ to solve my problem:\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis\
    \ doesn't work if there are duplicates in either list.\n<|/ c |>\n<| c |>\n: I\
    \ added a version that works with duplicates.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n\
    > x <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n> y <- list(c(4,5,6), c(7,8,9), c(1,2,3))\n\
    > \n> x <- unique(x)\n> y <- unique(y)\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in either list.\n<|/ c |>\n<| c |>\nI added a version that works with duplicates.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution that works with duplicates\
    \ in either list:\n<code>\n> x <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n> y <- list(c(4,5,6),\
    \ c(7,8,9), c(1,2,3))\n> \n> x <- unique(x)\n> y <- unique(y)\n> \n> x <- x[!duplicated(x)]\n\
    > y <- y[!duplicated(y)]\n> \n> x\n[[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n\
    [1] 7 8 9\n</code>\n<|/ a dscore=4 |>\n<| a tags=r,list,unique |>\n<code>\nx <-\
    \ list(c(1,2,3), c(4,5,6), c(7,8,9))\ny <- list(c(4,5,6), c(7,8,9), c(1,2,3))\n\
    </code>\nThe solutions above don't work if there are duplicates in either list.\n\
    <code>\nx <- unique(x)\ny <- unique(y)\n</code>\nThis doesn't work if there are\
    \ duplicates in either list.\n<code>\nx <- x[!duplicated(x)]\ny <- y[!duplicated(y)]\n\
    </code>\nThis doesn't work if there are duplicates in either list.\n<code>\nx\
    \ <- x[!duplicated(x)]\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to avoid the double `unique` calls.\n<|/ c |>\n\
    <| c |>\nI guess you could do something like `u1 <- unique(c(l1, l2)); u2 <- unique(c(l2,\
    \ l1)); u1[u2 != u1]`\n<|/ c |>\n<| c |>\nI added a version that avoids the double\
    \ `unique` calls.\n<|/ c |>\n<| c |>\nI like your solution, although I wonder\
    \ if there is a way to avoid the double `unique` calls.\n<|/ c |>\n<| c |>\nI\
    \ added a version that avoids the double `unique` calls.\n<|/ c |>\n<| a dscore=2\
    \ |>\nA solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\ndf[,\
    \ x := c(l1, l2)]\ndf[, y := c(l2, l1)]\ndf[x != y, .(common = x[y]), by = .(grp\
    \ = cumsum(x != y))]\n</code>\nwhich gives:\n\n<code>\n   grp common\n1:   1 \
    \    1\n2:   2     5\n3:   3    653\n</code>\n\nExplanation: \n\nsetDT converts\
    \ df to a data.table (which allows using := to assign new columns).\ndf[, x :=\
    \ c(l1, l2)] creates a new column x with the values of l1 and l2 concatenated\
    \ (as suggested by David Arenburg).\ndf[, y := c(l2, l1)] creates a new column\
    \ y with the values of l2 and l1 concatenated (as suggested by David Arenburg).\n\
    df[x != y, .(common = x[y]), by = .(grp = cumsum(x != y))] creates a new column\
    \ common with the values of common of l1 and l2 concatenated (as suggested by\
    \ David Arenburg).\n<|/ a tags=r |>\n<| a |>\nHere's a base R solution:\n<code>\n\
    x <- c(1, 4, 3, 34, 653, 2, 5)\ny <- c(5, 7, 1, 5, 9, 653, 121)\n</code>\nFirst,\
    \ create a vector that contains the unique values of x and y:\n<code>\nu <- unique(c(x,\
    \ y))\n</code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list |>\n<| c |>\nThis doesn't seem to work\
    \ if the lists are of different lengths. For example: `common(c(1,2,3), c(1,2))`\
    \ returns `[1] 1 2` instead of `[1] 1 3`.\n<|/ c |>\n<| c |>\nYes, I noticed that\
    \ after I posted my comment. I've updated my answer accordingly.\n<|/ c |>\n<|\
    \ c |>\nThanks for your answer! I ended up using something similar, but I used\
    \ `intersect` instead of `unique`\n<|/ c |>\n<| a tags=r,list |>\nThis should\
    \ work:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2\
    \ |>\nHere is a simple solution that works with different lengths of lists:\n\
    <code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n<| a tags=r,list |>\n\
    I came up with a solution using intersect:\n<code>\ncommon <- function(l1, l2)\
    \ {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  intersect(u1, u2)\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,list |>\nI came up with a solution\
    \ using intersect:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  intersect(u1, u2)\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list\
    \ |>\n<| a dscore=1 |>\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c",
  "\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nThanks for the answer. Your code works perfectly for small lists, but for\
    \ large lists it takes too long to run. Is there a way to speed it up?\n<|/ c\
    \ |>\n<| c |>\nI added a faster version. Let me know if it works for you.\n<|/\
    \ c |>\n<| c |>\nThanks for the answer. Your code works perfectly for small lists,\
    \ but for large lists it takes too long to run. Is there a way to speed it up?\n\
    <|/ c |>\n<| c |>\nI added a faster version. Let me know if it works for you.\n\
    <|/ c |>\n<| c |>\nThanks for the answer. Your code works perfectly for small\
    \ lists, but for large lists it takes too long to run. Is there a way to speed\
    \ it up?\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\ndt <- data.table(x = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,15",
  "\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2] <- NA\n  u1[is.na(u1)] <- NA\n  u1[is.na(u2)]\
    \ <- NA\n  return(u1)\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nThis doesn't\
    \ seem to work. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\
    \ returns `list(1, 5, 653)` instead of `list(1, 5, 653, 34)`\n<|/ c |>\n<| c |>\n\
    It does work. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\
    \ returns `list(1, 5, 653, 34)`\n<|/ c |>\n<| c |>\nOh I see what you mean. Sorry\
    \ I misunderstood your question. I'll edit my answer.\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to include a function that will do what you want. Let me know if that\
    \ works for you.\n<|/ c |>\n<| c |>\nI edited my answer to include a function\
    \ that will do what you want. Let me know if that works for you.\n<|/ c |>\n<|\
    \ a tags=r,sorting |>\nThis should work:\n<code>\ncommon = function(l1, l2) {\n\
    \  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2] <- NA\n  u1[is.na(u1)] <- NA\n  u1[is.na(u2)]\
    \ <- NA\n  return(u1)\n}\n</code>\n<|/ a dscore=0 |>\n<| c |>\nThis doesn't seem\
    \ to work. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns\
    \ `list(1, 5, 653)` instead of `list(1, 5, 653, 34)`\n<|/ c |>\n<| c |>\nI edited\
    \ my answer to include a function that will do what you want. Let me know if that\
    \ works for you.\n<|/ c |>\n<| a dscore=0 |>\n<code>\ncommon = function(l1, l2)\
    \ {\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nI like the idea of using sets to get unique elements. However, this doesn't\
    \ seem to work if the two lists have different lengths. For example, if `l1 =\
    \ c(1,2,3); l2 = c(1,2,3,4,5)`, then `common(l1, l2)` returns `list(1, 2, 3, 4,\
    \ 5)` instead of `list(1, 2, 3, 4)`.\n<|/ c |>\n<| c |>\n, thanks for pointing\
    \ that out. I fixed the code by adding `u1[u2 != u1]` at the end.\n<|/ c |>\n\
    <| a dscore=3 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5)))\nsetkey(setDT(list(l2=c(1,2,3,4,5))),\
    \ l2)\nsetkey(setDT(list(l1=c(1,2,3))), l1)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5))),\
    \ l1, l2)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5))), l2, l1)\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2,3,4,5))), l1, l2, l3)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5))),\
    \ l2, l1, l3)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5))), l1, l2, l3, l4)\n\
    setkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5))), l2, l1, l3, l4)\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2,3,4,5))), l1, l2, l3, l4, l5)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5))),\
    \ l2, l1, l3, l4, l5)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5))), l2, l1,\
    \ l3, l4, l5, l6)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5))), l2, l1, l3,\
    \ l4, l5, l6)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3,4,5))), l2, l1, l", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 %in% u1]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a dscore=1 |>\n<code>", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI like your use of setdiff, but I think it can be simplified to\
    \ `u1[!u2 %in% u1]`\n<|/ c |>\n<| c |>\nYes, that would work as well. I'm more\
    \ used to `setdiff` because I tend to think of sets as unordered and `setdiff`\
    \ makes more sense to me. I'll edit the answer to reflect that.\n<|/ c |>\n<|\
    \ c |>\nI like your use of setdiff, but I think it can be simplified to `u1[!u2\
    \ %in% u1]`\n<|/ c |>\n<| c |>\nI like your use of setdiff, but I think it can\
    \ be simplified to `u1[!u2 %in% u1]`\n<|/ c |>\n<| c |>\nI like your use of setdiff,\
    \ but I think it can be simplified to `u1[!u2 %in% u1]`\n<|/ c |>\n<| a |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\ndf[, setdiff(names(df),\
    \ names(df[, names(df) != \"id\"])), by = id]\n</code>\n<|/ a tags=r,dataframe,list\
    \ dscore=2 |>\n<| c |>\nI like your use of setdiff, but I think it can be simplified\
    \ to `df[, setdiff(names(df), names(df[, names(df) != \"id\"])), by = id]`\n<|/\
    \ c |>\n<| a tags=r,dataframe,list |>\nHere's a solution using base R:\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nI like this solution, but I wonder if there is a way\
    \ to make it more efficient? It seems like it would be O(n^2) to sort and then\
    \ O(n) to find common elements. Is there a way to do this in O(n)?\n<|/ c |>\n\
    <| c |>\n: Yes, you can do it in O(n) by using a hash table. I'll post an answer\
    \ in a minute.\n<|/ c |>\n<| c |>\n: I added a hash table solution to the answer.\n\
    <|/ c |>\n<| c |>\n: I added a hash table solution to the answer.\n<|/ c |>\n\
    <| c |>\n: I added a hash table solution to the answer.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(a = c(1,4,3,34,653,2,5), b = c(5,7,1,5,9,653,121))\ndt[, .(common\
    \ = unique(c(a, b))), by = a]\n</code>\n<|/ a tags=r,unique,list |>\n<| c |>\n\
    I like this solution, but I wonder if there is a way to make it more efficient?\
    \ It seems like it would be O(n^2) to sort and then O(n) to find common elements.\
    \ Is there a way to do this in O(n)?\n<|/ c |>\n<| c |>\n: I added a hash table\
    \ solution to the answer.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution using\
    \ base R:\n<code>\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\nz <- sort(union(x,y))\n\
    z[duplicated(z)]", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n \
    \ u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks so much for this!\
    \ I added a small modification to it that would allow me to sort by multiple columns.\
    \ I added a comment to the original post to show what I did.\n<|/ c |>\n<| a tags=r,sorting\
    \ |>\nI modified the code from to allow sorting by multiple columns. I added a\
    \ comment to the original post to show what I did.\n<code>", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI like your solution, but I wonder if there is a way\
    \ to avoid the sorting and unique steps. I wonder if there is a way to do this\
    \ without sorting and unique.\n<|/ c |>\n<| c |>\nI added a solution without sorting\
    \ and unique.\n<|/ c |>\n<| c |>\nI like your solution, but I wonder if there\
    \ is a way to avoid the sorting and unique steps. I wonder if there is a way to\
    \ do this without sorting and unique.\n<|/ c |>\n<| c |>\nI added a solution without\
    \ sorting and unique.\n<|/ c |>\n<| a dscore=1 |>\nHere's a solution without sorting\
    \ and unique:\n<code>\ncommon <- function(l1, l2) {\n  u <- union(l1, l2)\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a tags=r,unique,sorting |>\n<| c |>\nI like your solution, but\
    \ I wonder if there is a way to avoid the sorting and unique steps. I wonder if\
    \ there is a way to do this without sorting and unique.\n<|/ c |>\n<| c |>\nI\
    \ added a solution without sorting and unique.\n<|/ c |>\n<| a tags=r,unique,sorting\
    \ |>\nHere's a solution without sorting and unique:\n<code>\ncommon <- function(l1,\
    \ l2) {\n  u <- union(l1, l2)\n  u[!duplicated(u)]\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a dscore=0 |>\nHere's a solution without sorting and unique:\n<code>\n\
    common <- function(l1, l2) {\n  u <- union(l1, l2)\n  u[!duplicated(u)]\n}\n</code>\n\
    <|/ a tags=r,unique,sorting |>\n<| c |>\nI like your solution, but I wonder if\
    \ there is a way to avoid the sorting and unique steps. I wonder if there is a\
    \ way to do this without sorting and unique.\n<|/ c |>\n<| c |>\nI added a solution\
    \ without sorting and unique.\n<|/ c |>\n<| a dscore=0 |>\nHere's a solution without\
    \ sorting and unique:\n<code>\ncommon <- function(l1, l2) {\n  u <- union(l1,\
    \ l2)\n  u", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n\
    \  u[!duplicated(u)]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work\
    \ if there are repeated elements in the lists.\n<|/ c |>\n<| c |>\nThis doesn't\
    \ work if there are repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt does\
    \ work if there are repeated elements in the lists. I tested it before posting\
    \ it.\n<|/ c |>\n<| c |>\nIt does work if there are repeated elements in the lists.\
    \ I tested it before posting it.\n<|/ c |>\n<| c |>\nIt does work if there are\
    \ repeated elements in the lists. I tested it before posting it.\n<|/ c |>\n<|\
    \ a dscore=3 |>\n<code>\nlibrary(data.table)\nsetDT(list(l1=c(1, 4, 3, 34, 653,\
    \ 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1=c(1, 4, 3, 34,\
    \ 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\n</code>\n<|/ a tags=list,r\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nIt does work if there are repeated elements in the lists. I\
    \ tested it before posting it.\n<|/ c |>\n<| c |>\nIt does work if there are repeated\
    \ elements in the lists. I tested it before posting it.\n<|/ c |>\n<| c |>\nIt\
    \ does work if there are repeated elements in the lists. I tested it before posting\
    \ it.\n<|/ c |>\n<| c |>\nIt does work if there are repeated elements in the lists.\
    \ I tested it before posting it.\n<|/ c |>\n<| a |>\n<code>\n> x <- list(l1=c(1,\
    \ 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(l1=c(1, 4,\
    \ 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))\n> z <- list(l1=c(1, 4, 3,\
    \ 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))\n> x <- sort(x)\n> y <- sort(y)\n\
    > z <- sort(z)\n> x\n[[1]]\n[1] 1 4 3 34 65", "\n  u1 <- unique(c(l1, l2))\n \
    \ u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  l1 <- sort(l1)\n  l2 <-\
    \ sort(l2)\n  i <- 0\n  j <- 0\n  res <- list()\n  while (i + j < length(l1) &&\
    \ j + i < length(l2)) {\n    if (l1[i] == l2[j]) {\n      res[[i]] <- l1[i]\n\
    \      i <- i + 1\n    } else {\n      res[[i]] <- l2[j]\n      j <- j + 1\n \
    \   }\n  }\n  return(res)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks for your\
    \ answer. Your code works fine for small lists, but for larger lists it takes\
    \ too long. Do you know a faster solution?\n<|/ c |>\n<| c |>\nI added a faster\
    \ solution\n<|/ c |>\n<| c |>\nThanks for your answer. Your code works fine for\
    \ small lists, but for larger lists it takes too long. Do you know a faster solution?\n\
    <|/ c |>\n<| c |>\nI added a faster solution\n<|/ c |>\n<| c |>\nThanks for your\
    \ answer. Your code works fine for small lists, but for larger lists it takes\
    \ too long. Do you know a faster solution?\n<|/ c |>\n<| a tags=r |>\n<code>\n\
    library(data.table)\nlibrary(dplyr)\nlibrary(tidyr)\n", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  l1[duplicated(l1) | duplicated(l2, fromLast = TRUE)] \n}\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if `l1` is longer than\
    \ `l2`. `common(c(1,2,3), c(1,2,3))` returns `[1] 1 2 3`, but `common(c(1,2,3),\
    \ c(1,2,4,5))` returns `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nThanks, I fixed the bug.\
    \ Now it works as expected.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\ndf[, common:=Reduce(intersect,\
    \ lapply(.SD, unique)), by=V1]\ndf[, common:=lapply(common, unique), by=V1]\n\
    </code>\nThe first line creates a data.table with one column V1 containing the\
    \ unique values of each of the columns in df. The second line creates a data.table\
    \ with one column V1 containing the unique values of common from each of the columns\
    \ in df. The third line creates a data.table with one column V1 containing the\
    \ unique values of common from each of the columns in df. The fourth line creates\
    \ a data.table with one column V1 containing the unique values of common from\
    \ each of the columns in df. The fifth line creates a data.table with one column\
    \ V1 containing the unique values of common from each of the columns in df. The\
    \ sixth line creates a data.table with one column V1 containing the unique values\
    \ of common from each of the columns in df. The seventh line creates a data.table\
    \ with one column V1 containing the unique values of common from each of the columns\
    \ in df. The eighth line creates a data.table with one column V1 containing the\
    \ unique values of common from each of the columns in df. The ninth line creates\
    \ a data.table with one column V1 containing the unique values of common from\
    \ each of the columns in df. The tenth line creates a data.table with one column\
    \ V1 containing the unique values of common from each of the columns in df. The\
    \ eleventh line creates a data.table with one column V1 containing the unique\
    \ values of common from each of the columns in df. The twelfth line creates a\
    \ data.table with one column V1 containing the unique values of common from each\
    \ of the columns in df. The thirteenth line creates a data.table with one column\
    \ V1 containing the unique values of common from each of the columns in df. The\
    \ fourteenth line creates a data.table with one column V1 containing the unique\
    \ values of common from each of the columns in df. The fifteenth line creates\
    \ a ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThis doesn't seem to work if there are repeated\
    \ elements in the lists.\n<|/ c |>\n<| c |>\nYes, it does. Try it out with `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. Try it out with `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9,\
    \ 653, 121))`.\n<|/ c |>\n<| c |>\nYes, it does. Try it out with `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. Try it out with `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9,\
    \ 653, 121))`.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\nsetDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5,\
    \ 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2\
    \ = c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\nsetkey(setDT(list(l1 = c(1, 4, 3, 34,\
    \ 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l2, l1)\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't seem to work if there are repeated elements in the\
    \ lists.\n<|/ c |>\n<| c |>\nYes, it does. Try it out with `setDT(list(l1 = c(1,\
    \ 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))`.\n<|/ c |>\n<| c |>\n\
    Yes, it does. Try it out with `setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 =\
    \ c(5, 7, 1, 5, 9, 653, 121)))`.\n<|/ c |>\n<| c |>\nYes, it does. Try it out\
    \ with `setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653,\
    \ 121)))", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 ==\
    \ u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer! I really\
    \ like the idea of using sets to do this, but I ran into a problem when trying\
    \ to implement it. I've added my code to the original question. Thanks again!\n\
    <|/ c |>\n<| c |>\nI added a solution that uses `sets` instead of `data.table`\n\
    <|/ c |>\n<| c |>\nThanks again! I really like the idea of using sets to do this,\
    \ but I ran into a problem when trying to implement it. I've added my code to\
    \ the original question. Thanks again!\n<|/ c |>\n<| c |>\nI added a solution\
    \ that uses `sets` instead of `data.table`\n<|/ c |>\n<| a dscore=1 |>\nI like\
    \ using data.table for these types of problems. Here's a solution using data.table:\n\
    <code>\nlibrary(data.table)", "\n  u1 <- sort(unique(c(l1, l2)), decreasing =\
    \ TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r,list,sorting |>\n<| c |>\nThis doesn't seem to work if\
    \ there are repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt does work if\
    \ there are repeated elements in the lists. Try it out. `common(c(1, 4, 3, 34,\
    \ 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`.\n<|/ c |>\n\
    <| c |>\nYes, it works. I tested it before posting my comment. Thanks.\n<|/ c\
    \ |>\n<| c |>\nI tested it again and it doesn't work. Try it with `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`. `common(c(1, 4, 3, 34, 653,\
    \ 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`.\n<|/ c |>\n<|\
    \ c |>\nI tested it again and it doesn't work. Try it with `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`. `common(c(1, 4, 3, 34, 653, 2,\
    \ 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`.\n<|/ c |>\n<| a\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\n</code>\n\
    <|/ a dscore=2 tags=r,list,sorting |>\n<| a tags=r,list,sorting |>\nHere's a solution\
    \ using base R:\n<code>\ncommon = function(l1, l2) {\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,list,sorting |>\n\
    Here's a solution using base R:\n<code>\ncommon = function(l1, l2) {\n  u1 <-\
    \ sort(unique(c(l1, ", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1,\
    \ l2))\n  u <- u[!duplicated(u)]\n  u\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,list,unique\
    \ |>\nHere is a solution using base R:\n<code>", "\n  l1 <- sort(l1)\n  l2 <-\
    \ sort(l2)\n  i <- 0\n  j <- 0\n  res <- list()\n  while (i + j < length(l1) &&\
    \ j + i < length(l2)) {\n    if (l1[i] == l2[j]) {\n      res[[i]] <- l1[i]\n\
    \      i <- i + 1\n    } else {\n      res[[i]] <- l2[j]\n      j <- j + 1\n \
    \   }\n  }\n  return(res)\n}\n</code>\n<|/ a tags=r,list,merge |>\n<| c |>\nI\
    \ like the idea of using an index variable, but this doesn't seem to work if there\
    \ are duplicates in either list. For example, if `l1 = c(1, 4, 3, 34, 653, 2,\
    \ 5)` and `l2 = c(5, 7, 1, 5, 9, 653, 121)`, then `common(l1, l2)` returns `list(1,\
    \ 5, 653)` instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\nYes, I agree\
    \ with you. My code assumes that there are no duplicates in either list. I'll\
    \ try to fix it.\n<|/ c |>\n<| c |>\nI fixed my code. Now it works with duplicates\
    \ in either list.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\nsetDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5,\
    \ 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2\
    \ = c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\nl1[l2]\n</code>\n<|/ a tags=r,list,merge\
    \ |>\n<| c |>\nThis doesn't seem to work if there are duplicates in either list.\
    \ For example, if `l1 = c(1, 4, 3, 34, 653, 2, 5)` and `l2 = c(5, 7, 1, 5, 9,\
    \ 653, 121)`, then `l1[l2]` returns `list(1, 5, 653)` instead of `list(1, 5, 653,\
    \ 121)`.\n<|/ c |>\n<| c |>\nI fixed my code. Now it works with duplicates in\
    \ either list.\n<|/ c |>\n<| a tags=r,list,merge |>\nHere's a solution using base\
    \ R:\n<code>\nl1 <- c(1, 4, 3, 34, 653, 2, 5)\nl2 <- c(5, 7, 1, 5, 9, 653, 121)\n",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r,list |>\n<| c |>\nThanks so much! I didn't know about `intersect`\
    \ before. Very helpful.\n<|/ c |>\n<| c |>\n`intersect` doesn't work when there\
    \ are duplicates in the lists. `intersect(list(c(1,2), c(1,2)), list(c(1,2), c(1,3)))`\
    \ returns `list()` instead of `c(1,2)`.\n<|/ c |>\n<| c |>\nYes, that's true.\
    \ `intersect` doesn't work when there are duplicates in the lists. `intersect(list(c(1,2),\
    \ c(1,2)), list(c(1,2), c(1,3)))` returns `list()` instead of `c(1,2)`.\n<|/ c\
    \ |>\n<| a tags=r,list |>\nHere is a solution using base R:\n<code>", "\n  u1\
    \ <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)),\
    \ decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    Thanks for your answer. Your code works well for small lists, but for large lists\
    \ it takes too long to compute.\n<|/ c |>\n<| c |>\nI added a version that uses\
    \ `data.table` which should be faster for large lists.\n<|/ c |>\n<| c |>\nThanks\
    \ for your answer. Your code works well for small lists, but for large lists it\
    \ takes too long to compute.\n<|/ c |>\n<| c |>\nI added a version that uses `data.table`\
    \ which should be faster for large lists.\n<|/ c |>\n<| a dscore=1 |>\nHere's\
    \ a data.table solution:\n<code>\nlibrary(data.table)\ndt <- data.table(x = c(1,4,3,34,653,5,7,1,5,9,653,121))\n\
    dt[, y := c(5,7,1,5,9,653,121)]\ndt[, z := c(5,7,1,5,9,653,121)]\ndt[, y := sort(y,\
    \ decreasing = TRUE)]\ndt[, z := sort(z, decreasing = TRUE)]\ndt[, x := NULL]\n\
    dt[, z := NULL]\ndt[, y := unique(y)]\ndt[, z := unique(z)]\ndt\n</code>\n<|/\
    \ a tags=r,list,unique,sorting |>\n<| c |>\nThanks for your answer. Your code\
    \ works well for small lists, but for large lists it takes too long to compute.\n\
    <|/ c |>\n<| a tags=r,list,unique,sorting |>\n<code>", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThanks for your answer! I tested it and it works perfectly! I really\
    \ appreciate your help!\n<|/ c |>\n<| c |>\nGlad it helped! I added a benchmark\
    \ comparison to my answer.\n<|/ c |>\n<| a dscore=0 |>\nI wrote a function to\
    \ do this, which I believe is more efficient than using setdiff or intersect:\n\
    <code>\ncommon_elements <- function(list1, list2) {\n  list1 <- sort(list1)\n\
    \  list2 <- sort(list2)\n  list3 <- list1[list2 != list1]\n  list4 <- list2[list1\
    \ != list2]\n  list5 <- list3[list4 != list3]\n  list6 <- list4[list3 != list4]\n\
    \  list7 <- list5[list4 != list5]\n  list8 <- list6[list5 != list6]\n  list9 <-\
    \ list7[list6 != list7]\n  list10 <- list8[list7 != list8]\n  list11 <- list9[list8\
    \ != list9]\n  list12 <- list10[list9 != list10]\n  list13 <- list11[list10 !=\
    \ list11]\n  list14 <- list12[list11 != list12]\n  list15 <- list13[list12 !=\
    \ list13]\n  list16 <- list14[list13 != list14]\n  list17 <- list15[list14 !=\
    \ list15]\n  list18 <- list16[list15 != list16]\n  list19 <- list17[list16 !=\
    \ list17]\n  list20 <- list19[list17 != list18]\n  list21 <- list20[list18 !=\
    \ list19]\n  list22 <- list21[list19 != list20]\n  list23 <- list22[list20 !=\
    \ list21]\n  list24 <- list23[list21 != list22]\n  list25 <- list24[list22 !=\
    \ list23]\n  list26 <- list25[list23 != list24]\n  list27 <- list26[list24 !=\
    \ list25]\n  list", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to make it more efficient by avoiding `unique`?\n\
    <|/ c |>\n<| c |>\nI guess you could do something like `u1 <- sort(c(l1, l2))`\
    \ and `u2 <- sort(c(l2, l1))` and then `u1[u2 != u1]`\n<|/ c |>\n<| c |>\nYes,\
    \ that would work, but then you'd have to sort them twice. Not sure if that's\
    \ a big deal, but it's something to consider.\n<|/ c |>\n<| c |>\nYes, I agree\
    \ with you. Sorting twice is definitely not ideal. I'll see if I can think of\
    \ something better.\n<|/ c |>\n<| c |>\nI added a solution that avoids sorting.\n\
    <|/ c |>\n<| a dscore=3 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(a = c(1,4,3,34,653,5,7,1,5,9,653,121), \n                 b =\
    \ c(5,7,1,5,9,653,121,3,2,8,2,1))\ndt[, c := unique(c(a, b)), by = a]\ndt[, d\
    \ := unique(c(a, b)), by = b]\ndt[, e := unique(c(a, b)), by = c]\ndt[, f := unique(c(a,\
    \ b)), by = c]\ndt[, g := unique(c(a, b)), by = c]\ndt[, h := unique(c(a, b)),\
    \ by = c]\ndt[, i := unique(c(a, b)), by = c]\ndt[, j := unique(c(a, b)), by =\
    \ c]\ndt[, k := unique(c(a, b)), by = c]\ndt[, l := unique(c(a, b)), by = c]\n\
    dt[, m := unique(c(a, b)), by = c]\ndt[, n := unique(c(a, b)), by = c]\ndt[, o\
    \ := unique(c(a, b)), by = c]\ndt[, p := unique(c(a, b)), by = c]\ndt[, q := unique(c(a,\
    \ b)), by = c]\ndt[, r := unique(c(a, b)), by = c]\ndt[, s := unique(c(a, b)),\
    \ by = c]\ndt[, t := unique(c(a, b)), by = c", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThanks for your answer. Your solution works perfectly for my example,\
    \ but when I run it on my real data set I get the following error: `Error in sort.list(y)\
    \ : 'x' must be atomic for 'sort.list'\nHave you called 'sort' on a list?`\n<|/\
    \ c |>\n<| c |>\nI added the code I used to create the data set in the original\
    \ question.\n<|/ c |>\n<| c |>\nI added the code I used to create the data set\
    \ in the original question.\n<|/ c |>\n<| c |>\nI added the code I used to create\
    \ the data set in the original question.\n<|/ c |>\n<| c |>\nI added the code\
    \ I used to create the data set in the original question.\n<|/ c |>\n<| a |>\n\
    Here's a solution using data.table:\n<code>\nlibrary(data.table)", "\n  l1 <-\
    \ sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer. Your solution is very elegant\
    \ and works perfectly. I'm going to accept it as the answer but I'm also going\
    \ to add my own answer that uses `data.table` as suggested by and that also works\
    \ perfectly.\n<|/ c |>\n<| a dscore=1 |>\nHere is a solution using data.table:\n\
    <code>\nlibrary(data.table)\ndt <- data.table(x = c(1,4,3,34,653,5,7,1,5,9,653,121))\n\
    dt[, y := c(5,7,1,5,9,653,121)]\ndt[, y := sort(y)]\ndt[, y := unique(y)]\ndt[,\
    \ y := y[!duplicated(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\n\
    dt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[,\
    \ y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y\
    \ := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y :=\
    \ y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\n\
    dt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[,\
    \ y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y\
    \ := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := y[!is.na(y)]]\ndt[, y := ",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks for your answer. Your solution works perfectly\
    \ for my case. However I still don't understand why my solution doesn't work.\
    \ Could you please explain why my solution doesn't work?\n<|/ c |>\n<| c |>\n\
    I added a comment to the question to explain why my solution doesn't work. Hope\
    \ that helps.\n<|/ c |>\n<| c |>\nThanks for your explanation. Now I understand\
    \ why my solution doesn't work. Your solution works perfectly for my case. However\
    \ I still don't understand why my solution doesn't work. Could you please explain\
    \ why my solution doesn't work?\n<|/ c |>\n<| c |>\nI added a comment to the question\
    \ to explain why my solution doesn't work. Hope that helps.\n<|/ c |>\n<| c |>\n\
    Thanks for your explanation. Now I understand why my solution doesn't work. Your\
    \ solution works perfectly for my case. However I still don't understand why my\
    \ solution doesn't work. Could you please explain why my solution doesn't work?\n\
    <|/ c |>\n<| a dscore=2 |>\nI thought I'd post my solution, since I couldn't find\
    \ anything that worked for me (maybe I missed something).\n<code>\nlibrary(dplyr)\n\
    library(purrr)\n\ncommon_elements <- function(x, y) {\n  x <- unique(x)\n  y <-\
    \ unique(y)\n  x %>% \n    map(~intersect(x, y)) %>% \n    reduce(intersect)\n\
    }\n</code>\n<|/ a tags=r,intersection,list |>\n<| c |>\nThanks for your answer.\
    \ Your solution works perfectly for my case. However I still don't understand\
    \ why my solution doesn't work. Could you please explain why my solution doesn't\
    \ work?\n<|/ c |>\n<| c |>\nI added a comment to the question to explain why my\
    \ solution doesn't work. Hope that helps.\n<|/ c |>\n<| a tags=r,intersection,list\
    \ |>\nI thought I'd post my solution, since I couldn't find anything that worked\
    \ for me (maybe I missed something).\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \ncommon_elements <- function(x, y) {\n  x <- unique(x)\n  y <- unique(y)\n  x\
    \ %>% \n    map(~interse", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem\
    \ to work if there are repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt\
    \ does work if there are repeated elements in the lists. Try it out. `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`.\n\
    <|/ c |>\n<| c |>\nI see what you're saying. I was thinking that the OP wanted\
    \ the common elements to be returned in order of the original lists. I guess I\
    \ misunderstood.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\nsetDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5,\
    \ 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5,\
    \ 7, 1, 5, 9, 653, 121))), l1, l2)\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2,\
    \ 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l2, l1)\nsetkey(setDT(list(l1=c(1, 4, 3,\
    \ 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l1, l2, l2)\nsetkey(setDT(list(l1=c(1,\
    \ 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l2, l1, l2)\nsetkey(setDT(list(l1=c(1,\
    \ 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l2, l1, l2, l1)\nsetkey(setDT(list(l1=c(1,\
    \ 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l2, l1, l2, l1, l2)\n\
    setkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))),\
    \ l2, l1, l2, l1, l2, l1)\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5,\
    \ 7, 1, 5, 9, 653, 121))), l2, l1, l2, l1, l2, ", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ c |>\nThanks for your answer. I've tried it and it works. But I still don't\
    \ understand why my code doesn't work. Could you please explain to me why my code\
    \ doesn't work?\n<|/ c |>\n<| c |>\nI added some explanation to the answer.\n\
    <|/ c |>\n<| c |>\nThanks for your explanation. I understand now. Your code works\
    \ because `unique` removes duplicated elements. But why my code doesn't work?\
    \ Could you please explain to me why my code doesn't work?\n<|/ c |>\n<| c |>\n\
    I added some explanation to the answer.\n<|/ c |>\n<| a tags=r,list |>\nThe reason\
    \ your code doesn't work is because you use unique to remove duplicates. unique\
    \ removes duplicated elements. So when you do \n<code>\nu1 <- unique(c(l1, l2))\n\
    u2 <- unique(c(l2, l1))\nu1[u2 != u1]\n</code>\nu1 has only unique elements and\
    \ u2 has only unique elements. So u1[u2 != u1] will always return an empty vector.\
    \ \nTo fix your code, you can do \n<code>\ncommon <- function(l1, l2) {\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I've tried it and it works.\
    \ But I still don't understand why my code doesn't work. Could you please explain\
    \ to me why my code doesn't work?\n<|/ c |>\n<| c |>\nI added some explanation\
    \ to the answer.\n<|/ c |>\n<| a dscore=1 |>\nThe reason your code doesn't work\
    \ is because you use unique to remove duplicates. unique removes duplicated elements.\
    \ So when you do \n<code>\nu1 <- unique(c(l1, l2))\nu2 <- unique(c(l2, l1))\n\
    u1[u2 != u1]\n</code>\nu1 has only unique elements and u2 has only unique elements.\
    \ So u1[u2 != u1] will always return an empty vector. \nTo fix your code, you\
    \ can do \n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique", "\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,unique\
    \ |>\nHere's a solution using base R:\n<code>", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n\
    \  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have repeated elements in the list. For\
    \ example, `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns\
    \ `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\n, thanks\
    \ for pointing that out. I've updated my answer to account for repeated elements.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution using base R:\n<code>",
  "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2, l1)))\n  u1[u1 ==\
    \ u2] # remove duplicates\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\n\
    I like the idea of using setdiff, but this doesn't work if there are duplicates\
    \ in the list. For example, `common(c(1,2,3), c(1,2,3))` returns `[1] 1 2`, but\
    \ should return `[1] 1 3`.\n<|/ c |>\n<| c |>\nI added a fix for that. Thanks!\n\
    <|/ c |>\n<| c |>\nI added a fix for that as well. Thanks!\n<|/ c |>\n<| c |>\n\
    I added a fix for that as well. Thanks!\n<|/ c |>\n<| a tags=r,list,unique |>\n\
    Here's a solution using base R:\n<code>", "\n  u1 <- sort(unique(c(l1, l2)), decreasing\
    \ = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution, but I wonder if\
    \ there is a way to make it more efficient. For example, `common(c(1,2,3,4,5,6,7,8,9,10),\
    \ c(5,6,7,8,9,10,11,12,13,14,15))` returns `list(1, 5, 6, 11, 12, 13, 14, 15)`,\
    \ but `common(c(1,2,3,4,5,6,7,8,9,10), c(5,6,7,8,9,10,11,12,13,14,15,16))` returns\
    \ `list(1, 5, 6, 11, 12, 13, 14, 15, 16)`. Is there a way to avoid this problem?\n\
    <|/ c |>\n<| c |>\nYes, you can do `u1[u1 != u2]` instead of `u1[u1 == u2]`\n\
    <|/ c |>\n<| c |>\nI added a more efficient solution that doesn't require sorting.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(df)\ndf[, x := .I]\ndf[, y := .I]\ndf[, z := .I]\ndf[, x := x + 1]\ndf[,\
    \ y := y + 1]\ndf[, z := z + 1]\ndf[, x := x - 1]\ndf[, y := y - 1]\ndf[, z :=\
    \ z - 1]\ndf[, x := x + 2]\ndf[, y := y + 2]\ndf[, z := z + 2]\ndf[, x := x -\
    \ 2]\ndf[, y := y - 2]\ndf[, z := z - 2]\ndf[, x := x + 3]\ndf[, y := y + 3]\n\
    df[, z := z + 3]\ndf[, x := x - 3]\ndf[, y := y - 3]\ndf[, z := z - 3]\ndf[, x\
    \ := x + 4]\ndf[, y := y + 4]\ndf[, z := z + 4]\ndf[, x := x - 4]\ndf[, y := y\
    \ - 4]\ndf[, z := z - 4]\ndf[, x := x + 5]\ndf[, y := y + 5]\ndf[, z := z + 5]\n\
    df[, x := x - 5]\ndf[, y := y - 5]\ndf[, z := z - 5]\ndf[, x := x + 6]\ndf[, y\
    \ := y + 6]\ndf[, z := z + 6]\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem\
    \ to work if there are duplicates in the lists. For example, `common(c(1,2,3),\
    \ c(1,2,3))` returns `[1] 1 2 3` instead of `[1] 1 3`.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. I added a note about that to the answer.\n<|/ c |>\n<| c |>\nI added\
    \ a note about that to the answer.\n<|/ c |>\n<| c |>\nI added a note about that\
    \ to the answer.\n<|/ c |>\n<| c |>\nI added a note about that to the answer.\n\
    <|/ c |>\n<| a tags=r |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ncommon_elements\
    \ <- function(l1, l2) {\n  l1 %>% \n    map(~intersect(l2, .)) %>% \n    reduce(intersect)\n\
    }\n\ncommon_elements(c(1,2,3), c(1,2,3))", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| c |>\nThis doesn't work if there are duplicates in the list. For example, `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\
    \ instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\n, thanks for pointing\
    \ that out. I fixed the code accordingly.\n<|/ c |>\n<| a tags=r,list,unique |>\n\
    <code>\n> x <- list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n>\
    \ y <- list(c(5, 3, 2, 8), c(3, 2))\n> \n> x <- unlist(x)\n> y <- unlist(y)\n\
    > \n> x <- unique(x)\n> y <- unique(y)\n> \n> x <- sort(x)\n> y <- sort(y)\n>\
    \ \n> x <- x[x %in% y]\n> y <- y[x %in% y]\n> \n> x\n[1] 1 5 653\n> y\n[1] 2 3\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\n<code>\nx <- list(c(1, 4, 3, 34,\
    \ 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\ny <- list(c(5, 3, 2, 8), c(3, 2))\n\
    \nx <- unlist(x)\ny <- unlist(y)\n\nx <- unique(x)\ny <- unique(y)\n\nx <- sort(x)\n\
    y <- sort(y)\n\nx <- x[x %in% y]\ny <- y[x %in% y]\n\nx\n[1] 1 5 653\ny\n[1] 2\
    \ 3\n</code>\n<|/ a tags=r,list,unique |>\n<| a |>\n<code>\nx <- list(c(1, 4,\
    \ 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\ny <- list(c(5, 3, 2, 8), c(3,\
    \ 2))\n\nx <- unlist(x)\ny <- unlist(y)\n\nx <- unique(x)\ny <- unique(y)\n\n\
    x <- sort(x)\ny <- sort(y)\n\nx <- x[x %in% y]\ny <- y[x %in% y]\n\nx\n[1] 1 5\
    \ 653\ny\n[1] 2 3\n</code>\n<|/ a tags=r,list,unique dscore=2 |>\n<| a tags=r,list,unique\
    \ |>\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  l1[duplicated(l1) | duplicated(l2,\
    \ fromLast = TRUE)] <- NA\n  l2[duplicated(l2) | duplicated(l1, fromLast = TRUE)]\
    \ <- NA\n  l1[is.na(l1)] <- l2[is.na(l2)]\n  l2[is.na(l2)] <- l1[is.na(l1)]\n\
    \  return(l1)\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,unique\
    \ |>\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't seem to work. `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\
    \ instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\nI fixed the bug and added\
    \ a test case. Thanks for pointing it out.\n<|/ c |>\n<| c |>\nI added a test\
    \ case to my answer.\n<|/ c |>\n<| c |>\nI added a test case to my answer.\n<|/\
    \ c |>\n<| c |>\nI added a test case to my answer.\n<|/ c |>\n<| a tags=r |>\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ncommon_elements <- function(l1, l2)\
    \ {\n  l1 %>% \n    map(~.x[.x == .y]) %>% \n    reduce(intersect) %>% \n    sort()\
    \ %>% \n    unique()\n}\n\ncommon_elements(c(1,4,3,34,653,2,5), c(5,7,1,5,9,653,121))",
  "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a package for this. It\
    \ also has some nice features like the ability to sort by multiple columns and\
    \ also the ability to filter by multiple columns. \n<code>\nlibrary(dplyr)\nlibrary(tidyr)\n",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you have two lists\
    \ with different lengths.\n<|/ c |>\n<| c |>\nIt works if you add `u1[u2 != u1]`\
    \ to the end of the function.\n<|/ c |>\n<| c |>\nI added a version that works\
    \ with different lengths.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ different lengths.\n<|/ c |>\n<| c |>\nI added a version that works with different\
    \ lengths.\n<|/ c |>\n<| a dscore=5 |>\nHere's a solution using purrr::map2\n\
    <code>\nlibrary(purrr)\n\nlist1 <- list(a = 1, b = 2, c = 3)\nlist2 <- list(a\
    \ = 1, b = 2, c = 4, d = 5)\n\nmap2(list1, list2, function(x, y) x[y])", "\n \
    \ u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nI like your use of setdiff. Very clever!\n\
    <|/ c |>\n<| c |>\nI like your use of setdiff. Very clever!\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a solution using setdiff and intersect:\n<code>\n> setdiff(list(c(1,4,3,34,653,2),c(5,7,1,5,9,653,121)),list(c(5,3,2,8)))\n\
    [1]  1  5 653\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nI like your use\
    \ of setdiff. Very clever!\n<|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution\
    \ using setdiff and intersect:\n<code>\n> setdiff(list(c(1,4,3,34,653,2),c(5,7,1,5,9,653,121)),list(c(5,3,2,8)))\n\
    [1]  1  5 653\n</code>\n<|/ a dscore=3 |>\n<| a dscore=3 |>\nHere's a solution\
    \ using setdiff and intersect:\n<code>\nsetdiff(list(c(1,4,3,34,653,2),c(5,7,1,5,9,653,121)),list(c(5,3,2,8)))\n\
    </code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\nHere's a solution\
    \ using setdiff and intersect:\n<code>\nsetdiff(list(c(1,4,3,34,653,2),c(5,7,1,5,9,653,121)),list(c(5,3,2,8)))\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=r,list,unique |>\nHere's a solution using\
    \ setdiff and intersect:\n<code>\nsetdiff(list(c(1,4,3,34,653,2),c(5,7,1,5,9,653,121)),list(c(5,3,2,8)))\n\
    </code>\n<|/ a dscore=3 |>\n<| a tags=r,list,unique |>\nHere's a solution using\
    \ setdiff and intersect:\n<code>\nsetdiff(list(c(1,4,3,34,653,2),c(5,7,1,5,9,653,121)),list(c(5,3,2,8)))\n\
    </code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere's a solution using setdiff\
    \ and intersect:\n<code>\nsetdiff(list", "\n  u1 <- unique(c(l1, l2))\n  u2 <-\
    \ unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| c |>\nThis doesn't work if there are duplicates in either of the lists.\n<|/\
    \ c |>\n<| c |>\nIt does work if there are duplicates in either of the lists.\
    \ Try it yourself.\n<|/ c |>\n<| c |>\nIt doesn't work if there are duplicates\
    \ in either of the lists. Try it yourself.\n<|/ c |>\n<| c |>\nIt does work if\
    \ there are duplicates in either of the lists. Try it yourself.\n<|/ c |>\n<|\
    \ c |>\nIt does work if there are duplicates in either of the lists. Try it yourself.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| c |>\nThanks, this is very helpful. I'm still trying to wrap my head around\
    \ this code. Why does `u1` have to be unique? What does `%in%` do?\n<|/ c |>\n\
    <| c |>\n`%in%` checks whether one vector is a subset of the other. `u1` has unique\
    \ values because `unique` removes duplicates. `u2` has unique values because `unique`\
    \ removes duplicates. `u1 %in% u2` checks whether `u1` is a subset of `u2`.\n\
    <|/ c |>\n<| c |>\nI see. So `u1` has unique values because `unique` removes duplicates.\
    \ `u2` has unique values because `unique` removes duplicates. `u1 %in% u2` checks\
    \ whether `u1` is a subset of `u2`. But why does `u1` have to be unique?\n<|/\
    \ c |>\n<| c |>\n`u1` has unique values because `unique` removes duplicates. `u2`\
    \ has unique values because `unique` removes duplicates. `u1 %in% u2` checks whether\
    \ `u1` is a subset of `u2`. But why does `u1` have to be unique?\n<|/ c |>\n<|\
    \ c |>\n`u1` has unique values because `unique` removes duplicates. `u2` has unique\
    \ values because `unique` removes duplicates. `u1 %in% u2` checks whether `u1`\
    \ is a subset of `u2`. But why does `u1` have to be unique?\n<|/ c |>\n<| a tags=r,unique,list\
    \ |>\nA solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <-\
    \ unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| a dscore=0 |>\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks for your\
    \ answer! I ran your function on two lists with 1000 elements and it took about\
    \ 5 seconds. I ran it on two lists with 10000 elements and it took about 30 seconds.\
    \ I ran it on two lists with 100000 elements and it took about 45 seconds. I ran\
    \ it on two lists with 1000000 elements and it took about 60 seconds. I ran it\
    \ on two lists with 10000000 elements and it took about 90 seconds. I ran it on\
    \ two lists with 100000000 elements and it took about 120 seconds. I ran it on\
    \ two lists with 1000000000 elements and it took about 180 seconds. I ran it on\
    \ two lists with 10000000000 elements and it took about 240 seconds. I ran it\
    \ on two lists with 100000000000 elements and it took about 300 seconds. I ran\
    \ it on two lists with 1000000000000 elements and it took about 360 seconds. I\
    \ ran it on two lists with 10000000000000 elements and it took about 420 seconds.\
    \ I ran it on two lists with 100000000000000 elements and it took about 480 seconds.\
    \ I ran it on two lists with 1000000000000000 elements and it took about 540 seconds.\
    \ I ran it on two lists with 10000000000000000 elements and it took about 600\
    \ seconds. I ran it on two lists with 100000000000000000 elements and it took\
    \ about 660 seconds. I ran it on two lists with 100000000000000000 elements and\
    \ it took about 720 seconds. I ran it on two lists with 100000000000000000 elements\
    \ and it took about 780 seconds. I ran it on two lists with 100000000000000000\
    \ elements and it took about 840 seconds. I ran it on two lists with 100000000000000000\
    \ elements and it took about 880 seconds. I ran it on two lists with 100000000000000000\
    \ elements and it took about 920 seconds. I ran it on two lists with 100000000000000000\
    \ elements and it took about 980 seconds. I ran it on two lists with 100000000000000000\
    \ elements and it took about 1020 seconds. I ran it on two lists with 100000000000000000\
    \ elements and it took ", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  l1[duplicated(l1)\
    \ | duplicated(l2, fromLast = TRUE)] \n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to avoid the sorting\
    \ and just use unique to remove duplicates?\n<|/ c |>\n<| c |>\nYes, just use\
    \ `unique` instead of `sort` in the function.\n<|/ c |>\n<| c |>\nThis solution\
    \ doesn't work if there are NAs in the list. Try it with `c(NA,NA)` as the second\
    \ argument.\n<|/ c |>\n<| c |>\n, thanks for pointing that out. I've updated the\
    \ answer to account for that.\n<|/ c |>\n<| c |>\nThis solution doesn't work if\
    \ there are NAs in the list. Try it with `c(NA,NA)` as the second argument.\n\
    <|/ c |>\n<| a dscore=5 tags=r,list,unique |>\nA solution using lapply and unique:\n\
    <code>\nx <- list(c(1,2,3), c(4,5,6), c(7,8,9))\ny <- list(c(1,2,3), c(4,5,6),\
    \ c(7,8,9))\nz <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n\n> lapply(x, unique)\n\
    [[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n\n> lapply(y, unique)\n\
    [[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n\n> lapply(z, unique)\n\
    [[1]]\n[1] 1 2 3\n\n[[2]]\n[1] 4 5 6\n\n[[3]]\n[1] 7 8 9\n</code>\n<|/ a |>\n\
    <| c |>\nThis solution doesn't work if there are NAs in the list. Try it with\
    \ `c(NA,NA)` as the second argument.\n<|/ c |>\n<| c |>\nThis solution doesn't\
    \ work if there are NAs in the list. Try it with `c(NA,NA)` as the second argument.\n\
    <|/ c |>\n<| a dscore=5 |>\nHere is a solution using purrr::map2\n<code>\nx <-\
    \ list(c(1,2,3), c(4,5,6), c(7,8,9))\ny <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n\
    z <- list(c(1,2,3), c(4,5,6), c(7,8,", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n\
    \  l1 <- unique(l1)\n  l2 <- unique(l2)\n  l1 <- l1[-which(is.na(l1))]\n  l2 <-\
    \ l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n\
    \  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n\
    \  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n\
    \  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n\
    \  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n\
    \  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n\
    \  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n\
    \  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n\
    \  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n\
    \  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n\
    \  l2 <- l2[-which(is.na(l2))]\n  l1 <- l1[-which(is.na(l1))]\n  l2 <- l2[-which(is.na(l2))]\n\
    \  l1 ", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you have\
    \ multiple repeated elements in the list. For example, `common(c(1, 4, 3, 34,\
    \ 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)` instead of\
    \ `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\nYes, I see that now. I've added\
    \ a fix for that case.\n<|/ c |>\n<| a |>\n<code>\n> x <- c(1, 4, 3, 34, 653,\
    \ 2, 5)\n> y <- c(5, 7, 1, 5, 9, 653, 121)\n> \n> unique(c(x,y))\n[1] 1 5 653\
    \ 121\n</code>\n<|/ a tags=r,list,unique dscore=5 |>\n<| c |>\nThis doesn't work\
    \ if you have multiple repeated elements in the list. For example, `unique(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\
    \ instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\nThis doesn't work if\
    \ you have multiple repeated elements in the list. For example, `unique(c(1, 4,\
    \ 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)` instead\
    \ of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\nx <- c(1, 4,\
    \ 3, 34, 653, 2, 5)\ny <- c(5, 7, 1, 5, 9, 653, 121)\n</code>\nThe function unique\
    \ will remove duplicates. \n<code>\nunique(c(x,y))\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have multiple repeated elements in the\
    \ list. For example, `unique(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))` returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have multiple repeated elements in the list.\
    \ For example, `unique(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\
    \ returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| a ",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThis doesn't work if there are duplicates in either\
    \ list.\n<|/ c |>\n<| c |>\nYes, it does. I added a note about that to the answer.\n\
    <|/ c |>\n<| c |>\nI added a note about that to the answer.\n<|/ c |>\n<| c |>\n\
    This doesn't work if there are duplicates in either list. For example, `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\
    \ instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\nYes, it does. I added\
    \ a note about that to the answer.\n<|/ c |>\n<| a dscore=4 |>\n<code>\n> library(dplyr)\n\
    > x <- c(1,4,3,34,653,2,5)\n> y <- c(5,7,1,5,9,653,121)\n> common_elements <-\
    \ intersect(x, y)\n> common_elements\n[1] 1 5 653\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis doesn't work if there are duplicates in either list.\n<|/ c |>\n\
    <| c |>\nIt does work if there are duplicates in either list. For example, `common_elements\
    \ <- intersect(x, y)` returns `[1] 1 5 653` instead of `[1] 1 5 653 121`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. I added a note about that to the answer.\n<|/ c\
    \ |>\n<| a dscore=4 |>\n<code>\n> x <- c(1,4,3,34,653,2,5)\n> y <- c(5,7,1,5,9,653,121)\n\
    > common_elements <- intersect(x, y)\n> common_elements\n[1] 1 5 653\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThis doesn't work if there are duplicates in either\
    \ list.\n<|/ c |>\n<| c |>\nIt does work if there are duplicates in either list.\
    \ For example, `common_elements <- intersect(x, y)` returns `[1] 1 5 653` instead\
    \ of `[1] 1 5 653 121`.\n<|/ c |>\n<| a tags=r |>\n<code>\nx <- c(1,4,3,34,653,2,5)\n\
    y <- ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nI like this solution, but I believe it\
    \ can be improved by using setdiff() instead of intersect().\n<|/ c |>\n<| c |>\n\
    I believe that `setdiff` would return `NA` instead of `FALSE` when one of the\
    \ lists is empty.\n<|/ c |>\n<| c |>\n`setdiff` returns `NA` when the two lists\
    \ are empty. `intersect` returns `FALSE` when the two lists are empty.\n<|/ c\
    \ |>\n<| c |>\nYes, I see that now. Thanks for the clarification.\n<|/ c |>\n\
    <| a tags=r,intersection,list |>\n<code>\n> x <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n\
    > y <- list(c(4,5,6), c(7,8,9), c(1,2,3))\n> intersect(x, y)\n[[1]]\n[1] 4 5 6\n\
    \n[[2]]\n[1] 7 8 9\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if\
    \ you have more than two lists.\n<|/ c |>\n<| c |>\nThis doesn't work if you have\
    \ more than two lists.\n<|/ c |>\n<| a tags=r,intersection,list |>\n<code>\nintersect(list(c(1,2,3),\
    \ c(4,5,6), c(7,8,9)), list(c(4,5,6), c(7,8,9), c(1,2,3)))\n</code>\n<|/ a dscore=4\
    \ |>\n<| c |>\nThis doesn't work if you have more than two lists.\n<|/ c |>\n\
    <| a dscore=4 |>\n<code>\nintersect(list(c(1,2,3), c(4,5,6), c(7,8,9)), list(c(4,5,6),\
    \ c(7,8,9), c(1,2,3)))\n</code>\n<|/ a tags=r,intersection,list |>\n<| a tags=r,intersection,list\
    \ |>\n<code>\nintersect(list(c(1,2,3), c(4,5,6), c(7,8,9)), list(c(4,5,6), c(7,8,9),\
    \ c(1,2,3)))\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if you have\
    \ more than two lists.\n<|/ c |>\n<| a dscore=3 |>\n<code>\n> x <- list(c(1,2,3),\
    \ c(4,5,6), c(7,8,", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1,\
    \ l2))\n  u[!duplicated(u)]\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,list,unique\
    \ |>\n<code>\n> x <- list(c(1,4,3,34,653,2),c(5,7,1,5,9,653,121))\n> y <- list(c(5,3,2,8),c(3,2))\n\
    > \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem to work if there are duplicates\
    \ in the list. For example, `common(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2` instead\
    \ of `[1] 1 3`.\n<|/ c |>\n<| c |>\nI added a fix for that case.\n<|/ c |>\n<|\
    \ c |>\nI added a fix for that case.\n<|/ c |>\n<| a dscore=5 |>\nHere's a function\
    \ that will do what you want:\n<code>\nuncommon <- function(l1, l2) {\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 != u2]\n}\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem to work if there are duplicates\
    \ in the list. For example, `uncommon(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2`\
    \ instead of `[1] 1 3`.\n<|/ c |>\n<| c |>\nI added a fix for that case.\n<|/\
    \ c |>\n<| a dscore=5 |>\n<code>\nuncommon <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 != u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a tags=r,list,unique |>\n<code>\nuncommon <- function(l1, l2) {\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 != u2]\n}\n</code>\n\
    <|/ a dscore=4 |>\n<| c |>\nThis doesn't seem to work if there are duplicates\
    \ in the list. For example, `uncommon(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2`\
    \ instead of `[1] 1 3`.\n<|/ c |>\n<| a |>\n<code>\nuncommon <- function(l1, l2)\
    \ {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 != u2]\n}\n\
    </code>\n<|/ a tags=r,list,unique dscore=4 |>\n<| a tags=r,list,unique |>\n<code>\n\
    uncommon <- function(l1, l2) {\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u\
    \ <- unique(c(l1, l2))\n  u[!duplicated(u)]\n}\n</code>\n<|/ a dscore=5 |>\n<|\
    \ c |>\nI like this solution, but I wonder if there is a way to make it more efficient.\
    \ For example, `common(c(1,2,3,4,5), c(1,4,5,6,7))` returns `list(1, 4, 5)` but\
    \ `common(c(1,2,3,4,5), c(1,4,5,6,7,8))` returns `list(1, 4, 5)`.\n<|/ c |>\n\
    <| c |>\n, yes, I agree. `common(c(1,2,3,4,5), c(1,4,5,6,7,8))` returns `list(1,\
    \ 4, 5)` because `c(1,2,3,4,5)` has `1` twice. `c(1,4,5,6,7)` has `1` twice and\
    \ `c(1,4,5,6,7,8)` has `1` twice and `c(1,4,5,6,7)` has `1` twice and `c(1,4,5,6,7,8)`\
    \ has `1` twice and `c(1,4,5,6,7)` has `1` twice and `c(1,4,5,6,7,8)` has `1`\
    \ twice. `c(1,4,5,6,7)` has `1` twice and `c(1,4,5,6,7,8)` has `1` twice and `c(1,4,5,6,7)`\
    \ has `1` twice and `c(1,4,5,6,7,8)` has `1` twice and `c(1,4,5,6,7)` has `1`\
    \ twice and `c(1,4,5,6,7,8)` has `1` twice. `c(1,4,5,6,7)` has `1` twice and `c(1,4,5,6,7,8)`\
    \ has `1` twice and `c(1,4,5,6,7)` has `1` twice and `c(1,4,5,6,7,8)` has `1`\
    \ twice and `c(1,4,5,6,7)` has `1` twice and `c(1,4,5,6,7,8)` has `1` twice. `c(1,4,5,6,7)`\
    \ has `1` twice and `c(1,4,5,6,7,8)` has `1` twice and `c(1,4,5,6,7)` has `1`\
    \ twice and `c(1,4,5,6,7,8)` has `1` twice and `c(1,4,5,6,7)` has ", "\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you have two lists with\
    \ different lengths.\n<|/ c |>\n<| c |>\nIt works if you use the same length for\
    \ both lists. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\
    \ returns `list(1, 5, 653)`.\n<|/ c |>\n<| c |>\nYes, but if you have two lists\
    \ with different lengths, it returns `list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7,\
    \ 1, 5, 9, 653, 121))`\n<|/ c |>\n<| c |>\nYes, that's true. I missed that case.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n> x <- list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(c(5, 3, 2, 8),\
    \ c(3, 2))\n> Reduce(intersect, x)\n[1] 1 5 653\n> Reduce(intersect, y)\n[1] 2\
    \ 3\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\n`intersect` will also return\
    \ `NA` if the two lists are of different lengths.\n<|/ c |>\n<| c |>\n`intersect`\
    \ returns `NA` if the two lists are of different lengths. `Reduce(intersect, x)`\
    \ returns `[1] 1 5 653` and `Reduce(intersect, y)` returns `[1] 2 3`.\n<|/ c |>\n\
    <| c |>\n`Reduce(intersect, x)` returns `[1] 1 5 653` and `Reduce(intersect, y)`\
    \ returns `[1] 2 3` because `intersect` returns `NA` if the two lists are of different\
    \ lengths. `Reduce(intersect, list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9,\
    \ 653, 121)))` returns `[1] 1 5 653` and `Reduce(intersect, list(c(5, 3, 2, 8),\
    \ c(3, 2)))` returns `[1] 2 3`.\n<|/ c |>\n<| c |>\n`Reduce(intersect, list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)))` returns `[1] 1 5 653` and\
    \ `Reduce(intersect, list(c(5, 3, 2, 8), c(3, 2)))` returns `[1] 2 3` ", "\n \
    \ l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a dscore=4 |>\n<| c |>\nThis doesn't work if there are repeated\
    \ elements in the lists. For example, `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)` instead of `list(1, 5, 653,\
    \ 121)`.\n<|/ c |>\n<| c |>\nI added a version that works with repeated elements.\n\
    <|/ c |>\n<| c |>\nI added a version that works with repeated elements. I hope\
    \ you don't mind that I added a version that works with repeated elements.\n<|/\
    \ c |>\n<| c |>\nI added a version that works with repeated elements. I hope you\
    \ don't mind that I added a version that works with repeated elements.\n<|/ c\
    \ |>\n<| c |>\nI added a version that works with repeated elements. I hope you\
    \ don't mind that I added a version that works with repeated elements.\n<|/ c\
    \ |>\n<| a dscore=4 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(list(l1=c(1,4,3,34,653,2),\n           l2=c(5,7,1,5,9,653,121)))\nsetkey(setDT(list(l1=c(1,4,3,34,653,2),\n\
    \                  l2=c(5,7,1,5,9,653,121))),l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2),\n\
    \                  l2=c(5,7,1,5,9,653,121))),l2)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2),\n\
    \                  l2=c(5,7,1,5,9,653,121))),l1,l2)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2),\n\
    \                  l2=c(5,7,1,5,9,653,121))),l2,l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2),\n\
    \                  l2=c(5,7,1,5,9,653,121))),l1,l2,l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2),\n\
    \                  l2=c(5,7,1,5,9,653,121))),l2,l1,l2)\nsetkey(setDT(list(l1=c(1,",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique,intersection |>\n<| c |>\nThis doesn't seem to work if\
    \ there are duplicates in the lists.\n<|/ c |>\n<| c |>\nIt does work if there\
    \ are duplicates in the lists. Try it yourself.\n<|/ c |>\n<| c |>\nIt doesn't\
    \ work if there are duplicates in the lists. Try it yourself.\n<|/ c |>\n<| c\
    \ |>\nIt does work if there are duplicates in the lists. Try it yourself.\n<|/\
    \ c |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| a tags=r,list,unique,intersection |>\n<code>", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't seem to work if the lists are of different lengths.\n\
    <|/ c |>\n<| c |>\nI tested it and it works fine for different lengths. Please\
    \ provide an example where it doesn't work.\n<|/ c |>\n<| c |>\nI tested it and\
    \ it works fine for different lengths. Please provide an example where it doesn't\
    \ work.\n<|/ c |>\n<| c |>\nI tested it and it works fine for different lengths.\
    \ Please provide an example where it doesn't work.\n<|/ c |>\n<| c |>\nI tested\
    \ it and it works fine for different lengths. Please provide an example where\
    \ it doesn't work.\n<|/ c |>\n<| a tags=r,list,unique |>\nI came up with this\
    \ solution:\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n<| c |>\nThis doesn't seem\
    \ to work when there are duplicates in the list. For example: `common(c(1,2,2,3),\
    \ c(1,2,3))` returns `[1] 1 2 3` instead of `[1] 1 2 3`.\n<|/ c |>\n<| c |>\n\
    , you are right. I fixed the code. Thanks for pointing it out.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't seem to work when there are duplicates in the list. For example:\
    \ `common(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1] 1 2 3`.\n\
    <|/ c |>\n<| c |>\n, you are right. I fixed the code. Thanks for pointing it out.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work when there are duplicates in the\
    \ list. For example: `common(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3` instead\
    \ of `[1] 1 2 3`.\n<|/ c |>\n<| a tags=r,list |>\n<code>", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3\
    \ |>\n<| c |>\nI like the idea of using sets to avoid the O(n^2) complexity. Unfortunately,\
    \ the solution doesn't work for my case because I need the common elements to\
    \ be in order of the original lists. I edited my question to reflect this.\n<|/\
    \ c |>\n<| c |>\nI added a solution that works with your new requirements.\n<|/\
    \ c |>\n<| c |>\nI like the idea of using sets to avoid the O(n^2) complexity.\
    \ Unfortunately, the solution doesn't work for my case because I need the common\
    \ elements to be in order of the original lists. I edited my question to reflect\
    \ this.\n<|/ c |>\n<| c |>\nI added a solution that works with your new requirements.\n\
    <|/ c |>\n<| c |>\nI like your solution, but I realized that my example was too\
    \ simple. My actual problem is a bit more complicated and I realized that your\
    \ solution doesn't work because of the way I generate the lists. I edited my question\
    \ to reflect this.\n<|/ c |>\n<| a tags=r,list,sorting |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a tags=r,list,unique,intersection\
    \ |>\n<| c |>\nThis doesn't seem to work if the lists are of different lengths.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it with `c(1,2,3)` and `c(1,2,3,4,5)`.\n\
    <|/ c |>\n<| c |>\nIt does work. Try it with `c(1,2,3)` and `c(1,2,3,4,5)`. `common(c(1,2,3),\
    \ c(1,2,3,4,5))` returns `list(1, 2, 3)`.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ Yes, it does work. Try it with `c(1,2,3)` and `c(1,2,3,4,5)`. `common(c(1,2,3),\
    \ c(1,2,3,4,5))` returns `list(1, 2, 3)`.\n<|/ c |>\n<| c |>\nI see what you mean.\
    \ Yes, it does work. Try it with `c(1,2,3)` and `c(1,2,3,4,5)`. `common(c(1,2,3),\
    \ c(1,2,3,4,5))` returns `list(1, 2, 3)`.\n<|/ c |>\n<| a dscore=5 |>\n<code>\n\
    intersect(list1, list2)\n</code>\n<|/ a tags=r,list,unique,intersection |>\n<|\
    \ c |>\nThis doesn't seem to work if the lists are of different lengths.\n<|/\
    \ c |>\n<| c |>\nThis doesn't seem to work if the lists are of different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if the lists are of different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if the lists are of different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if the lists are of different lengths.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\nintersect(list1, list2)\n</code>\n<|/ a tags=r,list,unique,intersection\
    \ |>\n<| c |>\nThis doesn't seem to work if the lists are of different lengths.\n\
    <|/ c |>\n<| c |>\nThis doesn't seem to work if the lists are of different lengths.\n\
    <|/ c |>\n<| a tags=r,list,unique,intersection |>\n<code>\nintersect(list1, list2)\n\
    </code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't seem to work if the lists are\
    \ of different lengths.\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique,intersection |>\n\
    <| a tags=r,list,unique,intersection |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\nsetDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5,\
    \ 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l2=c(5, 7, 1, 5, 9, 653, 121))),\
    \ l2)\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5))), l1)\nsetkey(setDT(list(l1=c(1,\
    \ 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\n</code>\nThis\
    \ gives:\n<code>\n   l1 l2\n1:  1  5\n2:  4  7\n3:  3  1\n4: 34 653\n5: 653 121\n\
    </code>\n<|/ a dscore=2 |>\n<| c |>\nThis works well for small lists, but for\
    \ large lists it takes too long to run. Is there a way to speed it up?\n<|/ c\
    \ |>\n<| c |>\nI haven't tested it on large lists, but it seems that `setkey`\
    \ should be faster than `setDT`, so maybe try `setkey(setDT(list(l1=c(1, 4, 3,\
    \ 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l1, l2)`\n<|/ c |>\n<| c |>\n\
    This works very well for small lists, but for large lists it takes too long to\
    \ run. Is there a way to speed it up?\n<|/ c |>\n<| c |>\nI haven't tested it\
    \ on large lists, but it seems that `setkey` should be faster than `setDT`, so\
    \ maybe try `setkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5,\
    \ 9, 653, 121))), l1, l2)`\n<|/ c |>\n<| c |>\nI ran it on a large list and it\
    \ took about 30 seconds to run. Thanks!\n<|/ c |>\n<| a tags=r,list,unique,intersection\
    \ |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<|\
    \ a tags=r,sorting |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)",
  "\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to avoid the\
    \ double loop. Maybe `mapply` could help?\n<|/ c |>\n<| c |>\nI added a solution\
    \ using `mapply`.\n<|/ c |>\n<| c |>\nI added a solution using `mapply`.\n<|/\
    \ c |>\n<| c |>\nI added a solution using `mapply`.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\nHere's a solution using mapply and unique:\n<code>\nmapply(unique, list1,\
    \ list2)\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,list,unique |>\nHere's a solution\
    \ using sapply and unique:\n<code>\nsapply(list1, unique, list2)\n</code>\n<|/\
    \ a dscore=2 |>\n<| a dscore=1 |>\n<code>\nlist1 <- list(c(1, 4, 3, 34, 653, 2,\
    \ 5), c(5, 7, 1, 5, 9, 653, 121))\nlist2 <- list(c(5, 3, 2, 8), c(3, 2))\n\nlist1\
    \ <- lapply(list1, unique)\nlist2 <- lapply(list2, unique)\n\nlist1 <- list1[list2\
    \ != list1]\nlist2 <- list2[list2 != list1]\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a tags=r,list,unique |>\nHere's a solution using mapply and unique:\n\
    <code>\nmapply(unique, list1, list2)\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,list,unique\
    \ |>\nHere's a solution using purrr::map2\n<code>\nlibrary(purrr)\n\nlist1 <-\
    \ list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\nlist2 <- list(c(5,\
    \ 3, 2, 8), c(3, 2))\n\nmap2(list1, list2, unique)\n</code>\n<|/ a dscore=1 |>\n\
    <| a dscore=0 |>\nHere's a solution using purrr::map2\n<code>\nlist1 <- list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\nlist2 <- list(c(5, 3, 2,\
    \ 8), c(3, 2))\n\nmap2(list1, list2, unique)\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a d", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2\
    \ %in% u1]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2\
    \ != u1]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks so much! This works perfectly!\
    \ I really appreciate it!\n<|/ c |>\n<| c |>\nI added a more efficient solution\
    \ that doesn't require sorting.\n<|/ c |>\n<| c |>\nThanks so much! This works\
    \ perfectly! I really appreciate it!\n<|/ c |>\n<| a tags=r,sorting |>\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nI like the idea of using sets to find common elements.\
    \ But this doesn't work if you have duplicate elements. For example, if `l1 =\
    \ c(1,2,2,3)` and `l2 = c(1,2,3)` then `common(l1,l2)` returns `list(1, 2)` instead\
    \ of `list(1, 3)`.\n<|/ c |>\n<| c |>\nI added a solution that works with duplicate\
    \ elements.\n<|/ c |>\n<| c |>\nI like the idea of using sets to find common elements.\
    \ But this doesn't work if you have duplicate elements. For example, if `l1 =\
    \ c(1,2,2,3)` and `l2 = c(1,2,3)` then `common(l1,l2)` returns `list(1, 2)` instead\
    \ of `list(1, 3)`.\n<|/ c |>\n<| c |>\nI added a solution that works with duplicate\
    \ elements.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using data.table:\n\
    <code>\nlibrary(data.table)\nsetDT(list(l1 = c(1,2,2,3), l2 = c(1,2,3)))\nsetDT(list(l1\
    \ = c(1,2,2,3), l2 = c(1,2,3)))\nsetkey(setDT(list(l1 = c(1,2,2,3), l2 = c(1,2,3))),\
    \ l1, l2)\nsetkey(setDT(list(l1 = c(1,2,2,3), l2 = c(1,2,3))), l2, l1)\nsetkey(setDT(list(l1\
    \ = c(1,2,2,3), l2 = c(1,2,3))), l1, l2)\nsetkey(setDT(list(l1 = c(1,2,2,3), l2\
    \ = c(1,2,3))), l2, l1)\nsetkey(setDT(list(l1 = c(1,2,2,3), l2 = c(1,2,3))), l1,\
    \ l2)\nsetkey(setDT(list(l1 = c(1,2,2,3), l2 = c(1,2,3))), l2, l1)\nsetkey(setDT(list(l1\
    \ = c(1,2,2,3), l2 = c(1,2,3))), l1, l2)\nsetkey(setDT(list(l1 = c(1,2,2,3), l2\
    \ = c(1,2,3))), l2, l1)\nsetkey(setDT(list(l1 = c(1,2,2,3), l2 = c(1,2,3))), l1,\
    \ l2)\nsetkey(setDT(list(l1 = c(1,2,2,3), l2 = c(1,2,3))), l2, l1)\nsetkey(setDT(list(l1\
    \ = c(1,2,2,3), l", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks for your answer!\
    \ I didn't know about `intersect` before. Unfortunately this doesn't solve the\
    \ problem of overlapping intervals. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7,\
    \ 1, 5, 9, 653, 121))` returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`.\n\
    <|/ c |>\n<| c |>\nI see. I've edited my answer to include a solution that should\
    \ work. Let me know if it doesn't.\n<|/ c |>\n<| c |>\nThanks for your answer!\
    \ Unfortunately this doesn't solve the problem of overlapping intervals. `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\
    \ instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\nI see. I've edited my\
    \ answer to include a solution that should work. Let me know if it doesn't.\n\
    <|/ c |>\n<| c |>\nThanks for your answer! Unfortunately this doesn't solve the\
    \ problem of overlapping intervals. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7,\
    \ 1, 5, 9, 653, 121))` returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`.\n\
    <|/ c |>\n<| a dscore=2 |>\nHere is a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(intervals = c(1, 4, 3, 34, 653, 2, 5), \n                 values\
    \ = c(5, 7, 1, 5, 9, 653, 121))\n\ndt[, common_values := sort(unique(values)),\
    \ by = intervals]\ndt[, common_values := common_values[order(intervals)], by =\
    \ intervals]\ndt[, common_values := common_values[order(values)], by = intervals]\n\
    dt[, common_values := common_values[order(intervals, values)]\n</code>\n<|/ a\
    \ tags=r,intervals,overlap |>\n<| c |>\nThanks for your answer! Unfortunately\
    \ this doesn't solve the problem of overlapping intervals. `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)` instead\
    \ of `list(1, 5, 653, 12"]
stop_tokens:
- "\n#"
- "\n```"
