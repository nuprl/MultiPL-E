name: HumanEval_58_common
language: r
prompt: "# Return sorted unique common elements for two lists.\n# >>> common(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n# list(1, 5, 653)\n# >>> common(c(5,\
  \ 3, 2, 8), c(3, 2))\n# list(2, 3)\ncommon <- function(l1, l2) {"
tests: "test_humaneval <- function() {\ncandidate <- common\n    if(!identical(candidate(c(1,\
  \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), list(1, 5, 653))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(5, 3, 2, 8), c(3, 2)), list(2, 3))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 8), c(3, 2, 4)), list(2, 3, 4))){quit('no',\
  \ 1)}\n    if(!identical(candidate(c(4, 3, 2, 8), c()), list())){quit('no', 1)}\n\
  }\ntest_humaneval()"
completions: ["\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 !=\
    \ u1]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,list,unique |>\n<code>\n\
    > x <- list(c(1,4,3,34,653,2,5), c(5,7,1,5,9,653,121))\n> y <- list(c(5,3,2,8),\
    \ c(3,2))\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n\
    > \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n \
    \ u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to avoid the double `unique` calls. Maybe `u1\
    \ <- unique(c(l1, l2)); u2 <- unique(c(l2, l1)); u1[u1 == u2]`?\n<|/ c |>\n<|\
    \ c |>\nYes, that would work. I'll add it to the answer.\n<|/ c |>\n<| c |>\n\
    I added a version that avoids double `unique` calls.\n<|/ c |>\n<| a tags=r,unique,list\
    \ |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have multiple common elements. For example,\
    \ `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1,\
    \ 5, 653)` instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c |>\nThanks for pointing\
    \ that out. I fixed the code by adding `u1[u1 == u2]` at the end. Now it works\
    \ as expected.\n<|/ c |>\n<| a |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\ndt <- data.table(a = c(1,4,3,34,653,2,5), b = c(5,7,1,5,9,653,121))\n\
    dt[, setdiff(unique(c(a,b)), unique(c(b,a))), by = a]\n</code>\n<|/ a tags=r,list,unique\
    \ dscore=2 |>\n<| a dscore=2 |>\nHere's a base R solution:\n<code>\na <- c(1,4,3,34,653,2,5)\n\
    b <- c(5,7,1,5,9,653,121)\na <- unique(a)\nb <- unique(b)\na[!a %in% b]\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\nHere's a solution using\
    \ dplyr and purrr.\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\na <- c(1,4,3,34,653,2,5)\n\
    b <- c(5,7,1,5,9,653,121)\n\na %>% \n  unique() %>% \n  setdiff(b) %>% \n  unique()\
    \ %>% \n  setdiff(a)\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,list,unique |>\n\
    Here's a base R solution:\n<code>\na <- c(1,4,3,34,653,2,5)\nb <- c(5,7,1,5,9,653,121)\n\
    \na <- unique(a)\nb <- unique(b)\n\na[!a %in% b]\n</code>\n<|/ a dscore=2 |>\n\
    <| a tags=r,list,unique |>\nHere's a base R solution:\n<code>\na <- c(1,4,3,34,653,2,5)\n\
    b <- c(5,7,1,5,9,653,121)\n\na <- unique(a)\nb <- unique(b)\n\na[", "\n  u1 <-\
    \ sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)),\
    \ decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,sorting |>\n<|\
    \ c |>\nThis doesn't work if you have duplicates in either list.\n<|/ c |>\n<|\
    \ c |>\nYes, it does. I added a note at the bottom of the answer.\n<|/ c |>\n\
    <| c |>\nI added a note at the bottom of the answer. Thanks for pointing that\
    \ out.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n> x <- c(1,4,3,34,653,2,5)\n> y <-\
    \ c(5,7,1,5,9,653,121)\n> sort(unique(c(x,y)))\n[1] 1 5 653\n</code>\n<|/ a tags=r,sorting\
    \ |>\n<| c |>\nThis doesn't work if you have duplicates in either list.\n<|/ c\
    \ |>\n<| c |>\nYes, it does. I added a note at the bottom of the answer.\n<|/\
    \ c |>\n<| a |>\n<code>\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\n\
    sort(unique(c(x,y)))\n[1] 1 5 653\n</code>\n<|/ a tags=r,sorting dscore=2 |>\n\
    <| a dscore=1 |>\n<code>\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\n\
    sort(unique(c(x,y)))\n[1] 1 5 653\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\n\
    This doesn't work if you have duplicates in either list.\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\nsort(unique(c(x,y)))\n\
    [1] 1 5 653\n</code>\n<|/ a tags=r,sorting |>\n<| a |>\n<code>\nx <- c(1,4,3,34,653,2,5)\n\
    y <- c(5,7,1,5,9,653,121)\nsort(unique(c(x,y)))\n[1] 1 5 653\n</code>\n<|/ a dscore=1\
    \ tags=r,sorting |>\n<| a tags=r,sorting |>\n<code>\nx <- c(1,4,3,34,653,2,5)\n\
    y <- c(5,7,1,5,9,653,121)", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work if there\
    \ are duplicates in either list. For example: `common(c(1,2,3), c(1,2,3))` returns\
    \ `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nYes, I realized that after I posted it. I added\
    \ a fix to my answer.\n<|/ c |>\n<| c |>\nI added a fix to my answer. Thanks for\
    \ pointing that out.\n<|/ c |>\n<| c |>\nI added a fix to my answer. Thanks for\
    \ pointing that out.\n<|/ c |>\n<| c |>\nI added a fix to my answer. Thanks for\
    \ pointing that out.\n<|/ c |>\n<| a dscore=4 |>\nA simple solution that doesn't\
    \ require any packages:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis doesn't work if there are duplicates in either list. For example:\
    \ `common(c(1,2,3), c(1,2,3))` returns `[1] 1 2 3`.\n<|/ c |>\n<| a tags=r |>\n\
    Here's a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1=c(1,2,3),\
    \ l2=c(1,2,3)))\nsetDT(list(l1=c(1,2,3), l2=c(1,2,3)))\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2,3))), l1, l2)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2,3))), l2, l1)\n\
    </code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in either list. For example: `setDT(list(l1=c(1,2,3), l2=c(1,2,3)))` returns\
    \ `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nI added a fix to my answer. Thanks for pointing\
    \ that out.\n<|/ c |>\n<| a dscore=3 |>\nA solution using dplyr and purrr packages:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ncommon <- function(l1, l2) {\n  l1 %>%\
    \ \n    map(unique) ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nI like this\
    \ solution, but I believe it can be improved. For example, `common(c(1,2,3), c(1,2,3))`\
    \ returns `[1]  1  2  3` instead of `[1]  1  2  3`. I think it can be fixed by\
    \ replacing `u1[u1 == u2]` with `u1[!duplicated(u1)]`.\n<|/ c |>\n<| c |>\nThanks\
    \ for pointing that out. I fixed the code accordingly.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\nA simple and efficient solution is to use setdiff:\n<code>\nsetdiff(c(1,2,3),\
    \ c(1,2,3))", "\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks for the answer.\
    \ I'm still trying to understand how this works. I understand that `common` returns\
    \ all common elements, but how does it know which elements to return? It seems\
    \ like it just returns all common elements. How does it know which elements to\
    \ return?\n<|/ c |>\n<| c |>\nIt just returns all common elements. I added a little\
    \ explanation to the answer.\n<|/ c |>\n<| c |>\nThanks for the explanation. I'm\
    \ still trying to understand how this works. I understand that `common` returns\
    \ all common elements, but how does it know which elements to return? It seems\
    \ like it just returns all common elements. How does it know which elements to\
    \ return?\n<|/ c |>\n<| c |>\nIt just returns all common elements. I added a little\
    \ explanation to the answer.\n<|/ c |>\n<| c |>\nThanks for the explanation. I'm\
    \ still trying to understand how this works. I understand that `common` returns\
    \ all common elements, but how does it know which elements to return? It seems\
    \ like it just returns all common elements. How does it know which elements to\
    \ return?\n<|/ c |>\n<| a dscore=1 |>\nHere is a simple solution that uses setdiff\
    \ and intersect to find the common elements and then removes them from the original\
    \ vectors.\n<code>\ncommon <- function(l1, l2) {\n  setdiff(sort(unique(c(l1,\
    \ l2))), sort(unique(c(l2, l1))))\n}\n\ncommon(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work\
    \ if you have two lists with different lengths.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting it.\n<|/ c |>\n<| c |>\nIt doesn't work if you have\
    \ two lists with different lengths. Try `common(c(1,2,3), c(1,2,3,4,5))`.\n<|/\
    \ c |>\n<| c |>\nYes, it does. I tested it before posting it. The OP didn't specify\
    \ that lists had different lengths. I added a note to my answer.\n<|/ c |>\n<|\
    \ c |>\nYes, it does. I tested it before posting it. The OP didn't specify that\
    \ lists had different lengths. I added a note to my answer.\n<|/ c |>\n<| a dscore=2\
    \ |>\nHere's a solution that doesn't require any packages:\n<code>\ncommon <-\
    \ function(l1, l2) {\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2,\
    \ l1)))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work\
    \ if you have two lists with different lengths.\n<|/ c |>\n<| c |>\nYes, it does.\
    \ I tested it before posting it.\n<|/ c |>\n<| c |>\nYes, it does. I tested it\
    \ before posting it. The OP didn't specify that lists had different lengths. I\
    \ added a note to my answer.\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1 = c(1,2,3), l2 = c(1,2,3,4,5)))\n\
    setDT(list(l1 = c(1,2,3), l2 = c(1,2,3,4,5,6)))\n\nsetkey(setDT(list(l1 = c(1,2,3),\
    \ l2 = c(1,2,3,4,5,6))), l1, l2)\nsetkey(setDT(list(l1 = c(1,2,3), l2 = c(1,2,3,4,5,6))),\
    \ l2, l1)\n\nsetkey(setDT(list(l1 = c(1,2,3), l2 = c(1,2,3,4,5,6))), l1, l2)\n\
    setkey(setDT(list(l1 = c(1,2,3), l2 = c(", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n \
    \ u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r |>\n<| c\
    \ |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c |>\n\
    <| c |>\nYes, it does. I added a test case to my answer.\n<|/ c |>\n<| c |>\n\
    I added a test case to my answer. Your solution doesn't work if there are repeated\
    \ elements in the lists.\n<|/ c |>\n<| c |>\nI added a test case to my answer.\
    \ Your solution doesn't work if there are repeated elements in the lists.\n<|/\
    \ c |>\n<| c |>\nI added a test case to my answer. Your solution doesn't work\
    \ if there are repeated elements in the lists.\n<|/ c |>\n<| a tags=r |>\n<code>\n\
    library(dplyr)\nlibrary(purrr)\n\ncommon_elements <- function(...) {\n  args <-\
    \ list(...)\n  map(args, ~sort(unique(c(...))))\n}\n\ncommon_elements(c(1, 4,\
    \ 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if\
    \ you have repeated values in either of the lists.\n<|/ c |>\n<| c |>\nIt does\
    \ work if you use the `unique` function on both lists. I've edited my answer to\
    \ show this.\n<|/ c |>\n<| c |>\nThis doesn't work if you have repeated values\
    \ in either of the lists.\n<|/ c |>\n<| c |>\nIt does work if you use the `unique`\
    \ function on both lists. I've edited my answer to show this.\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if you have repeated values in either of the lists.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution using data.table:\n<code>\n\
    library(data.table)\nsetDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5,\
    \ 9, 653, 121)))\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1,\
    \ 5, 9, 653, 121))), l1, l2)\nunique(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5),\
    \ l2=c(5, 7, 1, 5, 9, 653, 121))))\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis\
    \ doesn't work if you have repeated values in either of the lists.\n<|/ c |>\n\
    <| c |>\nIt does work if you use the `unique` function on both lists. I've edited\
    \ my answer to show this.\n<|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution\
    \ using base R:\n<code>\nl1 <- c(1, 4, 3, 34, 653, 2, 5)\nl2 <- c(5, 7, 1, 5,\
    \ 9, 653, 121)\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n \
    \ u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't work if you\
    \ have two lists with different lengths.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works with different lengths.\n<|/ c |>\n<| a tags=r |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1=c(1,4,3,34,653,2,5),\
    \ l2=c(5,7,1,5,9,653,121)))\nsetkey(setDT(list(l2=c(5,7,1,5,9,653,121))), l2)\n\
    setkey(setDT(list(l1=c(1,4,3,34,653,2,5))), l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5),\
    \ l2=c(5,7,1,5,9,653,121))), l2)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))),\
    \ l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))), l2)\n\
    setkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))), l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5),\
    \ l2=c(5,7,1,5,9,653,121))), l2)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))),\
    \ l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))), l2)\n\
    setkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))), l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5),\
    \ l2=c(5,7,1,5,9,653,121))), l2)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), l2=c(5,7,1,5,9,653,121))),\
    \ l1)\nsetkey(setDT(list(l1=c(1,4,3,34,653,2,5), ", "\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't work if there\
    \ are duplicates in the lists.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting.\n<|/ c |>\n<| c |>\nIt doesn't work if there are duplicates in the\
    \ lists.\n<|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists.\
    \ Try it yourself.\n<|/ c |>\n<| c |>\nI tested it before posting. It doesn't\
    \ work if there are duplicates in the lists.\n<|/ c |>\n<| a dscore=2 |>\n<code>\n\
    library(dplyr)\nlibrary(purrr)\n\nlist1 <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n\
    list2 <- list(c(4,5,6), c(7,8,9), c(1,2,3))\n\nlist1 %>% \n  map(setNames(list2,\
    \ names(list1))) %>% \n  reduce(inner_join, by = \"name\") %>% \n  select(-name)\n\
    \n[[1]]\n[[1]]$`1`\n[1] 1 2 3\n\n[[1]]$`2`\n[1] 4 5 6\n\n[[1]]$`3`\n[1] 7 8 9\n\
    \n[[2]]\n[[2]]$`4`\n[1] 4 5 6\n\n[[2]]$`5`\n[1] 7 8 9\n\n[[3]]\n[[3]]$`7`\n[1]\
    \ 1 2 3\n\n[[3]]$`8`\n[1] 4 5 6\n\n[[3]]$`9`\n[1] 7 8 9\n</code>\n<|/ a tags=r\
    \ |>\n<| a dscore=2 |>\nHere's a solution using base R:\n<code>\nlist1 <- list(c(1,2,3),\
    \ c(4,5,6), c(7,8,9))\nlist2 <- list(c(4,5,6), c(7,8,9), c(1,2,3))\n\nlist1 <-\
    \ lapply(list1, function(x) setNames(list2, names(list1)))\nlist1 <- lapply(list1,\
    \ function(x) Reduce(function(x, y) merge(x, y, all = TRUE), x))\nlist1 <- lapply(list1,\
    \ function(x) x[!is.na(x$V1), ])\nlist1 <- lapply(list1, function(x) x[!is.na(x$V2), ",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nI like your use of setdiff and setdiff to find the\
    \ common elements. I wonder if there is a way to do this without using setdiff?\n\
    <|/ c |>\n<| c |>\nI guess you could use `intersect` but that would give you the\
    \ common elements. I guess you could use `setdiff` but that would give you the\
    \ elements that are in one but not the other. Not sure how you want the output\
    \ to look.\n<|/ c |>\n<| c |>\nI want the output to look like `list(1, 5, 653)`\n\
    <|/ c |>\n<| c |>\nI guess I misunderstood your question. Do you want the output\
    \ to be a list with all the common elements?\n<|/ c |>\n<| c |>\nYes, that is\
    \ correct. I want the output to be a list with all the common elements.\n<|/ c\
    \ |>\n<| a |>\n<code>\ncommonElements <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r dscore=1\
    \ |>\n<| a dscore=1 |>\n<code>\ncommonElements <- function(l1, l2) {\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/\
    \ a tags=r |>\n<| a dscore=1 |>\n<code>\ncommonElements <- function(l1, l2) {\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nPlease add some explanation to your answer such that\
    \ others can learn from it\n<|/ c |>\n<| a dscore=1 |>\n<code>\ncommonElements\
    \ <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=0 |>\n<code>\ncommonElements\
    \ <- function(l1, l2) {\n  u1 <- unique(c(l1, ", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nI added a version that works with repeated elements.\n<|/ c\
    \ |>\n<| a tags=r,list,unique |>\nHere's a solution using base R:\n<code>", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThanks for your answer! I tested it and\
    \ it works fine. However I noticed that my original question was a bit unclear.\
    \ I've edited it now. Sorry for that!\n<|/ c |>\n<| c |>\nI edited my answer to\
    \ include a solution that should work for your new question.\n<|/ c |>\n<| c |>\n\
    Thanks for your answer! I tested it and it works fine. However I noticed that\
    \ my original question was a bit unclear. I've edited it now. Sorry for that!\n\
    <|/ c |>\n<| c |>\nI edited my answer to include a solution that should work for\
    \ your new question.\n<|/ c |>\n<| a dscore=0 |>\n<code>\nlibrary(data.table)\n\
    library(magrittr)\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,list,subset |>\n<code>\n\
    > x <- list(c(1,2,3), c(4,5,6), c(7,8,9))\n> y <- list(c(1,2,3), c(4,5,6), c(7,8,9),\
    \ c(10,11,12))\n> z <- list(c(1,2,3), c(4,5,6), c(7,8,9), c(10,11,12), c(13,14,15))\n\
    > \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nI wrote a function\
    \ that does this in R:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\ncommon_elements\
    \ <- function(x, y) {\n  x <- as.character(x)\n  y <- as.character(y)\n  x <-\
    \ x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n\
    \  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in%\
    \ x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y\
    \ %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y\
    \ <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in%\
    \ y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x\
    \ %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x\
    \ <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in%\
    \ x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y\
    \ %in% x]\n  x <- x[!x %in% y]\n  y <- y[!y %in% x]\n  x <- x[!x %in% y]\n  y\
    \ <- y[!y %in% ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2\
    \ != u1]\n}\n", "\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <-\
    \ sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n", "\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/\
    \ a tags=r |>\n<| c |>\nI like your use of setdiff to find the unique common elements.\
    \ I wonder if there is a way to do this without setdiff. Maybe with some sort\
    \ of merge?\n<|/ c |>\n<| c |>\nI added a solution without `setdiff`.\n<|/ c |>\n\
    <| a dscore=2 |>\n<code>", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  i <- 0\n \
    \ j <- 1\n  res <- list()\n  while((i < length(l1) && j < length(l2)) && (l1[i]\
    \ == l2[j])) {\n    res[[i]] <- l1[i]\n    i <- i + 1\n    j <- j + 1\n  }\n \
    \ if(i < length(l1)) {\n    while(j < length(l2)) {\n      res[[i]] <- l2[j]\n\
    \      i <- i + 1\n      j <- j + 1\n    }\n  }\n  if(j < length(l2)) {\n    while(i\
    \ < length(l1)) {\n      res[[i]] <- l1[j]\n      i <- i + 1\n      j <- j + 1\n\
    \    }\n  }\n  return(res)\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't\
    \ work if there are duplicates in the lists.\n<|/ c |>\n<| c |>\nIt does work\
    \ if there are duplicates in the lists. Try it yourself.\n<|/ c |>\n<| c |>\n\
    It doesn't work if there are duplicates in the lists. Try it yourself.\n<|/ c\
    \ |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| a dscore=3 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l2=c(5,\
    \ 7, 1, 5, 9, 653, 121))), l2)\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5))),\
    \ l1)\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7, 1, 5, 9, 653,\
    \ 121))), l1, l2)\nsetkey(setDT(list(l1=c(1, 4, 3, 34, 653, 2, 5), l2=c(5, 7,\
    \ 1, 5, 9, 653, 121))), l1, l2, l1)\n</code>\n<|/ a tags=r,list,unique |>\n<|\
    \ c |>\nThis doesn't work if there are duplicates in the lists.\n<|/ c |>\n<|\
    \ c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| c |>\nIt does work if there are duplicates in the lists. Try it yourself.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution using base R:\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\n<code>", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't seem to work if you have two lists with different\
    \ lengths.\n<|/ c |>\n<| c |>\nYes, it does. Try it out with `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n<|/ c |>\n<| c |>\nI see what\
    \ you mean. My bad. Thanks for pointing that out.\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work\
    \ if there are repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt works with\
    \ repeated elements. Try `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))`\n<|/ c |>\n<| c |>\nI see what you mean. Yes, it works with repeated\
    \ elements. But it doesn't work with repeated elements in the same list as well.\n\
    <|/ c |>\n<| c |>\nYes, it works with repeated elements in the same list as well.\n\
    <|/ c |>\n<| c |>\nI see what you mean. Yes, it works with repeated elements.\
    \ But it doesn't work with repeated elements in the same list as well.\n<|/ c\
    \ |>\n<| a tags=r,list,unique |>\nThis should work:\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a dscore=2 |>\n<| c |>\nThis doesn't work if there are repeated elements in\
    \ the lists.\n<|/ c |>\n<| a dscore=2 |>\n<code>\ncommon<-function(l1,l2){\n \
    \ u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if there are repeated elements\
    \ in the lists.\n<|/ c |>\n<| a dscore=2 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| c |>\nThis ", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n\
    <| c |>\nThanks for your answer. Your solution is very similar to mine, except\
    \ that yours does not preserve the order of the elements. I prefer my solution\
    \ as it preserves the order of the elements. I guess your solution also has some\
    \ advantages over mine.\n<|/ c |>\n<| c |>\nI added a solution that preserves\
    \ the order of the elements. I guess yours is more efficient than mine.\n<|/ c\
    \ |>\n<| c |>\nI added a solution that preserves the order of the elements. I\
    \ guess yours is more efficient than mine.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1 = c(1,\
    \ 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\nunique(unlist(.SD))",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n\
    \  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ a dscore=1 |>\nHere is a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(df)[, list(common = sort(unique(unlist(.SD))), .SDcols = c(\"A\", \"B\"\
    )) ]\n</code>\nResult:\n<code>\n   A  B  common\n1: 1 10      1\n2: 2 20     \
    \ 2\n3: 3 30      3\n4: 4 40      4\n5: 5 50      5\n6: 6 60      6\n7: 7 70 \
    \     7\n8: 8 80      8\n9: 9 90      9\n</code>\n<|/ a tags=r,dataframe |>\n\
    <| a tags=r,dataframe |>\nA base R solution:\n<code>\ndf <- data.frame(A=c(1,4,3,34,653,2),\n\
    \                 B=c(5,7,1,5,9,653,121))\n\ndf$common <- apply(df[,2:3], 1, function(x)\
    \ sort(unique(x)))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nUsing dplyr\
    \ and purrr you could do:\n<code>\ndf %>%\n mutate(common = map(.x = .[,2:3],\
    \ .f = function(x) sort(unique(x))))\n</code>\nWhich gives:\n<code>\n  A  B common\n\
    1 1 10      1\n2 4 20      2\n3 3 30      3\n4 6 40      4\n5 7 50      5\n6 9\
    \ 60      6\n7 1 70      7\n8 5 80      8\n9 9 90      9\n</code>\n<|/ a tags=r,dataframe\
    \ |>\n<| a tags=r,dataframe |>\nHere is a base R solution:\n<code>\ndf$common\
    \ <- apply(df[,2:3], 1, function(x) sort(unique(x)))\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=r,dataframe |>\n<code>\ndf <- data.frame(A=c(1,4,3,34,653,2),\n\
    \                 B=c(5,7,1,5,9,653,121))\n\ndf$common <- apply(df[,2:3], 1, function(x)\
    \ sort(unique(x)))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nWe can use tidyverse\n\
    <code>\nlibrary(dplyr)\nlibrary(", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a |>\n<| c |>\nThanks for your answer.\
    \ Your code works well for small lists, but for larger lists it takes too long\
    \ to compute. Do you know a faster way to compute this?\n<|/ c |>\n<| c |>\nI\
    \ added a faster version. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ Your code works well for small lists, but for larger lists it takes too long\
    \ to compute. Do you know a faster way to compute this?\n<|/ c |>\n<| c |>\nI\
    \ added a faster version. Hope it helps.\n<|/ c |>\n<| c |>\nThanks for your answer.\
    \ Your code works well for small lists, but for larger lists it takes too long\
    \ to compute. Do you know a faster way to compute this?\n<|/ c |>\n<| a dscore=1\
    \ |>\nHere is a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(x = c(1,4,3,34,653,2,5), y = c(5,7,1,5,9,653,121))\ndt[, list(z =\
    \ x[y == min(y)])]\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThanks for\
    \ your answer. Your code works well for small lists, but for larger lists it takes\
    \ too long to compute. Do you know a faster way to compute this?\n<|/ c |>\n<|\
    \ c |>\nI added a faster version. Hope it helps.\n<|/ c |>\n<| a dscore=1 |>\n\
    Here is a solution using dplyr and purrr:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    \nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\n\ndf <- data.frame(x, y)\n\
    \ndf %>% \n  mutate(z = map2_dbl(x, y, ~.x[.y == min(.y)]))\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThanks for your answer. Your code works well for small lists, but\
    \ for larger lists it takes too long to compute. Do you know a faster way to compute\
    \ this?\n<|/ c |>\n<| a tags=r,list,unique |>\nHere is a solution using base R:\n\
    <code>\nx <- c(1,4,3,34,653,2,5)\ny ", "\n  u1 <- sort(unique(c(l1, l2)), decreasing\
    \ = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r |>\n<| a dscore=1 |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\
    library(stringr)\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u2 %in% u1]\n}\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  common1 <- intersect(l1,\
    \ l2)\n  common2 <- intersect(l2, l1)\n  common1 <- common1[!common1 %in% common2]\n\
    \  common2 <- common2[!common2 %in% common1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[!common2 %in% l1]\n  common1 <- common1[!common1 %in%\
    \ l1]\n  common2 <- common2[!common2 %in% l2]\n  common1 <- common1[!common1 %in%\
    \ l2]\n  common2 <- common2[", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to make it more efficient. My actual data set\
    \ is about 10 million rows and I run this on a laptop with 4 GB of RAM and it\
    \ takes about 15 minutes to run. Do you know if there is a way to speed it up?\n\
    <|/ c |>\n<| c |>\nI added a more efficient solution that uses `data.table` instead\
    \ of `data.frame`.\n<|/ c |>\n<| c |>\nI ran your new code on my laptop with 4\
    \ GB of RAM and it took about 15 minutes to run. Do you know if there is a way\
    \ to speed it up?\n<|/ c |>\n<| c |>\nI added a more efficient solution that uses\
    \ `data.table` instead of `data.frame`.\n<|/ c |>\n<| c |>\nI ran your new code\
    \ on my laptop with 4 GB of RAM and it took about 15 minutes to run. Do you know\
    \ if there is a way to speed it up?\n<|/ c |>\n<| a dscore=2 |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(df)\ndf[, common := Reduce(intersect,\
    \ lapply(.SD, unique)), by = .(id, date)]\n</code>\n<|/ a tags=r,dataframe,list\
    \ |>\n<| c |>\nI ran your new code on my laptop with 4 GB of RAM and it took about\
    \ 15 minutes to run. Do you know if there is a way to speed it up?\n<|/ c |>\n\
    <| c |>\nI added a more efficient solution that uses `data.table` instead of `data.frame`.\n\
    <|/ c |>\n<| a tags=r,dataframe,list |>\nHere's a solution using dplyr and purrr:\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\n\ndf %>%\n  group_by(id, date) %>%\n \
    \ summarise(common = map(.x, unique)) %>%\n  unnest(common)\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nI ran your new code on my laptop with 4 GB of RAM and it took about\
    \ 15 minutes to run. Do you know if there is a way to speed it up?\n<|/ c |>\n\
    <| c |>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if\
    \ you have two lists with different lengths.\n<|/ c |>\n<| c |>\nI added a solution\
    \ that works with lists with different lengths.\n<|/ c |>\n<| a dscore=5 |>\n\
    I like using Reduce for these types of problems:\n<code>\nReduce(intersect, list1,\
    \ list2)\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nI like this solution\
    \ as it also works with lists with different lengths.\n<|/ c |>\n<| c |>\nThis\
    \ should be the accepted answer. `Reduce` is designed for these types of problems.\n\
    <|/ c |>\n<| c |>\nThis should be the accepted answer. `Reduce` is designed for\
    \ these types of problems.\n<|/ c |>\n<| c |>\nI like this solution as it also\
    \ works with lists with different lengths.\n<|/ c |>\n<| c |>\nThis should be\
    \ the accepted answer. `Reduce` is designed for these types of problems.\n<|/\
    \ c |>\n<| a dscore=5 |>\n<code>\n> x <- list(c(\"a\", \"b\", \"c\"), c(\"a\"\
    , \"b\", \"d\"), c(\"a\", \"b\", \"e\"))\n> y <- list(c(\"a\", \"b\", \"c\"),\
    \ c(\"a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))\n> z <- list(c(\"a\", \"b\"\
    , \"c\"), c(\"a\", \"b\", \"d\"), c(\"a\", \"b\", \"e\"))\n> x <- unique(x)\n\
    > y <- unique(y)\n> z <- unique(z)\n> x\n[[1]]\n[1] \"a\" \"b\" \"c\"\n\n[[2]]\n\
    [1] \"a\" \"b\" \"d\"\n\n[[3]]\n[1] \"a\" \"b\" \"e\"\n\n> y\n[[1]]\n[1] \"a\"\
    \ \"b\" \"c\"\n\n[[2]]\n[1] \"a\" \"b\" \"d\"\n\n[[3]]\n[1] \"a\" \"b\" \"e\"\n\
    \n> z\n[[1]]\n[1] \"a\" \"b\" \"c\"\n\n[[2]]\n[1] \"a\" \"b\" \"d\"\n\n[[3]]\n\
    [1] \"a\" \"b\" \"e\"\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't\
    \ work if you have two lists with different lengths.\n<|/ c |>\n<|", "\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you have a list with\
    \ duplicates, e.g. `c(1, 4, 3, 34, 653, 2, 5)` and `c(5, 7, 1, 5, 9, 653, 121)`\n\
    <|/ c |>\n<| c |>\n, good point. I added a solution that should handle that case.\n\
    <|/ c |>\n<| a dscore=2 |>\n<code>\n> x <- c(1, 4, 3, 34, 653, 2, 5)\n> y <- c(5,\
    \ 7, 1, 5, 9, 653, 121)\n> x <- sort(x)\n> y <- sort(y)\n> x\n[1] 1 2 3 4 5 6\
    \ 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33\
    \ 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59\
    \ 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85\
    \ 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108\
    \ 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127\
    \ 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146\
    \ 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165\
    \ 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184\
    \ 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 ", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem to work if you have a\
    \ list with two identical elements. `common(c(1,2,2,3), c(1,2,2,3))` returns `[1]\
    \ 1 2 3` instead of `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nI added a fix for that case\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nHere's a solution using base R:\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| a dscore=2 |>\n<code>\nlibrary(data.table)\nsetDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\n</code>\nThis\
    \ gives you a data.table with two columns: l1 and l2. You can then use unique.\n\
    <code>\nunique(data.table(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9,\
    \ 653, 121)))\n</code>\n<|/ a tags=r,list,unique |>\n<| a dscore=2 |>\n<code>\n\
    > x <- list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> x <- unique(x)\n> y <-\
    \ unique(y)\n> x\n[[1]]\n[1] 1 4 3 34 653 2 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n\
    </code>\n<|/ a tags=r,list,unique |>\n<| a dscore=1 |>\n<code>\n> x <- list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(c(1, 4, 3, 34,\
    \ 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> x <- unique(x)\n> y <- unique(y)\n\
    > x\n[[1]]\n[1] 1 4 3 34 653 2 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n</code>\n<|/\
    \ a tags=r,list,unique |>\n<| a dscore=1 |>\n<code>\nx <- list(c(1, 4, 3, 34,\
    \ 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\ny <- list(c(1, 4, 3, 34, 653, 2, 5),\
    \ c(5, 7, 1, 5, 9, 653, 121))\nx <- unique(x)\ny <- unique(y)\nx\n[[1]]\n[1] 1\
    \ 4 3 34 653 2 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a tags=r,list,unique |>\n<code>\nx <- list(c(1, 4, 3, 34, 653, 2, 5),\
    \ c(5, 7, 1, 5, 9, 653, 121))\ny <- list(c(1, 4, 3, ", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a |>\n<| c\
    \ |>\nThis doesn't seem to work if the lists are of different lengths.\n<|/ c\
    \ |>\n<| c |>\nIt does work, try it out. `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<| c |>\nAh, I\
    \ see what you mean. Yes, it does work, but only if the lists are the same length.\
    \ Try it with `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121, 3))`\n\
    <|/ c |>\n<| c |>\nYes, I see what you mean. Yes, it does work, but only if the\
    \ lists are the same length. Try it with `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121, 3))`\n<|/ c |>\n<| c |>\nI see what you mean. Yes, it\
    \ does work, but only if the lists are the same length. Try it with `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121, 3))`\n<|/ c |>\n<| a |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1 = c(1,\
    \ 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l2\
    \ = c(5, 7, 1, 5, 9, 653, 121))), l2)\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653,\
    \ 2, 5))), l1)\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7,\
    \ 1, 5, 9, 653, 121))), l1, l2)\n</code>\nThis gives:\n<code>\n   l1 l2\n1:  1\
    \  5\n2:  4  7\n3:  3  1\n4: 34  5\n5: 653 653\n6:  2  9\n7:  5 121\n</code>\n\
    <|/ a tags=r,list dscore=2 |>\n<| a dscore=2 |>\nHere's a solution using base\
    \ R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2\
    \ %in% u1]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis solution works well for\
    \ small lists, but for large lists, it becomes very slow. For example, `common(c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,24",
  "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2, l1)))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a tags=r,list,merge |>\n<| c |>\nThis doesn't work if there\
    \ are duplicates in either list.\n<|/ c |>\n<| c |>\nIt does work if there are\
    \ duplicates in either list. Try it yourself.\n<|/ c |>\n<| c |>\nIt does work\
    \ if there are duplicates in either list. Try it yourself. `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/\
    \ c |>\n<| c |>\nIt does work if there are duplicates in either list. Try it yourself.\
    \ `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1,\
    \ 5, 653)`\n<|/ c |>\n<| c |>\nIt does work if there are duplicates in either\
    \ list. Try it yourself. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<| a dscore=5 |>\nThe data.table\
    \ package has some nice functions for this:\n<code>\nlibrary(data.table)\ndt1\
    \ <- data.table(a = c(1,2,3), b = c(4,5,6))\ndt2 <- data.table(a = c(4,5,6), b\
    \ = c(7,8,9))\ndt1[dt2, on = \"a\"]\n</code>\n<|/ a tags=r,list,merge |>\n<| c\
    \ |>\nThis should be the accepted answer. data.table is very efficient and easy\
    \ to use.\n<|/ c |>\n<| c |>\nI agree. data.table is very efficient and easy to\
    \ use.\n<|/ c |>\n<| c |>\nThis should be the accepted answer. data.table is very\
    \ efficient and easy to use.\n<|/ c |>\n<| c |>\nThis should be the accepted answer.\
    \ data.table is very efficient and easy to use.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. data.table is very efficient and easy to use.\n<|/ c\
    \ |>\n<| a tags=r,list,merge |>\nA simple base R solution:\n<code>\n> x <- list(c(1,4,3,34,653,2),\
    \ c(5,7,1,5,9,653,121))\n> y <- list(c(5,3,2,8), c(3,", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  l1 <- unique(l1)\n  l2 <- unique(l2)\n  l1[l1 == l2] <- NA\n\
    \  return(l1)\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,sorting |>\n<code>",
  "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work if there are duplicates\
    \ in the lists. For example, `common(c(1,2,3), c(1,2,3))` returns `[1] 1 2`, which\
    \ is not the correct answer.\n<|/ c |>\n<| c |>\nI added a fix for that case.\n\
    <|/ c |>\n<| c |>\nThis doesn't work for `common(c(1,2,3), c(1,2,3))` which returns\
    \ `[1] 1 2`\n<|/ c |>\n<| c |>\nI added a fix for that case.\n<|/ c |>\n<| a dscore=3\
    \ |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt <-\
    \ data.table(a = c(1,2,3), b = c(1,2,3))\ndt[, setdiff(unique(c(a, b)), c(a, b)),\
    \ by = a]$V1", "\n  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <-\
    \ sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/\
    \ a |>\n<| c |>\nThis doesn't work if there are duplicates in either list.\n<|/\
    \ c |>\n<| c |>\nIt does work if there are duplicates in either list. Try it out\
    \ and see.\n<|/ c |>\n<| c |>\nIt doesn't work if there are duplicates in either\
    \ list. Try it out and see.\n<|/ c |>\n<| c |>\nIt does work if there are duplicates\
    \ in either list. Try it out and see.\n<|/ c |>\n<| c |>\nIt does work if there\
    \ are duplicates in either list. Try it out and see.\n<|/ c |>\n<| a tags=r |>\n\
    <code>\nlibrary(dplyr)\nlibrary(purrr)\nlibrary(stringr)\n", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  i <- 1\n  result <- list()\n  while(i <= length(l1) && i\
    \ <= length(l2)) {\n    if(l1[i] == l2[i]) {\n      result[i] <- l1[i]\n     \
    \ i <- i + 1\n    } else {\n      if(l1[i] > l2[i]) {\n        i <- i + 1\n  \
    \    } else {\n        i <- i + 1\n      }\n    }\n  }\n  return(result)\n}\n",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to do this without having to create a temporary variable `u1`?\n<|/\
    \ c |>\n<| c |>\nI guess you could do `u1 <- unique(c(l1, l2)); u2 <- unique(c(l2,\
    \ l1)); u1[u1 == u2]`\n<|/ c |>\n<| c |>\nYes, that works. I guess I was just\
    \ hoping there was a way to do it without having to create a temporary variable.\
    \ Thanks!\n<|/ c |>\n<| a tags=r,list,unique |>\nI came up with this solution:\n\
    <code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to do this without having to create a temporary\
    \ variable `u1`?\n<|/ c |>\n<| c |>\nI guess you could do `u1 <- unique(c(l1,\
    \ l2)); u2 <- unique(c(l2, l1)); u1[u1 == u2]`\n<|/ c |>\n<| c |>\nYes, that works.\
    \ I guess I was just hoping there was a way to do it without having to create\
    \ a temporary variable. Thanks!\n<|/ c |>\n<| a dscore=3 |>\nI came up with this\
    \ solution:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without having to create a temporary variable `u1`?\n<|/ c |>\n<| c |>\nI guess\
    \ you could do `u1 <- unique(c(l1, l2)); u2 <- unique(c(l2, l1)); u1[u1 == u2]`\n\
    <|/ c |>\n<| a tags=r,list,unique |>\nI came up with this solution:\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, ", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  common1 <- intersect(l1, l2)\n  common2 <- intersect(l2,\
    \ l1)\n  common1 <- common1[!common1 %in% common2]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n\
    \  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n\
    \  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[", "\n  l1\
    \ <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  l1[duplicated(l1) | duplicated(l2,\
    \ fromLast = TRUE)] <- NA\n  l2[duplicated(l2) | duplicated(l1, fromLast = TRUE)]\
    \ <- NA\n  l1[!is.na(l1)] <- l2[!is.na(l2)]\n  l2[!is.na(l2)] <- l1[!is.na(l1)]\n\
    \  return(l1)\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,sorting,list |>\nA solution\
    \ using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n\
    \  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't\
    \ seem to work if there are repeated elements in the list. For example, `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\
    \ instead of `list(1, 5, 653, 653)`.\n<|/ c |>\n<| c |>\nThanks for pointing that\
    \ out. I fixed the code so that it works with repeated elements.\n<|/ c |>\n<|\
    \ a dscore=2 |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a tags=r,list,unique |>\nA simple and fast solution is to use setdiff\
    \ and union:\n<code>\nsetdiff(union(l1, l2), union(l2, l1))\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis should be the accepted answer. Much faster than the other\
    \ solutions.\n<|/ c |>\n<| c |>\nThis is actually the fastest solution. `setdiff`\
    \ takes O(n) time while `union` takes O(n^2). `setdiff` takes O(n) time because\
    \ `setdiff` only needs to compare the two lists once, while `union` needs to compare\
    \ each element of both lists twice. `union` takes O(n^2) because `union` needs\
    \ to compare each element of both lists twice. `setdiff` takes O(n) time because\
    \ `setdiff` only needs to compare the two lists once, while `union` needs to compare\
    \ each element of both lists twice.\n<|/ c |>\n<| c |>\nThis should be the accepted\
    \ answer. Much faster than the other solutions.\n<|/ c |>\n<| c |>\nThis should\
    \ be the accepted answer. Much faster than the other solutions.\n<|/ c |>\n<|\
    \ c |>\nThis should be the accepted answer. Much faster than the other solutions.\n\
    <|/ c |>\n<| a tags=r,list,unique |>\n<code>\n> unique(c(l1,l2))\n[1] 1 2 3 4\
    \ 5 6 7 8 9\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis doesn't work if l1 and\
    \ l2 have different lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if l1 and l2\
    \ have different lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if l1 and l2 have\
    \ different lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if l1 and l2 have different\
    \ lengths.\n<|/ c |>\n<| c |>\nThis doesn't work if l1 and l2 have different lengths.\n\
    <|/ c |>\n<| a dscore=5 |>\n<code>\nl1 <- list(1, 2, 3, 4, 5)\nl2 <- list(1, 2,\
    \ 3, 4, 5)\nl", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem\
    \ to work when there are duplicates in either of the lists.\n<|/ c |>\n<| c |>\n\
    It does work. Try `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n\
    <|/ c |>\n<| c |>\nI see. Thanks for your help.\n<|/ c |>\n<| a dscore=2 |>\n\
    <code>\n> x <- list(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n>\
    \ y <- list(c(5, 3, 2, 8), c(3, 2))\n> \n> x <- unlist(x)\n> y <- unlist(y)\n\
    > \n> x <- sort(x)\n> y <- sort(y)\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- unique(x)\n\
    > y <- unique(y)\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n\
    > x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n\
    > \n> x <- x[!duplicated(x)]\n> y <- y[!duplicated(y)]\n> \n> x <- x[!duplicated(x)]\n\
    > y <- ", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a dscore=5 |>\n<| c |>\nI like this solution, but I wonder\
    \ if there is a way to make it more efficient by not sorting the lists first?\n\
    <|/ c |>\n<| c |>\n: I doubt that sorting is going to be the bottleneck here,\
    \ but I added a version that doesn't sort the lists first. Maybe it's faster,\
    \ but I don't know.\n<|/ c |>\n<| c |>\n: I added a version that doesn't sort\
    \ the lists first. Maybe it's faster, but I don't know.\n<|/ c |>\n<| c |>\n:\
    \ I added a version that doesn't sort the lists first. Maybe it's faster, but\
    \ I don't know.\n<|/ c |>\n<| c |>\n: I added a version that doesn't sort the\
    \ lists first. Maybe it's faster, but I don't know.\n<|/ c |>\n<| a tags=r,list\
    \ |>\nHere's a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list |>\n\
    <| c |>\nThis doesn't seem to work if you have a list with duplicates. For example,\
    \ `common(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1] 1 2 3`\n\
    <|/ c |>\n<| c |>\nThanks for pointing that out. I fixed the code by adding `unique`\
    \ to the `common` function.\n<|/ c |>\n<| a tags=r,list |>\nI wrote a function\
    \ that does this for you:\n<code>\ncommon2 <- function(l1, l2) {\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=5\
    \ |>\n<| c |>\nThis doesn't seem to work if you have a list with duplicates. For\
    \ example, `common2(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1]\
    \ 1 2 3`\n<|/ c |>\n<| c |>\nThis doesn't seem to work if you have a list with\
    \ duplicates. For example, `common2(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3`\
    \ instead of `[1] 1 2 3`\n<|/ c |>\n<| c |>\nThis doesn't seem to work if you\
    \ have a list with duplicates. For example, `common2(c(1,2,2,3), c(1,2,3))` returns\
    \ `[1] 1 2 3` instead of `[1] 1 2 3`\n<|/ c |>\n<| a tags=r,list |>\nI wrote a\
    \ function that does this for you:\n<code>\ncommon2 <- function(l1, l2) {\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=5 |>\n<| c |>\nThis doesn't seem to work if you have a list with\
    \ duplicates. For example, `common2(c(1,2,2,3), c(1,2,3))` returns `[1] 1 2 3`\
    \ instead of `[1] 1 2 3`\n<|/ c |>\n<| a |>\nI wrote a function that does this\
    \ for you:\n<code>\ncommon2 <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u", "\n  u1 <- sort(unique(c(l1, l2)),\
    \ decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,sorting |>\n<| c |>\nI like this solution,\
    \ but I wonder if there is a way to avoid the sorting step. I wonder if there\
    \ is a way to do this without sorting the lists.\n<|/ c |>\n<| c |>\nI added a\
    \ solution without sorting the lists.\n<|/ c |>\n<| c |>\nI added a solution without\
    \ sorting the lists.\n<|/ c |>\n<| a tags=r,sorting |>\nHere's a solution without\
    \ sorting the lists:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- sort(unique(c(l1,\
    \ l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n\
    \  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,sorting |>\nHere's\
    \ a solution without sorting the lists:\n<code>\ncommon <- function(l1, l2) {\n\
    \  u1 <- sort(unique(c(l1, l2)), decreasing = TRUE)\n  u2 <- sort(unique(c(l2,\
    \ l1)), decreasing = TRUE)\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<|\
    \ a tags=r,sorting |>\nHere is a solution without sorting the lists:\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=r,sorting |>\n\
    Here's a solution without sorting the lists:\n<code>\ncommon <- function(l1, l2)\
    \ {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n\
    </code>\n<|/ a dscore=3 |>\n<| a dscore=2 |>\nHere's a solution without sorting\
    \ the lists:\n<code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,sorting |>\n\
    <| a dscore=2 |>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n \
    \ u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThis doesn't seem to work\
    \ if there are repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt does. Try\
    \ it with `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n<|/\
    \ c |>\n<| c |>\nAh, I see what you mean. Yes, this works. I misunderstood your\
    \ question at first. Thanks!\n<|/ c |>\n<| c |>\nThis doesn't work if there are\
    \ repeated elements in the lists.\n<|/ c |>\n<| c |>\nIt does. Try it with `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n<|/ c |>\n<| a dscore=5\
    \ |>\nA simple solution:\n<code>\nintersect(list1, list2)\n</code>\n<|/ a tags=r\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nIt does. Try it with `intersect(list1, list2)`\n<|/ c |>\n\
    <| c |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c\
    \ |>\n<| c |>\nIt does. Try it with `intersect(list1, list2)`\n<|/ c |>\n<| c\
    \ |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c |>\n\
    <| a tags=r |>\n<code>\n> intersect(list1, list2)\n[1] 1 5 653\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nThis doesn't work if there are repeated elements in the\
    \ lists.\n<|/ c |>\n<| c |>\nIt does. Try it with `intersect(list1, list2)`\n\
    <|/ c |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| c |>\nIt does. Try it with `intersect(list1, list2)`\n<|/ c |>\n\
    <| a tags=r |>\n<code>\n> intersect(list1, list2)\n[1] 1 5 653\n</code>\n<|/ a\
    \ dscore=5 |>\n<| c |>\nThis doesn't ", "\n  u1 <- unique(c(l1, l2))\n  u2 <-\
    \ unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks\
    \ for your answer. I've tried your solution and it works perfectly for my case.\
    \ I've also added my own solution to the question for future reference.\n<|/ c\
    \ |>\n<| a tags=r |>\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThanks for your answer! I tested your function and I got this error\
    \ `Error in unique(c(l1, l2)) : invalid 'length' argument`\n<|/ c |>\n<| c |>\n\
    I tested it again and it worked for me. Maybe you have a different version of\
    \ R? What does `unique(c(l1, l2))` return?\n<|/ c |>\n<| c |>\nI tested it again\
    \ and it worked for me. Maybe you have a different version of R? What does `unique(c(l1,\
    \ l2))` return?\n<|/ c |>\n<| c |>\nI tested it again and it worked for me. Maybe\
    \ you have a different version of R? What does `unique(c(l1, l2))` return?\n<|/\
    \ c |>\n<| c |>\nI tested it again and it worked for me. Maybe you have a different\
    \ version of R? What does `unique(c(l1, l2))` return?\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\nHere is a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have repeated values in either list.\n\
    <|/ c |>\n<| c |>\nI added a version that works with repeated values.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if you have repeated values in either list.\n<|/ c\
    \ |>\n<| c |>\nI added a version that works with repeated values.\n<|/ c |>\n\
    <| a dscore=4 |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt1 <- data.table(a = c(1,4,3,34,653,2), b = c(5,7,1,5,9,653,121))\ndt2 <- data.table(a\
    \ = c(5,3,2,8), b = c(3,2,1))\n\ndt1[dt2, on = \"a\"]\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't work if you have repeated values in either list.\n\
    <|/ c |>\n<| c |>\nI added a version that works with repeated values.\n<|/ c |>\n\
    <| a dscore=4 |>\nHere's a solution using base R:\n<code>\n> x <- c(1,4,3,34,653,2)\n\
    > y <- c(5,7,1,5,9,653,121)\n> x <- unique(x)\n> y <- unique(y)\n> x\n[1] 1 4\
    \ 3 34 653 2\n> y\n[1] 5 7 1 5 9 653 121\n> x <- x[x %in% y]\n> x\n[1] 1 5 653\n\
    </code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't work if you have repeated\
    \ values in either list.\n<|/ c |>\n<| c |>\nI added a version that works with\
    \ repeated values.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution using dplyr\
    \ and purrr packages:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n\nx <- c(1,4,3,34,653,2)\n\
    y <- c(5,7,1,5,9,653,121)\n\nx <- unique(x)\ny <- unique(y)\n\nx %>% \n  map(~.x[.x\
    \ %in% y]) %>% \n  reduce(`+`)\n</code>\n<|/ a tags=r,list,unique |>\n<| a |>\n\
    Here's a solution ", "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1,\
    \ l2))\n  u[order(u, decreasing = TRUE)]\n}\n</code>\n<|/ a tags=r,sorting |>\n\
    <| a |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\ndt\
    \ <- data.table(x = c(1,4,3,34,653,2,5), y = c(5,7,1,5,9,653,121))\ndt[, list(z\
    \ = x[which.min(y)]), by = y]\n</code>\n<|/ a tags=r,sorting dscore=1 |>\n<| a\
    \ tags=r,sorting |>\nHere's a solution using dplyr and tidyr:\n<code>\nlibrary(dplyr)\n\
    library(tidyr)\n\ndf <- data.frame(x = c(1,4,3,34,653,2,5), y = c(5,7,1,5,9,653,121))\n\
    \ndf %>%\n  group_by(y) %>%\n  mutate(z = min(x)) %>%\n  ungroup() %>%\n  select(-y)\
    \ %>%\n  arrange(z)\n</code>\n<|/ a dscore=1 |>\n<| a dscore=0 |>\nHere's a solution\
    \ using base R:\n<code>\nx <- c(1,4,3,34,653,2,5)\ny <- c(5,7,1,5,9,653,121)\n\
    xy <- data.frame(x,y)\nxy$z <- apply(xy, 1, function(x) min(x[order(x)]))\nxy\n\
    </code>\n<|/ a tags=r,sorting |>\n<| a tags=r,sorting |>\nHere's a solution using\
    \ data.table:\n<code>\nlibrary(data.table)\ndt <- data.table(x = c(1,4,3,34,653,2,5),\
    \ y = c(5,7,1,5,9,653,121))\ndt[, list(z = x[which.min(y)]), by = y]\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=r,sorting |>\nHere's a solution using dplyr and tidyr:\n\
    <code>\nlibrary(dplyr)\nlibrary(tidyr)\n\ndf <- data.frame(x = c(1,4,3,34,653,2,5),\
    \ y = c(5,7,1,5,9,653,121))\n\ndf %>%\n  group_by(y) %>%\n  mutate(z = min(x))\
    \ %>%\n  ungroup() %>%\n  select(-y) %>%\n  arrange(z)\n</code>\n<|/ a dscore=0\
    \ |>\n<| a tags=r,sorting |>\nHere's a solution using data.table:\n<code>\nlibrary(data.",
  "\n  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2, l1)))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem to\
    \ work if you have a list with duplicates. For example, `common(c(1,2,2,3), c(1,2,3))`\
    \ returns `[1] 1 2 3`, but `common(c(1,2,2,3), c(1,2,2,3))` returns `[1] 1 2 3`.\n\
    <|/ c |>\n<| c |>\nYes, I realized that after I posted my comment. I've edited\
    \ my answer to fix the problem.\n<|/ c |>\n<| c |>\nThis doesn't seem to work\
    \ if you have a list with duplicates. For example, `common(c(1,2,2,3), c(1,2,3))`\
    \ returns `[1] 1 2 3`, but `common(c(1,2,2,3), c(1,2,2,3))` returns `[1] 1 2 3`.\n\
    <|/ c |>\n<| c |>\nIt works fine for me. `common(c(1,2,2,3), c(1,2,3))` returns\
    \ `[1] 1 2 3`.\n<|/ c |>\n<| c |>\nYes, it works fine for me. `common(c(1,2,2,3),\
    \ c(1,2,3))` returns `[1] 1 2 3`.\n<|/ c |>\n<| a tags=r,list,unique |>\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nI like this solution, but I wonder if there\
    \ is a way to avoid the double `unique`?\n<|/ c |>\n<| c |>\nI added a solution\
    \ without `unique`\n<|/ c |>\n<| a tags=r,list,unique |>\n<code>\n> x <- list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(c(5, 3, 2, 8),\
    \ c(3, 2))\n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n>\
    \ \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n> \n",
  "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  common1 <- intersect(l1, l2)\n  common2\
    \ <- intersect(l2, l1)\n  common1 <- common1[!common1 %in% common2]\n  common1\
    \ <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2,\
    \ l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n\
    \  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n\
    \  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <- common1[!common1\
    \ %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n  common1 <-\
    \ common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1 %in% c(l2, l1)]\n\
    \  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <- common1[!common1\
    \ %in% c(l2, l1)]\n  common1 <- common1[!common1 %in% c(l1, l2)]\n  common1 <-\
    \ common1[", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThanks for the answer.\
    \ I'm getting an error when I try to use this code: `Error in unique(c(l1, l2))\
    \ : \n  no non-missing arguments to min; returning -Inf`\n<|/ c |>\n<| c |>\n\
    I added a line to my answer to handle that case.\n<|/ c |>\n<| c |>\nThanks for\
    \ the answer. I'm getting an error when I try to use this code: `Error in unique(c(l1,\
    \ l2)) : \n  no non-missing arguments to min; returning -Inf`\n<|/ c |>\n<| c\
    \ |>\nI added a line to my answer to handle that case.\n<|/ c |>\n<| c |>\nThanks\
    \ for the answer. I'm getting an error when I try to use this code: `Error in\
    \ unique(c(l1, l2)) : \n  no non-missing arguments to min; returning -Inf`\n<|/\
    \ c |>\n<| a |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    dt <- data.table(list1 = c(1, 4, 3, 34, 653, 2, 5), list2 = c(5, 7, 1, 5, 9, 653,\
    \ 121))\ndt[, list1 := list1[list2]]\ndt[, list2 := list2[list1]]\ndt[, list1\
    \ := NULL]\ndt[, list2 := NULL]\ndt", "\n  u1 <- sort(unique(c(l1, l2)), decreasing\
    \ = TRUE)\n  u2 <- sort(unique(c(l2, l1)), decreasing = TRUE)\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThis doesn't seem to work if the two lists\
    \ have different lengths. For example, `common(c(1,2,3), c(1,2))` returns `[1]\
    \ 1 2` instead of `[1] 1 3`.\n<|/ c |>\n<| c |>\n: I fixed the bug. Thanks for\
    \ pointing it out.\n<|/ c |>\n<| c |>\n: I added a faster version that doesn't\
    \ require sorting.\n<|/ c |>\n<| c |>\n: I added a version that doesn't require\
    \ sorting.\n<|/ c |>\n<| c |>\n: I added a version that doesn't require sorting.\n\
    <|/ c |>\n<| a |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(list(l1=c(1,2,3), l2=c(1,2)))\nsetkey(setDT(list(l2=c(1,2))), l2)\nsetkey(setDT(list(l1=c(1,2,3))),\
    \ l1)\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2)\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2))), l1, l2, key=\"l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))),\
    \ l1, l2, key=\"l1\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2, key=\"\
    l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2, key=\"l1\")\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2))), l1, l2, key=\"l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))),\
    \ l1, l2, key=\"l1\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2, key=\"\
    l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,2))), l1, l2, key=\"l1\")\nsetkey(setDT(list(l1=c(1,2,3),\
    \ l2=c(1,2))), l1, l2, key=\"l2\")\nsetkey(setDT(list(l1=c(1,2,3), l2=c(1,", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- sort(unique(c(l1, l2)))\n  u2 <- sort(unique(c(l2, l1)))\n  u1[u1 ==\
    \ u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThanks for your answer!\
    \ I tested your function and it works perfectly. However I noticed that when I\
    \ run it on a list of lists, it returns me a list with only one element. Do you\
    \ know why this happens?\n<|/ c |>\n<| c |>\nI tested it on a list with two elements\
    \ and it returned me a list with two elements. I tested it on a list with three\
    \ elements and it returned me a list with three elements. I tested it on a list\
    \ with four elements and it returned me a list with four elements. I tested it\
    \ on a list with five elements and it returned me a list with five elements. I\
    \ tested it on a list with six elements and it returned me a list with six elements.\
    \ I tested it on a list with seven elements and it returned me a list with seven\
    \ elements. I tested it on a list with eight elements and it returned me a list\
    \ with eight elements. I tested it on a list with nine elements and it returned\
    \ me a list with nine elements. I tested it on a list with ten elements and it\
    \ returned me a list with ten elements. I tested it on a list with eleven elements\
    \ and it returned me a list with eleven elements. I tested it on a list with twelve\
    \ elements and it returned me a list with twelve elements. I tested it on a list\
    \ with thirteen elements and it returned me a list with thirteen elements. I tested\
    \ it on a list with fourteen elements and it returned me a list with fourteen\
    \ elements. I tested it on a list with fifteen elements and it returned me a list\
    \ with fifteen elements.\n<|/ c |>\n<| c |>\nI tested it on a list with sixteen\
    \ elements and it returned me a list with sixteen elements. I tested it on a list\
    \ with thirty-one elements and it returned me a list with thirty-one elements.\
    \ I tested it on a list with thirty-two elements and it returned me a list with\
    \ thirty-two elements. I tested it on a list with thirty-three elements and it\
    \ returned me a list with thirty-three elements. I tested it on a list with thirty-four\
    \ elements and it returned me a list with thirty-four ", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThanks for your answer. I'm sorry I didn't mention this in my question,\
    \ but I do have another constraint in my problem: I cannot use any packages. I\
    \ must implement this using only base R.\n<|/ c |>\n<| c |>\n: I added a solution\
    \ using only base R.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm sorry I didn't\
    \ mention this in my question, but I do have another constraint in my problem:\
    \ I cannot use any packages. I must implement this using only base R.\n<|/ c |>\n\
    <| c |>\n: I added a solution using only base R.\n<|/ c |>\n<| a dscore=2 |>\n\
    Here's a solution using only base R:\n<code>\ncommon <- function(l1, l2) {\n \
    \ u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r |>\n<| a tags=r |>\nHere is a solution using only base R:\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nHere\
    \ is a solution using only base R:\n<code>\ncommon <- function(l1, l2) {\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n\
    <|/ a tags=r |>\n<| a tags=r |>\nHere is a solution using only base R:\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r |>\nHere is\
    \ a solution using only base R:\n<code>\ncommon <- function(l1, l2) {\n  u1 <-\
    \ unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != ", "\n  l1 <- sort(l1)\n\
    \  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| c |>\nThanks for your answer. Your solution works perfectly\
    \ for my example but when I try to use it on my real data set it gives me this\
    \ error `Error in sort.list(y) : 'x' must be atomic for 'sort.list'\nHave you\
    \ called 'sort' on a list?`\n<|/ c |>\n<| c |>\nI added a reproducible example\
    \ to my question. Maybe you can help me with that?\n<|/ c |>\n<| c |>\nI added\
    \ a reproducible example to my question. Maybe you can help me with that?\n<|/\
    \ c |>\n<| c |>\nI added a reproducible example to my question. Maybe you can\
    \ help me with that?\n<|/ c |>\n<| c |>\nI added a reproducible example to my\
    \ question. Maybe you can help me with that?\n<|/ c |>\n<| a dscore=1 |>\nHere\
    \ is a solution using data.table:\n<code>\nlibrary(data.table)", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r |>\n\
    <| c |>\nThis doesn't seem to work if there are repeated elements in the lists.\
    \ For example, `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\
    \ returns `list(1, 5, 653)`\n<|/ c |>\n<| c |>\nYes, I realized that after I posted\
    \ my comment. I've updated my answer to account for repeated elements.\n<|/ c\
    \ |>\n<| a tags=r |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\n\
    setkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))),\
    \ l1, l2)\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5,\
    \ 9, 653, 121))), l2, l1)\n</code>\nThe setkey function sorts the data.table by\
    \ l1 and l2 and then by l2, l1 so that the first two lines of the code above are\
    \ equivalent to:\n<code>\nsetkey(setDT(list(l1 = c(1, 4, 3, 34, 653, 2, 5), l2\
    \ = c(5, 7, 1, 5, 9, 653, 121))), l2, l1)\nsetkey(setDT(list(l1 = c(1, 4, 3, 34,\
    \ 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\n</code>\n<|/ a dscore=2\
    \ |>\n<| a tags=r |>\nHere's a solution using dplyr and purrr packages:\n<code>\n\
    library(dplyr)\nlibrary(purrr)\n\nl1 <- c(1, 4, 3, 34, 653, 2, 5)\nl2 <- c(5,\
    \ 7, 1, 5, 9, 653, 121)\n\ncommon_elements <- function(l1, l2) {\n  l1 <- sort(unique(l1))\n\
    \  l2 <- sort(unique(l2))\n  l1[l1 == l2]\n}\n\ncommon_elements(l1, l2)\n</code>\n\
    <|/ a dscore=2 |>\n<| a dscore=1 |>\nHere's a solution using base R:\n<code>\n\
    l1 <- c(1, 4, 3, 34, 653, 2, 5)\nl2 <- c(5, 7, 1, 5, 9, 653, 121)", "\n  l1 <-\
    \ sort(l1)\n  l2 <- sort(l2)\n  i <- 0\n  j <- 1\n  res <- list()\n  while(i <\
    \ length(l1) && j < length(l2)) {\n    if(l1[i] == l2[j]) {\n      res[[i]] <-\
    \ l1[i]\n      i <- i + 1\n      j <- j + 1\n    }\n    else if(l1[i] < l2[j])\
    \ {\n      i <- i + 1\n    }\n    else {\n      j <- j + 1\n    }\n  }\n  if(i\
    \ < length(l1)) {\n    res[[i]] <- l1[i]\n  }\n  if(j < length(l2)) {\n    res[[i]]\
    \ <- l2[j]\n  }\n  return(res)\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\nThanks\
    \ for your answer. Your code works perfectly for small lists, but for large lists\
    \ it takes too long to run. Do you know any way to make it faster?\n<|/ c |>\n\
    <| c |>\nI added a faster version to my answer. Hope it helps.\n<|/ c |>\n<| c\
    \ |>\nThanks again! Your code works perfectly for small lists, but for large lists\
    \ it takes too long to run. Do you know any way to make it faster?\n<|/ c |>\n\
    <| c |>\nI added a faster version to my answer. Hope it helps.\n<|/ c |>\n<| c\
    \ |>\nThanks again! Your code works perfectly for small lists, but for large lists\
    \ it takes too long to run. Do you know any way to make it faster?\n<|/ c |>\n\
    <| a tags=r |>\nHere's a solution using data.table:\n<code>\nlibrary(data.table)\n\
    setDT(df)\ndf[, i := .I]\ndf[, j := .I]\ndf[, j := j - i, by = i]\ndf[, j := j\
    \ - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j :=\
    \ j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j :=\
    \ j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j :=\
    \ j - i, by = i]\ndf[, j := j - i, by = i]\ndf[, j := j", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 %in% u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to do this\
    \ without having to sort the lists.\n<|/ c |>\n<| c |>\nI added a solution that\
    \ doesn't require sorting.\n<|/ c |>\n<| c |>\nI like the `common` function but\
    \ I don't think it works. Try `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5,\
    \ 9, 653, 121))`\n<|/ c |>\n<| c |>\nI added a version that doesn't require sorting.\n\
    <|/ c |>\n<| c |>\nI like your `common` function, but I wonder if there is a way\
    \ to do this without having to sort the lists.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThanks for the answer! I didn't know about `intersect` before.\
    \ Unfortunately, it seems that `intersect` doesn't work on lists containing `NA`s.\
    \ I edited my question to include a reproducible example.\n<|/ c |>\n<| c |>\n\
    I edited my answer to include a function that should work for your updated example.\n\
    <|/ c |>\n<| c |>\nThanks for the edit! I tested it and it works for the example\
    \ I gave, but when I apply it to my actual data, it returns `list()` instead of\
    \ `list(1, 5, 653)`. Any idea why this might be?\n<|/ c |>\n<| c |>\nIt works\
    \ for me with the example you gave. Maybe you can post a reproducible example\
    \ that doesn't work for you?\n<|/ c |>\n<| c |>\nI edited my question to include\
    \ a reproducible example that doesn't work for me.\n<|/ c |>\n<| a dscore=1 |>\n\
    Here is a solution using dplyr and purrr:\n<code>\nlibrary(dplyr)\nlibrary(purrr)\n",
  "\n  l1 <- sort(l1)\n  l2 <- sort(l2)\n  u <- unique(c(l1, l2))\n  u[!duplicated(u)]\n\
    }\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThanks for your answer. I'm\
    \ getting an error when I try to use your code. `Error in sort(l1) : object 'l1'\
    \ not found`\n<|/ c |>\n<| c |>\nSorry, I forgot to add `l1 <- sort(l1)`. I edited\
    \ my answer.\n<|/ c |>\n<| c |>\nThanks for your answer. I'm getting an error\
    \ when I try to use your code. `Error in sort(l1) : object 'l1' not found`\n<|/\
    \ c |>\n<| c |>\nSorry, I forgot to add `l1 <- sort(l1)`. I edited my answer.\n\
    <|/ c |>\n<| c |>\nThanks for your answer. I'm getting an error when I try to\
    \ use your code. `Error in sort(l1) : object 'l1' not found`\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\n<code>", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1\
    \ == u2]\n}\n</code>\n<|/ a tags=r,list,unique,intersection |>\n<| c |>\nThis\
    \ doesn't work for me. `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653,\
    \ 121))` returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`\n<|/ c |>\n\
    <| c |>\nI see what you mean. I've updated the answer to account for this.\n<|/\
    \ c |>\n<| c |>\nI see what you mean. I've updated the answer to account for this.\n\
    <|/ c |>\n<| a tags=r,list,unique,intersection |>\n<code>\nintersect(list(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121)), list(c(5, 3, 2, 8), c(3,\
    \ 2)))\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\nI like using Reduce for\
    \ this sort of thing:\n<code>\nReduce(intersect, list(c(1, 4, 3, 34, 653, 2, 5),\
    \ c(5, 7, 1, 5, 9, 653, 121)))", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a |>\n<| c |>\nThis does not work if there\
    \ are duplicates in either list.\n<|/ c |>\n<| c |>\nYes, it does. I tested it\
    \ before posting it. The OP did not specify what should happen if there are duplicates\
    \ in either list.\n<|/ c |>\n<| c |>\nI tested it again and it does work. Try\
    \ it yourself.\n<|/ c |>\n<| c |>\nI tested it again and it does work. Try it\
    \ yourself. It returns `list(1, 5, 653)` as expected.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. I tested it before posting it. The OP did not specify what should happen\
    \ if there are duplicates in either list.\n<|/ c |>\n<| a dscore=2 |>\nHere's\
    \ a solution using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1 = c(1,\
    \ 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\nsetkey(setDT(list(l1\
    \ = c(1, 4, 3, 34, 653, 2, 5), l2 = c(5, 7, 1, 5, 9, 653, 121))), l2, l1)\n</code>\n\
    This gives:\n<code>\n   l1 l2\n1:  1  5\n2:  4  7\n3:  3  1\n4: 34 653\n5: 653\
    \ 121\n</code>\n<|/ a tags=r,list |>\n<| c |>\nThis does not work if there are\
    \ duplicates in either list.\n<|/ c |>\n<| c |>\nYes, it does. I tested it before\
    \ posting it. The OP did not specify what should happen if there are duplicates\
    \ in either list.\n<|/ c |>\n<| c |>\nI tested it again and it does work. Try\
    \ it yourself.\n<|/ c |>\n<| c |>\nI tested it again and it does work. Try it\
    \ yourself. It returns `list(1, 5, 653)` as expected.\n<|/ c |>\n<| c |>\nYes,\
    \ it does. I tested it before posting it. The OP did not specify what should happen\
    \ if there are duplicates in either list.\n<|/ c ", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| a |>\nI came up with a solution using purrr::map2\n<code>\nlibrary(purrr)\n",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n", "\n\
    \  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a tags=r,list,unique |>\n<| c |>\nThis doesn't seem to work if there are repeated\
    \ elements in the lists. For example, `common(c(1,4,3,34,653,5,7,1,5,9,653,121),\
    \ c(5,7,1,5,9,653,121))` returns `list(1, 5, 653)` instead of `list(1, 5, 653,\
    \ 121)`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it before I saw your\
    \ comment. Thanks for pointing it out.\n<|/ c |>\n<| a dscore=4 |>\nHere's a solution\
    \ using data.table:\n<code>\nlibrary(data.table)\nsetDT(list(l1=c(1, 4, 3, 34,\
    \ 653, 5), l2=c(5, 7, 1, 5, 9, 653, 121)))\nsetkey(setDT(list(l1=c(1, 4, 3, 34,\
    \ 653, 5), l2=c(5, 7, 1, 5, 9, 653, 121))), l1, l2)\nunique(setDT(list(l1=c(1,\
    \ 4, 3, 34, 653, 5), l2=c(5, 7, 1, 5, 9, 653, 121))))\n</code>\n<|/ a tags=r,list,unique\
    \ |>\n<| c |>\nThis doesn't seem to work if there are repeated elements in the\
    \ lists. For example, `setDT(list(l1=c(1, 4, 3, 34, 653, 5), l2=c(5, 7, 1, 5,\
    \ 9, 653, 121)))` returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`.\n\
    <|/ c |>\n<| c |>\nYes, I noticed that and fixed it before I saw your comment.\
    \ Thanks for pointing it out.\n<|/ c |>\n<| a dscore=3 |>\n<code>\n> x <- list(c(1,\
    \ 4, 3, 34, 653, 5), c(5, 7, 1, 5, 9, 653, 121))\n> y <- list(c(1, 4, 3, 34, 653,\
    \ 5), c(5, 7, 1, 5, 9, 653, 121))\n> x <- unique(x)\n> y <- unique(y)\n> x\n[[1]]\n\
    [1] 1 4 3 34 653 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n> y\n[[1]]\n[1] 1 4 3 34 653\
    \ 5\n\n[[2]]\n[1] 5 7 1 5 9 653 121\n> \n</code>\n<|/ a tags=r,list,unique |>\n\
    <|", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 != u1]\n\
    }\n</code>\n<|/ a tags=r,list,unique |>\n<| a tags=r,list,unique |>\n<code>",
  "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 %in% u1]\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThis doesn't seem to work if there are duplicates in\
    \ either list.\n<|/ c |>\n<| c |>\nIt does work if there are duplicates in either\
    \ list. Try it yourself.\n<|/ c |>\n<| c |>\nI did. `common(c(1, 4, 3, 34, 653,\
    \ 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<|\
    \ c |>\nI see what you mean. My bad.\n<|/ c |>\n<| a dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u2%in%u1]\n}\n</code>\n\
    <|/ a tags=r |>\n<| c |>\nThis doesn't seem to work if there are duplicates in\
    \ either list.\n<|/ c |>\n<| a |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n\
    \  u2<-unique(c(l2,l1))\n  u1[u2%in%u1]\n}\n</code>\n<|/ a tags=r dscore=0 |>\n\
    <| c |>\nThis doesn't seem to work if there are duplicates in either list.\n<|/\
    \ c |>\n<| a dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n\
    \  u2<-unique(c(l2,l1))\n  u1[u2%in%u1]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    This doesn't seem to work if there are duplicates in either list.\n<|/ c |>\n\
    <| a dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n \
    \ u2<-unique(c(l2,l1))\n  u1[u2%in%u1]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    This doesn't seem to work if there are duplicates in either list.\n<|/ c |>\n\
    <| a |>\n<code>\ncommon<-function(l", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nThis\
    \ does not give the correct answer for `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))`\n<|/ c |>\n<| c |>\nI believe that is the correct answer\
    \ for the example given in the question. `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<| c |>\nYes, but\
    \ `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1,\
    \ 5, 653)` not `list(1, 5, 653, 121)`\n<|/ c |>\n<| c |>\nAh I see what you mean.\
    \ I'll update my answer.\n<|/ c |>\n<| c |>\nI believe that is the correct answer\
    \ for the example given in the question. `common(c(1, 4, 3, 34, 653, 2, 5), c(5,\
    \ 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\n<|/ c |>\n<| a dscore=0 |>\n\
    <code>\ncommon <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nWhile\
    \ this code may answer the question, providing additional context regarding why\
    \ and/or how this code answers the question improves its long-term value.\n<|/\
    \ c |>\n<| c |>\nThis does not give the correct answer for `common(c(1, 4, 3,\
    \ 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\n<|/ c |>\n<| a dscore=0 |>\n<code>\n\
    common <- function(l1, l2) {\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2,\
    \ l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a tags=r,list,unique |>\n<| c |>\nWhile\
    \ this code may answer the question, providing additional context regarding why\
    \ and/or how this code answers the question improves its long-term value.\n<|/\
    \ c |>\n<| c |>\nThis does not give the correct answer for `common(c", "\n  u1\
    \ <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there are duplicates in the lists.\
    \ For example, `common(c(1, 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))`\
    \ returns `list(1, 5, 653)` instead of `list(1, 5, 653, 121)`.\n<|/ c |>\n<| c\
    \ |>\n, you're right. I fixed the code. Thanks!\n<|/ c |>\n<| a tags=r,list,unique\
    \ |>\n<code>\nlibrary(data.table)\nlibrary(magrittr)\n", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| c |>\nThanks for the answer! I tested it and it works great! However,\
    \ I still don't understand why my code doesn't work. Could you please explain\
    \ it to me?\n<|/ c |>\n<| c |>\nI added an explanation to the answer.\n<|/ c |>\n\
    <| c |>\nThank you very much! I understand it now!\n<|/ c |>\n<| a dscore=1 |>\n\
    The problem is that the function common is called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicates from the vectors passed to it, so the\
    \ vectors passed to common must be of equal length. \nThe function common is then\
    \ called with vectors of different lengths. \nThe function unique removes duplicates\
    \ from the vectors passed to it, so the vectors passed to common must be of equal\
    \ length. \nThe function common is then called with vectors of different lengths.\
    \ \nThe function unique removes duplicate", "\n  u1 <- unique(c(l1, l2))\n  u2\
    \ <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2 |>\n<| c |>\n\
    I like your solution, but I believe it can be optimized a bit. For example, `common(c(1,\
    \ 4, 3, 34, 653, 2, 5), c(5, 7, 1, 5, 9, 653, 121))` returns `list(1, 5, 653)`\
    \ instead of `list(1, 5, 653, 121)`. Also, `common(c(5, 3, 2, 8), c(3, 2))` returns\
    \ `list(2, 3)` instead of `list(2, 3)`. You can see my answer for a more optimized\
    \ version.\n<|/ c |>\n<| c |>\nThanks for the comment. I've updated my answer\
    \ to include your suggestions.\n<|/ c |>\n<| a tags=r,unique,intersection,list\
    \ |>\nHere is a solution using base R:\n<code>", "\n  u1 <- unique(c(l1, l2))\n\
    \  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=1 |>\n<|\
    \ c |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c\
    \ |>\n<| c |>\nI added a version that works with repeated elements.\n<|/ c |>\n\
    <| c |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c\
    \ |>\n<| c |>\nI added a version that works with repeated elements.\n<|/ c |>\n\
    <| a tags=r |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n\
    \  u1[u1==u2]\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThis doesn't work if there\
    \ are repeated elements in the lists.\n<|/ c |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/\
    \ a tags=r |>\n<| a |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n\
    \  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/ a tags=r dscore=0 |>\n\
    <| c |>\nThis doesn't work if there are repeated elements in the lists.\n<|/ c\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\n\
    <|/ c |>\n<| a dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n\
    \  u2<-unique(c(l2,l1))\n  u1[u1==u2]\n}\n</code>\n<|/ a tags=r |>\n<| c |>\n\
    This doesn't work if there are repeated elements in the lists.\n<|/ c |>\n<| a\
    \ dscore=0 |>\n<code>\ncommon<-function(l1,l2){\n  u1<-unique(c(l1,l2))\n  u2<-unique(c(l2,l1))\n\
    \  u1[", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n\
    }\n</code>\n<|/ a tags=r,list |>\n<| c |>\nI like your answer but I think it can\
    \ be simplified a bit. `common` can be simplified to `u1 <- unique(c(l1, l2));\
    \ u2 <- unique(c(l2, l1)); u1[u1 == u2]`\n<|/ c |>\n<| c |>\nThanks, I didn't\
    \ know that `unique` could take two vectors as inputs. I updated my answer.\n\
    <|/ c |>\n<| a tags=r,list |>\nI like using Reduce:\n<code>\nReduce(intersect,\
    \ list1, list2)\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted\
    \ answer. `Reduce` is designed for this.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer. `Reduce` is designed for this.\n<|/ c |>\n<| a tags=r,list\
    \ |>\n<code>\n> list1 <- list(a = 1, b = 2, c = 3)\n> list2 <- list(a = 2, b =\
    \ 2, c = 4)\n> list3 <- list(a = 1, b = 2, c = 4)\n> list4 <- list(a = 2, b =\
    \ 2, c = 4)\n> list5 <- list(a = 1, b = 2, c = 4)\n> list6 <- list(a = 1, b =\
    \ 2, c = 4)\n> list7 <- list(a = 1, b = 2, c = 4)\n> list8 <- list(a = 1, b =\
    \ 2, c = 4)\n> list9 <- list(a = 1, b = 2, c = 4)\n> list10 <- list(a = 1, b =\
    \ 2, c = 4)\n> list11 <- list(a = 1, b = 2, c = 4)\n> list12 <- list(a = 1, b\
    \ = 2, c = 4)\n> list13 <- list(a = 1, b = 2, c = 4)\n> list14 <- list(a = 1,\
    \ b = 2, c = 4)\n> list15 <- list(a = 1, b = 2, c = 4)\n> list16 <- list(a = 1,\
    \ b = 2, c = 4)\n> list17 <- list(a = 1, b = 2, c = 4)\n> list18 <- list(a = 1,\
    \ b = 2, c = 4)\n> list19 <- list(a = 1, b = 2, c = 4)\n> list20 <- list(a = 1,\
    \ b = 2, c = 4)\n> list21 <- list(a = 1, b = 2, c = 4)", "\n  u1 <- unique(c(l1,\
    \ l2))\n  u2 <- unique(c(l2, l1))\n  u1[u1 == u2]\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| c |>\nThis doesn't work if there are repeated elements in the lists.\
    \ For example: `common(c(1,2,3), c(1,2,3))` returns `[1] 1 2 3` instead of `[1]\
    \ 1 3`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed it now. Thanks.\n<|/\
    \ c |>\n<| a |>\n<code>\ncommon<-function(l1,l2){\n  u1<-sort(unique(c(l1,l2)))\n\
    \  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n</code>\n<|/ a tags=r dscore=2\
    \ |>\n<| a tags=r |>\nI like using %in% for this:\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1%in%u2]\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n\
    </code>\n<|/ a tags=r |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n\
    </code>\n<|/ a tags=r |>\n<| a tags=r |>\n<code>\ncommon<-function(l1,l2){\n \
    \ u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n\
    </code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\ncommon<-function(l1,l2){\n\
    \  u1<-sort(unique(c(l1,l2)))\n  u2<-sort(unique(c(l2,l1)))\n  u1[u1==u2]\n}\n\
    </code>\n", "\n  u1 <- unique(c(l1, l2))\n  u2 <- unique(c(l2, l1))\n  u1[u2 !=\
    \ u1]\n}\n</code>\n<|/ a tags=r,list,merge |>\n<| a tags=r,list,merge |>\nHere's\
    \ a solution using base R:\n<code>"]
stop_tokens:
- "\n#"
- "\n```"
