name: HumanEval_49_modp
language: r
prompt: "# Return 2^n modulo p (be aware of numerics).\n# >>> modp(3, 5)\n# 3\n# >>>\
  \ modp(1101, 101)\n# 2\n# >>> modp(0, 101)\n# 1\n# >>> modp(3, 11)\n# 8\n# >>> modp(100,\
  \ 101)\n# 1\nmodp <- function(n, p) {"
tests: "test_humaneval <- function() {\ncandidate <- modp\n    if(!identical(candidate(3,\
  \ 5), 3)){quit('no', 1)}\n    if(!identical(candidate(1101, 101), 2)){quit('no',\
  \ 1)}\n    if(!identical(candidate(0, 101), 1)){quit('no', 1)}\n    if(!identical(candidate(3,\
  \ 11), 8)){quit('no', 1)}\n    if(!identical(candidate(100, 101), 1)){quit('no',\
  \ 1)}\n    if(!identical(candidate(30, 5), 4)){quit('no', 1)}\n    if(!identical(candidate(31,\
  \ 5), 3)){quit('no', 1)}\n}\ntest_humaneval()"
completions: ["\n  n <- as.integer(n)\n  p <- as.integer(p)\n  if(n == 0) return(1)\n\
    \  if(p == 0) return(0)\n  if(p == 1) return(n)\n  if(n == 1) return(p)\n  if(n\
    \ == 2) return(p ^ 1)\n  if(n == 3) return(p ^ 2)\n  if(n == 4) return(p ^ 3)\n\
    \  if(n == 5) return(p ^ 4)\n  if(n == 6) return(p ^ 5)\n  if(n == 7) return(p\
    \ ^ 6)\n  if(n == 8) return(p ^ 7)\n  if(n == 9) return(p ^ 8)\n  if(n == 10)\
    \ return(p ^ 9)\n  if(n == 11) return(p ^ 10)\n  if(n == 12) return(p ^ 11)\n\
    \  if(n == 13) return(p ^ 12)\n  if(n == 14) return(p ^ 13)\n  if(n == 15) return(p\
    \ ^ 14)\n  if(n == 16) return(p ^ 15)\n  if(n == 17) return(p ^ 16)\n  if(n ==\
    \ 18) return(p ^ 17)\n  if(n == 19) return(p ^ 18)\n  if(n == 20) return(p ^ 19)\n\
    \  if(n == 21) return(p ^ 20)\n  if(n == 22) return(p ^ 21)\n  if(n == 23) return(p\
    \ ^ 22)\n  if(n == 24) return(p ^ 23)\n  if(n == 25) return(p ^ 24)\n  if(n ==\
    \ 26) return(p ^ 25)\n  if(n == 27) return(p ^ 26)\n  if(n == 28) return(p ^ 27)\n\
    \  if(n == 29) return(p ^ 28)\n  if(n == 30) return(p ^ 29)\n  if(n == 31) return(p\
    \ ^ 30)\n  if(n == 32) return(p ^ 31)\n  if(n == 33) return(p ^ 32)\n  if(n ==\
    \ 34) return(p ^ 33)\n  if(n == 35) return(p ^ 34)\n  if(n == 36) return(p ^ 35)\n\
    \  if(n == 37) return(p ^ 36)\n  if(n == 38) return(p ^ 37)\n  if(n == 39) return(p\
    \ ^ 38)\n  if(n == 40) return(p ^ 39", "\n  return(mod((p + 1) * (n - p + 1),\
    \ p))\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n\
    }\n", "\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a dscore=3 |>\n<| c\
    \ |>\nThis doesn't work. `modp(3, 5)` returns `3` instead of `2`.\n<|/ c |>\n\
    <| c |>\nIt does work. `modp(3, 5)` returns `2` because `log2(3)` is `1` and `log2(5)`\
    \ is `2`.\n<|/ c |>\n<| c |>\nYes, it does work. `modp(3, 5)` returns `2` because\
    \ `log2(3)` is `1` and `log2(5)` is `2`.\n<|/ c |>\n<| c |>\nYes, it does work.\
    \ `modp(3, 5)` returns `2` because `log2(3)` is `1` and `log2(5)` is `2`.\n<|/\
    \ c |>\n<| c |>\nYes, it does work. `modp(3, 5)` returns `2` because `log2(3)`\
    \ is `1` and `log2(5)` is `2`.\n<|/ c |>\n<| a tags=r,modulo,integer-division\
    \ |>\nThe accepted answer does not work for negative numbers. Here is a function\
    \ that works for negative numbers:\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work. `modp(3, 5)`\
    \ returns `3` instead of `2`.\n<|/ c |>\n<| a tags=r,modulo,integer-division |>\n\
    The accepted answer does not work for negative numbers. Here is a function that\
    \ works for negative numbers:\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=r,modulo,integer-division |>\n\
    <code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n\
    <|/ a dscore=2 |>\n<| a tags=r,modulo,integer-division |>\n<code>\nmodp <- function(n,\
    \ p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,modulo,integer-division\
    \ |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n",
  "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ifelse(n < 0, -modp(-n, p),\
    \ modp(n, p)))\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=1 |>\n<| a tags=r,integer,modulo,math |>\nI\
    \ believe this should work:\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nmodp <- function(n,\
    \ p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a tags=r,integer,modulo,math\
    \ |>\n<| a dscore=1 |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a tags=r,integer,modulo,math |>\n<| a tags=r,integer,modulo,math\
    \ |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a tags=r,integer,modulo,math |>\n<| a tags=r,integer,modulo,math\
    \ |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=r,integer,modulo,math |>\n<code>\nmodp <- function(n,\
    \ p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a dscore=0 |>\n<| a tags=r,integer,modulo,math\
    \ |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a dscore=0 |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a tags=r,integer,modulo,math |>\n<| a tags=r,integer,modulo,math\
    \ |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| a tags=r,integer,modulo,math |>\n<code>\nmodp <- function(n, ",
  "\n  return(ceiling(log2(n))%%p)\n}\n</code>\n<|/ a |>\n<| c |>\nThis doesn't work\
    \ for large numbers. `modp(1e30, 1e30)` returns `0`.\n<|/ c |>\n<| c |>\nI guess\
    \ you meant `modp(1e30, 1e31)` returns `1`\n<|/ c |>\n<| c |>\nYes, I meant `modp(1e30,\
    \ 1e31)` returns `1`.\n<|/ c |>\n<| c |>\nYes, I meant `modp(1e30, 1e31)` returns\
    \ `1`.\n<|/ c |>\n<| c |>\nThis doesn't work for large numbers. `modp(1e30, 1e30)`\
    \ returns `0`.\n<|/ c |>\n<| a dscore=5 |>\nHere's a function that will do what\
    \ you want:\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))%%p)\n\
    }\n</code>\n<|/ a tags=r,modulo |>\n<| c |>\nThis doesn't work for large numbers.\
    \ `modp(1e30, 1e30)` returns `0`.\n<|/ c |>\n<| c |>\n: I guess you meant `modp(1e30,\
    \ 1e31)` returns `1`\n<|/ c |>\n<| c |>\n: I guess you meant `modp(1e30, 1e31)`\
    \ returns `1`\n<|/ c |>\n<| c |>\n: I guess you meant `modp(1e30, 1e31)` returns\
    \ `1`\n<|/ c |>\n<| c |>\n: I guess you meant `modp(1e30, 1e31)` returns `1`\n\
    <|/ c |>\n<| a dscore=5 |>\nThe package gmp can do this.\n<code>\nlibrary(gmp)\n\
    modp(1e30, 1e30)\n[1] 0\n</code>\n<|/ a tags=r,modulo |>\n<| c |>\nThis doesn't\
    \ work for large numbers. `modp(1e30, 1e30)` returns `0`.\n<|/ c |>\n<| c |>\n\
    This package is no longer maintained.\n<|/ c |>\n<| c |>\nThe package is still\
    \ maintained.\n<|/ c |>\n<| c |>\nThis package is still maintained. `modp(1e30,\
    \ 1e30)` returns `0`.\n<|/ c |>\n<| a tags=r,modulo ", "\n  return(mod((2^n)%p,\
    \ p))\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(mod((2^n)-1, p))\n}\n</code>\n<|/ a tags=r,modulo,integer-division\
    \ |>\n<| c |>\nI like this solution, but I wonder if there is a way to avoid the\
    \ use of mod. For example, if I wanted to compute `2^n` modulo `p`, I would have\
    \ to compute `2^n` modulo `p^2`, which would require a division operation. Is\
    \ there a way to avoid this division?\n<|/ c |>\n<| c |>\n: Yes, you can avoid\
    \ the division by using repeated squaring. See my answer.\n<|/ c |>\n<| a dscore=5\
    \ |>\nThe package Rmpfr has a function mpfr::mpfrmod which does what you want.\n\
    <code>\nlibrary(Rmpfr)\nmpfrmod(\"2^n\", p)\n</code>\n<|/ a tags=r,modulo,integer-division\
    \ |>\n<| c |>\nThis should be the accepted answer since it uses Rmpfr instead\
    \ of base R.\n<|/ c |>\n<| c |>\nThis should be the accepted answer since it uses\
    \ Rmpfr instead of base R.\n<|/ c |>\n<| c |>\nThis should be the accepted answer\
    \ since it uses Rmpfr instead of base R.\n<|/ c |>\n<| c |>\nThis should be the\
    \ accepted answer since it uses Rmpfr instead of base R.\n<|/ c |>\n<| c |>\n\
    This should be the accepted answer since it uses Rmpfr instead of base R.\n<|/\
    \ c |>\n<| a tags=r,modulo,integer-division |>\nThe package Rmpfr has a function\
    \ mpfr::mpfrmod which does what you want.\n<code>\nlibrary(Rmpfr)\nmpfrmod(\"\
    2^n\", p)\n</code>\n<|/ a dscore=5 |>\n<| c |>\nThis should be the accepted answer\
    \ since it uses Rmpfr instead of base R.\n<|/ c |>\n<| a tags=r,modulo,integer-division\
    \ |>\nThe package Rmpfr has a function mpfr::mpfrmod which does what you want.\n\
    <code>\nlibrary(Rmpfr)\nmpfrmod(\"2^n\", p)\n</code>\n<|/ a dscore=5 |>\n<| c\
    \ |>\nThis should be the accepted answer since it uses Rmpfr instead of base R.\n\
    <|/ c |>\n<| a dscore=4 |>\nThe package Rmpfr has a function mp", "\n  return(mod((2^n)-1,\
    \ p))\n}\n", "\n  return(as.integer(p^n)) %% p\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n\
    }\n", "\n  n <- as.integer(n)\n  p <- as.integer(p)\n  return(as.integer(p + p^n\
    \ * (1-p^n)))\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n\
    }\n", "\n  n <- as.integer(n)\n  p <- as.integer(p)\n  return(ifelse(n %% p ==\
    \ 0, n, n - mod((n - 1) %% p, p)))\n}\n", "\n  return(mod((2^n)-1, p))\n}\n",
  "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  n <- as.integer(n)\n  p <- as.integer(p)\n\
    \  return(as.integer(p^n%p))\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n",
  "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n\
    }\n", "\n  return(mod((2^n)-1, p))\n}\n", "\n  return(ceiling(log2(n))-log2(p))\n\
    }\n", "\n  return(ifelse(n < p, n, p + modp(n - p, p)))\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(mod((2^n)-1,\
    \ p))\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThis doesn't work for negative\
    \ numbers. `modp(3, -5)` returns `1` instead of `3`.\n<|/ c |>\n<| c |>\nThanks,\
    \ I fixed it.\n<|/ c |>\n<| a dscore=3 |>\nHere's a solution using modular arithmetic:\n\
    <code>\nmodp <- function(n, p) {\n  return(mod((2^n)-1, p))\n}\n</code>\n<|/ a\
    \ tags=math,r,modulo |>\n<| a tags=math,r,modulo |>\nHere's a solution that works\
    \ with negative numbers:\n<code>\nmodp <- function(n, p) {\n  return(mod((2^n)-1,\
    \ p))\n}\n</code>\n<|/ a dscore=3 |>\n<| a tags=math,r,modulo |>\n<code>\nmodp\
    \ <- function(n, p) {\n  return(mod((2^n)-1, p))\n}\n</code>\n<|/ a dscore=2 |>\n\
    <| a dscore=2 |>\n<code>\nmodp <- function(n, p) {\n  return(mod((2^n)-1, p))\n\
    }\n</code>\n<|/ a tags=math,r,modulo |>\n<| a tags=math,r,modulo |>\n<code>\n\
    modp <- function(n, p) {\n  return(mod((2^n)-1, p))\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\n<code>\nmodp <- function(n, p) {\n  return(mod((2^n)-1,\
    \ p))\n}\n</code>\n<|/ a tags=math,r,modulo |>\n<| a |>\n<code>\nmodp <- function(n,\
    \ p) {\n  return(mod((2^n)-1, p))\n}\n</code>\n<|/ a tags=math,r,modulo dscore=2\
    \ |>\n<| a dscore=1 |>\n<code>\nmodp <- function(n, p) {\n  return(mod((2^n)-1,\
    \ p))\n}\n</code>\n<|/ a tags=math,r,modulo |>\n<| a tags=math,r,modulo |>\n<code>\n\
    modp <- function(n, p) {\n  return(mod((2^n)-1, p))\n}\n</code>\n<|/ a dscore=1\
    \ |>\n<| a tags=math,r,modulo |>\n<code>\nmodp <- function(n, p) {\n  return(mod((2^n)-1,\
    \ p))\n}\n</code>\n<|/ a dscore=1 |>\n<|", "\n  return(ceiling(log2(n)) %% p)\n\
    }\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n)) %%\
    \ p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(mod((2^n)-1,\
    \ p))\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(mod((p + 1) %% n, p))\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n}\n", "\n  return(mod((2^n)-1,\
    \ p))\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n}\n", "\n  return(mod((2^n)-1,\
    \ p))\n}\n</code>\n<|/ a dscore=1 |>\n<| c |>\nThanks for your answer. I'm going\
    \ to try this out and see how it goes. I appreciate your time.\n<|/ c |>\n<| c\
    \ |>\nI ran your function and got this error: `Error in mod((2^n)-1, p) : non-numeric\
    \ argument to binary operator`\n<|/ c |>\n<| c |>\nI forgot to add `mod` as a\
    \ function. I added it now.\n<|/ c |>\n<| c |>\nI ran your function and got this\
    \ error: `Error in mod((2^n)-1, p) : non-numeric argument to binary operator`\n\
    <|/ c |>\n<| c |>\nI forgot to add `mod` as a function. I added it now.\n<|/ c\
    \ |>\n<| a dscore=0 |>\nI believe this should work:\n<code>\nmodp <- function(n,\
    \ p) {\n  return(mod((2^n)-1, p))\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks\
    \ for your answer. I'm going to try this out and see how it goes. I appreciate\
    \ your time.\n<|/ c |>\n<| c |>\nI ran your function and got this error: `Error\
    \ in mod((2^n)-1, p) : non-numeric argument to binary operator`\n<|/ c |>\n<|\
    \ c |>\nI forgot to add `mod` as a function. I added it now.\n<|/ c |>\n<| a dscore=0\
    \ |>\nThe mod function will return the remainder of a division operation between\
    \ two integers. \n<code>\nmod <- function(x,y) return(x%y)\n</code>\nSo if you\
    \ want a function that returns the remainder of a division operation between two\
    \ integers, you can use the mod function. \n<code>\nmodp <- function(n, p){\n\
    \  return(mod((2^n)-1, p))\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks for your\
    \ answer. I'm going to try this out and see how it goes. I appreciate your time.\n\
    <|/ c |>\n<| c |>\nI ran your function and got this error: `Error in mod((2^n)-1,\
    \ p) : non-numeric argument to binary operator`\n<|/ c |>\n<| c |>\nI forgot to\
    \ add `mod` as a function. I added it now.\n<|/ c |>\n<| c |>\nI ran your function\
    \ and got this error: `Error in mod((", "\n  return(as.integer(p^n) % p)\n}\n",
  "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ifelse(n < 0, -modp(abs(n),\
    \ p), modp(abs(n), p)))\n}\n", "\n  return(ifelse(n %% p == 0, n, modp(n - n,\
    \ p)))\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(mod((2^n)-1, p))\n}\n", "\n  return(as.integer(p^n))\
    \ %% p\n}\n", "\n  return(mod((2^n)-1, p))\n}\n", "\n  return(ceiling(log2(n))%%p)\n\
    }\n", "\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a tags=r,modulo |>\n\
    <| c |>\nI like this solution, but I wonder if there is a way to avoid the use\
    \ of log2()?\n<|/ c |>\n<| c |>\nI guess you could use `log2(n)` instead of `log(n)/log(p)`\
    \ but that would only work if `p` is prime. Otherwise you'd have to find a way\
    \ to determine if `n` is divisible by `p`.\n<|/ c |>\n<| c |>\nI guess you could\
    \ use `log2(n)` instead of `log(n)/log(p)` but that would only work if `p` is\
    \ prime. Otherwise you'd have to find a way to determine if `n` is divisible by\
    \ `p`.\n<|/ c |>\n<| c |>\nI guess you could use `log2(n)` instead of `log(n)/log(p)`\
    \ but that would only work if `p` is prime. Otherwise you'd have to find a way\
    \ to determine if `n` is divisible by `p`.\n<|/ c |>\n<| c |>\nI guess you could\
    \ use `log2(n)` instead of `log(n)/log(p)` but that would only work if `p` is\
    \ prime. Otherwise you'd have to find a way to determine if `n` is divisible by\
    \ `p`.\n<|/ c |>\n<| a tags=r,modulo |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=5 |>\n<| a tags=r,modulo |>\n<code>\nmodp <-\
    \ function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| a tags=r,modulo |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=4 |>\n<| a tags=r,modulo |>\n<code>\nmodp <-\
    \ function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a dscore=4\
    \ |>\n<| a dscore=4 |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a tags=r,modulo |>\n<| a tags=r,modulo |>\n<code>\nmodp\
    \ <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a ", "\n\
    \  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n",
  "\n  n <- as.integer(n)\n  p <- as.integer(p)\n  return(2^(n%p)) %% p\n}\n", "\n\
    \  return(mod((p^n) %% p, p))\n}\n", "\n  return(mod((n-1)%p + 1, p))\n}\n", "\n\
    \  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n))-log2(p))\n\
    }\n", "\n  n <- as.integer(n)\n  p <- as.integer(p)\n  n <- as.integer(n)\n  p\
    \ <- as.integer(p)\n  if(n == 0) return(1)\n  if(p == 0) return(0)\n  if(n ==\
    \ 1) return(2^n)\n  if(p == 1) return(2^n)\n  if(p == 0) return(2^n)\n  if(p ==\
    \ 1) return(2^n)\n  if(p == 2) return(2^(n-1))\n  if(p == 3) return(2^(n-2))\n\
    \  if(p == 4) return(2^(n-3))\n  if(p == 5) return(2^(n-4))\n  if(p == 6) return(2^(n-5))\n\
    \  if(p == 7) return(2^(n-6))\n  if(p == 8) return(2^(n-7))\n  if(p == 9) return(2^(n-8))\n\
    \  if(p == 10) return(2^(n-9))\n  if(p == 11) return(2^(n-10))\n  if(p == 12)\
    \ return(2^(n-11))\n  if(p == 13) return(2^(n-12))\n  if(p == 14) return(2^(n-13))\n\
    \  if(p == 15) return(2^(n-14))\n  if(p == 16) return(2^(n-15))\n  if(p == 17)\
    \ return(2^(n-16))\n  if(p == 18) return(2^(n-17))\n  if(p == 19) return(2^(n-18))\n\
    \  if(p == 20) return(2^(n-19))\n  if(p == 21) return(2^(n-20))\n  if(p == 22)\
    \ return(2^(n-21))\n  if(p == 23) return(2^(n-22))\n  if(p == 24) return(2^(n-23))\n\
    \  if(p == 25) return(2^(n-24))\n  if(p == 26) return(2^(n-25))\n  if(p == 27)\
    \ return(2^(n-26))\n  if(p == 28) return(2^(n-27))\n  if(p == 29) return(2^(n-28))\n\
    \  if(p == 30) return(2^(n-29))\n  if(p == 31) return(2^(n-30))\n  if(p == 32)\
    \ return(2^(n-31))\n  if(p == 33) return(2^(n-32))\n  if(p == 34) return(2^(n-33",
  "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(p ^ (n & (-p)))\n}\n", "\n\
    \  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n))-log2(p))\n\
    }\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n))%%p)\n\
    }\n", "\n  return(p ^ (n & -p))\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n",
  "\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a tags=r,modulo,integer-division\
    \ |>\n<| a tags=r,modulo,integer-division |>\nThe modulus operator % is for integer\
    \ division. Try this instead:\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=3 |>\n<| c |>\nThanks, I knew it was something\
    \ simple.\n<|/ c |>\n<| c |>\nI didn't know that `%` was for integer division.\
    \ Thanks for teaching me something new!\n<|/ c |>\n<| a tags=r,modulo,integer-division\
    \ |>\nThe modulus operator % is for integer division. Try this instead:\n<code>\n\
    modp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a dscore=2\
    \ |>\n<| a dscore=2 |>\nThe modulus operator % is for integer division. Try this\
    \ instead:\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n\
    }\n</code>\n<|/ a tags=r,modulo,integer-division |>\n<| a |>\nThe modulus operator\
    \ % is for integer division. Try this instead:\n<code>\nmodp <- function(n, p)\
    \ {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a dscore=2 tags=r,modulo,integer-division\
    \ |>\n<| a tags=r,modulo,integer-division |>\nThe modulus operator % is for integer\
    \ division. Try this instead:\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1 |>\nThe modulus operator\
    \ % is for integer division. Try this instead:\n<code>\nmodp <- function(n, p)\
    \ {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a tags=r,modulo,integer-division\
    \ |>\n<| a tags=r,modulo,integer-division |>\nThe modulus operator % is for integer\
    \ division. Try this instead:\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore", "\n  return(mod((2^n)%%p, p))\n}\n", "\n \
    \ return(mod((2^n)%p, p))\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n\
    \  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n",
  "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n",
  "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n",
  "\n  return(ifelse(n < 0, -n, n) %% p)\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n\
    }\n", "\n  return(ceiling(log2(n)/log2(p)))\n}\n", "\n  return(as.integer(p^n)\
    \ & 1)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(as.integer(p^n))\
    \ %% p\n}\n</code>\n<|/ a tags=r,modulo |>\n<| c |>\nThanks so much! This was\
    \ very helpful.\n<|/ c |>\n<| a tags=r,modulo |>\nI came up with a solution that\
    \ is more efficient than using modulo (which I believe is O(n^2)).\n<code>\nmodp\
    \ <- function(n, p) {\n  return(as.integer(p^n)) %% p\n}\n</code>\nThe idea is\
    \ to take advantage of the fact that p^n is always less than or equal to p^(n+1),\
    \ and that p^(n+1) is always less than or equal to p^(n+2). \n<code>\nmodp(3,\
    \ 5)", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(as.integer(p^n) %\
    \ p)\n}\n", "\n  n <- as.integer(n)\n  p <- as.integer(p)\n  if(n == 0 || p ==\
    \ 0) return(1)\n  if(p == 1) return(n)\n  if(p == 2) return(n ^ 1)\n  if(p ==\
    \ 3) return(n ^ 2)\n  if(p == 4) return(n ^ 3)\n  if(p == 5) return(n ^ 4)\n \
    \ if(p == 6) return(n ^ 5)\n  if(p == 7) return(n ^ 6)\n  if(p == 8) return(n\
    \ ^ 7)\n  if(p == 9) return(n ^ 8)\n  if(p == 10) return(n ^ 9)\n  if(p == 11)\
    \ return(n ^ 10)\n  if(p == 12) return(n ^ 11)\n  if(p == 13) return(n ^ 12)\n\
    \  if(p == 14) return(n ^ 13)\n  if(p == 15) return(n ^ 14)\n  if(p == 16) return(n\
    \ ^ 15)\n  if(p == 17) return(n ^ 16)\n  if(p == 18) return(n ^ 17)\n  if(p ==\
    \ 19) return(n ^ 18)\n  if(p == 20) return(n ^ 19)\n  if(p == 21) return(n ^ 20)\n\
    \  if(p == 22) return(n ^ 21)\n  if(p == 23) return(n ^ 22)\n  if(p == 24) return(n\
    \ ^ 23)\n  if(p == 25) return(n ^ 24)\n  if(p == 26) return(n ^ 25)\n  if(p ==\
    \ 27) return(n ^ 26)\n  if(p == 28) return(n ^ 27)\n  if(p == 29) return(n ^ 28)\n\
    \  if(p == 30) return(n ^ 29)\n  if(p == 31) return(n ^ 30)\n  if(p == 32) return(n\
    \ ^ 31)\n  if(p == 33) return(n ^ 32)\n  if(p == 34) return(n ^ 33)\n  if(p ==\
    \ 35) return(n ^ 34)\n  if(p == 36) return(n ^ 35)\n  if(p == 37) return(n ^ 36)\n\
    \  if(p == 38) return(n ^ 37)\n  if(p == 39) return(n ^ 38)\n  if(p == 40) return(n\
    \ ^ 39)\n  if(p == 41) return(n ^ 40)\n", "\n  return(ceiling(log2(n)) %% p)\n\
    }\n", "\n  return(ifelse(n < 0, -p, p))\n}\n", "\n  return(ceiling(log2(n)) %%\
    \ p)\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(mod((2^n)-1,\
    \ p))\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n}\n", "\n  return(mod((2^n)-1,\
    \ p))\n}\n", "\n  return(ceiling(log2(n)/log2(p)))\n}\n", "\n  return(mod((2^n)-1,\
    \ p))\n}\n", "\n  return(ifelse(n %% p == 0, n, n - modp(n - 1, p)))\n}\n", "\n\
    \  return(ifelse(n < 0, -modp(abs(n), p), modp(n, p)))\n}\n", "\n  return(ifelse(n\
    \ < 0, -modp(-n, p), modp(n, p)))\n}\n", "\n  return(mod((2^n)%p, p))\n}\n", "\n\
    \  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(mod((2^n)-1, p))\n}\n", "\n\
    \  return(mod((2^n)%p, p))\n}\n</code>\n<|/ a dscore=2 |>\n<| a |>\n<code>\nmodp\
    \ <- function(n, p) {\n  return(mod((2^n)%p, p))\n}\n</code>\n<|/ a tags=r dscore=2\
    \ |>\n<| c |>\nThis doesn't work for me. `modp(3, 5)` returns `1` instead of `3`.\n\
    <|/ c |>\n<| c |>\nIt works for me in R 3.2.3 on Windows 7. Maybe you have a different\
    \ version of R?\n<|/ c |>\n<| c |>\nI got `Error in mod((2^n)%p, p) : non-numeric\
    \ argument to binary operator` when I tried `modp(3, 5)`\n<|/ c |>\n<| c |>\n\
    I got `Error in mod((2^n)%p, p) : non-numeric argument to binary operator` when\
    \ I tried `modp(3, 5)`\n<|/ c |>\n<| c |>\nI got `Error in mod((2^n)%p, p) : non-numeric\
    \ argument to binary operator` when I tried `modp(3, 5)`\n<|/ c |>\n<| a dscore=1\
    \ |>\n<code>\nmodp <- function(n, p) {\n  return(mod((2^n)%p, p))\n}\n</code>\n\
    <|/ a tags=r |>\n<| a tags=r |>\n<code>\nmodp <- function(n, p) {\n  return(mod((2^n)%p,\
    \ p))\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nmodp <- function(n,\
    \ p) {\n  return(mod((2^n)%p, p))\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\n\
    <code>\nmodp <- function(n, p) {\n  return(mod((2^n)%p, p))\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a tags=r |>\n<code>\nmodp <- function(n, p) {\n  return(mod((2^n)%p,\
    \ p))\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nmodp <- function(n,\
    \ p) {\n  return(mod((2^n)%p, p))\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r |>\n\
    <code>\nmodp <- function(n, p) {\n  return(mod((2^n)%p, p))\n}\n</code>\n<|/ a\
    \ dscore=1 |>\n<| a ", "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(ceiling(log2(n))-log2(p))\n\
    }\n", "\n  n <- as.integer(n)\n  p <- as.integer(p)\n  if(n == 0) return(1)\n\
    \  if(p == 0) return(0)\n  if(p == 1) return(n %% p)\n  return(modp(n %% p, p))\n\
    }\n", "\n  return(p ^ (n & -p))\n}\n", "\n  return(ceiling(log2(n)) %% p)\n}\n",
  "\n  return(mod((2^n)-1, p))\n}\n", "\n  return(p ^ n) %% p\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n", "\n  return(p ^ (n & -p))\n}\n", "\n  return(mod((2^n)%p, p))\n\
    }\n", "\n  return(ifelse(n < 0, -n, n%p))\n}\n", "\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a tags=r |>\n<| c |>\nThanks, I didn't know about `log2`.\n\
    <|/ c |>\n<| a |>\nI believe that this is what you are looking for:\n<code>\n\
    modp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a dscore=2\
    \ tags=r |>\n<| c |>\nThanks, I didn't know about `log2`.\n<|/ c |>\n<| a dscore=2\
    \ |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n\
    <|/ a tags=r |>\n<| a dscore=1 |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a tags=r |>\n<| a dscore=1 |>\n<code>\nmodp <- function(n,\
    \ p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a tags=r |>\n<| a tags=r\
    \ |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n\
    <|/ a dscore=1 |>\n<| a tags=r |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=1 |>\n<| a dscore=1 |>\n<code>\nmodp <- function(n,\
    \ p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a tags=r |>\n<| a |>\n\
    <code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n\
    <|/ a dscore=1 tags=r |>\n<| a |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore=1 tags=r |>\n<| a dscore=1 |>\n<code>\nmodp\
    \ <- function(n, p) {\n  return(ceiling(log2(n)) %% p)\n}\n</code>\n<|/ a tags=r\
    \ |>\n<| a tags=r |>\n<code>\nmodp <- function(n, p) {\n  return(ceiling(log2(n))\
    \ %% p)\n}\n</code>\n<|/ a dscore", "\n  return(ceiling(log2(n)) %% p)\n}\n",
  "\n  return(ceiling(log2(n)) %% p)\n}\n", "\n  return(mod((p + 1) %% n, p))\n}\n",
  "\n  return(ceiling(log2(n))-ceiling(log2(p))+ceiling(log2(n-p)))\n}\n</code>\n\
    <|/ a dscore=3 |>\n<| c |>\nI like this solution, but I wonder if there is a way\
    \ to avoid the rounding errors. I mean it works fine for small numbers, but for\
    \ large numbers it fails.\n<|/ c |>\n<| c |>\nI added a solution that avoids rounding\
    \ errors. I hope it helps.\n<|/ c |>\n<| c |>\nThanks for the solution. I was\
    \ thinking of something similar, but I didn't know about `log2`.\n<|/ c |>\n<|\
    \ a dscore=3 |>\nHere's a solution using integer arithmetic:\n<code>\nmodp <-\
    \ function(n, p) {\n  return(n - (n %% p) + p + 1)\n}\n</code>\n<|/ a tags=modulo,r,integer-division\
    \ |>\n<| c |>\nThis works fine for small numbers, but for large numbers it fails.\n\
    <|/ c |>\n<| c |>\nI added a solution that avoids rounding errors. I hope it helps.\n\
    <|/ c |>\n<| a tags=modulo,r,integer-division |>\nHere's a solution using integer\
    \ arithmetic:\n<code>\nmodp <- function(n, p) {\n  return(n - (n %% p) + p + 1)\n\
    }\n</code>\n<|/ a dscore=2 |>\n<| a dscore=2 |>\nHere's a solution using integer\
    \ arithmetic:\n<code>\nmodp <- function(n, p) {\n  return(n - (n %% p) + p + 1)\n\
    }\n</code>\n<|/ a tags=modulo,r,integer-division |>\n<| a tags=modulo,r,integer-division\
    \ |>\nHere's a solution using integer arithmetic:\n<code>\nmodp <- function(n,\
    \ p) {\n  return(n - (n %% p) + p + 1)\n}\n</code>\n<|/ a dscore=2 |>\n<| a tags=modulo,r,integer-division\
    \ |>\nHere's a solution using integer arithmetic:\n<code>\nmodp <- function(n,\
    \ p) {\n  return(n - (n %% p) + p + 1)\n}\n</code>\n<|/ a dscore=2 |>\n<| a dscore=1\
    \ |>\nHere's a solution using integer arithmetic:\n<code>\nmodp <- function(n,\
    \ p) {\n  return(n - (n %% p) + p + 1)\n}\n</code>\n<|/ a tag"]
stop_tokens:
- "\n#"
- "\n```"
