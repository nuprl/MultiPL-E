name: HumanEval_129_minPath
language: js
prompt: "//Given a grid with N rows and N columns (N >= 2) and a positive integer\
  \ k, \n// each cell of the grid contains a value. Every integer in the range [1,\
  \ N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have\
  \ to find the minimum path of length k in the grid. You can start\n// from any cell,\
  \ and in each step you can move to any of the neighbor cells,\n// in other words,\
  \ you can go to cells which share an edge with you current\n// cell.\n// Please\
  \ note that a path of length k means visiting exactly k cells (not\n// necessarily\
  \ distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered\
  \ less than a path B (of length k) if\n// after making the ordered arrays of the\
  \ values on the cells that A and B go\n// through (let's call them lst_A and lst_B),\
  \ lst_A is lexicographically less\n// than lst_B, in other words, there exist an\
  \ integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j\
  \ (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer\
  \ is unique.\n// Return an ordered array of the values on the cells that the minimum\
  \ path go through.\n// >>> minPath([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3)\n// [1,\
  \ 2, 1]\n// >>> minPath([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1)\n// [1]\nfunction\
  \ minPath(grid, k){\n"
tests: "const assert = require('node:assert');\n\n\nfunction test() {\n  let candidate\
  \ = minPath;\n  assert.deepEqual(candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3),[1,\
  \ 2, 1]);\n  assert.deepEqual(candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1),[1]);\n\
  \  assert.deepEqual(candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13,\
  \ 14, 15, 16]], 4),[1, 2, 1, 2]);\n  assert.deepEqual(candidate([[6, 4, 13, 10],\
  \ [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 7),[1, 10, 1, 10, 1, 10, 1]);\n\
  \  assert.deepEqual(candidate([[8, 14, 9, 2], [6, 4, 13, 15], [5, 7, 1, 12], [3,\
  \ 10, 11, 16]], 5),[1, 7, 1, 7, 1]);\n  assert.deepEqual(candidate([[11, 8, 7, 2],\
  \ [5, 16, 14, 4], [9, 3, 15, 6], [12, 13, 10, 1]], 9),[1, 6, 1, 6, 1, 6, 1, 6, 1]);\n\
  \  assert.deepEqual(candidate([[12, 13, 10, 1], [9, 3, 15, 6], [5, 16, 14, 4], [11,\
  \ 8, 7, 2]], 12),[1, 6, 1, 6, 1, 6, 1, 6, 1, 6, 1, 6]);\n  assert.deepEqual(candidate([[2,\
  \ 7, 4], [3, 1, 5], [6, 8, 9]], 8),[1, 3, 1, 3, 1, 3, 1, 3]);\n  assert.deepEqual(candidate([[6,\
  \ 1, 5], [3, 8, 9], [2, 7, 4]], 8),[1, 5, 1, 5, 1, 5, 1, 5]);\n  assert.deepEqual(candidate([[1,\
  \ 2], [3, 4]], 10),[1, 2, 1, 2, 1, 2, 1, 2, 1, 2]);\n  assert.deepEqual(candidate([[1,\
  \ 3], [3, 2]], 10),[1, 3, 1, 3, 1, 3, 1, 3, 1, 3]);\n}\n\ntest();"
completions: ["\tvar n = grid.length;\n\tvar m = grid[0].length;\n\tvar dp = [];\n\
    \tfor(var i = 0; i < n; i++){\n\t\tdp[i] = [];\n\t\tfor(var j = 0; j < m; j++){\n\
    \t\t\tdp[i][j] = [];\n\t\t\tfor(var l = 0; l < k; l++){\n\t\t\t\tdp[i][j][l] =\
    \ [];\n\t\t\t}\n\t\t}\n\t}\n\tfor(var i = 0; i < n; i++){\n\t\tfor(var j = 0;\
    \ j < m; j++){\n\t\t\tdp[i][j][0] = [grid[i][j]];\n\t\t}\n\t}\n\tfor(var l = 1;\
    \ l < k; l++){\n\t\tfor(var i = 0; i < n; i++){\n\t\t\tfor(var j = 0; j < m; j++){\n\
    \t\t\t\tdp[i][j][l] = [];\n\t\t\t\tif(i > 0){\n\t\t\t\t\tdp[i][j][l] = dp[i][j][l].concat(dp[i\
    \ - 1][j][l - 1]);\n\t\t\t\t}\n\t\t\t\tif(j > 0){\n\t\t\t\t\tdp[i][j][l] = dp[i][j][l].concat(dp[i][j\
    \ - 1][l - 1]);\n\t\t\t\t}\n\t\t\t\tif(i < n - 1){\n\t\t\t\t\tdp[i][j][l] = dp[i][j][l].concat(dp[i\
    \ + 1][j][l - 1]);\n\t\t\t\t}\n\t\t\t\tif(j < m - 1){\n\t\t\t\t\tdp[i][j][l] =\
    \ dp[i][j][l].concat(dp[i][j + 1][l - 1]);\n\t\t\t\t}\n\t\t\t\tdp[i][j][l].sort();\n\
    \t\t\t}\n\t\t}\n\t}\n\tvar min", "  // your code here\n}\n", "    var n = grid.length;\n\
    \    var m = grid[0].length;\n    var min = [];\n    var min_sum = Infinity;\n\
    \    var min_path = [];\n    var path = [];\n    var sum = 0;\n    for(var i =\
    \ 0; i < n; i++){\n        for(var j = 0; j < m; j++){\n            path = [];\n\
    \            sum = 0;\n            dfs(grid, i, j, k, path, sum);\n        }\n\
    \    }\n    return min_path;\n    function dfs(grid, i, j, k, path, sum){\n  \
    \      if(i < 0 || i >= n || j < 0 || j >= m || k < 0){\n            return;\n\
    \        }\n        if(k == 0){\n            if(sum < min_sum){\n            \
    \    min_sum = sum;\n                min_path = path.slice();\n            }\n\
    \            else if(sum == min_sum){\n                if(path.slice().sort().join('')\
    \ < min_path.slice().sort().join('')){\n                    min_path = path.slice();\n\
    \                }\n            }\n            return;\n        }\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(grid, i - 1, j, k - 1, path, sum);\n\
    \        dfs(grid, i + 1, j, k - 1, path, sum);\n        dfs(grid, i, j - 1, k\
    \ - 1, path, sum);\n        dfs(grid, i, j + 1, k - 1, path, sum);\n        path.pop();\n\
    \        sum -= grid[i][j];\n    }\n}\n", "    // your code here\n}\n", "  //\
    \ your code here\n}\n", "  // your code here\n}\n", "  let n = grid.length;\n\
    \  let m = grid[0].length;\n  let minPath = [];\n  let minSum = Infinity;\n  let\
    \ visited = new Set();\n  let dfs = function(i, j, path, sum){\n    if(i < 0 ||\
    \ i >= n || j < 0 || j >= m || visited.has(i + ',' + j)){\n      return;\n   \
    \ }\n    if(path.length === k){\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minPath = path;\n      }\n      return;\n    }\n    visited.add(i + ','\
    \ + j);\n    path.push(grid[i][j]);\n    sum += grid[i][j];\n    dfs(i + 1, j,\
    \ path.slice(), sum);\n    dfs(i - 1, j, path.slice(), sum);\n    dfs(i, j + 1,\
    \ path.slice(), sum);\n    dfs(i, j - 1, path.slice(), sum);\n    visited.delete(i\
    \ + ',' + j);\n  }\n  for(let i = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n\
    \      dfs(i, j, [], 0);\n    }\n  }\n  return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = new Array(k);\n    let minPathSum = Infinity;\n    let minPathSumIndex\
    \ = -1;\n    let dfs = function(i, j, path, pathSum, pathIndex){\n        if(pathIndex\
    \ === k){\n            if(pathSum < minPathSum){\n                minPathSum =\
    \ pathSum;\n                minPathSumIndex = pathIndex;\n                minPath\
    \ = path.slice();\n            }\n            return;\n        }\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n \
    \       }\n        visited[i][j] = true;\n        path[pathIndex] = grid[i][j];\n\
    \        pathSum += grid[i][j];\n        if(pathSum > minPathSum){\n         \
    \   visited[i][j] = false;\n            return;\n        }\n        dfs(i + 1,\
    \ j, path, pathSum, pathIndex + 1);\n        dfs(i - 1, j, path, pathSum, pathIndex\
    \ + 1);\n        dfs(i, j + 1, path, pathSum, pathIndex + 1);\n        dfs(i,\
    \ j - 1, path, pathSum, pathIndex + 1);\n        visited[i][j] = false;\n    }\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      dfs(i, j, [], 0, 0);\n        }\n    }\n    return minPath;\n}\n", "  \
    \  // your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let min = Number.MAX_SAFE_INTEGER;\n\
    \    let minPath = [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0;\
    \ j < m; j++){\n            let path = [];\n            dfs(grid, i, j, k, visited,\
    \ path, min, minPath);\n        }\n    }\n    return minPath;\n}\n", "    // Your\
    \ code here\n}\n", "    // your code here\n    let min = [];\n    let min_sum\
    \ = Infinity;\n    let min_path = [];\n    let min_path_sum = Infinity;\n    let\
    \ min_path_length = Infinity;\n    let min_path_length_sum = Infinity;\n    let\
    \ min_path_length_path = [];\n    let min_path_length_path_sum = Infinity;\n \
    \   let min_path_length_path_length = Infinity;\n    let min_path_length_path_length_sum\
    \ = Infinity;\n    let min_path_length_path_length_path = [];\n    let min_path_length_path_length_path_sum\
    \ = Infinity;\n    let min_path_length_path_length_path_length = Infinity;\n \
    \   let min_path_length_path_length_path_length_sum = Infinity;\n    let min_path_length_path_length_path_length_path\
    \ = [];\n    let min_path_length_path_length_path_length_path_sum = Infinity;\n\
    \    let min_path_length_path_length_path_length_path_length = Infinity;\n   \
    \ let min_path_length_path_length_path_length_path_length_sum = Infinity;\n  \
    \  let min_path_length_path_length_path_length_path_length_path = [];\n    let\
    \ min_path_length_path_length_path_length_path_length_path_sum = Infinity;\n \
    \   let min_path_length_path_length_path_length_path_length_path_length = Infinity;\n\
    \    let min_path_length_path_length_path_length_path_length_path_length_sum =\
    \ Infinity;\n    let min_path_length_path_length_path_length_path_length_path_length_path\
    \ = [];\n    let min_path_length_path_length_path_length_path_length_path_length_path_sum\
    \ = Infinity;\n    let min_path_length_path_length_path_length_path_length_path_length_path_length\
    \ = Infinity;\n    let min_path_length_path_length_path_length_path_length_path_length_path",
  "    // your code here\n}\n", "    // your code here\n}\n", "    // Your code here\n\
    }\n", "    // your code here\n}\n", "    // your code here\n}\n", "    let n =\
    \ grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n    for(let\
    \ i = 0; i < n; i++){\n        dp[i] = new Array(m);\n        for(let j = 0; j\
    \ < m; j++){\n            dp[i][j] = new Array(k+1);\n            for(let l =\
    \ 0; l <= k; l++){\n                dp[i][j][l] = Infinity;\n            }\n \
    \       }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(let\
    \ l = 2; l <= k; l++){\n        for(let i = 0; i < n; i++){\n            for(let\
    \ j = 0; j < m; j++){\n                let min = Infinity;\n                if(i\
    \ > 0){\n                    min = Math.min(min, dp[i-1][j][l-1]);\n         \
    \       }\n                if(i < n-1){\n                    min = Math.min(min,\
    \ dp[i+1][j][l-1]);\n                }\n                if(j > 0){\n         \
    \           min = Math.min(min, dp[i][j-1][l-1]);\n                }\n       \
    \         if(j < m-1){\n                    min = Math.min(min, dp[i][j+1][l-1]);\n\
    \                }\n                dp[i][j][l] = min + grid[i][j];\n        \
    \    }\n        }\n    }\n    let min = Infinity;\n    let minI = 0;\n    let\
    \ minJ = 0;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            if(dp[i][j][k] < min){\n                min = dp[i][j][k];\n    \
    \            minI = i;\n                minJ = j;\n            }", "    // your\
    \ code here\n}\n", "  let n = grid.length;\n  let minPath = [];\n  let minSum\
    \ = Infinity;\n  let minPathSum = Infinity;\n  let minPathSum2 = Infinity;\n \
    \ let minPathSum3 = Infinity;\n  let minPathSum4 = Infinity;\n  let minPathSum5\
    \ = Infinity;\n  let minPathSum6 = Infinity;\n  let minPathSum7 = Infinity;\n\
    \  let minPathSum8 = Infinity;\n  let minPathSum9 = Infinity;\n  let minPathSum10\
    \ = Infinity;\n  let minPathSum11 = Infinity;\n  let minPathSum12 = Infinity;\n\
    \  let minPathSum13 = Infinity;\n  let minPathSum14 = Infinity;\n  let minPathSum15\
    \ = Infinity;\n  let minPathSum16 = Infinity;\n  let minPathSum17 = Infinity;\n\
    \  let minPathSum18 = Infinity;\n  let minPathSum19 = Infinity;\n  let minPathSum20\
    \ = Infinity;\n  let minPathSum21 = Infinity;\n  let minPathSum22 = Infinity;\n\
    \  let minPathSum23 = Infinity;\n  let minPathSum24 = Infinity;\n  let minPathSum25\
    \ = Infinity;\n  let minPathSum26 = Infinity;\n  let minPathSum27 = Infinity;\n\
    \  let minPathSum28 = Infinity;\n  let minPathSum29 = Infinity;\n  let minPathSum30\
    \ = Infinity;\n  let minPathSum31 = Infinity;\n  let minPathSum32 = Infinity;\n\
    \  let minPathSum33 = Infinity;\n  let minPathSum34 = Infinity;\n  let minPathSum35\
    \ = Infinity;\n  let minPathSum36 = Infinity;\n  let minPathSum37 = Infinity;\n\
    \  let minPathSum38 = Infinity;\n  let minPathSum39 = Infinity;\n  let minPathSum40\
    \ = Infinity;\n  let minPathSum41 = Infinity;\n  let minPathSum42 = Infinity;\n\
    \  let minPathSum43 = Infinity;\n  let minPathSum44 = Infinity;\n  let minPathSum45\
    \ = Infinity;\n  let minPathSum46 = Infinity;\n  let minPathSum47 = Infinity;\n\
    \  let minPathSum48 = Infinity;\n  let minPathSum49 = Infinity", "    var n =\
    \ grid.length;\n    var m = grid[0].length;\n    var min = [];\n    var min_path\
    \ = [];\n    var min_path_len = 0;\n    var min_path_sum = 0;\n    var min_path_sum_len\
    \ = 0;\n    var min_path_sum_len_len = 0;\n    var min_path_sum_len_len_len =\
    \ 0;\n    var min_path_sum_len_len_len_len = 0;\n    var min_path_sum_len_len_len_len_len\
    \ = 0;\n    var min_path_sum_len_len_len_len_len_len = 0;\n    var min_path_sum_len_len_len_len_len_len_len\
    \ = 0;\n    var min_path_sum_len_len_len_len_len_len_len_len = 0;\n    var min_path_sum_len_len_len_len_len_len_len_len_len\
    \ = 0;\n    var min_path_sum_len_len_len_len_len_len_len_len_len_len = 0;\n  \
    \  var min_path_sum_len_len_len_len_len_len_len_len_len_len_len = 0;\n    var\
    \ min_path_sum_len_len_len_len_len_len_len_len_len_len_len_len = 0;\n    var min_path_sum_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = 0;\n    var min_path_sum_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = 0;\n    var min_path_sum_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = 0;\n    var min_path_sum_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len_len\
    \ = 0;\n    var min_path_sum", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSumIndex = -1;\n    let minPathSumIndex2 = -1;\n    let minPathSumIndex3\
    \ = -1;\n    let minPathSumIndex4 = -1;\n    let minPathSumIndex5 = -1;\n    let\
    \ minPathSumIndex6 = -1;\n    let minPathSumIndex7 = -1;\n    let minPathSumIndex8\
    \ = -1;\n    let minPathSumIndex9 = -1;\n    let minPathSumIndex10 = -1;\n   \
    \ let minPathSumIndex11 = -1;\n    let minPathSumIndex12 = -1;\n    let minPathSumIndex13\
    \ = -1;\n    let minPathSumIndex14 = -1;\n    let minPathSumIndex15 = -1;\n  \
    \  let minPathSumIndex16 = -1;\n    let minPathSumIndex17 = -1;\n    let minPathSumIndex18\
    \ = -1;\n    let minPathSumIndex19 = -1;\n    let minPathSumIndex20 = -1;\n  \
    \  let minPathSumIndex21 = -1;\n    let minPathSumIndex22 = -1;\n    let minPathSumIndex23\
    \ = -1;\n    let minPathSumIndex24 = -1;\n    let minPathSumIndex25 = -1;\n  \
    \  let minPathSumIndex26 = -1;\n    let minPathSumIndex27 = -1;\n    let minPathSumIndex28\
    \ = -1;\n    let minPathSumIndex29 = -1;\n    let minPathSumIndex30 = -1;\n  \
    \  let minPathSumIndex31 = -1;\n    let minPathSumIndex32 = -1;\n    let minPathSumIndex33\
    \ = -1;\n    let minPathSumIndex34 = -1;\n    let minPathSumIndex35 = -1;\n  \
    \  let minPathSumIndex36 = -1;\n    let minPathSumIndex37 = -1;\n    let minPathSumIndex38\
    \ = -1;\n    let minPathSumIndex39 = -1;\n", "    let n = grid.length;\n    let\
    \ min = [];\n    let min_sum = Infinity;\n    let min_path = [];\n    let visited\
    \ = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n        for(let\
    \ j = 0; j < n; j++){\n            visited[i].push(false);\n        }\n    }\n\
    \    function dfs(i, j, sum, path){\n        if(sum > min_sum){\n            return;\n\
    \        }\n        if(path.length == k){\n            if(sum < min_sum){\n  \
    \              min_sum = sum;\n                min_path = path;\n            }\n\
    \            return;\n        }\n        if(i < 0 || i >= n || j < 0 || j >= n\
    \ || visited[i][j]){\n            return;\n        }\n        visited[i][j] =\
    \ true;\n        path.push(grid[i][j]);\n        dfs(i - 1, j, sum + grid[i][j],\
    \ path);\n        dfs(i + 1, j, sum + grid[i][j], path);\n        dfs(i, j - 1,\
    \ sum + grid[i][j], path);\n        dfs(i, j + 1, sum + grid[i][j], path);\n \
    \       path.pop();\n        visited[i][j] = false;\n    }\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < n; j++){\n            dfs(i, j, 0,\
    \ []);\n        }\n    }\n    return min_path;\n}\n", "    let n = grid.length;\n\
    \    let visited = new Array(n).fill(0).map(() => new Array(n).fill(false));\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPaths = [];\n    function dfs(x, y, path, sum, pathSum){\n       \
    \ if(x < 0 || x >= n || y < 0 || y >= n || visited[x][y]) return;\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPaths = [];\n                minPaths.push(path);\n          \
    \  }\n            else if(sum === minSum){\n                minPaths.push(path);\n\
    \            }\n            return;\n        }\n        visited[x][y] = true;\n\
    \        path.push(grid[x][y]);\n        sum += grid[x][y];\n        pathSum +=\
    \ grid[x][y] * Math.pow(10, k - path.length);\n        dfs(x + 1, y, path.slice(),\
    \ sum, pathSum);\n        dfs(x - 1, y, path.slice(), sum, pathSum);\n       \
    \ dfs(x, y + 1, path.slice(), sum, pathSum);\n        dfs(x, y - 1, path.slice(),\
    \ sum, pathSum);\n        visited[x][y] = false;\n    }\n    for(let i = 0; i\
    \ < n; i++){\n        for(let j = 0; j < n; j++){\n            dfs(i, j, [], 0,\
    \ 0);\n        }\n    }\n    for(let i = 0; i < minPaths.length; i++){\n     \
    \   if(minPaths[i].reduce((a, b) => a * 10 + b, 0) < minPathSum){\n          \
    \  minPathSum = minPaths[i].reduce((a, b) => a * 10 + b, 0);\n            minPath\
    \ = minPaths[i];\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let dfs = function(i, j, path, sum, pathSum){\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n          \
    \  return;\n        }\n        if(path.length === k){\n            if(sum < minSum\
    \ || (sum === minSum && pathSum < minPathSum)){\n                minSum = sum;\n\
    \                minPathSum = pathSum;\n                minPath = path;\n    \
    \        }\n            return;\n        }\n        visited[i][j] = true;\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        pathSum +=\
    \ grid[i][j] * path.length;\n        dfs(i - 1, j, path.slice(), sum, pathSum);\n\
    \        dfs(i + 1, j, path.slice(), sum, pathSum);\n        dfs(i, j - 1, path.slice(),\
    \ sum, pathSum);\n        dfs(i, j + 1, path.slice(), sum, pathSum);\n       \
    \ visited[i][j] = false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let\
    \ j = 0; j < m; j++){\n            dfs(i, j, [], 0, 0);\n        }\n    }\n  \
    \  return minPath;\n}\n", "    // your code here\n    var n = grid.length;\n \
    \   var m = grid[0].length;\n    var min = [];\n    var min_path = [];\n    var\
    \ min_sum = Infinity;\n    var min_sum_path = [];\n    var visited = [];\n   \
    \ for(var i = 0; i < n; i++){\n        visited.push([]);\n        for(var j =\
    \ 0; j < m; j++){\n            visited[i].push(false);\n        }\n    }\n   \
    \ function dfs(i, j, path, sum){\n        if(sum > min_sum){\n            return;\n\
    \        }\n        if(path.length == k){\n            if(sum < min_sum){\n  \
    \              min_sum = sum;\n                min_sum_path = path.slice();\n\
    \            }\n            return;\n        }\n        if(i < 0 || i >= n ||\
    \ j < 0 || j >= m || visited[i][j]){\n            return;\n        }\n       \
    \ visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        dfs(i - 1, j, path, sum);\n        dfs(i + 1, j, path, sum);\n      \
    \  dfs(i, j - 1, path, sum);\n        dfs(i, j + 1, path, sum);\n        path.pop();\n\
    \        sum -= grid[i][j];\n        visited[i][j] = false;\n    }\n    for(var\
    \ i = 0; i < n; i++){\n        for(var j = 0; j < m; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return min_sum_path;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            let path = [];\n           \
    \ let sum = 0;\n            dfs(i, j, k, path, sum);\n        }\n    }\n    return\
    \ minPath;\n\n    function dfs(i, j, k, path, sum){\n        if(i < 0 || i >=\
    \ n || j < 0 || j >= m || visited[i][j]){\n            return;\n        }\n  \
    \      if(path.length === k){\n            if(sum < minSum){\n               \
    \ minSum = sum;\n                minPath = path.slice();\n            }\n    \
    \        return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, k, path, sum);\n        dfs(i\
    \ - 1, j, k, path, sum);\n        dfs(i, j + 1, k, path, sum);\n        dfs(i,\
    \ j - 1, k, path, sum);\n        path.pop();\n        sum -= grid[i][j];\n   \
    \     visited[i][j] = false;\n    }\n}\n", "    //YOUR CODE HERE\n}\n", "    let\
    \ n = grid.length;\n    let minPath = [];\n    let min = Infinity;\n    let minPaths\
    \ = [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n\
    \            let path = [];\n            let sum = 0;\n            let paths =\
    \ [];\n            findPath(grid, i, j, k, path, sum, paths);\n            for(let\
    \ p of paths){\n                if(p[p.length - 1] < min){\n                 \
    \   min = p[p.length - 1];\n                    minPath = p;\n               \
    \ }\n            }\n        }\n    }\n    return minPath;\n}\n", "    //YOUR CODE\
    \ HERE\n}\n", "    // your code here\n}\n", "  let n = grid.length;\n  let m =\
    \ grid[0].length;\n  let min = Infinity;\n  let minPath = [];\n  let visited =\
    \ [];\n  for(let i = 0; i < n; i++){\n    visited.push([]);\n    for(let j = 0;\
    \ j < m; j++){\n      visited[i].push(false);\n    }\n  }\n  for(let i = 0; i\
    \ < n; i++){\n    for(let j = 0; j < m; j++){\n      let path = [];\n      let\
    \ pathSum = 0;\n      dfs(i, j, k, path, pathSum, visited);\n      if(pathSum\
    \ < min){\n        min = pathSum;\n        minPath = path;\n      }\n    }\n \
    \ }\n  return minPath;\n}\n", "  var n = grid.length;\n  var m = grid[0].length;\n\
    \  var min = Infinity;\n  var minPath = [];\n  var path = [];\n  var visited =\
    \ [];\n  for(var i = 0; i < n; i++){\n    visited.push([]);\n    for(var j = 0;\
    \ j < m; j++){\n      visited[i].push(false);\n    }\n  }\n  for(var i = 0; i\
    \ < n; i++){\n    for(var j = 0; j < m; j++){\n      dfs(i, j, k, 0, path, visited);\n\
    \    }\n  }\n  return minPath;\n  function dfs(i, j, k, sum, path, visited){\n\
    \    if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n      return;\n\
    \    }\n    if(sum + grid[i][j] > min){\n      return;\n    }\n    if(k === 0){\n\
    \      if(sum + grid[i][j] < min){\n        min = sum + grid[i][j];\n        minPath\
    \ = path.slice();\n        minPath.push(grid[i][j]);\n      }\n      return;\n\
    \    }\n    visited[i][j] = true;\n    path.push(grid[i][j]);\n    dfs(i - 1,\
    \ j, k - 1, sum + grid[i][j], path, visited);\n    dfs(i + 1, j, k - 1, sum +\
    \ grid[i][j], path, visited);\n    dfs(i, j - 1, k - 1, sum + grid[i][j], path,\
    \ visited);\n    dfs(i, j + 1, k - 1, sum + grid[i][j], path, visited);\n    path.pop();\n\
    \    visited[i][j] = false;\n  }\n}\n", "\tvar minPath = [];\n\tvar minPathSum\
    \ = Infinity;\n\tvar minPathSumIndex = 0;\n\tvar minPathSumIndex2 = 0;\n\tvar\
    \ minPathSumIndex3 = 0;\n\tvar minPathSumIndex4 = 0;\n\tvar minPathSumIndex5 =\
    \ 0;\n\tvar minPathSumIndex6 = 0;\n\tvar minPathSumIndex7 = 0;\n\tvar minPathSumIndex8\
    \ = 0;\n\tvar minPathSumIndex9 = 0;\n\tvar minPathSumIndex10 = 0;\n\tvar minPathSumIndex11\
    \ = 0;\n\tvar minPathSumIndex12 = 0;\n\tvar minPathSumIndex13 = 0;\n\tvar minPathSumIndex14\
    \ = 0;\n\tvar minPathSumIndex15 = 0;\n\tvar minPathSumIndex16 = 0;\n\tvar minPathSumIndex17\
    \ = 0;\n\tvar minPathSumIndex18 = 0;\n\tvar minPathSumIndex19 = 0;\n\tvar minPathSumIndex20\
    \ = 0;\n\tvar minPathSumIndex21 = 0;\n\tvar minPathSumIndex22 = 0;\n\tvar minPathSumIndex23\
    \ = 0;\n\tvar minPathSumIndex24 = 0;\n\tvar minPathSumIndex25 = 0;\n\tvar minPathSumIndex26\
    \ = 0;\n\tvar minPathSumIndex27 = 0;\n\tvar minPathSumIndex28 = 0;\n\tvar minPathSumIndex29\
    \ = 0;\n\tvar minPathSumIndex30 = 0;\n\tvar minPathSumIndex31 = 0;\n\tvar minPathSumIndex32\
    \ = 0;\n\tvar minPathSumIndex33 = 0;\n\tvar minPathSumIndex34 = 0;\n\tvar minPathSumIndex35\
    \ = 0;\n\tvar minPathSumIndex36 = 0;\n\tvar minPathSumIndex37 = 0;\n\tvar minPathSumIndex38\
    \ = 0;\n\tvar minPathSumIndex39 = 0;\n\tvar minPathSumIndex40 = 0;\n\tvar minPathSumIndex41\
    \ = 0;\n\tvar minPathSumIndex42 = 0;\n\tvar minPathSumIndex43 = 0;\n\tvar minPathSumIndex44\
    \ = 0;\n\tvar minPathSumIndex45 = 0;\n\t", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let visited = [];\n    for(let i = 0; i < n; i++){\n\
    \        visited.push([]);\n        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n\
    \        }\n    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            let sum = 0;\n            dfs(grid, i, j, k, visited, path,\
    \ sum);\n            if(sum < minSum){\n                minSum = sum;\n      \
    \          minPath = path;\n            }\n        }\n    }\n    return minPath;\n\
    }\n", "    // Your code here\n}\n", "  // your code here\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n);\n    for(let i = 0; i\
    \ < n; i++){\n        dp[i] = new Array(m);\n        for(let j = 0; j < m; j++){\n\
    \            dp[i][j] = new Array(k + 1);\n            for(let l = 0; l <= k;\
    \ l++){\n                dp[i][j][l] = new Array(2);\n                dp[i][j][l][0]\
    \ = Number.MAX_SAFE_INTEGER;\n                dp[i][j][l][1] = [];\n         \
    \   }\n        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j =\
    \ 0; j < m; j++){\n            dp[i][j][1][0] = grid[i][j];\n            dp[i][j][1][1]\
    \ = [grid[i][j]];\n        }\n    }\n    for(let l = 2; l <= k; l++){\n      \
    \  for(let i = 0; i < n; i++){\n            for(let j = 0; j < m; j++){\n    \
    \            if(i > 0){\n                    let temp = dp[i - 1][j][l - 1][0]\
    \ + grid[i][j];\n                    if(temp < dp[i][j][l][0]){\n            \
    \            dp[i][j][l][0] = temp;\n                        dp[i][j][l][1] =\
    \ dp[i - 1][j][l - 1][1].slice();\n                        dp[i][j][l][1].push(grid[i][j]);\n\
    \                    }\n                    else if(temp == dp[i][j][l][0]){\n\
    \                        let tempArr = dp[i - 1][j][l - 1][1].slice();\n     \
    \                   tempArr.push(grid[i][j]);\n                        if(tempArr.join(\"\
    \") < dp[i][j][l][1].join(\"\")){\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            let path = [];\n            let sum = 0;\n            dfs(i, j, k,\
    \ path, sum);\n        }\n    }\n    return minPath;\n\n    function dfs(i, j,\
    \ k, path, sum){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        visited[i][j] = true;\n        if(path.length === k){\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path.slice();\n            }\n            else if(sum === minSum){\n\
    \                if(path.join('') < minPath.join('')){\n                    minPath\
    \ = path.slice();\n                }\n            }\n        }\n        else{\n\
    \            dfs(i + 1, j, k, path, sum);\n            dfs(i - 1, j, k, path,\
    \ sum);\n            dfs(i, j + 1, k, path, sum);\n            dfs(i, j - 1, k,\
    \ path, sum);\n        }\n        path.pop();\n        visited[i][j] = false;\n\
    \    }\n}\n", "    var n = grid.length;\n    var m = grid[0].length;\n    var\
    \ min = [];\n    var min_sum = Infinity;\n    var min_path = [];\n    var min_path_sum\
    \ = Infinity;\n    var min_path_length = Infinity;\n    var min_path_sum_length\
    \ = Infinity;\n    var min_path_sum_length_path = [];\n    var min_path_sum_length_sum\
    \ = Infinity;\n    var min_path_sum_length_path_sum = Infinity;\n    var min_path_sum_length_path_sum_path\
    \ = [];\n    var min_path_sum_length_path_sum_path_sum = Infinity;\n    var min_path_sum_length_path_sum_path_sum_path\
    \ = [];\n    var min_path_sum_length_path_sum_path_sum_path_sum = Infinity;\n\
    \    var min_path_sum_length_path_sum_path_sum_path_sum_path = [];\n    var min_path_sum_length_path_sum_path_sum_path_sum_path_sum\
    \ = Infinity;\n    var min_path_sum_length_path_sum_path_sum_path_sum_path_sum_path\
    \ = [];\n    var min_path_sum_length_path_sum_path_sum_path_sum_path_sum_path_sum\
    \ = Infinity;\n    var min_path_sum_length_path_sum_path_sum_path_sum_path_sum_path_sum_path\
    \ = [];\n    var min_path_sum_length_path_sum_path_sum_path_sum_path_sum_path_sum_path_sum\
    \ = Infinity;\n    var min_path_sum_length_path_sum_path_sum_path_sum_path_sum_path_sum_path_sum_path\
    \ = [];\n    var min_path_sum_length_path_sum_path_sum_path_sum_path_sum_path_sum_path_sum_path_sum\
    \ = Infinity;\n    var min_path_sum_length_path_sum_path_sum_path_sum_path_sum_path_sum_path_sum",
  "    // your code here\n}\n", "    // your code here\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = [];\n    let min_sum = Infinity;\n\
    \    let min_path = [];\n    for(let i = 0; i < n; i++){\n        for(let j =\
    \ 0; j < m; j++){\n            let path = [];\n            let sum = 0;\n    \
    \        let visited = [];\n            for(let i = 0; i < n; i++){\n        \
    \        visited.push([]);\n                for(let j = 0; j < m; j++){\n    \
    \                visited[i].push(false);\n                }\n            }\n \
    \           dfs(grid, i, j, k, path, sum, visited);\n            if(sum < min_sum){\n\
    \                min_sum = sum;\n                min_path = path;\n          \
    \  }\n        }\n    }\n    return min_path;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n\
    \    let visited = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            let path = [];\n            let pathSum = 0;\n          \
    \  dfs(i, j, k, path, pathSum, visited);\n            if(pathSum < min){\n   \
    \             min = pathSum;\n                minPath = path;\n            }\n\
    \        }\n    }\n    return minPath;\n}\n", "    // your code here\n}\n", " \
    \   var n = grid.length;\n    var m = grid[0].length;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPathSum2 = Infinity;\n    var minPath2\
    \ = [];\n    var minPathSum3 = Infinity;\n    var minPath3 = [];\n    var minPathSum4\
    \ = Infinity;\n    var minPath4 = [];\n    var minPathSum5 = Infinity;\n    var\
    \ minPath5 = [];\n    var minPathSum6 = Infinity;\n    var minPath6 = [];\n  \
    \  var minPathSum7 = Infinity;\n    var minPath7 = [];\n    var minPathSum8 =\
    \ Infinity;\n    var minPath8 = [];\n    var minPathSum9 = Infinity;\n    var\
    \ minPath9 = [];\n    var minPathSum10 = Infinity;\n    var minPath10 = [];\n\
    \    var minPathSum11 = Infinity;\n    var minPath11 = [];\n    var minPathSum12\
    \ = Infinity;\n    var minPath12 = [];\n    var minPathSum13 = Infinity;\n   \
    \ var minPath13 = [];\n    var minPathSum14 = Infinity;\n    var minPath14 = [];\n\
    \    var minPathSum15 = Infinity;\n    var minPath15 = [];\n    var minPathSum16\
    \ = Infinity;\n    var minPath16 = [];\n    var minPathSum17 = Infinity;\n   \
    \ var minPath17 = [];\n    var minPathSum18 = Infinity;\n    var minPath18 = [];\n\
    \    var minPathSum19 = Infinity;\n    var minPath19 = [];\n    var minPathSum20\
    \ = Infinity;\n    var minPath20 = [];\n    var minPathSum21 = Infinity;\n   \
    \ var minPath21 = [];\n    var minPathSum22 = Infinity;\n    var minPath22 = [];\n\
    \    var minPathSum23 = Infinity;\n    var minPath23 = [];\n    var minPathSum24\
    \ = Infinity;\n    var minPath24 = [];\n    var minPathSum25 = Infinity;\n   \
    \ var minPath25 = [];\n    var minPathSum26 = Infinity;\n    var minPath26 = [];\n\
    \    var minPathSum27 = Infinity;\n    var minPath27 = [];\n    var minPathSum28\
    \ =", "    // Your code here\n}\n", "    // your code here\n}\n", "    // your\
    \ code here\n}\n", "    // Your code here\n}\n", "    // TODO\n}\n", "    // your\
    \ code here\n}\n", "    var result = [];\n    var min = Infinity;\n    var minPath\
    \ = [];\n    var path = [];\n    var visited = [];\n    for(var i = 0; i < grid.length;\
    \ i++){\n        visited.push([]);\n        for(var j = 0; j < grid[0].length;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    for(var i\
    \ = 0; i < grid.length; i++){\n        for(var j = 0; j < grid[0].length; j++){\n\
    \            path = [];\n            dfs(grid, i, j, k, path, visited);\n    \
    \        if(path.length < min){\n                min = path.length;\n        \
    \        minPath = path;\n            }\n            else if(path.length == min){\n\
    \                if(path < minPath){\n                    minPath = path;\n  \
    \              }\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPathSum10 = Infinity;\n    let minPathSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let minPathSum14\
    \ = Infinity;\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPathSum17 = Infinity;\n    let minPathSum18 = Infinity;\n    let minPathSum19\
    \ = Infinity;\n    let minPathSum20 = Infinity;\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPathSum25 = Infinity;\n    let minPathSum26 = Infinity;\n\
    \    let minPathSum27 = Infinity;\n    let minPathSum28 = Infinity;\n    let minPathSum29\
    \ = Infinity;\n    let minPathSum30 = Infinity;\n    let minPathSum31 = Infinity;\n\
    \    let minPathSum32 = Infinity;\n    let minPathSum33 = Infinity;\n    let minPathSum34\
    \ = Infinity;\n    let minPathSum35 = Infinity;\n    let minPathSum36 = Infinity;\n\
    \    let minPathSum37 = Infinity;\n    let minPathSum38 = Infinity;\n    let minPathSum39\
    \ = Infinity;\n    let minPathSum40 = Infinity;\n    let minPathSum41 = Infinity;\n\
    \    let minPathSum42 = Infinity;\n    let minPathSum43 = Infinity;\n    let minPathSum44\
    \ = Infinity;\n    let minPathSum45 = Infinity;\n    let minPathSum46 = Infinity;\n\
    \    let minPathSum47 = Infinity;\n    let minPathSum48 = Infinity;\n    let minPathSum49\
    \ = Infinity;\n    let minPathSum50 =", "    let n = grid.length;\n    let m =\
    \ grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let sum\
    \ = 0;\n            let path = [];\n            let visited = [];\n          \
    \  for(let x = 0; x < n; x++){\n                visited.push([]);\n          \
    \      for(let y = 0; y < m; y++){\n                    visited[x].push(false);\n\
    \                }\n            }\n            dfs(i, j, k, sum, path, visited);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    // Your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n).fill(false).map(() => new Array(m).fill(false));\n\
    \    let minPath = new Array(k);\n    let minSum = Infinity;\n    let dfs = function(i,\
    \ j, path, sum, count){\n        if(count === k){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path.slice();\n    \
    \        }\n            return;\n        }\n        if(sum > minSum) return;\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m) return;\n        if(visited[i][j])\
    \ return;\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n   \
    \     dfs(i - 1, j, path, sum + grid[i][j], count + 1);\n        dfs(i + 1, j,\
    \ path, sum + grid[i][j], count + 1);\n        dfs(i, j - 1, path, sum + grid[i][j],\
    \ count + 1);\n        dfs(i, j + 1, path, sum + grid[i][j], count + 1);\n   \
    \     visited[i][j] = false;\n        path.pop();\n    }\n    for(let i = 0; i\
    \ < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0,\
    \ 0);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let min = Infinity;\n    let minPath = [];\n\
    \    let visited = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            let path = [];\n            let pathSum = 0;\n          \
    \  dfs(i, j, path, pathSum, k, grid, visited);\n            if(pathSum < min){\n\
    \                min = pathSum;\n                minPath = path;\n           \
    \ }\n        }\n    }\n    return minPath;\n}\n", "    let minPath = [];\n   \
    \ let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let\
    \ minPath5 = [];\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n  \
    \  let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minPathSum8 =\
    \ Infinity;\n    let minPath8 = [];\n    let minPathSum9 = Infinity;\n    let\
    \ minPath9 = [];\n    let minPathSum10 = Infinity;\n    let minPath10 = [];\n\
    \    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPathSum13 = Infinity;\n   \
    \ let minPath13 = [];\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n\
    \    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPathSum17 = Infinity;\n   \
    \ let minPath17 = [];\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n\
    \    let minPathSum19 = Infinity;\n    let minPath19 = [];\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPathSum21 = Infinity;\n   \
    \ let minPath21 = [];\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n\
    \    let minPathSum23 = Infinity;\n    let minPath23 = [];\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPathSum25 = Infinity;\n   \
    \ let minPath25 = [];\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n\
    \    let minPathSum27 = Infinity;\n    let minPath27 = [];\n    let minPathSum28\
    \ = Infinity;\n    let minPath28 = [];\n    let minPathSum29 = Infinity;", " \
    \   let n = grid.length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSumIndex = -1;\n    let minPathSumIndex2 = -1;\n    let minPathSumIndex3\
    \ = -1;\n    let minPathSumIndex4 = -1;\n    let minPathSumIndex5 = -1;\n    let\
    \ minPathSumIndex6 = -1;\n    let minPathSumIndex7 = -1;\n    let minPathSumIndex8\
    \ = -1;\n    let minPathSumIndex9 = -1;\n    let minPathSumIndex10 = -1;\n   \
    \ let minPathSumIndex11 = -1;\n    let minPathSumIndex12 = -1;\n    let minPathSumIndex13\
    \ = -1;\n    let minPathSumIndex14 = -1;\n    let minPathSumIndex15 = -1;\n  \
    \  let minPathSumIndex16 = -1;\n    let minPathSumIndex17 = -1;\n    let minPathSumIndex18\
    \ = -1;\n    let minPathSumIndex19 = -1;\n    let minPathSumIndex20 = -1;\n  \
    \  let minPathSumIndex21 = -1;\n    let minPathSumIndex22 = -1;\n    let minPathSumIndex23\
    \ = -1;\n    let minPathSumIndex24 = -1;\n    let minPathSumIndex25 = -1;\n  \
    \  let minPathSumIndex26 = -1;\n    let minPathSumIndex27 = -1;\n    let minPathSumIndex28\
    \ = -1;\n    let minPathSumIndex29 = -1;\n    let minPathSumIndex30 = -1;\n  \
    \  let minPathSumIndex31 = -1;\n    let minPathSumIndex32 = -1;\n    let minPathSumIndex33\
    \ = -1;\n    let minPathSumIndex34 = -1;\n    let minPathSumIndex35 = -1;\n  \
    \  let minPathSumIndex36 = -1;\n    let minPathSumIndex37 = -1;\n    let minPathSumIndex38\
    \ = -1;\n    let minPathSumIndex39 = -1;\n    let minPathSumIndex40 = -1;\n  \
    \  let minPathSumIndex41", "    // Your code here\n}\n", "    var n = grid.length;\n\
    \    var m = grid[0].length;\n    var min = [];\n    var min_path = [];\n    for(var\
    \ i = 0; i < n; i++){\n        for(var j = 0; j < m; j++){\n            var path\
    \ = [];\n            var path_value = [];\n            var visited = [];\n   \
    \         for(var x = 0; x < n; x++){\n                visited.push([]);\n   \
    \             for(var y = 0; y < m; y++){\n                    visited[x].push(false);\n\
    \                }\n            }\n            dfs(grid, i, j, k, path, path_value,\
    \ visited);\n            if(min.length == 0 || path_value < min){\n          \
    \      min = path_value;\n                min_path = path;\n            }\n  \
    \      }\n    }\n    return min_path;\n}\n", "    let minPath = [];\n    let minPathSum\
    \ = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let\
    \ minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minPathSum4 = Infinity;\n\
    \    let minPath4 = [];\n    let minPathSum5 = Infinity;\n    let minPath5 = [];\n\
    \    let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minPathSum7\
    \ = Infinity;\n    let minPath7 = [];\n    let minPathSum8 = Infinity;\n    let\
    \ minPath8 = [];\n    let minPathSum9 = Infinity;\n    let minPath9 = [];\n  \
    \  let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minPathSum11\
    \ = Infinity;\n    let minPath11 = [];\n    let minPathSum12 = Infinity;\n   \
    \ let minPath12 = [];\n    let minPathSum13 = Infinity;\n    let minPath13 = [];\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minPathSum15\
    \ = Infinity;\n    let minPath15 = [];\n    let minPathSum16 = Infinity;\n   \
    \ let minPath16 = [];\n    let minPathSum17 = Infinity;\n    let minPath17 = [];\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minPathSum19\
    \ = Infinity;\n    let minPath19 = [];\n    let minPathSum20 = Infinity;\n   \
    \ let minPath20 = [];\n    let minPathSum21 = Infinity;\n    let minPath21 = [];\n\
    \    let minPathSum22 = Infinity;\n    let minPath22 = [];\n    let minPathSum23\
    \ = Infinity;\n    let minPath23 = [];\n    let minPathSum24 = Infinity;\n   \
    \ let minPath24 = [];\n    let minPathSum25 = Infinity;\n    let minPath25 = [];\n\
    \    let minPathSum26 = Infinity;\n    let minPath26 = [];\n    let minPathSum27\
    \ = Infinity;\n    let minPath27 = [];\n    let minPathSum28 = Infinity;\n   \
    \ let minPath28 = [];\n    let minPathSum29 = Infinity;", "    let minPath = [];\n\
    \    let minPathSum = Infinity;\n    let minPathSumIndex = 0;\n    let minPathSumIndex2\
    \ = 0;\n    let minPathSumIndex3 = 0;\n    let minPathSumIndex4 = 0;\n    let\
    \ minPathSumIndex5 = 0;\n    let minPathSumIndex6 = 0;\n    let minPathSumIndex7\
    \ = 0;\n    let minPathSumIndex8 = 0;\n    let minPathSumIndex9 = 0;\n    let\
    \ minPathSumIndex10 = 0;\n    let minPathSumIndex11 = 0;\n    let minPathSumIndex12\
    \ = 0;\n    let minPathSumIndex13 = 0;\n    let minPathSumIndex14 = 0;\n    let\
    \ minPathSumIndex15 = 0;\n    let minPathSumIndex16 = 0;\n    let minPathSumIndex17\
    \ = 0;\n    let minPathSumIndex18 = 0;\n    let minPathSumIndex19 = 0;\n    let\
    \ minPathSumIndex20 = 0;\n    let minPathSumIndex21 = 0;\n    let minPathSumIndex22\
    \ = 0;\n    let minPathSumIndex23 = 0;\n    let minPathSumIndex24 = 0;\n    let\
    \ minPathSumIndex25 = 0;\n    let minPathSumIndex26 = 0;\n    let minPathSumIndex27\
    \ = 0;\n    let minPathSumIndex28 = 0;\n    let minPathSumIndex29 = 0;\n    let\
    \ minPathSumIndex30 = 0;\n    let minPathSumIndex31 = 0;\n    let minPathSumIndex32\
    \ = 0;\n    let minPathSumIndex33 = 0;\n    let minPathSumIndex34 = 0;\n    let\
    \ minPathSumIndex35 = 0;\n    let minPathSumIndex36 = 0;\n    let minPathSumIndex37\
    \ = 0;\n    let minPathSumIndex38 = 0;\n    let minPathSumIndex39 = 0;\n    let\
    \ minPathSumIndex40 = 0;\n    let minPathSumIndex41 = 0;\n    let minPathSumIndex42\
    \ = 0;\n    let minPathSumIndex43 = 0;\n    let minPathSumIndex44 = 0;\n    let\
    \ minPathSumIndex45 = 0;\n   ", "    var n = grid.length;\n    var m = grid[0].length;\n\
    \    var min = Infinity;\n    var minPath = [];\n    var visited = [];\n    for(var\
    \ i = 0; i < n; i++){\n        visited.push([]);\n        for(var j = 0; j < m;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    for(var i\
    \ = 0; i < n; i++){\n        for(var j = 0; j < m; j++){\n            var path\
    \ = [];\n            var pathSum = 0;\n            dfs(grid, i, j, k, path, pathSum,\
    \ visited);\n            if(pathSum < min){\n                min = pathSum;\n\
    \                minPath = path;\n            }\n        }\n    }\n    return\
    \ minPath;\n}\n", "    // your code here\n}\n", "\tvar n = grid.length;\n\tvar\
    \ m = grid[0].length;\n\tvar visited = new Array(n);\n\tfor(var i = 0; i < n;\
    \ i++){\n\t\tvisited[i] = new Array(m);\n\t\tfor(var j = 0; j < m; j++){\n\t\t\
    \tvisited[i][j] = false;\n\t\t}\n\t}\n\tvar minPath = [];\n\tvar minSum = Infinity;\n\
    \tvar minPathSum = Infinity;\n\tvar minPathSumHelper = function(i, j, path, sum){\n\
    \t\tif(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\t\t\treturn;\n\t\
    \t}\n\t\tpath.push(grid[i][j]);\n\t\tsum += grid[i][j];\n\t\tvisited[i][j] = true;\n\
    \t\tif(path.length === k){\n\t\t\tif(sum < minPathSum){\n\t\t\t\tminPathSum =\
    \ sum;\n\t\t\t\tminPath = path.slice();\n\t\t\t}\n\t\t\telse if(sum === minPathSum){\n\
    \t\t\t\tif(path.toString() < minPath.toString()){\n\t\t\t\t\tminPath = path.slice();\n\
    \t\t\t\t}\n\t\t\t}\n\t\t\tvisited[i][j] = false;\n\t\t\tpath.pop();\n\t\t\treturn;\n\
    \t\t}\n\t\tminPathSumHelper(i + 1, j, path, sum);\n\t\tminPathSumHelper(i - 1,\
    \ j, path, sum);\n\t\tminPathSumHelper(i, j + 1, path, sum);\n\t\tminPathSumHelper(i,\
    \ j - 1, path, sum);\n\t\tvisited[i][j] = false;\n\t\tpath.pop();\n\t}\n\tfor(var\
    \ i = 0; i < n; i++){\n\t\tfor(var j = 0; j < m; j++){\n\t\t\tminPathSumHelper(i,\
    \ j, [], 0);\n\t\t}\n\t}\n\treturn minPath", "    let n = grid.length;\n    let\
    \ minPath = [];\n    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n\
    \    let minPath2 = [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n\
    \    let minPathSum4 = Infinity;\n    let minPath4 = [];\n    let minPathSum5\
    \ = Infinity;\n    let minPath5 = [];\n    let minPathSum6 = Infinity;\n    let\
    \ minPath6 = [];\n    let minPathSum7 = Infinity;\n    let minPath7 = [];\n  \
    \  let minPathSum8 = Infinity;\n    let minPath8 = [];\n    let minPathSum9 =\
    \ Infinity;\n    let minPath9 = [];\n    let minPathSum10 = Infinity;\n    let\
    \ minPath10 = [];\n    let minPathSum11 = Infinity;\n    let minPath11 = [];\n\
    \    let minPathSum12 = Infinity;\n    let minPath12 = [];\n    let minPathSum13\
    \ = Infinity;\n    let minPath13 = [];\n    let minPathSum14 = Infinity;\n   \
    \ let minPath14 = [];\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n\
    \    let minPathSum16 = Infinity;\n    let minPath16 = [];\n    let minPathSum17\
    \ = Infinity;\n    let minPath17 = [];\n    let minPathSum18 = Infinity;\n   \
    \ let minPath18 = [];\n    let minPathSum19 = Infinity;\n    let minPath19 = [];\n\
    \    let minPathSum20 = Infinity;\n    let minPath20 = [];\n    let minPathSum21\
    \ = Infinity;\n    let minPath21 = [];\n    let minPathSum22 = Infinity;\n   \
    \ let minPath22 = [];\n    let minPathSum23 = Infinity;\n    let minPath23 = [];\n\
    \    let minPathSum24 = Infinity;\n    let minPath24 = [];\n    let minPathSum25\
    \ = Infinity;\n    let minPath25 = [];\n    let minPathSum26 = Infinity;\n   \
    \ let minPath26 = [];\n    let minPathSum27 = Infinity;\n    let minPath27 = [];\n\
    \    let minPathSum28 = Infinity;\n    let minPath28 = [];\n", "    // your code\
    \ here\n}\n", "  let n = grid.length;\n  let m = grid[0].length;\n  let minPath\
    \ = [];\n  let minSum = Infinity;\n  for(let i = 0; i < n; i++){\n    for(let\
    \ j = 0; j < m; j++){\n      let path = [];\n      let sum = 0;\n      let visited\
    \ = new Set();\n      dfs(i, j, k, path, sum, visited);\n    }\n  }\n  return\
    \ minPath;\n  function dfs(i, j, k, path, sum, visited){\n    if(i < 0 || i >=\
    \ n || j < 0 || j >= m || visited.has(i * m + j)){\n      return;\n    }\n   \
    \ path.push(grid[i][j]);\n    sum += grid[i][j];\n    visited.add(i * m + j);\n\
    \    if(path.length === k){\n      if(sum < minSum){\n        minSum = sum;\n\
    \        minPath = path.slice();\n      }\n      else if(sum === minSum){\n  \
    \      for(let i = 0; i < k; i++){\n          if(path[i] < minPath[i]){\n    \
    \        minPath = path.slice();\n            break;\n          }\n          else\
    \ if(path[i] > minPath[i]){\n            break;\n          }\n        }\n    \
    \  }\n    }\n    else{\n      dfs(i - 1, j, k, path, sum, visited);\n      dfs(i\
    \ + 1, j, k, path, sum, visited);\n      dfs(i, j - 1, k, path, sum, visited);\n\
    \      dfs(i, j + 1, k, path, sum, visited);\n    }\n    path.pop();\n    sum\
    \ -= grid[i][j];\n    visited.delete(i * m + j);\n  }\n}\n", "    // your code\
    \ here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ dp = new Array(n).fill(0).map(() => new Array(m).fill(0).map(() => new Array(k\
    \ + 1).fill(0)));\n    let min = Infinity;\n    let minPath = [];\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            for(let\
    \ l = 0; l <= k; l++){\n                if(l == 0){\n                    dp[i][j][l]\
    \ = grid[i][j];\n                }\n                else{\n                  \
    \  let minVal = Infinity;\n                    if(i > 0){\n                  \
    \      minVal = Math.min(minVal, dp[i - 1][j][l - 1]);\n                    }\n\
    \                    if(j > 0){\n                        minVal = Math.min(minVal,\
    \ dp[i][j - 1][l - 1]);\n                    }\n                    if(i < n -\
    \ 1){\n                        minVal = Math.min(minVal, dp[i + 1][j][l - 1]);\n\
    \                    }\n                    if(j < m - 1){\n                 \
    \       minVal = Math.min(minVal, dp[i][j + 1][l - 1]);\n                    }\n\
    \                    dp[i][j][l] = minVal + grid[i][j];\n                }\n \
    \               if(l == k && dp[i][j][l] < min){\n                    min = dp[i][j][l];\n\
    \                    minPath = [grid[i][j]];\n                }\n            \
    \    else if(l == k && dp[i][j][l] == min){\n                    minPath.push(grid[i][j]);\n\
    \                }\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n    let\
    \ min_sum = Infinity;\n    let min_path = [];\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            let path = [];\n           \
    \ let sum = 0;\n            let visited = [];\n            for(let i = 0; i <\
    \ n; i++){\n                visited.push([]);\n                for(let j = 0;\
    \ j < m; j++){\n                    visited[i].push(false);\n                }\n\
    \            }\n            dfs(grid, i, j, k, path, sum, visited);\n        \
    \    if(sum < min_sum){\n                min_sum = sum;\n                min_path\
    \ = path;\n            }\n        }\n    }\n    return min_path;\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let min = Infinity;\n   \
    \ let minPath = [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j\
    \ < m; j++){\n            let path = [];\n            let curr = grid[i][j];\n\
    \            path.push(curr);\n            let currMin = dfs(grid, i, j, path,\
    \ k, curr);\n            if(currMin < min){\n                min = currMin;\n\
    \                minPath = path;\n            }\n        }\n    }\n    return\
    \ minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n   \
    \ let min = [];\n    let visited = [];\n    for(let i = 0; i < n; i++){\n    \
    \    visited.push([]);\n        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n\
    \        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            let path = [];\n            dfs(grid, i, j, k, path, visited);\n\
    \            if(min.length == 0 || path.length < min.length){\n              \
    \  min = path;\n            }\n            else if(path.length == min.length){\n\
    \                for(let i = 0; i < path.length; i++){\n                    if(path[i]\
    \ < min[i]){\n                        min = path;\n                        break;\n\
    \                    }\n                    else if(path[i] > min[i]){\n     \
    \                   break;\n                    }\n                }\n       \
    \     }\n        }\n    }\n    return min;\n}\n", "    // your code here\n}\n",
  "    let result = [];\n    let min = Infinity;\n    let minPath = [];\n    let path\
    \ = [];\n    let visited = [];\n    for(let i = 0; i < grid.length; i++){\n  \
    \      visited.push([]);\n        for(let j = 0; j < grid[0].length; j++){\n \
    \           visited[i].push(false);\n        }\n    }\n    for(let i = 0; i <\
    \ grid.length; i++){\n        for(let j = 0; j < grid[0].length; j++){\n     \
    \       dfs(grid, i, j, k, path, visited);\n            if(path.length < min){\n\
    \                min = path.length;\n                minPath = path;\n       \
    \     }\n            path = [];\n            for(let i = 0; i < grid.length; i++){\n\
    \                for(let j = 0; j < grid[0].length; j++){\n                  \
    \  visited[i][j] = false;\n                }\n            }\n        }\n    }\n\
    \    return minPath;\n}\n", "\tvar minPath = [];\n\tvar minPathSum = Infinity;\n\
    \tvar minPathSumIndex = -1;\n\tvar minPathSumIndex2 = -1;\n\tvar minPathSumIndex3\
    \ = -1;\n\tvar minPathSumIndex4 = -1;\n\tvar minPathSumIndex5 = -1;\n\tvar minPathSumIndex6\
    \ = -1;\n\tvar minPathSumIndex7 = -1;\n\tvar minPathSumIndex8 = -1;\n\tvar minPathSumIndex9\
    \ = -1;\n\tvar minPathSumIndex10 = -1;\n\tvar minPathSumIndex11 = -1;\n\tvar minPathSumIndex12\
    \ = -1;\n\tvar minPathSumIndex13 = -1;\n\tvar minPathSumIndex14 = -1;\n\tvar minPathSumIndex15\
    \ = -1;\n\tvar minPathSumIndex16 = -1;\n\tvar minPathSumIndex17 = -1;\n\tvar minPathSumIndex18\
    \ = -1;\n\tvar minPathSumIndex19 = -1;\n\tvar minPathSumIndex20 = -1;\n\tvar minPathSumIndex21\
    \ = -1;\n\tvar minPathSumIndex22 = -1;\n\tvar minPathSumIndex23 = -1;\n\tvar minPathSumIndex24\
    \ = -1;\n\tvar minPathSumIndex25 = -1;\n\tvar minPathSumIndex26 = -1;\n\tvar minPathSumIndex27\
    \ = -1;\n\tvar minPathSumIndex28 = -1;\n\tvar minPathSumIndex29 = -1;\n\tvar minPathSumIndex30\
    \ = -1;\n\tvar minPathSumIndex31 = -1;\n\tvar minPathSumIndex32 = -1;\n\tvar minPathSumIndex33\
    \ = -1;\n\tvar minPathSumIndex34 = -1;\n\tvar minPathSumIndex35 = -1;\n\tvar minPathSumIndex36\
    \ = -1;\n\tvar minPathSumIndex37 = -1;\n\tvar minPathSumIndex38 = -1;\n\tvar minPathSumIndex39\
    \ = -1;\n\tvar minPathSumIndex40 = -1;\n\tvar minPathSumIndex41 = -1;\n\tvar minPath",
  "  let minPath = [];\n  let minPathSum = Infinity;\n  let minPathSumIndex = 0;\n\
    \  let minPathSumIndex2 = 0;\n  let minPathSumIndex3 = 0;\n  let minPathSumIndex4\
    \ = 0;\n  let minPathSumIndex5 = 0;\n  let minPathSumIndex6 = 0;\n  let minPathSumIndex7\
    \ = 0;\n  let minPathSumIndex8 = 0;\n  let minPathSumIndex9 = 0;\n  let minPathSumIndex10\
    \ = 0;\n  let minPathSumIndex11 = 0;\n  let minPathSumIndex12 = 0;\n  let minPathSumIndex13\
    \ = 0;\n  let minPathSumIndex14 = 0;\n  let minPathSumIndex15 = 0;\n  let minPathSumIndex16\
    \ = 0;\n  let minPathSumIndex17 = 0;\n  let minPathSumIndex18 = 0;\n  let minPathSumIndex19\
    \ = 0;\n  let minPathSumIndex20 = 0;\n  let minPathSumIndex21 = 0;\n  let minPathSumIndex22\
    \ = 0;\n  let minPathSumIndex23 = 0;\n  let minPathSumIndex24 = 0;\n  let minPathSumIndex25\
    \ = 0;\n  let minPathSumIndex26 = 0;\n  let minPathSumIndex27 = 0;\n  let minPathSumIndex28\
    \ = 0;\n  let minPathSumIndex29 = 0;\n  let minPathSumIndex30 = 0;\n  let minPathSumIndex31\
    \ = 0;\n  let minPathSumIndex32 = 0;\n  let minPathSumIndex33 = 0;\n  let minPathSumIndex34\
    \ = 0;\n  let minPathSumIndex35 = 0;\n  let minPathSumIndex36 = 0;\n  let minPathSumIndex37\
    \ = 0;\n  let minPathSumIndex38 = 0;\n  let minPathSumIndex39 = 0;\n  let minPathSumIndex40\
    \ = 0;\n  let minPathSumIndex41 = 0;\n  let minPathSumIndex42 = 0;\n  let minPathSumIndex43\
    \ = 0;\n  let minPathSumIndex44 = 0;\n  let minPathSumIndex45 = 0;\n ", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n    let minSum\
    \ = Infinity;\n    let minPath = [];\n    let visited = [];\n    for(let i = 0;\
    \ i < n; i++){\n        visited.push([]);\n        for(let j = 0; j < m; j++){\n\
    \            visited[i].push(false);\n        }\n    }\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n\
    \            let sum = 0;\n            dfs(i, j, k, path, sum);\n        }\n \
    \   }\n    return minPath;\n    function dfs(i, j, k, path, sum){\n        if(k\
    \ === 0){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path;\n            }\n            return;\n        }\n\
    \        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n          \
    \  return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        sum += grid[i][j];\n        dfs(i + 1, j, k - 1, path, sum);\n      \
    \  dfs(i - 1, j, k - 1, path, sum);\n        dfs(i, j + 1, k - 1, path, sum);\n\
    \        dfs(i, j - 1, k - 1, path, sum);\n        visited[i][j] = false;\n  \
    \      path.pop();\n    }\n}\n", "    // your code here\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let visited = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    function dfs(i, j, path, pathSum){\n        if(i < 0 || i\
    \ >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n        }\n\
    \        path.push(grid[i][j]);\n        pathSum += grid[i][j];\n        visited[i][j]\
    \ = true;\n        if(path.length === k){\n            if(pathSum < minPathSum){\n\
    \                minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n            else if(pathSum === minPathSum){\n               \
    \ for(let i = 0; i < k; i++){\n                    if(path[i] < minPath[i]){\n\
    \                        minPath = path.slice();\n                        break;\n\
    \                    }\n                    else if(path[i] > minPath[i]){\n \
    \                       break;\n                    }\n                }\n   \
    \         }\n        }\n        else{\n            dfs(i + 1, j, path, pathSum);\n\
    \            dfs(i - 1, j, path, pathSum);\n            dfs(i, j + 1, path, pathSum);\n\
    \            dfs(i, j - 1, path, pathSum);\n        }\n        path.pop();\n \
    \       pathSum -= grid[i][j];\n        visited[i][j] = false;\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i,\
    \ j, [], 0);\n        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let dp = new Array(n).fill(0).map(() => new\
    \ Array(m).fill(0).map(() => new Array(k + 1).fill(Infinity)));\n    let res =\
    \ [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(let i = 0; i\
    \ < n; i++){\n        for(let j = 0; j < m; j++){\n            for(let l = 2;\
    \ l <= k; l++){\n                if(i > 0){\n                    dp[i][j][l] =\
    \ Math.min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n           \
    \     if(j > 0){\n                    dp[i][j][l] = Math.min(dp[i][j][l], dp[i][j\
    \ - 1][l - 1]);\n                }\n                if(i < n - 1){\n         \
    \           dp[i][j][l] = Math.min(dp[i][j][l], dp[i + 1][j][l - 1]);\n      \
    \          }\n                if(j < m - 1){\n                    dp[i][j][l]\
    \ = Math.min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    let min = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            min = Math.min(min, dp[i][j][k]);\n\
    \        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            if(dp[i][j][k] == min){\n                res.push([i,\
    \ j]);\n            }\n        }\n    }\n   ", "    // your code here\n}\n", " \
    \   let minPath = [];\n    let minPathVal = Infinity;\n    let minPathValSum =\
    \ Infinity;\n    let minPathValSumIndex = Infinity;\n    let minPathValSumIndexVal\
    \ = Infinity;\n    let minPathValSumIndexValIndex = Infinity;\n    let minPathValSumIndexValIndexVal\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndex = Infinity;\n    let\
    \ minPathValSumIndexValIndexValIndexVal = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndex\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexVal = Infinity;\n\
    \    let minPathValSumIndexValIndexValIndexValIndexValIndex = Infinity;\n    let\
    \ minPathValSumIndexValIndexValIndexValIndexValIndexVal = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndex\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexVal\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndex\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndexVal\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndex\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexVal\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndex\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexVal\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndex\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexVal\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndex\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexValIndexVal\
    \ = Infinity;\n    let minPathValSumIndexValIndexValIndexVal", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      let path = [];\n            let sum = 0;\n            dfs(i, j, k, path,\
    \ sum);\n        }\n    }\n    return minPath;\n    function dfs(i, j, k, path,\
    \ sum){\n        if(k === 0){\n            if(sum < minPathSum){\n           \
    \     minPathSum = sum;\n                minPath = path.slice();\n           \
    \ }\n            return;\n        }\n        if(i < 0 || i >= n || j < 0 || j\
    \ >= m || visited[i][j]){\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n      \
    \  if(sum > minPathSum){\n            path.pop();\n            visited[i][j] =\
    \ false;\n            return;\n        }\n        dfs(i - 1, j, k - 1, path, sum);\n\
    \        dfs(i + 1, j, k - 1, path, sum);\n        dfs(i, j - 1, k - 1, path,\
    \ sum);\n        dfs(i, j + 1, k - 1, path, sum);\n        path.pop();\n     \
    \   visited[i][j] = false;\n    }\n}\n", "    // your code here\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPaths = [];\n    function dfs(i, j,\
    \ path, sum, pathSum){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j])\
    \ return;\n        if(path.length === k){\n            if(sum < minSum){\n   \
    \             minSum = sum;\n                minPaths = [path];\n            }else\
    \ if(sum === minSum){\n                minPaths.push(path);\n            }\n \
    \           if(pathSum < minPathSum){\n                minPathSum = pathSum;\n\
    \                minPath = path;\n            }else if(pathSum === minPathSum){\n\
    \                minPath = minPath.map((e, i) => e < path[i] ? e : path[i]);\n\
    \            }\n            return;\n        }\n        visited[i][j] = true;\n\
    \        dfs(i + 1, j, path.concat(grid[i][j]), sum + grid[i][j], pathSum * 10\
    \ + grid[i][j]);\n        dfs(i - 1, j, path.concat(grid[i][j]), sum + grid[i][j],\
    \ pathSum * 10 + grid[i][j]);\n        dfs(i, j + 1, path.concat(grid[i][j]),\
    \ sum + grid[i][j], pathSum * 10 + grid[i][j]);\n        dfs(i, j - 1, path.concat(grid[i][j]),\
    \ sum + grid[i][j], pathSum * 10 + grid[i][j]);\n        visited[i][j] = false;\n\
    \    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            dfs(i, j, [], 0, 0);\n        }\n    }\n    return minPath;\n}\n",
  "  let n = grid.length;\n  let m = grid[0].length;\n  let dp = new Array(n);\n \
    \ for(let i = 0; i < n; i++){\n    dp[i] = new Array(m);\n    for(let j = 0; j\
    \ < m; j++){\n      dp[i][j] = new Array(k+1);\n      for(let l = 0; l <= k; l++){\n\
    \        dp[i][j][l] = new Array(2);\n        dp[i][j][l][0] = Infinity;\n   \
    \     dp[i][j][l][1] = Infinity;\n      }\n    }\n  }\n  for(let i = 0; i < n;\
    \ i++){\n    for(let j = 0; j < m; j++){\n      dp[i][j][1][0] = grid[i][j];\n\
    \      dp[i][j][1][1] = grid[i][j];\n    }\n  }\n  for(let l = 2; l <= k; l++){\n\
    \    for(let i = 0; i < n; i++){\n      for(let j = 0; j < m; j++){\n        if(i\
    \ > 0){\n          if(dp[i-1][j][l-1][0] < dp[i][j][l][0]){\n            dp[i][j][l][0]\
    \ = dp[i-1][j][l-1][0];\n            dp[i][j][l][1] = dp[i-1][j][l-1][1];\n  \
    \        }\n          else if(dp[i-1][j][l-1][0] == dp[i][j][l][0]){\n       \
    \     dp[i][j][l][1] = Math.min(dp[i][j][l][1], dp[i-1][j][l-1][1]);\n       \
    \   }\n        }\n        if(i < n-1){\n          if(dp[i+1][j][l-1][0] < dp[i][j][l][",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        dp[i] = new Array(m);\n        for(let\
    \ j = 0; j < m; j++){\n            dp[i][j] = new Array(k + 1);\n            for(let\
    \ l = 0; l <= k; l++){\n                dp[i][j][l] = [];\n            }\n   \
    \     }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            dp[i][j][1] = [grid[i][j]];\n        }\n    }\n    for(let\
    \ l = 2; l <= k; l++){\n        for(let i = 0; i < n; i++){\n            for(let\
    \ j = 0; j < m; j++){\n                let min = [];\n                if(i - 1\
    \ >= 0){\n                    min = dp[i - 1][j][l - 1];\n                }\n\
    \                if(i + 1 < n && (min.length == 0 || compare(dp[i + 1][j][l -\
    \ 1], min) < 0)){\n                    min = dp[i + 1][j][l - 1];\n          \
    \      }\n                if(j - 1 >= 0 && (min.length == 0 || compare(dp[i][j\
    \ - 1][l - 1], min) < 0)){\n                    min = dp[i][j - 1][l - 1];\n \
    \               }\n                if(j + 1 < m && (min.length == 0 || compare(dp[i][j\
    \ + 1][l - 1], min) < 0)){\n                    min = dp[i][j + 1][l - 1];\n \
    \               }\n                dp[i][j][l] = min.concat(grid[i][j]);\n   \
    \         }\n        }\n    }\n    let min = [];\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = Infinity;\n    let minPath = [];\n    let visited = [];\n    for(let\
    \ i = 0; i < n; i++){\n        visited.push([]);\n        for(let j = 0; j < m;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            let curr = grid[i][j];\n            path.push(curr);\n  \
    \          visited[i][j] = true;\n            dfs(i, j, path, curr, k, visited);\n\
    \            visited[i][j] = false;\n        }\n    }\n    return minPath;\n \
    \   function dfs(i, j, path, curr, k, visited){\n        if(path.length === k){\n\
    \            if(curr < min){\n                min = curr;\n                minPath\
    \ = path.slice();\n            }\n            return;\n        }\n        if(i\
    \ > 0 && !visited[i - 1][j]){\n            path.push(grid[i - 1][j]);\n      \
    \      visited[i - 1][j] = true;\n            dfs(i - 1, j, path, curr + grid[i\
    \ - 1][j], k, visited);\n            visited[i - 1][j] = false;\n            path.pop();\n\
    \        }\n        if(i < n - 1 && !visited[i + 1][j]){\n            path.push(grid[i\
    \ + 1][j]);\n            visited[i + 1][j] = true;\n            dfs(i + 1, j,\
    \ path, curr + grid[i + 1][j], k, visited);\n            visited[i + 1][j] = false;\n\
    \            path.pop();\n        }\n        if(j > 0 && !visited[i][j - 1]){\n\
    \            path.push(grid[i][j - 1]);\n            visited[i][j - 1] = true;\n",
  "    let n = grid.length;\n    let visited = new Array(n);\n    for(let i = 0; i\
    \ < n; i++){\n        visited[i] = new Array(n).fill(false);\n    }\n    let min\
    \ = [];\n    let min_sum = Infinity;\n    for(let i = 0; i < n; i++){\n      \
    \  for(let j = 0; j < n; j++){\n            let curr = [];\n            let curr_sum\
    \ = 0;\n            dfs(i, j, k, curr, curr_sum, grid, visited, min, min_sum);\n\
    \        }\n    }\n    return min;\n}\n", "  // your code here\n}\n", "    let\
    \ n = grid.length;\n    let path = [];\n    let minPath = [];\n    let minPathSum\
    \ = Infinity;\n    let visited = [];\n    for(let i = 0; i < n; i++){\n      \
    \  visited.push([]);\n        for(let j = 0; j < n; j++){\n            visited[i].push(false);\n\
    \        }\n    }\n    function dfs(i, j, path, pathSum){\n        if(i < 0 ||\
    \ i >= n || j < 0 || j >= n || visited[i][j]){\n            return;\n        }\n\
    \        visited[i][j] = true;\n        path.push(grid[i][j]);\n        pathSum\
    \ += grid[i][j];\n        if(path.length === k){\n            if(pathSum < minPathSum){\n\
    \                minPathSum = pathSum;\n                minPath = path.slice();\n\
    \            }\n        }else{\n            dfs(i - 1, j, path, pathSum);\n  \
    \          dfs(i + 1, j, path, pathSum);\n            dfs(i, j - 1, path, pathSum);\n\
    \            dfs(i, j + 1, path, pathSum);\n        }\n        path.pop();\n \
    \       pathSum -= grid[i][j];\n        visited[i][j] = false;\n    }\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n            dfs(i,\
    \ j, path, 0);\n        }\n    }\n    return minPath;\n}\n", "    // your code\
    \ here\n}\n", "  // Your code here\n}\n", "    let n = grid.length;\n    let m\
    \ = grid[0].length;\n    let min = [];\n    let min_sum = Infinity;\n    let min_path\
    \ = [];\n    let visited = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(let j = 0; j < m; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    function dfs(i, j, path, sum){\n        if(sum > min_sum){\n\
    \            return;\n        }\n        if(path.length == k){\n            if(sum\
    \ < min_sum){\n                min_sum = sum;\n                min_path = path;\n\
    \            }\n            return;\n        }\n        visited[i][j] = true;\n\
    \        if(i - 1 >= 0 && !visited[i - 1][j]){\n            dfs(i - 1, j, path.concat(grid[i\
    \ - 1][j]), sum + grid[i - 1][j]);\n        }\n        if(i + 1 < n && !visited[i\
    \ + 1][j]){\n            dfs(i + 1, j, path.concat(grid[i + 1][j]), sum + grid[i\
    \ + 1][j]);\n        }\n        if(j - 1 >= 0 && !visited[i][j - 1]){\n      \
    \      dfs(i, j - 1, path.concat(grid[i][j - 1]), sum + grid[i][j - 1]);\n   \
    \     }\n        if(j + 1 < m && !visited[i][j + 1]){\n            dfs(i, j +\
    \ 1, path.concat(grid[i][j + 1]), sum + grid[i][j + 1]);\n        }\n        visited[i][j]\
    \ = false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ m; j++){\n            dfs(i, j, [grid[i][j]], grid[i][j]);\n        }\n    }\n\
    \    return min_path;\n}\n", "    //YOUR CODE HERE\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n).fill(0).map(() =>\
    \ new Array(m).fill(false));\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let dfs = function(i, j, path, sum){\n  \
    \      if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n\
    \        }\n        if(path.length === k){\n            if(sum < minPathSum){\n\
    \                minPathSum = sum;\n                minPath = path;\n        \
    \    }\n            return;\n        }\n        visited[i][j] = true;\n      \
    \  path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i + 1, j, path.slice(),\
    \ sum);\n        dfs(i - 1, j, path.slice(), sum);\n        dfs(i, j + 1, path.slice(),\
    \ sum);\n        dfs(i, j - 1, path.slice(), sum);\n        visited[i][j] = false;\n\
    \    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n}\n", " \
    \   // your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = [];\n    let min_sum = Infinity;\n    for(let i = 0; i < n; i++){\n\
    \        for(let j = 0; j < m; j++){\n            let path = [];\n           \
    \ let sum = 0;\n            let visited = new Set();\n            let queue =\
    \ [[i, j]];\n            while(queue.length > 0){\n                let curr =\
    \ queue.shift();\n                let x = curr[0];\n                let y = curr[1];\n\
    \                if(visited.has(x + \",\" + y)){\n                    continue;\n\
    \                }\n                visited.add(x + \",\" + y);\n            \
    \    path.push(grid[x][y]);\n                sum += grid[x][y];\n            \
    \    if(path.length === k){\n                    if(sum < min_sum){\n        \
    \                min_sum = sum;\n                        min = path;\n       \
    \             }\n                    else if(sum === min_sum){\n             \
    \           for(let i = 0; i < k; i++){\n                            if(path[i]\
    \ < min[i]){\n                                min = path;\n                  \
    \              break;\n                            }\n                       \
    \     else if(path[i] > min[i]){\n                                break;\n   \
    \                         }\n                        }\n                    }\n\
    \                    break;\n                }\n                if(x > 0){\n \
    \                   queue.push([x - 1, y]);\n                }\n             \
    \   if(x < n - 1){\n                    queue.push([x + 1, y]);\n            \
    \    }\n                if(y > 0){\n                    queue.push([x, y - 1]);\n\
    \                }\n                if(y < m - 1){\n                    queue.push([x,\
    \ y + 1]);\n                }\n            }\n        }\n    }\n    return min;\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let min = Infinity;\n\
    \    let minPath = [];\n    let visited = new Set();\n    function dfs(i, j, path,\
    \ sum){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited.has(i + ','\
    \ + j)) return;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n\
    \        if(path.length === k){\n            if(sum < min){\n                min\
    \ = sum;\n                minPath = path.slice();\n            }\n           \
    \ path.pop();\n            return;\n        }\n        visited.add(i + ',' + j);\n\
    \        dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path, sum);\n      \
    \  dfs(i, j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n        visited.delete(i\
    \ + ',' + j);\n        path.pop();\n    }\n    for(let i = 0; i < n; i++){\n \
    \       for(let j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n        }\n\
    \    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minPathSum = Infinity;\n    let minPathSum2 =\
    \ Infinity;\n    let minPath2 = [];\n    let minPathSum3 = Infinity;\n    let\
    \ minPath3 = [];\n    let minPathSum4 = Infinity;\n    let minPath4 = [];\n  \
    \  let minPathSum5 = Infinity;\n    let minPath5 = [];\n    let minPathSum6 =\
    \ Infinity;\n    let minPath6 = [];\n    let minPathSum7 = Infinity;\n    let\
    \ minPath7 = [];\n    let minPathSum8 = Infinity;\n    let minPath8 = [];\n  \
    \  let minPathSum9 = Infinity;\n    let minPath9 = [];\n    let minPathSum10 =\
    \ Infinity;\n    let minPath10 = [];\n    let minPathSum11 = Infinity;\n    let\
    \ minPath11 = [];\n    let minPathSum12 = Infinity;\n    let minPath12 = [];\n\
    \    let minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minPathSum14\
    \ = Infinity;\n    let minPath14 = [];\n    let minPathSum15 = Infinity;\n   \
    \ let minPath15 = [];\n    let minPathSum16 = Infinity;\n    let minPath16 = [];\n\
    \    let minPathSum17 = Infinity;\n    let minPath17 = [];\n    let minPathSum18\
    \ = Infinity;\n    let minPath18 = [];\n    let minPathSum19 = Infinity;\n   \
    \ let minPath19 = [];\n    let minPathSum20 = Infinity;\n    let minPath20 = [];\n\
    \    let minPathSum21 = Infinity;\n    let minPath21 = [];\n    let minPathSum22\
    \ = Infinity;\n    let minPath22 = [];\n    let minPathSum23 = Infinity;\n   \
    \ let minPath23 = [];\n    let minPathSum24 = Infinity;\n    let minPath24 = [];\n\
    \    let minPathSum25 = Infinity;\n    let minPath25 = [];\n    let minPathSum26\
    \ = Infinity;\n    let minPath26 = [];\n    let minPathSum27 = Infinity;\n   \
    \ let minPath27 = [];\n    let minPathSum28 =", "    var n = grid.length;\n  \
    \  var m = grid[0].length;\n    var minPath = [];\n    var minPathValue = Infinity;\n\
    \    var minPathIndex = -1;\n    var visited = [];\n    for(var i = 0; i < n;\
    \ i++){\n        visited.push([]);\n        for(var j = 0; j < m; j++){\n    \
    \        visited[i].push(false);\n        }\n    }\n    var dfs = function(i,\
    \ j, path, pathValue){\n        if(i < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n\
    \            return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        pathValue += grid[i][j];\n        if(path.length === k){\n          \
    \  if(pathValue < minPathValue){\n                minPathValue = pathValue;\n\
    \                minPathIndex = path.length - 1;\n                minPath = path.slice();\n\
    \            }\n            else if(pathValue === minPathValue){\n           \
    \     for(var l = 0; l < path.length; l++){\n                    if(path[l] <\
    \ minPath[l]){\n                        minPathIndex = path.length - 1;\n    \
    \                    minPath = path.slice();\n                        break;\n\
    \                    }\n                    else if(path[l] > minPath[l]){\n \
    \                       break;\n                    }\n                }\n   \
    \         }\n        }\n        else{\n            dfs(i - 1, j, path, pathValue);\n\
    \            dfs(i + 1, j, path, pathValue);\n            dfs(i, j - 1, path,\
    \ pathValue);\n            dfs(i, j + 1, path, pathValue);\n        }\n      \
    \  path.pop();\n        pathValue -= grid[i][j];\n        visited[i][j] = false;\n\
    \    };\n    for(var i = 0; i < n; i++){\n        for(var j = 0; j < m; j++){\n\
    \            dfs(i, j, [], 0);\n        }\n    }\n    return minPath;\n", "  let\
    \ result = [];\n  let min = Infinity;\n  let minPath = [];\n  let visited = new\
    \ Set();\n  let queue = [[0, 0, grid[0][0]]];\n  let directions = [[0, 1], [0,\
    \ -1], [1, 0], [-1, 0]];\n  while(queue.length){\n    let [x, y, sum] = queue.shift();\n\
    \    if(visited.has(`${x},${y}`)) continue;\n    visited.add(`${x},${y}`);\n \
    \   if(sum > min) continue;\n    if(sum === min && result.length < minPath.length)\
    \ continue;\n    if(sum > k) continue;\n    if(sum === k){\n      if(sum < min){\n\
    \        min = sum;\n        minPath = result.slice();\n      }\n      continue;\n\
    \    }\n    result.push(grid[x][y]);\n    for(let [dx, dy] of directions){\n \
    \     let newX = x + dx;\n      let newY = y + dy;\n      if(newX < 0 || newX\
    \ >= grid.length || newY < 0 || newY >= grid[0].length) continue;\n      queue.push([newX,\
    \ newY, sum + grid[newX][newY]]);\n    }\n    result.pop();\n  }\n  return minPath;\n\
    }\n", "  // your code here\n}\n", "    // your code here\n}\n", "    // your code\
    \ here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ visited = new Array(n).fill(0).map(() => new Array(m).fill(false));\n    let\
    \ minPath = [];\n    let minSum = Infinity;\n    let minSumPath = [];\n    let\
    \ dfs = function(i, j, path, sum){\n        if(i < 0 || i >= n || j < 0 || j >=\
    \ m || visited[i][j]){\n            return;\n        }\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minSumPath = path;\n            }\n            return;\n        }\n\
    \        visited[i][j] = true;\n        path.push(grid[i][j]);\n        sum +=\
    \ grid[i][j];\n        dfs(i + 1, j, path, sum);\n        dfs(i - 1, j, path,\
    \ sum);\n        dfs(i, j + 1, path, sum);\n        dfs(i, j - 1, path, sum);\n\
    \        path.pop();\n        visited[i][j] = false;\n    }\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < m; j++){\n            dfs(i, j, [],\
    \ 0);\n        }\n    }\n    return minSumPath;\n}\n", "  // your code here\n\
    }\n", "\tlet minPath = [];\n\tlet minSum = Infinity;\n\tlet minPaths = [];\n\t\
    let minPathsSum = [];\n\tlet minPathsSumIndex = [];\n\tlet minPathsSumIndex2 =\
    \ [];\n\tlet minPathsSumIndex3 = [];\n\tlet minPathsSumIndex4 = [];\n\tlet minPathsSumIndex5\
    \ = [];\n\tlet minPathsSumIndex6 = [];\n\tlet minPathsSumIndex7 = [];\n\tlet minPathsSumIndex8\
    \ = [];\n\tlet minPathsSumIndex9 = [];\n\tlet minPathsSumIndex10 = [];\n\tlet\
    \ minPathsSumIndex11 = [];\n\tlet minPathsSumIndex12 = [];\n\tlet minPathsSumIndex13\
    \ = [];\n\tlet minPathsSumIndex14 = [];\n\tlet minPathsSumIndex15 = [];\n\tlet\
    \ minPathsSumIndex16 = [];\n\tlet minPathsSumIndex17 = [];\n\tlet minPathsSumIndex18\
    \ = [];\n\tlet minPathsSumIndex19 = [];\n\tlet minPathsSumIndex20 = [];\n\tlet\
    \ minPathsSumIndex21 = [];\n\tlet minPathsSumIndex22 = [];\n\tlet minPathsSumIndex23\
    \ = [];\n\tlet minPathsSumIndex24 = [];\n\tlet minPathsSumIndex25 = [];\n\tlet\
    \ minPathsSumIndex26 = [];\n\tlet minPathsSumIndex27 = [];\n\tlet minPathsSumIndex28\
    \ = [];\n\tlet minPathsSumIndex29 = [];\n\tlet minPathsSumIndex30 = [];\n\tlet\
    \ minPathsSumIndex31 = [];\n\tlet minPathsSumIndex32 = [];\n\tlet minPathsSumIndex33\
    \ = [];\n\tlet minPathsSumIndex34 = [];\n\tlet minPathsSumIndex35 = [];\n\tlet\
    \ minPathsSumIndex36 = [];\n\tlet minPathsSumIndex37 = [];\n\tlet minPathsSumIndex38\
    \ = [];\n\tlet minPathsSumIndex39 = [];\n\tlet minPathsSumIndex40 = [];\n\tlet\
    \ minPathsSumIndex41 = [];\n\tlet minPathsSumIndex42 = [];\n\tlet minPathsSumIndex43\
    \ = [];\n\tlet minPathsSumIndex", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let visited = new Array(n);\n    for(let i = 0; i < n; i++){\n        visited[i]\
    \ = new Array(m).fill(false);\n    }\n    let minPath = [];\n    let minSum =\
    \ Number.MAX_SAFE_INTEGER;\n    for(let i = 0; i < n; i++){\n        for(let j\
    \ = 0; j < m; j++){\n            let path = [];\n            let sum = 0;\n  \
    \          dfs(i, j, k, path, sum);\n        }\n    }\n    return minPath;\n\n\
    \    function dfs(i, j, k, path, sum){\n        if(i < 0 || i >= n || j < 0 ||\
    \ j >= m || visited[i][j] || path.length > k){\n            return;\n        }\n\
    \        path.push(grid[i][j]);\n        sum += grid[i][j];\n        if(path.length\
    \ === k){\n            if(sum < minSum){\n                minSum = sum;\n    \
    \            minPath = path.slice();\n            }else if(sum === minSum){\n\
    \                if(path.join('') < minPath.join('')){\n                    minPath\
    \ = path.slice();\n                }\n            }\n            path.pop();\n\
    \            return;\n        }\n        visited[i][j] = true;\n        dfs(i\
    \ - 1, j, k, path, sum);\n        dfs(i + 1, j, k, path, sum);\n        dfs(i,\
    \ j - 1, k, path, sum);\n        dfs(i, j + 1, k, path, sum);\n        visited[i][j]\
    \ = false;\n        path.pop();\n    }\n}\n", "\tvar n = grid.length;\n\tvar m\
    \ = grid[0].length;\n\tvar minPath = [];\n\tvar minPathSum = Infinity;\n\tvar\
    \ minPathSum2 = Infinity;\n\tvar minPath2 = [];\n\tvar minPathSum3 = Infinity;\n\
    \tvar minPath3 = [];\n\tvar minPathSum4 = Infinity;\n\tvar minPath4 = [];\n\t\
    var minPathSum5 = Infinity;\n\tvar minPath5 = [];\n\tvar minPathSum6 = Infinity;\n\
    \tvar minPath6 = [];\n\tvar minPathSum7 = Infinity;\n\tvar minPath7 = [];\n\t\
    var minPathSum8 = Infinity;\n\tvar minPath8 = [];\n\tvar minPathSum9 = Infinity;\n\
    \tvar minPath9 = [];\n\tvar minPathSum10 = Infinity;\n\tvar minPath10 = [];\n\t\
    var minPathSum11 = Infinity;\n\tvar minPath11 = [];\n\tvar minPathSum12 = Infinity;\n\
    \tvar minPath12 = [];\n\tvar minPathSum13 = Infinity;\n\tvar minPath13 = [];\n\
    \tvar minPathSum14 = Infinity;\n\tvar minPath14 = [];\n\tvar minPathSum15 = Infinity;\n\
    \tvar minPath15 = [];\n\tvar minPathSum16 = Infinity;\n\tvar minPath16 = [];\n\
    \tvar minPathSum17 = Infinity;\n\tvar minPath17 = [];\n\tvar minPathSum18 = Infinity;\n\
    \tvar minPath18 = [];\n\tvar minPathSum19 = Infinity;\n\tvar minPath19 = [];\n\
    \tvar minPathSum20 = Infinity;\n\tvar minPath20 = [];\n\tvar minPathSum21 = Infinity;\n\
    \tvar minPath21 = [];\n\tvar minPathSum22 = Infinity;\n\tvar minPath22 = [];\n\
    \tvar minPathSum23 = Infinity;\n\tvar minPath23 = [];\n\tvar minPathSum24 = Infinity;\n\
    \tvar minPath24 = [];\n\tvar minPathSum25 = Infinity;\n\tvar minPath25 = [];\n\
    \tvar minPathSum26 = Infinity;\n\tvar minPath26 = [];\n\tvar minPathSum27 = Infinity;\n\
    \tvar minPath27 = [];\n\tvar minPathSum28 =", "    var n = grid.length;\n    var\
    \ m = grid[0].length;\n    var min = [];\n    var min_sum = Infinity;\n    var\
    \ min_path = [];\n    var path = [];\n    var sum = 0;\n    var visited = [];\n\
    \    for(var i = 0; i < n; i++){\n        visited[i] = [];\n        for(var j\
    \ = 0; j < m; j++){\n            visited[i][j] = false;\n        }\n    }\n  \
    \  for(var i = 0; i < n; i++){\n        for(var j = 0; j < m; j++){\n        \
    \    dfs(i, j, k);\n        }\n    }\n    return min_path;\n    function dfs(i,\
    \ j, k){\n        if(k == 0){\n            if(sum < min_sum){\n              \
    \  min_sum = sum;\n                min_path = path.slice();\n            }\n \
    \           return;\n        }\n        if(i < 0 || i >= n || j < 0 || j >= m\
    \ || visited[i][j]){\n            return;\n        }\n        visited[i][j] =\
    \ true;\n        path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i\
    \ - 1, j, k - 1);\n        dfs(i + 1, j, k - 1);\n        dfs(i, j - 1, k - 1);\n\
    \        dfs(i, j + 1, k - 1);\n        path.pop();\n        sum -= grid[i][j];\n\
    \        visited[i][j] = false;\n    }\n}\n", "    var n = grid.length;\n    var\
    \ m = grid[0].length;\n    var minPath = [];\n    var minSum = Infinity;\n   \
    \ var minPathSum = Infinity;\n    var minPathSum = Infinity;\n    var minPath\
    \ = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum\
    \ = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n    var\
    \ minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n    var\
    \ minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var min", "    // your code here\n}\n", "    // your code here\n}\n", " \
    \   let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n    let minPathSum9\
    \ = Infinity;\n    let minPathSum10 = Infinity;\n    let minPathSum11 = Infinity;\n\
    \    let minPathSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let minPathSum14\
    \ = Infinity;\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPathSum17 = Infinity;\n    let minPathSum18 = Infinity;\n    let minPathSum19\
    \ = Infinity;\n    let minPathSum20 = Infinity;\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPathSum25 = Infinity;\n    let minPathSum26 = Infinity;\n\
    \    let minPathSum27 = Infinity;\n    let minPathSum28 = Infinity;\n    let minPathSum29\
    \ = Infinity;\n    let minPathSum30 = Infinity;\n    let minPathSum31 = Infinity;\n\
    \    let minPathSum32 = Infinity;\n    let minPathSum33 = Infinity;\n    let minPathSum34\
    \ = Infinity;\n    let minPathSum35 = Infinity;\n    let minPathSum36 = Infinity;\n\
    \    let minPathSum37 = Infinity;\n    let minPathSum38 = Infinity;\n    let minPathSum39\
    \ = Infinity;\n    let minPathSum40 = Infinity;\n    let minPathSum41 = Infinity;\n\
    \    let minPathSum42 = Infinity;\n    let minPathSum43 = Infinity;\n    let minPathSum44\
    \ = Infinity;\n    let minPathSum45 = Infinity;\n    let minPathSum46 = Infinity;\n\
    \    let minPathSum47 = Infinity;\n    let minPathSum48 = Infinity;\n    let minPathSum49\
    \ = Infinity;\n    let minPathSum50 =", "    let n = grid.length;\n    let m =\
    \ grid[0].length;\n    let visited = new Array(n);\n    for(let i = 0; i < n;\
    \ i++){\n        visited[i] = new Array(m).fill(false);\n    }\n    let minPath\
    \ = [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n\
    \            let path = [];\n            dfs(grid, i, j, visited, path, k);\n\
    \            if(path.length == k){\n                if(minPath.length == 0){\n\
    \                    minPath = path;\n                }else{\n               \
    \     for(let i = 0; i < k; i++){\n                        if(path[i] < minPath[i]){\n\
    \                            minPath = path;\n                            break;\n\
    \                        }else if(path[i] > minPath[i]){\n                   \
    \         break;\n                        }\n                    }\n         \
    \       }\n            }\n        }\n    }\n    return minPath;\n}", "    // your\
    \ code here\n}\n", "    // your code here\n    var minPath = [];\n    var minSum\
    \ = Infinity;\n    var minPathSum = Infinity;\n    var minPath = [];\n    var\
    \ minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n   ", "  let n = grid.length;\n\
    \  let min = [];\n  let minVal = Infinity;\n  for(let i = 0; i < n; i++){\n  \
    \  for(let j = 0; j < n; j++){\n      let path = [];\n      let val = 0;\n   \
    \   let visited = new Set();\n      visited.add(i * n + j);\n      path.push(grid[i][j]);\n\
    \      val += grid[i][j];\n      let res = minPathHelper(grid, i, j, k - 1, path,\
    \ val, visited);\n      if(res[1] < minVal){\n        minVal = res[1];\n     \
    \   min = res[0];\n      }\n    }\n  }\n  return min;\n}\n", "  let n = grid.length;\n\
    \  let minPath = [];\n  let minSum = Infinity;\n  let minPathSum = Infinity;\n\
    \  let minPathSum2 = Infinity;\n  let minPathSum3 = Infinity;\n  let minPathSum4\
    \ = Infinity;\n  let minPathSum5 = Infinity;\n  let minPathSum6 = Infinity;\n\
    \  let minPathSum7 = Infinity;\n  let minPathSum8 = Infinity;\n  let minPathSum9\
    \ = Infinity;\n  let minPathSum10 = Infinity;\n  let minPathSum11 = Infinity;\n\
    \  let minPathSum12 = Infinity;\n  let minPathSum13 = Infinity;\n  let minPathSum14\
    \ = Infinity;\n  let minPathSum15 = Infinity;\n  let minPathSum16 = Infinity;\n\
    \  let minPathSum17 = Infinity;\n  let minPathSum18 = Infinity;\n  let minPathSum19\
    \ = Infinity;\n  let minPathSum20 = Infinity;\n  let minPathSum21 = Infinity;\n\
    \  let minPathSum22 = Infinity;\n  let minPathSum23 = Infinity;\n  let minPathSum24\
    \ = Infinity;\n  let minPathSum25 = Infinity;\n  let minPathSum26 = Infinity;\n\
    \  let minPathSum27 = Infinity;\n  let minPathSum28 = Infinity;\n  let minPathSum29\
    \ = Infinity;\n  let minPathSum30 = Infinity;\n  let minPathSum31 = Infinity;\n\
    \  let minPathSum32 = Infinity;\n  let minPathSum33 = Infinity;\n  let minPathSum34\
    \ = Infinity;\n  let minPathSum35 = Infinity;\n  let minPathSum36 = Infinity;\n\
    \  let minPathSum37 = Infinity;\n  let minPathSum38 = Infinity;\n  let minPathSum39\
    \ = Infinity;\n  let minPathSum40 = Infinity;\n  let minPathSum41 = Infinity;\n\
    \  let minPathSum42 = Infinity;\n  let minPathSum43 = Infinity;\n  let minPathSum44\
    \ = Infinity;\n  let minPathSum45 = Infinity;\n  let minPathSum46 = Infinity;\n\
    \  let minPathSum47 = Infinity;\n  let minPathSum48 = Infinity;\n  let minPathSum49\
    \ = Infinity", "    // your code here\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n   \
    \ for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n         \
    \   let path = [];\n            let sum = 0;\n            let visited = new Set();\n\
    \            dfs(i, j, 0);\n        }\n    }\n    return minPath;\n    function\
    \ dfs(i, j, len){\n        if(len > k) return;\n        if(len == k){\n      \
    \      if(sum < minSum){\n                minSum = sum;\n                minPath\
    \ = path.slice();\n            }\n            return;\n        }\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m) return;\n        if(visited.has(i * m + j))\
    \ return;\n        visited.add(i * m + j);\n        path.push(grid[i][j]);\n \
    \       sum += grid[i][j];\n        dfs(i - 1, j, len + 1);\n        dfs(i + 1,\
    \ j, len + 1);\n        dfs(i, j - 1, len + 1);\n        dfs(i, j + 1, len + 1);\n\
    \        path.pop();\n        sum -= grid[i][j];\n        visited.delete(i * m\
    \ + j);\n    }\n}\n", "    let n = grid.length;\n    let minPath = [];\n    let\
    \ minSum = Infinity;\n    let minPaths = [];\n    let minPathsSum = [];\n    let\
    \ visited = [];\n    for(let i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(let j = 0; j < n; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    function dfs(i, j, path, sum){\n        if(i < 0 || i >=\
    \ n || j < 0 || j >= n || visited[i][j]){\n            return;\n        }\n  \
    \      path.push(grid[i][j]);\n        sum += grid[i][j];\n        visited[i][j]\
    \ = true;\n        if(path.length === k){\n            if(sum < minSum){\n   \
    \             minSum = sum;\n                minPath = path.slice();\n       \
    \     }\n            else if(sum === minSum){\n                minPaths.push(path.slice());\n\
    \                minPathsSum.push(sum);\n            }\n        }\n        else{\n\
    \            dfs(i - 1, j, path, sum);\n            dfs(i + 1, j, path, sum);\n\
    \            dfs(i, j - 1, path, sum);\n            dfs(i, j + 1, path, sum);\n\
    \        }\n        path.pop();\n        sum -= grid[i][j];\n        visited[i][j]\
    \ = false;\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ n; j++){\n            dfs(i, j, [], 0);\n        }\n    }\n    if(minPaths.length\
    \ === 0){\n        return minPath;\n    }\n    for(let i = 0; i < minPaths.length;\
    \ i++){\n        for(let j = 0; j < minPaths[i].length; j++){\n            if(minPaths[i][j]\
    \ < minPath[j]){\n                return minPaths[i];\n            }\n       \
    \     else if(minPaths[", "    // your code here\n}\n", "    // Write your code\
    \ here\n    let n = grid.length;\n    let m = grid[0].length;\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    let visited = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(false));\n    let dfs = function(i, j, sum, path) {\n \
    \       if (sum > minSum) {\n            return;\n        }\n        if (path.length\
    \ === k) {\n            if (sum < minSum) {\n                minSum = sum;\n \
    \               minPath = path;\n            }\n            return;\n        }\n\
    \        if (i < 0 || i >= n || j < 0 || j >= m || visited[i][j]) {\n        \
    \    return;\n        }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n\
    \        dfs(i - 1, j, sum + grid[i][j], path);\n        dfs(i + 1, j, sum + grid[i][j],\
    \ path);\n        dfs(i, j - 1, sum + grid[i][j], path);\n        dfs(i, j + 1,\
    \ sum + grid[i][j], path);\n        path.pop();\n        visited[i][j] = false;\n\
    \    }\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < m; j++)\
    \ {\n            dfs(i, j, 0, []);\n        }\n    }\n    return minPath;\n}\n",
  "    // your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = Infinity;\n    let minPath = [];\n    let visited = new Set();\n\
    \    let queue = [];\n    let path = [];\n    let start = grid[0][0];\n    let\
    \ end = grid[n-1][m-1];\n    let pathSum = 0;\n    let pathLength = 0;\n    let\
    \ pathString = \"\";\n    let pathArray = [];\n    let pathObject = {};\n    let\
    \ pathObjectArray = [];\n    let pathObjectArraySorted = [];\n    let pathObjectArraySortedString\
    \ = \"\";\n    let pathObjectArraySortedStringArray = [];\n    let pathObjectArraySortedStringArraySorted\
    \ = [];\n    let pathObjectArraySortedStringArraySortedString = \"\";\n    let\
    \ pathObjectArraySortedStringArraySortedStringArray = [];\n    let pathObjectArraySortedStringArraySortedStringArraySorted\
    \ = [];\n    let pathObjectArraySortedStringArraySortedStringArraySortedString\
    \ = \"\";\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArray\
    \ = [];\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArraySorted\
    \ = [];\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArraySortedString\
    \ = \"\";\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArraySortedStringArray\
    \ = [];\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArraySortedStringArraySorted\
    \ = [];\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArraySortedStringArraySortedString\
    \ = \"\";\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArraySortedStringArraySortedStringArray\
    \ = [];\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArraySortedStringArraySortedStringArraySorted\
    \ = [];\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArraySortedStringArraySortedStringArraySortedString\
    \ = \"\";\n    let pathObjectArraySortedStringArraySortedStringArraySortedStringArraySortedStringArraySortedStringArraySortedStringArray\
    \ = [];\n", "\tvar minPath = [];\n\tvar minPathSum = Infinity;\n\tvar minPathSumIndex\
    \ = 0;\n\tvar minPathSumIndex2 = 0;\n\tvar minPathSumIndex3 = 0;\n\tvar minPathSumIndex4\
    \ = 0;\n\tvar minPathSumIndex5 = 0;\n\tvar minPathSumIndex6 = 0;\n\tvar minPathSumIndex7\
    \ = 0;\n\tvar minPathSumIndex8 = 0;\n\tvar minPathSumIndex9 = 0;\n\tvar minPathSumIndex10\
    \ = 0;\n\tvar minPathSumIndex11 = 0;\n\tvar minPathSumIndex12 = 0;\n\tvar minPathSumIndex13\
    \ = 0;\n\tvar minPathSumIndex14 = 0;\n\tvar minPathSumIndex15 = 0;\n\tvar minPathSumIndex16\
    \ = 0;\n\tvar minPathSumIndex17 = 0;\n\tvar minPathSumIndex18 = 0;\n\tvar minPathSumIndex19\
    \ = 0;\n\tvar minPathSumIndex20 = 0;\n\tvar minPathSumIndex21 = 0;\n\tvar minPathSumIndex22\
    \ = 0;\n\tvar minPathSumIndex23 = 0;\n\tvar minPathSumIndex24 = 0;\n\tvar minPathSumIndex25\
    \ = 0;\n\tvar minPathSumIndex26 = 0;\n\tvar minPathSumIndex27 = 0;\n\tvar minPathSumIndex28\
    \ = 0;\n\tvar minPathSumIndex29 = 0;\n\tvar minPathSumIndex30 = 0;\n\tvar minPathSumIndex31\
    \ = 0;\n\tvar minPathSumIndex32 = 0;\n\tvar minPathSumIndex33 = 0;\n\tvar minPathSumIndex34\
    \ = 0;\n\tvar minPathSumIndex35 = 0;\n\tvar minPathSumIndex36 = 0;\n\tvar minPathSumIndex37\
    \ = 0;\n\tvar minPathSumIndex38 = 0;\n\tvar minPathSumIndex39 = 0;\n\tvar minPathSumIndex40\
    \ = 0;\n\tvar minPathSumIndex41 = 0;\n\tvar minPathSumIndex42 = 0;\n\tvar minPathSumIndex43\
    \ = 0;\n\tvar minPathSumIndex44 = 0;\n\tvar minPathSumIndex45 = 0;\n\t", "   \
    \ // your code here\n}\n", "    // your code here\n}\n", "  // your code here\n\
    }\n", "    var n = grid.length;\n    var m = grid[0].length;\n    var minPath\
    \ = [];\n    var minPathSum = Infinity;\n    var pathSum = 0;\n    var path =\
    \ [];\n    var visited = [];\n    for(var i = 0; i < n; i++){\n        visited[i]\
    \ = [];\n        for(var j = 0; j < m; j++){\n            visited[i][j] = false;\n\
    \        }\n    }\n    var dfs = function(i, j, pathSum, path){\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n \
    \       }\n        visited[i][j] = true;\n        path.push(grid[i][j]);\n   \
    \     pathSum += grid[i][j];\n        if(path.length === k){\n            if(pathSum\
    \ < minPathSum){\n                minPathSum = pathSum;\n                minPath\
    \ = path.slice();\n            }\n            else if(pathSum === minPathSum){\n\
    \                if(path.slice().sort() < minPath.slice().sort()){\n         \
    \           minPath = path.slice();\n                }\n            }\n      \
    \  }\n        else{\n            dfs(i, j - 1, pathSum, path);\n            dfs(i,\
    \ j + 1, pathSum, path);\n            dfs(i - 1, j, pathSum, path);\n        \
    \    dfs(i + 1, j, pathSum, path);\n        }\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n    for(var i = 0; i < n; i++){\n        for(var j = 0; j <\
    \ m; j++){\n            dfs(i, j, 0, []);\n        }\n    }\n    return minPath;\n\
    }\n", "    //YOUR CODE HERE\n}\n", "    // your code here\n}\n", "    // your\
    \ code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n  \
    \  let dp = new Array(n);\n    for(let i = 0; i < n; i++){\n        dp[i] = new\
    \ Array(m);\n        for(let j = 0; j < m; j++){\n            dp[i][j] = new Array(k+1);\n\
    \            for(let l = 0; l <= k; l++){\n                dp[i][j][l] = new Array(2);\n\
    \                dp[i][j][l][0] = new Array(k+1);\n                dp[i][j][l][1]\
    \ = new Array(k+1);\n            }\n        }\n    }\n    for(let i = 0; i < n;\
    \ i++){\n        for(let j = 0; j < m; j++){\n            for(let l = 0; l <=\
    \ k; l++){\n                for(let p = 0; p <= l; p++){\n                   \
    \ dp[i][j][l][0][p] = Number.MAX_SAFE_INTEGER;\n                    dp[i][j][l][1][p]\
    \ = Number.MAX_SAFE_INTEGER;\n                }\n            }\n        }\n  \
    \  }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n \
    \           dp[i][j][1][0][0] = grid[i][j];\n            dp[i][j][1][1][0] = grid[i][j];\n\
    \        }\n    }\n    for(let l = 2; l <= k; l++){\n        for(let i = 0; i\
    \ < n; i++){\n            for(let j = 0; j < m; j++){\n                for(let\
    \ p = 0; p < l; p++){\n                    if(i > 0){\n                      \
    \  if(dp[i-1][j][l-1][0][p] < dp[i][j][l][0][p]){\n                          \
    \  dp[i][j][l][0][p]", "    var n = grid.length;\n    var m = grid[0].length;\n\
    \    var min = [];\n    var min_sum = Infinity;\n    var min_path = [];\n    var\
    \ visited = [];\n    for(var i = 0; i < n; i++){\n        visited.push([]);\n\
    \        for(var j = 0; j < m; j++){\n            visited[i].push(false);\n  \
    \      }\n    }\n    for(var i = 0; i < n; i++){\n        for(var j = 0; j < m;\
    \ j++){\n            var path = [];\n            var sum = 0;\n            for(var\
    \ i = 0; i < n; i++){\n                visited.push([]);\n                for(var\
    \ j = 0; j < m; j++){\n                    visited[i].push(false);\n         \
    \       }\n            }\n            dfs(grid, i, j, k, path, sum, visited);\n\
    \            if(sum < min_sum){\n                min_sum = sum;\n            \
    \    min_path = path;\n            }\n        }\n    }\n    return min_path;\n\
    }\n", "    let N = grid.length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSumGrid = [];\n    for(let i = 0; i < N; i++){\n        minPathSumGrid.push(new\
    \ Array(N).fill(Infinity));\n    }\n    for(let i = 0; i < N; i++){\n        for(let\
    \ j = 0; j < N; j++){\n            if(i === 0 && j === 0){\n                minPathSumGrid[i][j]\
    \ = grid[i][j];\n            }\n            else if(i === 0){\n              \
    \  minPathSumGrid[i][j] = minPathSumGrid[i][j - 1] + grid[i][j];\n           \
    \ }\n            else if(j === 0){\n                minPathSumGrid[i][j] = minPathSumGrid[i\
    \ - 1][j] + grid[i][j];\n            }\n            else{\n                minPathSumGrid[i][j]\
    \ = Math.min(minPathSumGrid[i - 1][j], minPathSumGrid[i][j - 1]) + grid[i][j];\n\
    \            }\n        }\n    }\n    for(let i = 0; i < N; i++){\n        for(let\
    \ j = 0; j < N; j++){\n            if(minPathSumGrid[i][j] < minPathSum){\n  \
    \              minPathSum = minPathSumGrid[i][j];\n            }\n        }\n\
    \    }\n    let i = 0;\n    let j = 0;\n    while(k > 0){\n        if(i === 0\
    \ && j === 0){\n            minPath.push(grid[i][j]);\n            k--;\n    \
    \        i++;\n        }\n        else if(i === 0){\n            if(minPathSumGrid[i][j\
    \ - 1] < minPathSumGrid[i + 1][j]){\n                minPath.push(grid[i][j]);\n\
    \                k--;\n                j--;\n            }\n            else{\n\
    \                minPath.push(grid[i][j]);\n                k--;\n           \
    \     i++;\n            }\n        }\n        else if(", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let visited = new Array(n);\n    for(let i =\
    \ 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n   \
    \ let minPath = [];\n    let minSum = Number.MAX_SAFE_INTEGER;\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            let sum = 0;\n            dfs(grid, i, j, k, path, sum, visited);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    let n = grid.length;\n    let m = grid[0].length;\n    let min = [];\n    let\
    \ minSum = Infinity;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPaths = [];\n    let minPathsSum = Infinity;\n    let minPathsPath\
    \ = [];\n    let minPathsPathSum = Infinity;\n    let minPathsPaths = [];\n  \
    \  let minPathsPathsSum = Infinity;\n    let minPathsPathsPath = [];\n    let\
    \ minPathsPathsPathSum = Infinity;\n    let minPathsPathsPaths = [];\n    let\
    \ minPathsPathsPathsSum = Infinity;\n    let minPathsPathsPathsPath = [];\n  \
    \  let minPathsPathsPathsPathSum = Infinity;\n    let minPathsPathsPathsPaths\
    \ = [];\n    let minPathsPathsPathsPathsSum = Infinity;\n    let minPathsPathsPathsPathsPath\
    \ = [];\n    let minPathsPathsPathsPathsPathSum = Infinity;\n    let minPathsPathsPathsPathsPaths\
    \ = [];\n    let minPathsPathsPathsPathsPathsSum = Infinity;\n    let minPathsPathsPathsPathsPathsPath\
    \ = [];\n    let minPathsPathsPathsPathsPathsPathSum = Infinity;\n    let minPathsPathsPathsPathsPathsPaths\
    \ = [];\n    let minPathsPathsPathsPathsPathsPathsSum = Infinity;\n    let minPathsPathsPathsPathsPathsPathsPath\
    \ = [];\n    let minPathsPathsPathsPathsPathsPathsPathSum = Infinity;\n    let\
    \ minPathsPathsPathsPathsPathsPathsPaths = [];\n    let minPathsPathsPathsPathsPathsPathsPathsSum\
    \ = Infinity;\n    let minPathsPathsPathsPathsPathsPathsPathsPath = [];\n    let\
    \ minPathsPathsPathsPathsPathsPathsPathsPathSum = Infinity;\n    let minPathsPathsPathsPathsPathsPathsPathsPaths\
    \ = [];\n    let minPaths", "    var min = [];\n    var min_sum = 0;\n    var\
    \ min_path = [];\n    var min_path_sum = 0;\n    var min_path_sum_index = 0;\n\
    \    var min_path_sum_index_value = 0;\n    var min_path_sum_index_value_index\
    \ = 0;\n    var min_path_sum_index_value_index_value = 0;\n    var min_path_sum_index_value_index_value_index\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value = 0;\n    var\
    \ min_path_sum_index_value_index_value_index_value_index = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value_index\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value_index_value\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value_index_value_index\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value_index_value_index_value\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value_index_value_index_value_index\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value_index_value_index_value_index_value\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value_index_value_index_value_index_value_index_value\
    \ = 0;\n    var min_path_sum_index_value_index_value_index_value_index_value_index_value_index",
  "    let n = grid.length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSumGrid = [];\n    for(let i = 0; i < n; i++){\n        minPathSumGrid.push([]);\n\
    \        for(let j = 0; j < n; j++){\n            minPathSumGrid[i].push(Infinity);\n\
    \        }\n    }\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j <\
    \ n; j++){\n            if(k === 1){\n                minPathSumGrid[i][j] = grid[i][j];\n\
    \            }\n            else{\n                let minSum = Infinity;\n  \
    \              if(i > 0){\n                    minSum = Math.min(minSum, minPathSumGrid[i\
    \ - 1][j]);\n                }\n                if(j > 0){\n                 \
    \   minSum = Math.min(minSum, minPathSumGrid[i][j - 1]);\n                }\n\
    \                if(i < n - 1){\n                    minSum = Math.min(minSum,\
    \ minPathSumGrid[i + 1][j]);\n                }\n                if(j < n - 1){\n\
    \                    minSum = Math.min(minSum, minPathSumGrid[i][j + 1]);\n  \
    \              }\n                minPathSumGrid[i][j] = minSum + grid[i][j];\n\
    \            }\n            if(minPathSumGrid[i][j] < minPathSum){\n         \
    \       minPathSum = minPathSumGrid[i][j];\n                minPath = [grid[i][j]];\n\
    \            }\n            else if(minPathSumGrid[i][j] === minPathSum){\n  \
    \              minPath.push(grid[i][j]);\n            }\n        }\n    }\n  \
    \  return minPath;\n}\n", "    // your code here\n}\n", "    let N = grid.length;\n\
    \    let minPath = [];\n    let minPathSum = Infinity;\n    let minPathSum2 =\
    \ Infinity;\n    let minPath2 = [];\n    let minPath3 = [];\n    let minPathSum3\
    \ = Infinity;\n    let minPathSum4 = Infinity;\n    let minPath4 = [];\n    let\
    \ minPath5 = [];\n    let minPathSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minPath7 = [];\n    let minPathSum7 = Infinity;\n\
    \    let minPathSum8 = Infinity;\n    let minPath8 = [];\n    let minPath9 = [];\n\
    \    let minPathSum9 = Infinity;\n    let minPathSum10 = Infinity;\n    let minPath10\
    \ = [];\n    let minPath11 = [];\n    let minPathSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minPath13 = [];\n    let minPathSum13\
    \ = Infinity;\n    let minPathSum14 = Infinity;\n    let minPath14 = [];\n   \
    \ let minPath15 = [];\n    let minPathSum15 = Infinity;\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minPath17 = [];\n    let minPathSum17\
    \ = Infinity;\n    let minPathSum18 = Infinity;\n    let minPath18 = [];\n   \
    \ let minPath19 = [];\n    let minPathSum19 = Infinity;\n    let minPathSum20\
    \ = Infinity;\n    let minPath20 = [];\n    let minPath21 = [];\n    let minPathSum21\
    \ = Infinity;\n    let minPathSum22 = Infinity;\n    let minPath22 = [];\n   \
    \ let minPath23 = [];\n    let minPathSum23 = Infinity;\n    let minPathSum24\
    \ = Infinity;\n    let minPath24 = [];\n    let minPath25 = [];\n    let minPathSum25\
    \ = Infinity;\n    let minPathSum26 = Infinity;\n    let minPath26 = [];\n   \
    \ let minPath27 = [];\n    let minPathSum27 = Infinity;\n    let minPathSum28\
    \ = Infinity;\n    let minPath28 = [];\n", "    //YOUR CODE HERE\n}\n", "    let\
    \ n = grid.length;\n    let m = grid[0].length;\n    let dp = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(Infinity));\n    let path = new Array(n).fill(0).map(()\
    \ => new Array(m).fill(0));\n    let min = Infinity;\n    let min_path = [];\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      if(i === 0 && j === 0){\n                dp[i][j] = grid[i][j];\n     \
    \           path[i][j] = grid[i][j];\n            }\n            else if(i ===\
    \ 0){\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n               \
    \ path[i][j] = path[i][j - 1] * 10 + grid[i][j];\n            }\n            else\
    \ if(j === 0){\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n      \
    \          path[i][j] = path[i - 1][j] * 10 + grid[i][j];\n            }\n   \
    \         else{\n                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1])\
    \ + grid[i][j];\n                if(dp[i - 1][j] < dp[i][j - 1]){\n          \
    \          path[i][j] = path[i - 1][j] * 10 + grid[i][j];\n                }\n\
    \                else{\n                    path[i][j] = path[i][j - 1] * 10 +\
    \ grid[i][j];\n                }\n            }\n            if(i === n - 1 &&\
    \ j === m - 1 && dp[i][j] <= min){\n                if(dp[i][j] < min){\n    \
    \                min = dp[i][j];\n                    min_path = [];\n       \
    \         }\n                min_path.push(path[i][j]);\n            }\n     \
    \   }\n    }\n   ", "    // your code here\n}\n", "    // your code here\n}\n",
  "    // your code here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let min = Infinity;\n    let minPath = [];\n    let visited = [];\n    for(let\
    \ i = 0; i < n; i++){\n        visited.push([]);\n        for(let j = 0; j < m;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    for(let i\
    \ = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            let curr = grid[i][j];\n            path.push(curr);\n  \
    \          visited[i][j] = true;\n            dfs(i, j, k - 1, path, grid, visited);\n\
    \            visited[i][j] = false;\n        }\n    }\n    return minPath;\n \
    \   function dfs(i, j, k, path, grid, visited){\n        if(k === 0){\n      \
    \      let curr = path.join('');\n            if(curr < min){\n              \
    \  min = curr;\n                minPath = path.slice();\n            }\n     \
    \       return;\n        }\n        if(i > 0 && !visited[i - 1][j]){\n       \
    \     visited[i - 1][j] = true;\n            path.push(grid[i - 1][j]);\n    \
    \        dfs(i - 1, j, k - 1, path, grid, visited);\n            path.pop();\n\
    \            visited[i - 1][j] = false;\n        }\n        if(i < n - 1 && !visited[i\
    \ + 1][j]){\n            visited[i + 1][j] = true;\n            path.push(grid[i\
    \ + 1][j]);\n            dfs(i + 1, j, k - 1, path, grid, visited);\n        \
    \    path.pop();\n            visited[i + 1][j] = false;\n        }\n        if(j\
    \ > 0 && !visited[i][j - 1]){\n            visited[i][j - 1] = true;\n       \
    \     path.push(grid[i][j - 1]);\n            dfs(", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n      \
    \      let path = [];\n            let sum = 0;\n            let visited = new\
    \ Set();\n            dfs(i, j, k, path, sum, visited);\n        }\n    }\n  \
    \  return minPath;\n    function dfs(i, j, k, path, sum, visited){\n        if(i\
    \ < 0 || i >= n || j < 0 || j >= m || visited.has(i + ',' + j)){\n           \
    \ return;\n        }\n        if(path.length === k){\n            if(sum < minSum){\n\
    \                minSum = sum;\n                minPath = path.slice();\n    \
    \        }\n            return;\n        }\n        visited.add(i + ',' + j);\n\
    \        path.push(grid[i][j]);\n        sum += grid[i][j];\n        dfs(i - 1,\
    \ j, k, path, sum, visited);\n        dfs(i + 1, j, k, path, sum, visited);\n\
    \        dfs(i, j - 1, k, path, sum, visited);\n        dfs(i, j + 1, k, path,\
    \ sum, visited);\n        path.pop();\n        sum -= grid[i][j];\n        visited.delete(i\
    \ + ',' + j);\n    }\n}\n", "    var result = [];\n    var min = Infinity;\n \
    \   var minPath = [];\n    var path = [];\n    var visited = [];\n    for(var\
    \ i = 0; i < grid.length; i++){\n        visited.push([]);\n        for(var j\
    \ = 0; j < grid[0].length; j++){\n            visited[i].push(false);\n      \
    \  }\n    }\n    for(var i = 0; i < grid.length; i++){\n        for(var j = 0;\
    \ j < grid[0].length; j++){\n            dfs(grid, i, j, k, path, visited);\n\
    \        }\n    }\n    return minPath;\n}\n", "    // your code here\n}\n", " \
    \   let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    for(let i = 0;\
    \ i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path = [];\n\
    \            let sum = 0;\n            dfs(grid, i, j, k, path, sum, visited);\n\
    \            if(sum < minSum){\n                minSum = sum;\n              \
    \  minPath = path;\n            }\n        }\n    }\n    return minPath;\n}\n",
  "    // your code here\n}\n", "    // your code here\n}\n", "    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPathSumIndex = 0;\n    var minPathSumIndex2\
    \ = 0;\n    var minPathSumIndex3 = 0;\n    var minPathSumIndex4 = 0;\n    var\
    \ minPathSumIndex5 = 0;\n    var minPathSumIndex6 = 0;\n    var minPathSumIndex7\
    \ = 0;\n    var minPathSumIndex8 = 0;\n    var minPathSumIndex9 = 0;\n    var\
    \ minPathSumIndex10 = 0;\n    var minPathSumIndex11 = 0;\n    var minPathSumIndex12\
    \ = 0;\n    var minPathSumIndex13 = 0;\n    var minPathSumIndex14 = 0;\n    var\
    \ minPathSumIndex15 = 0;\n    var minPathSumIndex16 = 0;\n    var minPathSumIndex17\
    \ = 0;\n    var minPathSumIndex18 = 0;\n    var minPathSumIndex19 = 0;\n    var\
    \ minPathSumIndex20 = 0;\n    var minPathSumIndex21 = 0;\n    var minPathSumIndex22\
    \ = 0;\n    var minPathSumIndex23 = 0;\n    var minPathSumIndex24 = 0;\n    var\
    \ minPathSumIndex25 = 0;\n    var minPathSumIndex26 = 0;\n    var minPathSumIndex27\
    \ = 0;\n    var minPathSumIndex28 = 0;\n    var minPathSumIndex29 = 0;\n    var\
    \ minPathSumIndex30 = 0;\n    var minPathSumIndex31 = 0;\n    var minPathSumIndex32\
    \ = 0;\n    var minPathSumIndex33 = 0;\n    var minPathSumIndex34 = 0;\n    var\
    \ minPathSumIndex35 = 0;\n    var minPathSumIndex36 = 0;\n    var minPathSumIndex37\
    \ = 0;\n    var minPathSumIndex38 = 0;\n    var minPathSumIndex39 = 0;\n    var\
    \ minPathSumIndex40 = 0;\n    var minPathSumIndex41 = 0;\n    var minPathSumIndex42\
    \ = 0;\n    var minPathSumIndex43 = 0;\n    var minPathSumIndex44 = 0;\n    var\
    \ minPathSumIndex45 = 0;\n   ", "    let N = grid.length;\n    let minPath = [];\n\
    \    let minSum = Infinity;\n    for(let i = 0; i < N; i++){\n        for(let\
    \ j = 0; j < N; j++){\n            let path = [];\n            let sum = 0;\n\
    \            let visited = new Set();\n            let queue = [[i, j]];\n   \
    \         while(queue.length > 0){\n                let [x, y] = queue.shift();\n\
    \                if(visited.has(x + ',' + y)) continue;\n                visited.add(x\
    \ + ',' + y);\n                path.push(grid[x][y]);\n                sum +=\
    \ grid[x][y];\n                if(path.length === k){\n                    if(sum\
    \ < minSum){\n                        minSum = sum;\n                        minPath\
    \ = path;\n                    }\n                    break;\n               \
    \ }\n                if(x > 0) queue.push([x - 1, y]);\n                if(x <\
    \ N - 1) queue.push([x + 1, y]);\n                if(y > 0) queue.push([x, y -\
    \ 1]);\n                if(y < N - 1) queue.push([x, y + 1]);\n            }\n\
    \        }\n    }\n    return minPath;\n}\n", "    let n = grid.length;\n    let\
    \ m = grid[0].length;\n    let visited = new Array(n);\n    for(let i = 0; i <\
    \ n; i++){\n        visited[i] = new Array(m).fill(false);\n    }\n    let minPath\
    \ = [];\n    let minSum = Infinity;\n    for(let i = 0; i < n; i++){\n       \
    \ for(let j = 0; j < m; j++){\n            let path = [];\n            let sum\
    \ = 0;\n            dfs(grid, visited, i, j, k, path, sum);\n            if(sum\
    \ < minSum){\n                minSum = sum;\n                minPath = path;\n\
    \            }\n        }\n    }\n    return minPath;\n}\n", "  // your code here\n\
    }\n", "    // your code here\n}\n", "    //YOUR CODE HERE\n}\n", "    var n =\
    \ grid.length;\n    var m = grid[0].length;\n    var minPath = [];\n    var minSum\
    \ = Infinity;\n    var minPathSum = Infinity;\n    var minPathSum2 = Infinity;\n\
    \    var minPathSum3 = Infinity;\n    var minPathSum4 = Infinity;\n    var minPathSum5\
    \ = Infinity;\n    var minPathSum6 = Infinity;\n    var minPathSum7 = Infinity;\n\
    \    var minPathSum8 = Infinity;\n    var minPathSum9 = Infinity;\n    var minPathSum10\
    \ = Infinity;\n    var minPathSum11 = Infinity;\n    var minPathSum12 = Infinity;\n\
    \    var minPathSum13 = Infinity;\n    var minPathSum14 = Infinity;\n    var minPathSum15\
    \ = Infinity;\n    var minPathSum16 = Infinity;\n    var minPathSum17 = Infinity;\n\
    \    var minPathSum18 = Infinity;\n    var minPathSum19 = Infinity;\n    var minPathSum20\
    \ = Infinity;\n    var minPathSum21 = Infinity;\n    var minPathSum22 = Infinity;\n\
    \    var minPathSum23 = Infinity;\n    var minPathSum24 = Infinity;\n    var minPathSum25\
    \ = Infinity;\n    var minPathSum26 = Infinity;\n    var minPathSum27 = Infinity;\n\
    \    var minPathSum28 = Infinity;\n    var minPathSum29 = Infinity;\n    var minPathSum30\
    \ = Infinity;\n    var minPathSum31 = Infinity;\n    var minPathSum32 = Infinity;\n\
    \    var minPathSum33 = Infinity;\n    var minPathSum34 = Infinity;\n    var minPathSum35\
    \ = Infinity;\n    var minPathSum36 = Infinity;\n    var minPathSum37 = Infinity;\n\
    \    var minPathSum38 = Infinity;\n    var minPathSum39 = Infinity;\n    var minPathSum40\
    \ = Infinity;\n    var minPathSum41 = Infinity;\n    var minPathSum42 = Infinity;\n\
    \    var minPathSum43 = Infinity;\n    var minPathSum44 = Infinity;\n    var minPathSum45\
    \ = Infinity;\n    var minPathSum46 = Infinity;\n    var minPathSum47 = Infinity;\n\
    \    var minPathSum48 =", "    let n = grid.length;\n    let m = grid[0].length;\n\
    \    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum = Infinity;\n\
    \    let minPathSum2 = Infinity;\n    let minPath2 = [];\n    let minSum2 = Infinity;\n\
    \    let minPathSum3 = Infinity;\n    let minPath3 = [];\n    let minSum3 = Infinity;\n\
    \    let minPathSum4 = Infinity;\n    let minPath4 = [];\n    let minSum4 = Infinity;\n\
    \    let minPathSum5 = Infinity;\n    let minPath5 = [];\n    let minSum5 = Infinity;\n\
    \    let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let minSum6 = Infinity;\n\
    \    let minPathSum7 = Infinity;\n    let minPath7 = [];\n    let minSum7 = Infinity;\n\
    \    let minPathSum8 = Infinity;\n    let minPath8 = [];\n    let minSum8 = Infinity;\n\
    \    let minPathSum9 = Infinity;\n    let minPath9 = [];\n    let minSum9 = Infinity;\n\
    \    let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minSum10 =\
    \ Infinity;\n    let minPathSum11 = Infinity;\n    let minPath11 = [];\n    let\
    \ minSum11 = Infinity;\n    let minPathSum12 = Infinity;\n    let minPath12 =\
    \ [];\n    let minSum12 = Infinity;\n    let minPathSum13 = Infinity;\n    let\
    \ minPath13 = [];\n    let minSum13 = Infinity;\n    let minPathSum14 = Infinity;\n\
    \    let minPath14 = [];\n    let minSum14 = Infinity;\n    let minPathSum15 =\
    \ Infinity;\n    let minPath15 = [];\n    let minSum15 = Infinity;\n    let minPathSum16\
    \ = Infinity;\n    let minPath16 = [];\n    let minSum16 = Infinity;\n    let\
    \ minPathSum17 = Infinity;\n    let minPath17 = [];\n    let minSum17 = Infinity;\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minSum18 =\
    \ Infinity;\n    let minPathSum19 = Infinity", "    var n = grid.length;\n   \
    \ var m = grid[0].length;\n    var min = Infinity;\n    var minPath = [];\n  \
    \  var path = [];\n    var visited = [];\n    for(var i = 0; i < n; i++){\n  \
    \      visited.push([]);\n        for(var j = 0; j < m; j++){\n            visited[i].push(false);\n\
    \        }\n    }\n    for(var i = 0; i < n; i++){\n        for(var j = 0; j <\
    \ m; j++){\n            dfs(i, j, 0, 0);\n        }\n    }\n    return minPath;\n\
    \    function dfs(i, j, len, sum){\n        if(i < 0 || i >= n || j < 0 || j >=\
    \ m || visited[i][j] || len > k){\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        path.push(grid[i][j]);\n        if(len === k){\n          \
    \  if(sum < min){\n                min = sum;\n                minPath = path.slice();\n\
    \            }\n        }\n        else{\n            dfs(i + 1, j, len + 1, sum\
    \ + grid[i][j]);\n            dfs(i - 1, j, len + 1, sum + grid[i][j]);\n    \
    \        dfs(i, j + 1, len + 1, sum + grid[i][j]);\n            dfs(i, j - 1,\
    \ len + 1, sum + grid[i][j]);\n        }\n        path.pop();\n        visited[i][j]\
    \ = false;\n    }\n}\n", "    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minSum2 = Infinity;\n    let minPathSum3 = Infinity;\n    let\
    \ minPath3 = [];\n    let minSum3 = Infinity;\n    let minPathSum4 = Infinity;\n\
    \    let minPath4 = [];\n    let minSum4 = Infinity;\n    let minPathSum5 = Infinity;\n\
    \    let minPath5 = [];\n    let minSum5 = Infinity;\n    let minPathSum6 = Infinity;\n\
    \    let minPath6 = [];\n    let minSum6 = Infinity;\n    let minPathSum7 = Infinity;\n\
    \    let minPath7 = [];\n    let minSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minSum8 = Infinity;\n    let minPathSum9 = Infinity;\n\
    \    let minPath9 = [];\n    let minSum9 = Infinity;\n    let minPathSum10 = Infinity;\n\
    \    let minPath10 = [];\n    let minSum10 = Infinity;\n    let minPathSum11 =\
    \ Infinity;\n    let minPath11 = [];\n    let minSum11 = Infinity;\n    let minPathSum12\
    \ = Infinity;\n    let minPath12 = [];\n    let minSum12 = Infinity;\n    let\
    \ minPathSum13 = Infinity;\n    let minPath13 = [];\n    let minSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minSum14 =\
    \ Infinity;\n    let minPathSum15 = Infinity;\n    let minPath15 = [];\n    let\
    \ minSum15 = Infinity;\n    let minPathSum16 = Infinity;\n    let minPath16 =\
    \ [];\n    let minSum16 = Infinity;\n    let minPathSum17 = Infinity;\n    let\
    \ minPath17 = [];\n    let minSum17 = Infinity;\n    let minPathSum18 = Infinity;\n\
    \    let minPath18 = [];\n    let minSum18 = Infinity;\n    let minPathSum19 =\
    \ Infinity;\n    let minPath19 = [];\n    let minSum19 = Infinity;\n   ", "  \
    \  var n = grid.length;\n    var m = grid[0].length;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPathSum2 = Infinity;\n    var minPath2\
    \ = [];\n    var minPathSum3 = Infinity;\n    var minPath3 = [];\n    var minPathSum4\
    \ = Infinity;\n    var minPath4 = [];\n    var minPathSum5 = Infinity;\n    var\
    \ minPath5 = [];\n    var minPathSum6 = Infinity;\n    var minPath6 = [];\n  \
    \  var minPathSum7 = Infinity;\n    var minPath7 = [];\n    var minPathSum8 =\
    \ Infinity;\n    var minPath8 = [];\n    var minPathSum9 = Infinity;\n    var\
    \ minPath9 = [];\n    var minPathSum10 = Infinity;\n    var minPath10 = [];\n\
    \    var minPathSum11 = Infinity;\n    var minPath11 = [];\n    var minPathSum12\
    \ = Infinity;\n    var minPath12 = [];\n    var minPathSum13 = Infinity;\n   \
    \ var minPath13 = [];\n    var minPathSum14 = Infinity;\n    var minPath14 = [];\n\
    \    var minPathSum15 = Infinity;\n    var minPath15 = [];\n    var minPathSum16\
    \ = Infinity;\n    var minPath16 = [];\n    var minPathSum17 = Infinity;\n   \
    \ var minPath17 = [];\n    var minPathSum18 = Infinity;\n    var minPath18 = [];\n\
    \    var minPathSum19 = Infinity;\n    var minPath19 = [];\n    var minPathSum20\
    \ = Infinity;\n    var minPath20 = [];\n    var minPathSum21 = Infinity;\n   \
    \ var minPath21 = [];\n    var minPathSum22 = Infinity;\n    var minPath22 = [];\n\
    \    var minPathSum23 = Infinity;\n    var minPath23 = [];\n    var minPathSum24\
    \ = Infinity;\n    var minPath24 = [];\n    var minPathSum25 = Infinity;\n   \
    \ var minPath25 = [];\n    var minPathSum26 = Infinity;\n    var minPath26 = [];\n\
    \    var minPathSum27 = Infinity;\n    var minPath27 = [];\n    var minPathSum28\
    \ =", "    // your code here\n}\n", "    // your code here\n}\n", "    let n =\
    \ grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let minPath = [];\n    let minSum = Infinity;\n    let minPathSum\
    \ = Infinity;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < m;\
    \ j++){\n            let currPath = [];\n            let currSum = 0;\n      \
    \      let currPathSum = 0;\n            dfs(grid, i, j, k, visited, currPath,\
    \ currSum, currPathSum);\n            if(currPathSum < minPathSum){\n        \
    \        minPathSum = currPathSum;\n                minPath = currPath;\n    \
    \        }\n            if(currSum < minSum){\n                minSum = currSum;\n\
    \            }\n        }\n    }\n    return minPath;\n}\n", "    // your code\
    \ here\n}\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let\
    \ minPath = [];\n    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n\
    \    let minPath2 = [];\n    let minPathSum3 = Infinity;\n    let minPath3 = [];\n\
    \    let minPathSum4 = Infinity;\n    let minPath4 = [];\n    let minPathSum5\
    \ = Infinity;\n    let minPath5 = [];\n    let minPathSum6 = Infinity;\n    let\
    \ minPath6 = [];\n    let minPathSum7 = Infinity;\n    let minPath7 = [];\n  \
    \  let minPathSum8 = Infinity;\n    let minPath8 = [];\n    for(let i = 0; i <\
    \ n; i++){\n        for(let j = 0; j < m; j++){\n            if(i == 0 && j ==\
    \ 0){\n                minPathSum = grid[i][j];\n                minPath = [grid[i][j]];\n\
    \            }\n            if(i == 0 && j == 1){\n                minPathSum2\
    \ = grid[i][j];\n                minPath2 = [grid[i][j]];\n            }\n   \
    \         if(i == 0 && j == 2){\n                minPathSum3 = grid[i][j];\n \
    \               minPath3 = [grid[i][j]];\n            }\n            if(i == 1\
    \ && j == 0){\n                minPathSum4 = grid[i][j];\n                minPath4\
    \ = [grid[i][j]];\n            }\n            if(i == 1 && j == 1){\n        \
    \        minPathSum5 = grid[i][j];\n                minPath5 = [grid[i][j]];\n\
    \            }\n            if(i == 1 && j == 2){\n                minPathSum6\
    \ = grid[i][j];\n                minPath6 = [grid[i][j]];\n            }\n   \
    \         if(i == 2 && j == 0){\n                minPathSum7 = grid[i][j];\n \
    \               minPath7 = [grid[i][j]];\n            }\n            if(i == 2\
    \ && j == 1){\n                minPathSum8 = grid[i][j];\n", "    // your code\
    \ here\n}\n", "    var n = grid.length;\n    var m = grid[0].length;\n    var\
    \ minPath = [];\n    var minPathValue = Infinity;\n    var visited = [];\n   \
    \ for(var i = 0; i < n; i++){\n        visited.push([]);\n        for(var j =\
    \ 0; j < m; j++){\n            visited[i].push(false);\n        }\n    }\n   \
    \ for(var i = 0; i < n; i++){\n        for(var j = 0; j < m; j++){\n         \
    \   var path = [];\n            var pathValue = 0;\n            var pathLength\
    \ = 0;\n            var pathValue = 0;\n            var path = [];\n         \
    \   var pathLength = 0;\n            var pathValue = 0;\n            var path\
    \ = [];\n            var pathLength = 0;\n            var pathValue = 0;\n   \
    \         var path = [];\n            var pathLength = 0;\n            var pathValue\
    \ = 0;\n            var path = [];\n            var pathLength = 0;\n        \
    \    var pathValue = 0;\n            var path = [];\n            var pathLength\
    \ = 0;\n            var pathValue = 0;\n            var path = [];\n         \
    \   var pathLength = 0;\n            var pathValue = 0;\n            var path\
    \ = [];\n            var pathLength = 0;\n            var pathValue = 0;\n   \
    \         var path = [];\n            var pathLength = 0;\n            var pathValue\
    \ = 0;\n            var path = [];\n            var pathLength = 0;\n        \
    \    var pathValue = 0;\n            var path = [];\n            var pathLength\
    \ = 0;\n            var pathValue = 0;\n            var path = [];\n         \
    \   var pathLength = 0;\n            var pathValue = 0;\n            var path\
    \ = [];\n            var pathLength = 0;\n            var pathValue = 0;\n   \
    \         var path = [];\n            var pathLength = 0;\n            var pathValue\
    \ = 0;\n            var path = [];\n            var pathLength = 0;\n        \
    \    var pathValue = 0;\n            var path = [];\n            var pathLength\
    \ = 0;\n            var pathValue = 0;\n            var path = [];\n         \
    \   var pathLength = 0;\n            var pathValue = 0;", "    var n = grid.length;\n\
    \    var m = grid[0].length;\n    var minPath = [];\n    var minSum = Infinity;\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var minPath = [];\n\
    \    var minPathSum = Infinity;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPath = [];\n    var minPathSum = Infinity;\n    var min", "    var\
    \ n = grid.length;\n    var m = grid[0].length;\n    var min = Infinity;\n   \
    \ var minPath = [];\n    var visited = [];\n    for(var i = 0; i < n; i++){\n\
    \        visited.push([]);\n        for(var j = 0; j < m; j++){\n            visited[i].push(false);\n\
    \        }\n    }\n    for(var i = 0; i < n; i++){\n        for(var j = 0; j <\
    \ m; j++){\n            var path = [];\n            var pathSum = 0;\n       \
    \     dfs(grid, i, j, k, path, pathSum, visited);\n            if(pathSum < min){\n\
    \                min = pathSum;\n                minPath = path;\n           \
    \ }\n        }\n    }\n    return minPath;\n}\n", "    var n = grid.length;\n\
    \    var m = grid[0].length;\n    var minPath = [];\n    var minPathSum = Infinity;\n\
    \    var minPathSum2 = Infinity;\n    var minPath2 = [];\n    var minPathSum3\
    \ = Infinity;\n    var minPath3 = [];\n    var minPathSum4 = Infinity;\n    var\
    \ minPath4 = [];\n    var minPathSum5 = Infinity;\n    var minPath5 = [];\n  \
    \  var minPathSum6 = Infinity;\n    var minPath6 = [];\n    var minPathSum7 =\
    \ Infinity;\n    var minPath7 = [];\n    var minPathSum8 = Infinity;\n    var\
    \ minPath8 = [];\n    var minPathSum9 = Infinity;\n    var minPath9 = [];\n  \
    \  var minPathSum10 = Infinity;\n    var minPath10 = [];\n    var minPathSum11\
    \ = Infinity;\n    var minPath11 = [];\n    var minPathSum12 = Infinity;\n   \
    \ var minPath12 = [];\n    var minPathSum13 = Infinity;\n    var minPath13 = [];\n\
    \    var minPathSum14 = Infinity;\n    var minPath14 = [];\n    var minPathSum15\
    \ = Infinity;\n    var minPath15 = [];\n    var minPathSum16 = Infinity;\n   \
    \ var minPath16 = [];\n    var minPathSum17 = Infinity;\n    var minPath17 = [];\n\
    \    var minPathSum18 = Infinity;\n    var minPath18 = [];\n    var minPathSum19\
    \ = Infinity;\n    var minPath19 = [];\n    var minPathSum20 = Infinity;\n   \
    \ var minPath20 = [];\n    var minPathSum21 = Infinity;\n    var minPath21 = [];\n\
    \    var minPathSum22 = Infinity;\n    var minPath22 = [];\n    var minPathSum23\
    \ = Infinity;\n    var minPath23 = [];\n    var minPathSum24 = Infinity;\n   \
    \ var minPath24 = [];\n    var minPathSum25 = Infinity;\n    var minPath25 = [];\n\
    \    var minPathSum26 = Infinity;\n    var minPath26 = [];\n    var minPathSum27\
    \ = Infinity;\n    var minPath27 = [];\n    var minPathSum28 =", "    // your\
    \ code here\n}\n", "    var n = grid.length;\n    var m = grid[0].length;\n  \
    \  var min = [];\n    var min_val = Infinity;\n    var visited = [];\n    for(var\
    \ i = 0; i < n; i++){\n        visited.push([]);\n        for(var j = 0; j < m;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    var dfs =\
    \ function(i, j, path, val){\n        if(i < 0 || i >= n || j < 0 || j >= m ||\
    \ visited[i][j]){\n            return;\n        }\n        path.push(grid[i][j]);\n\
    \        val += grid[i][j];\n        if(path.length === k){\n            if(val\
    \ < min_val){\n                min_val = val;\n                min = path.slice();\n\
    \            }\n            else if(val === min_val){\n                if(path\
    \ < min){\n                    min = path.slice();\n                }\n      \
    \      }\n            path.pop();\n            return;\n        }\n        visited[i][j]\
    \ = true;\n        dfs(i + 1, j, path, val);\n        dfs(i - 1, j, path, val);\n\
    \        dfs(i, j + 1, path, val);\n        dfs(i, j - 1, path, val);\n      \
    \  visited[i][j] = false;\n        path.pop();\n    }\n    for(var i = 0; i <\
    \ n; i++){\n        for(var j = 0; j < m; j++){\n            dfs(i, j, [], 0);\n\
    \        }\n    }\n    return min;\n}\n", "    let minPath = [];\n    let minPathValue\
    \ = Infinity;\n    let minPathIndex = [];\n    let minPathIndexValue = Infinity;\n\
    \    let path = [];\n    let pathValue = 0;\n    let pathIndex = [];\n    let\
    \ pathIndexValue = 0;\n    let visited = [];\n    for(let i = 0; i < grid.length;\
    \ i++){\n        visited.push([]);\n        for(let j = 0; j < grid[i].length;\
    \ j++){\n            visited[i].push(false);\n        }\n    }\n    for(let i\
    \ = 0; i < grid.length; i++){\n        for(let j = 0; j < grid[i].length; j++){\n\
    \            path = [];\n            pathValue = 0;\n            pathIndex = [];\n\
    \            pathIndexValue = 0;\n            for(let i = 0; i < grid.length;\
    \ i++){\n                visited.push([]);\n                for(let j = 0; j <\
    \ grid[i].length; j++){\n                    visited[i].push(false);\n       \
    \         }\n            }\n            dfs(grid, i, j, k, path, pathValue, pathIndex,\
    \ pathIndexValue, visited);\n            if(pathValue < minPathValue){\n     \
    \           minPath = path;\n                minPathValue = pathValue;\n     \
    \           minPathIndex = pathIndex;\n                minPathIndexValue = pathIndexValue;\n\
    \            }\n            else if(pathValue === minPathValue){\n           \
    \     if(pathIndexValue < minPathIndexValue){\n                    minPath = path;\n\
    \                    minPathValue = pathValue;\n                    minPathIndex\
    \ = pathIndex;\n                    minPathIndexValue = pathIndexValue;\n    \
    \            }\n            }\n        }\n    }\n    return minPath;\n}", "  \
    \  // your code here\n}\n", "    // your code here\n}\n", "    let n = grid.length;\n\
    \    let m = grid[0].length;\n    let minPath = [];\n    let minSum = Infinity;\n\
    \    let minPathSum = Infinity;\n    let minPathSum2 = Infinity;\n    let minPath2\
    \ = [];\n    let minPath3 = [];\n    let minPathSum3 = Infinity;\n    let minPathSum4\
    \ = Infinity;\n    let minPath4 = [];\n    let minPath5 = [];\n    let minPathSum5\
    \ = Infinity;\n    let minPathSum6 = Infinity;\n    let minPath6 = [];\n    let\
    \ minPath7 = [];\n    let minPathSum7 = Infinity;\n    let minPathSum8 = Infinity;\n\
    \    let minPath8 = [];\n    let minPath9 = [];\n    let minPathSum9 = Infinity;\n\
    \    let minPathSum10 = Infinity;\n    let minPath10 = [];\n    let minPath11\
    \ = [];\n    let minPathSum11 = Infinity;\n    let minPathSum12 = Infinity;\n\
    \    let minPath12 = [];\n    let minPath13 = [];\n    let minPathSum13 = Infinity;\n\
    \    let minPathSum14 = Infinity;\n    let minPath14 = [];\n    let minPath15\
    \ = [];\n    let minPathSum15 = Infinity;\n    let minPathSum16 = Infinity;\n\
    \    let minPath16 = [];\n    let minPath17 = [];\n    let minPathSum17 = Infinity;\n\
    \    let minPathSum18 = Infinity;\n    let minPath18 = [];\n    let minPath19\
    \ = [];\n    let minPathSum19 = Infinity;\n    let minPathSum20 = Infinity;\n\
    \    let minPath20 = [];\n    let minPath21 = [];\n    let minPathSum21 = Infinity;\n\
    \    let minPathSum22 = Infinity;\n    let minPath22 = [];\n    let minPath23\
    \ = [];\n    let minPathSum23 = Infinity;\n    let minPathSum24 = Infinity;\n\
    \    let minPath24 = [];\n    let minPath25 = [];\n    let minPathSum25 = Infinity;\n\
    \    let minPathSum26 = Infinity;\n    let minPath26 = [];\n    let minPath27\
    \ = [];\n    let minPathSum27 = Infinity;", "  let n = grid.length;\n  let m =\
    \ grid[0].length;\n  let visited = new Array(n);\n  for(let i = 0; i < n; i++){\n\
    \    visited[i] = new Array(m).fill(false);\n  }\n  let min = [];\n  for(let i\
    \ = 0; i < n; i++){\n    for(let j = 0; j < m; j++){\n      let path = [];\n \
    \     dfs(grid, i, j, k, visited, path, min);\n    }\n  }\n  return min;\n}\n",
  "    let n = grid.length;\n    let minPath = [];\n    let minPathSum = Infinity;\n\
    \    let minPathSumIndex = -1;\n    let minPathSumIndex2 = -1;\n    let minPathSumIndex3\
    \ = -1;\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j < n; j++){\n\
    \            let path = [];\n            let pathSum = 0;\n            let pathSumIndex\
    \ = -1;\n            let pathSumIndex2 = -1;\n            let pathSumIndex3 =\
    \ -1;\n            let pathSumIndex4 = -1;\n            let pathSumIndex5 = -1;\n\
    \            let pathSumIndex6 = -1;\n            let pathSumIndex7 = -1;\n  \
    \          let pathSumIndex8 = -1;\n            let pathSumIndex9 = -1;\n    \
    \        let pathSumIndex10 = -1;\n            let pathSumIndex11 = -1;\n    \
    \        let pathSumIndex12 = -1;\n            let pathSumIndex13 = -1;\n    \
    \        let pathSumIndex14 = -1;\n            let pathSumIndex15 = -1;\n    \
    \        let pathSumIndex16 = -1;\n            let pathSumIndex17 = -1;\n    \
    \        let pathSumIndex18 = -1;\n            let pathSumIndex19 = -1;\n    \
    \        let pathSumIndex20 = -1;\n            let pathSumIndex21 = -1;\n    \
    \        let pathSumIndex22 = -1;\n            let pathSumIndex23 = -1;\n    \
    \        let pathSumIndex24 = -1;\n            let pathSumIndex25 = -1;\n    \
    \        let pathSumIndex26 = -1;\n            let pathSumIndex27 = -1;\n    \
    \        let pathSumIndex28 = -1;\n            let pathSumIndex29 = -1;\n    \
    \        let pathSumIndex30 = -1;\n            let pathSumIndex31 = -1;\n    \
    \        let pathSumIndex32 = -1;\n            let pathSumIndex33 = -1;\n    \
    \        let pathSumIndex34 = -1;\n            let pathSumIndex35 = -1;\n    \
    \        let pathSumIndex36 = -1;\n            let pathSumIndex37 = -1;", "  \
    \  let n = grid.length;\n    let m = grid[0].length;\n    let visited = new Array(n);\n\
    \    for(let i = 0; i < n; i++){\n        visited[i] = new Array(m).fill(false);\n\
    \    }\n    let min = Number.MAX_SAFE_INTEGER;\n    let minPath = [];\n    for(let\
    \ i = 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            let path\
    \ = [];\n            dfs(i, j, 0, path);\n        }\n    }\n    return minPath;\n\
    \    function dfs(i, j, count, path){\n        if(count > k){\n            return;\n\
    \        }\n        if(count === k){\n            let sum = 0;\n            for(let\
    \ i = 0; i < path.length; i++){\n                sum += path[i];\n           \
    \ }\n            if(sum < min){\n                min = sum;\n                minPath\
    \ = path;\n            }\n            return;\n        }\n        if(i < 0 ||\
    \ i >= n || j < 0 || j >= m || visited[i][j]){\n            return;\n        }\n\
    \        visited[i][j] = true;\n        path.push(grid[i][j]);\n        dfs(i\
    \ + 1, j, count + 1, path);\n        dfs(i - 1, j, count + 1, path);\n       \
    \ dfs(i, j + 1, count + 1, path);\n        dfs(i, j - 1, count + 1, path);\n \
    \       path.pop();\n        visited[i][j] = false;\n    }\n}\n", "    // your\
    \ code here\n}\n", "\tlet n = grid.length;\n\tlet minPath = [];\n\tlet minPathSum\
    \ = Infinity;\n\tlet minPathSum2 = Infinity;\n\tlet minPath2 = [];\n\tlet minPathSum3\
    \ = Infinity;\n\tlet minPath3 = [];\n\tlet minPathSum4 = Infinity;\n\tlet minPath4\
    \ = [];\n\tlet minPathSum5 = Infinity;\n\tlet minPath5 = [];\n\tlet minPathSum6\
    \ = Infinity;\n\tlet minPath6 = [];\n\tlet minPathSum7 = Infinity;\n\tlet minPath7\
    \ = [];\n\tlet minPathSum8 = Infinity;\n\tlet minPath8 = [];\n\tlet minPathSum9\
    \ = Infinity;\n\tlet minPath9 = [];\n\tlet minPathSum10 = Infinity;\n\tlet minPath10\
    \ = [];\n\tlet minPathSum11 = Infinity;\n\tlet minPath11 = [];\n\tlet minPathSum12\
    \ = Infinity;\n\tlet minPath12 = [];\n\tlet minPathSum13 = Infinity;\n\tlet minPath13\
    \ = [];\n\tlet minPathSum14 = Infinity;\n\tlet minPath14 = [];\n\tlet minPathSum15\
    \ = Infinity;\n\tlet minPath15 = [];\n\tlet minPathSum16 = Infinity;\n\tlet minPath16\
    \ = [];\n\tlet minPathSum17 = Infinity;\n\tlet minPath17 = [];\n\tlet minPathSum18\
    \ = Infinity;\n\tlet minPath18 = [];\n\tlet minPathSum19 = Infinity;\n\tlet minPath19\
    \ = [];\n\tlet minPathSum20 = Infinity;\n\tlet minPath20 = [];\n\tlet minPathSum21\
    \ = Infinity;\n\tlet minPath21 = [];\n\tlet minPathSum22 = Infinity;\n\tlet minPath22\
    \ = [];\n\tlet minPathSum23 = Infinity;\n\tlet minPath23 = [];\n\tlet minPathSum24\
    \ = Infinity;\n\tlet minPath24 = [];\n\tlet minPathSum25 = Infinity;\n\tlet minPath25\
    \ = [];\n\tlet minPathSum26 = Infinity;\n\tlet minPath26 = [];\n\tlet minPathSum27\
    \ = Infinity;\n\tlet minPath27 = [];\n\tlet minPathSum28 = Infinity;\n\tlet minPath28\
    \ = [];\n", "    // your code here\n}\n", "    // Your code here\n}\n", "\tvar\
    \ n = grid.length;\n\tvar m = grid[0].length;\n\tvar visited = [];\n\tfor(var\
    \ i = 0; i < n; i++){\n\t\tvisited.push([]);\n\t\tfor(var j = 0; j < m; j++){\n\
    \t\t\tvisited[i].push(false);\n\t\t}\n\t}\n\tvar min = [];\n\tfor(var i = 0; i\
    \ < n; i++){\n\t\tfor(var j = 0; j < m; j++){\n\t\t\tvar curr = [];\n\t\t\tvar\
    \ curr_min = [];\n\t\t\tdfs(grid, visited, i, j, k, curr, curr_min, min);\n\t\t\
    }\n\t}\n\treturn min;\n}\n", "    // your code here\n}\n", "    // your code here\n\
    }\n", "    let n = grid.length;\n    let m = grid[0].length;\n    let dp = [];\n\
    \    for(let i = 0; i < n; i++){\n        dp.push([]);\n        for(let j = 0;\
    \ j < m; j++){\n            dp[i].push([]);\n        }\n    }\n    for(let i =\
    \ 0; i < n; i++){\n        for(let j = 0; j < m; j++){\n            dp[i][j].push(grid[i][j]);\n\
    \        }\n    }\n    for(let i = 1; i < k; i++){\n        for(let j = 0; j <\
    \ n; j++){\n            for(let l = 0; l < m; l++){\n                let min =\
    \ [];\n                if(j > 0){\n                    min = dp[j - 1][l];\n \
    \               }\n                if(j < n - 1 && (min.length == 0 || min[min.length\
    \ - 1] > dp[j + 1][l][dp[j + 1][l].length - 1])){\n                    min = dp[j\
    \ + 1][l];\n                }\n                if(l > 0 && (min.length == 0 ||\
    \ min[min.length - 1] > dp[j][l - 1][dp[j][l - 1].length - 1])){\n           \
    \         min = dp[j][l - 1];\n                }\n                if(l < m - 1\
    \ && (min.length == 0 || min[min.length - 1] > dp[j][l + 1][dp[j][l + 1].length\
    \ - 1])){\n                    min = dp[j][l + 1];\n                }\n      \
    \          dp[j][l] = min.concat(grid[j][l]);\n            }\n        }\n    }\n\
    \    let min = [];\n    for(let i = 0; i < n; i++){\n        for(let j = 0; j\
    \ < m; j++){\n            if(min.length == 0 || min[min.length - 1] > dp[i][j][dp[i][j].length",
  "    //YOUR CODE HERE\n}\n", "    // your code here\n}\n", "    // your code here\n\
    }\n"]
stop_tokens:
- "\nfunction "
- "\n/*"
- "\n//"
- "\nconsole.log"
