{
  "language": "py",
  "name": "HumanEval_6_parse_nested_parens",
  "results": [
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise Exception(\"Mismatched parentheses\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, i - paren_stack[-1])\n                else:\n                    max_depth = max(max_depth, i - paren_stack[-1])\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7ao2wf8.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpu7ao2wf8.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7ao2wf8.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpu7ao2wf8.py\", line 22, in parse_nested_parens\n    max_depth = max(max_depth, i - paren_stack[-1])\nIndexError: list index out of range\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Invalid parentheses string\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            raise ValueError(\"Invalid parentheses string\")\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpq8opz7x8.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpq8opz7x8.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpq8opz7x8.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpq8opz7x8.py\", line 24, in parse_nested_parens\n    raise ValueError(\"Invalid parentheses string\")\nValueError: Invalid parentheses string\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unexpected closing parenthesis')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpf8wpdmii.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpf8wpdmii.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpf8wpdmii.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unexpected closing parenthesis at position {}'.format(i))\n            else:\n                nesting = len(paren_stack)\n                if nesting > max_nesting:\n                    max_nesting = nesting\n                paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpstv5kyaf.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmpstv5kyaf.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpstv5kyaf.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        elif c == ' ':\n            if len(paren_stack) > max_depth:\n                max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmph5nh4qvk.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmph5nh4qvk.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph5nh4qvk.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp38mngu1g.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp38mngu1g.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp38mngu1g.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            last_open_paren = paren_stack.pop()\n            if len(paren_stack) == 0:\n                max_depth = max(max_depth, i - last_open_paren)\n            else:\n                max_depth = max(max_depth, i - paren_stack[-1])\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpyor3pw_2.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmpyor3pw_2.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyor3pw_2.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdxwwjjyb.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdxwwjjyb.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdxwwjjyb.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp9wjsl5wk.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp9wjsl5wk.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9wjsl5wk.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                nesting = len(paren_stack)\n                if nesting > max_nesting:\n                    max_nesting = nesting\n                paren_stack.pop()\n        else:\n            raise ValueError('Invalid character')\n    return max_nesting\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp872htvbv.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmp872htvbv.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp872htvbv.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmp872htvbv.py\", line 25, in parse_nested_parens\n    raise ValueError('Invalid character')\nValueError: Invalid character\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            nesting = len(paren_stack)\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpqa3y9vdt.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpqa3y9vdt.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqa3y9vdt.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                depth = len(paren_stack)\n                paren_stack.pop()\n                if depth > max_depth:\n                    max_depth = depth\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpm_a5my8w.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmpm_a5my8w.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpm_a5my8w.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Invalid paren string\")\n            last_paren_index = paren_stack.pop()\n            max_depth = max(max_depth, len(paren_stack))\n            i = last_paren_index\n        else:\n            raise ValueError(\"Invalid paren string\")\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpgc884ngv.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmpgc884ngv.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpgc884ngv.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpgc884ngv.py\", line 23, in parse_nested_parens\n    raise ValueError(\"Invalid paren string\")\nValueError: Invalid paren string\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpiyaex11k.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpiyaex11k.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpiyaex11k.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            else:\n                paren_stack.append(paren_count)\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdfowmf3q.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdfowmf3q.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdfowmf3q.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unexpected closing parenthesis at position {}'.format(i))\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpaun0e5kf.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpaun0e5kf.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpaun0e5kf.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            pass\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpc31a4f1_.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpc31a4f1_.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpc31a4f1_.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984037
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpt1msbzz5.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmpt1msbzz5.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpt1msbzz5.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpt1msbzz5.py\", line 25, in parse_nested_parens\n    raise ValueError(\"Mismatched parentheses\")\nValueError: Mismatched parentheses\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return [max(x, y) for x, y in zip(paren_stack, paren_stack[1:])]\n            else:\n                paren_stack.pop()\n    return []\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp6hcq_xwz.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp6hcq_xwz.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6hcq_xwz.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return [max(x, y) for x, y in zip(paren_stack, paren_stack[1:])]\n            else:\n                paren_stack.pop()\n    return []\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp6hcq_xwz.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp6hcq_xwz.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6hcq_xwz.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpzgulitg6.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpzgulitg6.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzgulitg6.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unexpected closing parenthesis at index {}'.format(i))\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpm0af28tx.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpm0af28tx.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpm0af28tx.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_stack.append(i)\n        elif char == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n        else:\n            raise ValueError('Invalid character')\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpj993g5d4.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpj993g5d4.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpj993g5d4.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpj993g5d4.py\", line 24, in parse_nested_parens\n    raise ValueError('Invalid character')\nValueError: Invalid character\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpi5aur83r.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpi5aur83r.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpi5aur83r.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp1m1i5q2f.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmp1m1i5q2f.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1m1i5q2f.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp9wgi0w01.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp9wgi0w01.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9wgi0w01.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            else:\n                paren_stack.append(paren_count)\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdfowmf3q.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdfowmf3q.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdfowmf3q.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    result = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                result.append(i)\n            else:\n                result.append(paren_stack.pop())\n    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkxw87nsv.py\", line 31, in <module>\n    test_check()\n  File \"/tmp/tmpkxw87nsv.py\", line 29, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkxw87nsv.py\", line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            continue\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp41uj1auf.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmp41uj1auf.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp41uj1auf.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdxwwjjyb.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdxwwjjyb.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdxwwjjyb.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_stack.append(i)\n        elif char == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpqybq0a5j.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpqybq0a5j.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqybq0a5j.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_stack.append(i)\n        elif char == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            last_paren_index = paren_stack.pop()\n            nesting_level = len(paren_stack)\n            if nesting_level > 0:\n                nesting_level += 1\n            yield nesting_level\n\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpa9c210el.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpa9c210el.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpa9c210el.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpx05zl3om.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpx05zl3om.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpx05zl3om.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp9wjsl5wk.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp9wjsl5wk.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9wjsl5wk.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpupik_dqb.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpupik_dqb.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpupik_dqb.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            last_paren_index = paren_stack.pop()\n            if len(paren_stack) > max_depth:\n                max_depth = len(paren_stack)\n            if len(paren_stack) == 0:\n                break\n            else:\n                i = last_paren_index\n    return [max_depth] * max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp3o4kps07.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmp3o4kps07.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3o4kps07.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n            if len(paren_stack) > 0:\n                paren_stack.pop()\n            else:\n                return [0]\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpp75fqiwb.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpp75fqiwb.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpp75fqiwb.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Invalid parentheses string\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpypvh1ees.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpypvh1ees.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpypvh1ees.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid input')\n            else:\n                paren_stack.pop()\n    return len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpuwztokmj.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpuwztokmj.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpuwztokmj.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            continue\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpi8kx8h6s.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpi8kx8h6s.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpi8kx8h6s.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmph69qpggd.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmph69qpggd.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph69qpggd.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpqaaf25gt.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpqaaf25gt.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqaaf25gt.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n            paren_count += 1\n        elif c == ')':\n            if paren_count == 0:\n                raise ValueError('Invalid parentheses')\n            paren_count -= 1\n            if paren_count == 0:\n                paren_stack.pop()\n        else:\n            if paren_count == 0:\n                raise ValueError('Invalid parentheses')\n    return [len(paren_stack) - 1] + [len(paren_stack) - i - 1 for i in range(len(paren_stack))]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpok0sf8l_.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmpok0sf8l_.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpok0sf8l_.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpok0sf8l_.py\", line 25, in parse_nested_parens\n    raise ValueError('Invalid parentheses')\nValueError: Invalid parentheses\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unexpected closing parenthesis')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n        else:\n            raise ValueError('Unexpected character')\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkd75_6xj.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpkd75_6xj.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkd75_6xj.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpkd75_6xj.py\", line 24, in parse_nested_parens\n    raise ValueError('Unexpected character')\nValueError: Unexpected character\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpiyaex11k.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpiyaex11k.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpiyaex11k.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdxwwjjyb.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdxwwjjyb.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdxwwjjyb.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [max_depth]\n            else:\n                paren_stack.pop()\n                max_depth = max(max_depth, len(paren_stack))\n    return [max_depth]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpr7161uh_.py\", line 32, in <module>\n    test_check()\n  File \"/tmp/tmpr7161uh_.py\", line 30, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpr7161uh_.py\", line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        elif c == ' ':\n            if len(paren_stack) > max_depth:\n                max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmph5nh4qvk.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmph5nh4qvk.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph5nh4qvk.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return [max(x, y) for x, y in zip(paren_stack, paren_stack[1:])]\n            else:\n                paren_stack.pop()\n    return [paren_count]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmphz_3x78r.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmphz_3x78r.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmphz_3x78r.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif c == ')':\n            paren_count -= 1\n            if len(paren_stack) > 0:\n                paren_stack.pop()\n    return [len(paren_stack) for _ in range(len(paren_string))]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp6l3mkuhg.py\", line 31, in <module>\n    test_check()\n  File \"/tmp/tmp6l3mkuhg.py\", line 29, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6l3mkuhg.py\", line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpcd5mrhpq.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpcd5mrhpq.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpcd5mrhpq.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpuinc8t_0.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmpuinc8t_0.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpuinc8t_0.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpuinc8t_0.py\", line 25, in parse_nested_parens\n    raise ValueError('Mismatched parentheses')\nValueError: Mismatched parentheses\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unexpected closing parenthesis')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp64pvptn6.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp64pvptn6.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp64pvptn6.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_stack.append(i)\n        elif char == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpa39wihtt.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpa39wihtt.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpa39wihtt.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_stack.append(paren)\n        else:\n            if paren_stack:\n                nested_paren_count = len(paren_stack) - 1\n                paren_stack.pop()\n                if nested_paren_count > 0:\n                    nested_paren_count += 1\n                return [nested_paren_count] + parse_nested_parens(' '.join(paren_stack))\n            else:\n                return []\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpwc12rjfc.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpwc12rjfc.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwc12rjfc.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid input')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            continue\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpizp1qbwt.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpizp1qbwt.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpizp1qbwt.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n            nesting = len(paren_stack)\n            paren_stack.pop()\n            if nesting > max_nesting:\n                max_nesting = nesting\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp77qxcwso.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp77qxcwso.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp77qxcwso.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp1m1i5q2f.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmp1m1i5q2f.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1m1i5q2f.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpso69fqsb.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpso69fqsb.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpso69fqsb.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n        if len(paren_stack) > max_depth:\n            max_depth = len(paren_stack)\n    return [max_depth - len(paren_stack) + 1] * max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu1roq7qh.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu1roq7qh.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu1roq7qh.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpko52a5i2.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpko52a5i2.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpko52a5i2.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpko52a5i2.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpko52a5i2.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpko52a5i2.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmph8ppm9ok.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmph8ppm9ok.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph8ppm9ok.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpiyaex11k.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpiyaex11k.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpiyaex11k.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdjk1nfzm.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdjk1nfzm.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdjk1nfzm.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            last_paren_index = paren_stack.pop()\n            max_depth = max(max_depth, len(paren_stack))\n            i = last_paren_index\n        else:\n            raise ValueError('Invalid parentheses string')\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpzsnwzl3t.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmpzsnwzl3t.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzsnwzl3t.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpzsnwzl3t.py\", line 23, in parse_nested_parens\n    raise ValueError('Invalid parentheses string')\nValueError: Invalid parentheses string\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpp_zkz2dw.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmpp_zkz2dw.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpp_zkz2dw.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpp_zkz2dw.py\", line 25, in parse_nested_parens\n    raise ValueError('Invalid parentheses string')\nValueError: Invalid parentheses string\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [i]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpskmp6ck5.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpskmp6ck5.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpskmp6ck5.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                depth = len(paren_stack)\n                paren_stack.pop()\n                if depth > max_depth:\n                    max_depth = depth\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpm_a5my8w.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmpm_a5my8w.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpm_a5my8w.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpqaaf25gt.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpqaaf25gt.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqaaf25gt.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid input')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            continue\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp14bu85sk.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmp14bu85sk.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp14bu85sk.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count < 0:\n                raise ValueError('Invalid parentheses')\n            if paren_count == 0:\n                return [max(x, y) for x, y in zip(paren_stack, paren_stack[1:])]\n        else:\n            pass\n    raise ValueError('Invalid parentheses')\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmptde1r4gs.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmptde1r4gs.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptde1r4gs.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmph69qpggd.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmph69qpggd.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph69qpggd.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            last_paren_index = paren_stack.pop()\n            max_depth = max(max_depth, len(paren_stack))\n            i = last_paren_index\n        else:\n            raise ValueError('Invalid parentheses string')\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpzsnwzl3t.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmpzsnwzl3t.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpzsnwzl3t.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpzsnwzl3t.py\", line 23, in parse_nested_parens\n    raise ValueError('Invalid parentheses string')\nValueError: Invalid parentheses string\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        elif c == ' ':\n            if len(paren_stack) > max_depth:\n                max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxy4tcorv.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmpxy4tcorv.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxy4tcorv.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if len(paren_stack) > 0 and paren_count == paren_stack[-1]:\n                paren_stack.pop()\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpsm044lh7.py\", line 31, in <module>\n    test_check()\n  File \"/tmp/tmpsm044lh7.py\", line 29, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpsm044lh7.py\", line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            last_paren_index = paren_stack.pop()\n            max_depth = max(max_depth, len(paren_stack))\n            i = last_paren_index\n        else:\n            raise ValueError('Invalid parentheses')\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpk6h_d5ep.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmpk6h_d5ep.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpk6h_d5ep.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmpk6h_d5ep.py\", line 23, in parse_nested_parens\n    raise ValueError('Invalid parentheses')\nValueError: Invalid parentheses\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == max_depth:\n                    max_depth = max(max_depth, len(paren_stack))\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpx7bzxp6_.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpx7bzxp6_.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpx7bzxp6_.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    result = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                result.append(i)\n            else:\n                result.append(paren_stack.pop())\n    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkxw87nsv.py\", line 31, in <module>\n    test_check()\n  File \"/tmp/tmpkxw87nsv.py\", line 29, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkxw87nsv.py\", line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpko52a5i2.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpko52a5i2.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpko52a5i2.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpupik_dqb.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpupik_dqb.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpupik_dqb.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_stack.append(i)\n        elif char == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpnqedw7v0.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpnqedw7v0.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpnqedw7v0.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpqaaf25gt.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpqaaf25gt.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqaaf25gt.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid input')\n            else:\n                max_depth = max(max_depth, len(paren_stack))\n                paren_stack.pop()\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmptxw5kkko.py\", line 32, in <module>\n    test_check()\n  File \"/tmp/tmptxw5kkko.py\", line 30, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptxw5kkko.py\", line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpyzudvhtu.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpyzudvhtu.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpyzudvhtu.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmptg4vmnl9.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmptg4vmnl9.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptg4vmnl9.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp1nqqwd7u.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp1nqqwd7u.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1nqqwd7u.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            last_paren_index = paren_stack.pop()\n            nesting_level = len(paren_stack)\n            if nesting_level > 0:\n                nesting_level += 1\n            return [nesting_level, last_paren_index]\n    raise ValueError('Invalid parentheses')\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp8xqa4zhr.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp8xqa4zhr.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8xqa4zhr.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_stack.append(paren)\n        else:\n            if paren_stack:\n                paren_stack.pop()\n            else:\n                return [0]\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpf8ydhn7r.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpf8ydhn7r.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpf8ydhn7r.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            continue\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp8r3l1t4i.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmp8r3l1t4i.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8r3l1t4i.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            paren_stack.append(paren_count)\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp5v21xxag.py\", line 32, in <module>\n    test_check()\n  File \"/tmp/tmp5v21xxag.py\", line 30, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp5v21xxag.py\", line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid input')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp5lc6c5jh.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp5lc6c5jh.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp5lc6c5jh.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    result = []\n    for paren in paren_string.split(' '):\n        if paren == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            result.append(len(paren_stack))\n            paren_stack.pop()\n    if len(paren_stack) > 0:\n        raise ValueError('Mismatched parentheses')\n    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp8gafufvj.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp8gafufvj.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp8gafufvj.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp3sasmjup.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmp3sasmjup.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp3sasmjup.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmptg4vmnl9.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmptg4vmnl9.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptg4vmnl9.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            pass\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpwm77ana2.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpwm77ana2.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwm77ana2.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    result = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                result.append(0)\n            else:\n                result.append(len(paren_stack) - 1)\n            paren_stack.pop()\n    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpn4n8kzo1.py\", line 32, in <module>\n    test_check()\n  File \"/tmp/tmpn4n8kzo1.py\", line 30, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpn4n8kzo1.py\", line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdxwwjjyb.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdxwwjjyb.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdxwwjjyb.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmph69qpggd.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmph69qpggd.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph69qpggd.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            else:\n                paren_stack.append(paren_count)\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdfowmf3q.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdfowmf3q.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdfowmf3q.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            else:\n                paren_stack.pop()\n        if len(paren_stack) > max_depth:\n            max_depth = len(paren_stack)\n    return [max_depth - len(paren_stack) + 1] * max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp4clnx0ae.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp4clnx0ae.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp4clnx0ae.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            paren_stack.pop()\n        else:\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            paren_stack[-1] += paren\n    return [len(paren_stack) - 1] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmppdpvduta.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmppdpvduta.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppdpvduta.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmppdpvduta.py\", line 21, in parse_nested_parens\n    raise ValueError('Invalid parentheses string')\nValueError: Invalid parentheses string\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            continue\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpi8kx8h6s.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpi8kx8h6s.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpi8kx8h6s.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            continue\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpun0zwbq9.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpun0zwbq9.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpun0zwbq9.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmptg4vmnl9.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmptg4vmnl9.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptg4vmnl9.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmptg4vmnl9.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmptg4vmnl9.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmptg4vmnl9.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpi5aur83r.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpi5aur83r.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpi5aur83r.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                depth = len(paren_stack)\n                paren_stack.pop()\n                if depth > max_depth:\n                    max_depth = depth\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpm_a5my8w.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmpm_a5my8w.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpm_a5my8w.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count < 0:\n                raise ValueError('Invalid parentheses')\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            if paren_count == paren_stack[-1]:\n                paren_stack.pop()\n            else:\n                raise ValueError('Invalid parentheses')\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpwuq2gmqp.py\", line 37, in <module>\n    test_check()\n  File \"/tmp/tmpwuq2gmqp.py\", line 35, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwuq2gmqp.py\", line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            else:\n                paren_stack.append(paren_count)\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdfowmf3q.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdfowmf3q.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdfowmf3q.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_stack.append(i)\n        elif char == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpmvx9aijq.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpmvx9aijq.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpmvx9aijq.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_stack.append(i)\n        elif char == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmph3q0ov2e.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmph3q0ov2e.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmph3q0ov2e.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    result = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                result.append(i)\n            else:\n                result.append(paren_stack.pop())\n    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkxw87nsv.py\", line 31, in <module>\n    test_check()\n  File \"/tmp/tmpkxw87nsv.py\", line 29, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkxw87nsv.py\", line 24, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            last_paren = paren_stack.pop()\n            if len(paren_stack) > 0:\n                max_depth = max(max_depth, len(paren_stack))\n            else:\n                max_depth = max(max_depth, i - last_paren)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp5rs74gf5.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmp5rs74gf5.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp5rs74gf5.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for paren in paren_string.split(' '):\n        if paren == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n            paren_stack.pop()\n        else:\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                return [len(paren_stack)] + parse_nested_parens(paren_stack[-1])\n    return [len(paren_stack)] + parse_nested_parens(paren_stack[-1])\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp234mdrqu.py\", line 32, in <module>\n    test_check()\n  File \"/tmp/tmp234mdrqu.py\", line 30, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp234mdrqu.py\", line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n        if len(paren_stack) > max_depth:\n            max_depth = len(paren_stack)\n    return [max_depth - len(paren_stack) + 1] * max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu1roq7qh.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu1roq7qh.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu1roq7qh.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            last_paren_index = paren_stack.pop()\n            if len(paren_stack) > 0:\n                max_depth = max(max_depth, len(paren_stack))\n            else:\n                max_depth = max(max_depth, i - last_paren_index)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmppyltocqu.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmppyltocqu.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmppyltocqu.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpilmy637u.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpilmy637u.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpilmy637u.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            if paren_count < 0:\n                raise ValueError('Invalid parentheses')\n        else:\n            pass\n    raise ValueError('Invalid parentheses')\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp1y3wc8jt.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmp1y3wc8jt.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1y3wc8jt.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_stack.append(i)\n        elif char == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            paren_stack.pop()\n            if len(paren_stack) == max_depth:\n                max_depth = max(max_depth, len(paren_stack))\n    return [len(paren_stack) - 1] * max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpjomfax4s.py\", line 32, in <module>\n    test_check()\n  File \"/tmp/tmpjomfax4s.py\", line 30, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpjomfax4s.py\", line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count < 0:\n                raise ValueError('Invalid parentheses')\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            if paren_count == paren_stack[-1]:\n                paren_stack.pop()\n            else:\n                raise ValueError('Invalid parentheses')\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpwuq2gmqp.py\", line 37, in <module>\n    test_check()\n  File \"/tmp/tmpwuq2gmqp.py\", line 35, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpwuq2gmqp.py\", line 30, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            paren_stack.append(paren_count)\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp5v21xxag.py\", line 32, in <module>\n    test_check()\n  File \"/tmp/tmp5v21xxag.py\", line 30, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp5v21xxag.py\", line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return [max(x, y) for x, y in zip(paren_stack, paren_stack[1:])]\n            else:\n                paren_stack.pop()\n    return []\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp6hcq_xwz.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp6hcq_xwz.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6hcq_xwz.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            last_paren_index = paren_stack.pop()\n            max_depth = max(max_depth, len(paren_stack))\n            if len(paren_stack) == 0:\n                break\n            else:\n                i = last_paren_index\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp7czbf8zq.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmp7czbf8zq.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp7czbf8zq.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    result = []\n    for paren in paren_string.split(' '):\n        if paren == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n            if len(paren_stack) > 0:\n                result.append(len(paren_stack))\n                paren_stack.pop()\n            else:\n                raise ValueError('Mismatched parentheses')\n    if len(paren_stack) > 0:\n        raise ValueError('Mismatched parentheses')\n    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp6s_peo8n.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmp6s_peo8n.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp6s_peo8n.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_stack.append(i)\n        elif char == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp2aiodmze.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp2aiodmze.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp2aiodmze.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            nesting = len(paren_stack) - 1\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp9ii5bpq4.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp9ii5bpq4.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp9ii5bpq4.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [i]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpskmp6ck5.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpskmp6ck5.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpskmp6ck5.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            nesting = len(paren_stack) - len(paren_stack) % 2\n            if nesting > max_nesting:\n                max_nesting = nesting\n            paren_stack.pop()\n    return [max_nesting] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmps9jtxp66.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmps9jtxp66.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmps9jtxp66.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n            if len(paren_stack) > 0:\n                paren_stack.pop()\n            else:\n                return [0]\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpp75fqiwb.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpp75fqiwb.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpp75fqiwb.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpx_p1lm92.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpx_p1lm92.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpx_p1lm92.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    result = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                result.append(0)\n            else:\n                result.append(len(paren_stack) - 1)\n            paren_stack.pop()\n    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpn4n8kzo1.py\", line 32, in <module>\n    test_check()\n  File \"/tmp/tmpn4n8kzo1.py\", line 30, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpn4n8kzo1.py\", line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdxwwjjyb.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdxwwjjyb.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdxwwjjyb.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            elif paren_count < 0:\n                raise ValueError('Invalid parentheses')\n        elif paren_string[i] == ' ':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                return paren_stack\n    raise ValueError('Invalid parentheses')\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp1vruutf8.py\", line 38, in <module>\n    test_check()\n  File \"/tmp/tmp1vruutf8.py\", line 36, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp1vruutf8.py\", line 31, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Invalid parentheses string\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp5qnp6ja1.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp5qnp6ja1.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp5qnp6ja1.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    result = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                result.append(0)\n            else:\n                result.append(len(paren_stack) - 1)\n            paren_stack.pop()\n    return result\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpn4n8kzo1.py\", line 32, in <module>\n    test_check()\n  File \"/tmp/tmpn4n8kzo1.py\", line 30, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpn4n8kzo1.py\", line 25, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp0vhwxug_.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmp0vhwxug_.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp0vhwxug_.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmp0vhwxug_.py\", line 25, in parse_nested_parens\n    raise ValueError('Invalid parentheses string')\nValueError: Invalid parentheses string\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n        else:\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmplhw435co.py\", line 36, in <module>\n    test_check()\n  File \"/tmp/tmplhw435co.py\", line 34, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmplhw435co.py\", line 29, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n  File \"/tmp/tmplhw435co.py\", line 25, in parse_nested_parens\n    raise ValueError('Invalid parentheses')\nValueError: Invalid parentheses\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            else:\n                paren_stack.append(paren_count)\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdfowmf3q.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdfowmf3q.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdfowmf3q.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Unbalanced parentheses')\n            else:\n                paren_stack.pop()\n        if len(paren_stack) > max_depth:\n            max_depth = len(paren_stack)\n    return [max_depth - len(paren_stack) + 1] * max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp4clnx0ae.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp4clnx0ae.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp4clnx0ae.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662863133
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpqe8fl0i2.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpqe8fl0i2.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqe8fl0i2.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662891960
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return paren_stack\n            else:\n                paren_stack.append(paren_count)\n    return paren_stack\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdfowmf3q.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdfowmf3q.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdfowmf3q.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_nesting = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses')\n            else:\n                nesting = len(paren_stack) - 1\n                if nesting > max_nesting:\n                    max_nesting = nesting\n                paren_stack.pop()\n    return [max_nesting]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp141ivmtk.py\", line 34, in <module>\n    test_check()\n  File \"/tmp/tmp141ivmtk.py\", line 32, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp141ivmtk.py\", line 27, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662891960
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    paren_count = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(paren_count)\n            paren_count += 1\n        elif paren_string[i] == ')':\n            paren_count -= 1\n            if paren_count == 0:\n                return [max(x, y) for x, y in zip(paren_stack, paren_stack[1:])]\n            else:\n                paren_stack.pop()\n    return [0]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpewz69j_4.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpewz69j_4.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpewz69j_4.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662891960
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError(\"Mismatched parentheses\")\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp38mngu1g.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmp38mngu1g.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp38mngu1g.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid input')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpz73eq9gt.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpz73eq9gt.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpz73eq9gt.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662891960
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) == 0:\n                    max_depth = max(max_depth, len(paren_stack))\n                else:\n                    max_depth = max(max_depth, len(paren_stack))\n    return max_depth\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpqzujx4bk.py\", line 35, in <module>\n    test_check()\n  File \"/tmp/tmpqzujx4bk.py\", line 33, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpqzujx4bk.py\", line 28, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662891960
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Invalid parentheses string')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpu7uhy34d.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpu7uhy34d.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpu7uhy34d.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                return [0]\n            else:\n                paren_stack.pop()\n    return [len(paren_stack)]\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpkaa535_h.py\", line 30, in <module>\n    test_check()\n  File \"/tmp/tmpkaa535_h.py\", line 28, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpkaa535_h.py\", line 23, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    for paren in paren_string.split():\n        if paren == '(':\n            paren_stack.append(paren)\n        elif paren == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            paren_stack.pop()\n    return len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmp79easa06.py\", line 29, in <module>\n    test_check()\n  File \"/tmp/tmp79easa06.py\", line 27, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmp79easa06.py\", line 22, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1662891960
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            paren_stack.append(i)\n        elif c == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_stack)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpdxwwjjyb.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpdxwwjjyb.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpdxwwjjyb.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    },
    {
      "exit_code": 1,
      "program": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = []\n    max_depth = 0\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            paren_stack.append(i)\n        elif paren_string[i] == ')':\n            if len(paren_stack) == 0:\n                raise ValueError('Mismatched parentheses')\n            else:\n                paren_stack.pop()\n                if len(paren_stack) > max_depth:\n                    max_depth = len(paren_stack)\n    return [max_depth] * len(paren_string)\n\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n\ndef test_check():\n    check(parse_nested_parens)\n\ntest_check()\n",
      "status": "Exception",
      "stderr": "Traceback (most recent call last):\n  File \"/tmp/tmpxiikgt22.py\", line 33, in <module>\n    test_check()\n  File \"/tmp/tmpxiikgt22.py\", line 31, in test_check\n    check(parse_nested_parens)\n  File \"/tmp/tmpxiikgt22.py\", line 26, in check\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\nAssertionError\n",
      "stdout": "",
      "timestamp": 1661984036
    }
  ]
}