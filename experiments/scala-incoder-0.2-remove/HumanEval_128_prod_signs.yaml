name: HumanEval_128_prod_signs
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // You are given an array arr of integers and you need to return\n    // sum\
  \ of magnitudes of integers multiplied by product of all signs\n    // of each number\
  \ in the array, represented by 1, -1 or 0.\n    // Note: return None for empty arr.\n\
  \    // Example:\n    def prodSigns(arr : List[Long]) : Option[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(prodSigns((List[Long](1l.toLong,\
  \ 2l.toLong, 2l.toLong, -4l.toLong))).equals(-9l));\n    assert(prodSigns((List[Long](0l.toLong,\
  \ 1l.toLong))).equals(0l));\n    assert(prodSigns((List[Long](1l.toLong, 1l.toLong,\
  \ 1l.toLong, 2l.toLong, 3l.toLong, -1l.toLong, 1l.toLong))).equals(-10l));\n   \
  \ assert(prodSigns((List[Long]())).equals(None));\n    assert(prodSigns((List[Long](2l.toLong,\
  \ 4l.toLong, 1l.toLong, 2l.toLong, -1l.toLong, -1l.toLong, 9l.toLong))).equals(20l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, -1l.toLong, 1l.toLong))).equals(4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 1l.toLong))).equals(-4l));\n\
  \    assert(prodSigns((List[Long](-1l.toLong, 1l.toLong, 1l.toLong, 0l.toLong))).equals(0l));\n\
  \    }\n\n}\n"
completions: ["        val product = arr.foldLeft(1L) {\n            (product, value)\
    \ => product * value\n        }\n        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.foldLeft(product) {\n            (sum, value) =>\
    \ sum + value\n        }\n        Some(sum)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum", "        val product = arr.foldLeft(1L) { (product, element)\
    \ => product * element }\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        signs.foldLeft(product) { (product, sign) => product\
    \ * sign }", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        val product = signs.foldLeft(1L) { (x, y) => x * y }\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(0L)\
    \ { (x, y) => x + y }\n        val result = Some(product * sum)\n        result",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ product = arr.foldLeft(1L) { (product, elem) =>\n            product * elem\n\
    \        }\n        val signs = arr.map(elem => if (elem < 0) -1 else if (elem\
    \ > 0) 1 else 0)\n        val magnitudes = signs.map(elem => math.abs(elem))\n\
    \        magnitudes.zip(product).map(elem => elem._1 * elem._2).sum", "      \
    \  val product = arr.foldLeft(1L) { (product, num) => product * num }\n      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ magnitudes = signs.map(x => math.abs(x))\n        val magnitudesProduct = magnitudes.foldLeft(1L)\
    \ { (product, magnitude) => product * magnitude }\n        val result = magnitudesProduct\
    \ * product\n        Some(result)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val m = arr.map(x => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n\
    \        Some(s * m)", "        val m = arr.map(x => math.abs(x)).sum\n      \
    \  val s = arr.map(x => math.signum(x)).sum\n        val product = arr.map(x =>\
    \ math.signum(x) * math.abs(x)).sum\n        Some(product * math.abs(m) / s)",
  "        val product = arr.map(x => x * x).sum\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs * product)",
  "        val m = arr.map(x => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n\
    \        Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum", " \
    \       val product = arr.foldLeft(1L) { (product, num) => product * num }\n \
    \       val signs = arr.map(num => if (num < 0) -1 else if (num > 0) 1 else 0)\n\
    \        val magnitudes = signs.map(num => math.abs(num))\n        magnitudes.zip(product).map(x\
    \ => x._1 * x._2)", "        val product = arr.map(x => x * x).sum\n        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduceLeft(_ + _)\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.getOrElse(0))\n\
    \        val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val product = arr.map(x => x * x).sum\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs * product)",
  "        val product = arr.map(x => x * x).sum\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x\
    \ => math.abs(x))\n        magnitudes.sum", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.foldLeft(0L)(_ + _)\n        Some(sum * product)", "        val m\
    \ = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.product\n        val result =\
    \ Some(signs.map(x => x * product).sum * m)\n        result", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitude = product.map(x => math.abs(x))\n\
    \        magnitude.sum", "        val product = arr.foldLeft(1L) { (product, element)\
    \ => product * element }\n        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        magnitudes.zip(product).map { case (mag, prod) => mag * prod }", "  \
    \      val m = arr.map(x => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n\
    \        val product = arr.map(x => math.signum(x) * math.abs(x)).sum\n      \
    \  Some(product * math.abs(m) / s)", "        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x => x\
    \ * product).getOrElse(None)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.product\n        val\
    \ magnitudes = signs.map(x => math.abs(x))\n        magnitudes.sum * product",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n\
    \        val mag = product.map(x => math.abs(x)).sum\n        mag match {\n  \
    \          case 0 => None\n            case x if x == x => Some(sum)\n       \
    \     case x => Some(sum - mag)\n        }", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.product\n        val result = signs.map(x => x * product).sum\n\
    \        Some(result)", "        val m = arr.map(x => math.abs(x)).reduceLeft(_\
    \ * _)\n        val s = arr.map(x => math.signum(x)).reduceLeft(_ * _)\n     \
    \   Some(m * s)", "        val product = arr.foldLeft(1L) { (product, value) =>\
    \ product * value }\n        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n     \
    \   magnitudes.zip(product).map { case (mag, prod) => mag * prod }", "       \
    \ val m = arr.map(_.abs).sum\n        val n = arr.map(_.signum).sum\n        Some(arr.map(x\
    \ => x * m * n).sum)", "        val product = arr.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val signs = arr.map(x => if (x == 0) -1 else if\
    \ (x == 1) 1 else 0)\n        signs.foldLeft(product) { (product, sign) => product\
    \ * sign }", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        val product = arr.map(x => x * signs.sum)\n        val magnitudes\
    \ = product.map(x => math.abs(x))\n        magnitudes.sum", "        val m = arr.map(_.abs).sum\n\
    \        val s = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n  \
    \      Some(m * s)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        product.sum",
  "        val product = arr.foldLeft(1L) { (product, value) => product * value }\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val magnitudes = signs.map(x => math.abs(x))\n        magnitudes.foldLeft(product)\
    \ { (product, magnitude) => product * magnitude }", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x)).sum\n        val result = mag if sum == 0 else mag / sum\n \
    \       Some(result)", "        val product = arr.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n  \
    \      magnitudes.zip(product).map(x => x._1 * x._2)", "        val result = arr.foldLeft(0L)\
    \ {\n            (acc, x) => acc + (if (x < 0) -1 * x else x * 1)\n        }\n\
    \        if (result > 0) Some(result) else None", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        val productOfSigns = product.map(x => x\
    \ * signs.sum)\n        val productOfMagnitudes = productOfSigns.map(x => math.abs(x))\n\
    \        val productOfMagnitudesSum = productOfMagnitudes.sum\n        val productOfMagnitudesProduct\
    \ = productOfMagnitudes.map(x => x * signs.sum)\n        val productOfMagnitudesProductSum\
    \ = productOfMagnitudesProduct.sum\n        val productOfMagnitudesProductProduct\
    \ = productOfMagnitudesProduct.map(x => x * signs.sum)\n        val productOfMagnitudesProductProductSum\
    \ = productOfMagnitudesProductProduct.sum\n        val productOfMagnitudesProductProductProduct\
    \ = productOfMagnitudesProductProduct.map(x => x * signs.sum)\n        val productOfMagnitudesProductProductProductSum\
    \ = productOfMagnitudesProductProductProduct.sum\n        val productOfMagnitudesProductProductProductProduct\
    \ = productOfMagnitudesProductProductProduct.map(x => x * signs.sum)\n       \
    \ val productOfMagnitudesProductProductProductProductSum = productOfMagnitudesProductProductProductProduct.sum\n\
    \        val productOfMagnitudesProductProductProductProductProduct = productOfMagnitudesProductProductProductProduct.map(x\
    \ => x * signs.sum)\n        val productOfMagnitudesProductProductProductProductSum\
    \ = productOfMagnitudesProductProductProductProduct.sum\n        val productOfMagnitudesProductProductProductProductProduct\
    \ = productOfMagnitudesProductProductProductProduct.map(x => x * signs.sum)\n\
    \        val productOfMagnitudesProductProductProductProductProductSum = productOfMagnitudesProductProductProductProductProduct.sum\n\
    \        val productOfMagnitudesProductProductProductProductProduct = productOfMagnitudesProductProductProductProductProduct.map(x\
    \ => x * signs.sum)\n        val productOfMagnitudesProductProductProductProductProductSum\
    \ = productOfMagnitudesProductProductProductProductProduct.sum\n        val productOfMagnitudesProductProductProductProductProductProduct\
    \ = productOfMagnitudesProduct", "        val product = arr.foldLeft(1L) { (product,\
    \ elem) => product * elem}\n        val signs = arr.map(x => if (x == 0) -1 else\
    \ if (x == -1) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ product = arr.foldLeft(1L) { (product, elem) => product * elem * sign }\n  \
    \      val sign = arr.foldLeft(1L) { (sign, elem) => sign * elem * sign }\n  \
    \      Some(product)", "        val product = arr.map(x => x * x).sum\n      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n    \
    \    Some(signs * product)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n  \
    \      val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val m = arr.map(_.abs).sum\n        val s = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0).sum\n        Some(s * m)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val sum = product.sum\n        val mag = product.map(x\
    \ => math.abs(x)).sum\n        mag match {\n            case 0 => None\n     \
    \       case x if x == 0 => Some(sum)\n            case x => Some(sum - mag)\n\
    \        }", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(0L)(_ + _)\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.product\n        val\
    \ magnitudes = signs.map(x => math.abs(x))\n        magnitudes.sum", "       \
    \ val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x\
    \ => math.abs(x))\n        magnitudes.sum", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.reduce(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x\
    \ => x * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ sum = product.sum\n        val mag = product.map(x => math.abs(x)).sum\n   \
    \     val mag2 = mag * mag\n        val mag3 = mag2 * mag\n        val mag4 =\
    \ mag3 * mag\n        val mag5 = mag4 * mag\n        val mag6 = mag5 * mag\n \
    \       val mag7 = mag6 * mag\n        val mag8 = mag7 * mag\n        val mag9\
    \ = mag8 * mag\n        val mag10 = mag9 * mag\n        val mag11 = mag10 * mag\n\
    \        val mag12 = mag11 * mag\n        val mag13 = mag12 * mag\n        val\
    \ mag14 = mag13 * mag\n        val mag15 = mag14 * mag\n        val mag16 = mag15\
    \ * mag\n        val mag17 = mag16 * mag\n        val mag18 = mag17 * mag\n  \
    \      val mag19 = mag18 * mag\n        val mag20 = mag19 * mag\n        val mag21\
    \ = mag20 * mag\n        val mag22 = mag21 * mag\n        val mag23 = mag22 *\
    \ mag\n        val mag24 = mag23 * mag\n        val mag25 = mag24 * mag\n    \
    \    val mag26 = mag25 * mag\n        val mag27 = mag26 * mag\n        val mag28\
    \ = mag27 * mag\n        val mag29 = mag28 * mag\n        val mag30 = mag29 *\
    \ mag\n        val mag31 = mag30 * mag\n        val mag32 = mag31 * mag\n    \
    \    val mag33 = mag32 * mag\n        val mag34 = mag33 * mag\n        val mag35\
    \ = mag34 * mag\n        val mag36 = mag35 * mag\n        val mag37 = mag36 *\
    \ mag\n        val mag38 = mag37 * mag\n        val mag39 = mag38 * mag\n    \
    \    val mag40 = mag39 * mag\n        val mag41 = mag40 * mag\n        val mag42\
    \ = mag41 * mag\n        val mag43 = mag42 * mag\n        val mag44 = mag43 *\
    \ mag\n        val mag45 = mag44 * mag\n        val mag46 = mag45 * mag\n    \
    \    val mag47 = mag46 * mag\n        val mag48 = mag47 * mag\n        val mag49\
    \ = mag48 * ", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val magnitudes\
    \ = product.map(x => math.abs(x))\n        magnitudes.sum", "        val m = arr.map(x\
    \ => math.abs(x)).foldLeft(0)(_ * _)\n        val signs = arr.map(x => math.signum(x)).foldLeft(0)(_\
    \ * _)\n        Some(signs * m)", "        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        product.sum", "        val m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n\
    \        Some(arr.map(x => x * Math.signum(x) * Math.sign(x) * m * s).sum)", " \
    \       val m = arr.map(_.abs).sum\n        val n = arr.map(_.signum).sum\n  \
    \      Some(m * n)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum", "     \
    \   val m = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n\
    \        Some(signs.map(x => x * product).sum / m)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.reduceLeft(_ * _)\n        magnitudes.map(x\
    \ => x * product).sum", "        val m = arr.map(_.abs).sum\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.foldLeft(1L)(_ * _)\n        Some(signs.map(x => x * product).sum)",
  "        val m = arr.map(x => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n\
    \        Some(m * s)", "        val product = arr.map(x => x * x).sum\n      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ magnitudes = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map\
    \ { case (m, p) => m * p }", "        val product = arr.foldLeft(1L)(_ * _)\n\
    \        val signs = arr.map(x => if (x < 0) -1 else 1)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map { case (mag,\
    \ prod) => (mag * prod) }", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n  \
    \      val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitude = product.map(x\
    \ => math.abs(x))\n        magnitude.sum", "        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x *\
    \ signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n        val\
    \ sum = magnitudes.sum\n        val productSigns = product.map(x => x * signs.sum)\n\
    \        val magnitudesSigns = magnitudes.map(x => math.abs(x))\n        val productSignsSum\
    \ = productSigns.sum\n        val magnitudesSignsSum = magnitudesSigns.sum\n \
    \       if (productSignsSum == sum && magnitudesSignsSum == sum) {\n         \
    \   Some(magnitudes.sum)\n        } else {\n            None\n        }", "  \
    \      val m = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.product\n        Some(signs.map(x\
    \ => x * product).sum * m)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n  \
    \      val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduceLeft(_ * _)\n        val magnitude = arr.map(x\
    \ => math.abs(x)).sum\n        Some(magnitude * product)", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val product = arr.foldLeft(1L)\
    \ { (product, num) => product * num }\n        val signs = arr.map(num => if (num\
    \ < 0) -1 else 1)\n        signs.foldLeft(product) { (product, sign) => product\
    \ * sign}", "        val m = arr.map(_.abs).sum\n        val s = arr.map(_.signum).sum\n\
    \        val p = arr.map(_.toInt).sum\n        Some(m + (m * p) + (s * p))", " \
    \       val m = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n\
    \        Some(signs.map(x => x * product).sum * m)", "        val m = arr.map(x\
    \ => math.abs(x)).foldLeft(0)(_ * _)\n        val signs = arr.map(x => math.signum(x)).foldLeft(0)(_\
    \ * _)\n        Some(m * signs)", "        val result = arr.foldLeft(0L) {\n \
    \           (sum, element) => sum + element * math.signum(element)\n        }\n\
    \        Some(result)", "        val product = arr.foldLeft(1L)(_ * _)\n     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ signs.foldLeft(product)((x, y) => x * y)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n   \
    \     magnitudes.sum", "        val product = arr.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n  \
    \      magnitudes.zip(product).map(x => x._1 * x._2).sum", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n\
    \        magnitudes.sum", "        val m = arr.map(_.abs).sum\n        val s =\
    \ arr.map(x => math.signum(x)).sum\n        Some(m * s)", "        val product\
    \ = arr.foldLeft(1L) { (product, elem) => product * elem }\n        val signs\
    \ = arr.map(elem => if (elem < 0) -1 else if (elem > 0) 1 else 0)\n        val\
    \ magnitudes = signs.map(elem => math.pow(elem, 2))\n        magnitudes.zip(product).map\
    \ { case (mag, prod) => mag * prod }", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes\
    \ = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0)((acc, x) =>\
    \ acc * x._1 * x._2)", "        val product = arr.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n  \
    \      val result = magnitudes.foldLeft(product) { (product, magnitude) => product\
    \ * magnitude }\n        Some(result)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val product = signs.zip(magnitudes).map(x => x._1 * x._2)\n        val\
    \ sum = product.sum\n        val result = if (sum > 0) Some(sum) else None\n \
    \       result", "        val product = arr.foldLeft(1L) { (product, elem) =>\
    \ product * elem }\n        val signs = arr.map(elem => if (elem < 0) -1 else\
    \ if (elem > 0) 1 else 0)\n        signs.foldLeft(product) { (product, sign) =>\
    \ product * sign }", "        val m = arr.map(_.abs).sum\n        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ signs.foldLeft(1L)(_ * _)\n        Some(signs.map(x => x * product).sum * m)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        magnitudes.zip(signs).map(x => x * product)", "   \
    \     val product = arr.foldLeft(1L) { (product, value) => product * value }\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val magnitudes = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map\
    \ { case (m, p) => m * p }", "        val product = arr.foldLeft(1L) { (product,\
    \ num) =>\n            product * num\n        }\n        val signs = arr.map(num\
    \ => if (num > 0) 1 else -1)\n        val magnitudes = signs.map(num => math.abs(num))\n\
    \        magnitudes.zip(product).map {\n            case (mag, prod) => mag *\
    \ prod\n        }.sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        val productSigns\
    \ = product.map(x => if (x == 0) 0 else math.signum(x))\n        val magnitudeSigns\
    \ = magnitudes.map(x => math.signum(x))\n        val productMagnitudes = productSigns.zip(magnitudeSigns)\n\
    \        val productMagnitudesSum = productMagnitudes.map(x => x._1 * x._2)\n\
    \        val productMagnitudesSumSum = productMagnitudesSum.sum\n        val productMagnitudesSumSumProduct\
    \ = productMagnitudesSumSum * product\n        val productMagnitudesSumSumProductSum\
    \ = productMagnitudesSumSumProduct.sum\n        val productMagnitudesSumSumProductSumProduct\
    \ = productMagnitudesSumSumProductSum * product\n        val productMagnitudesSumSumProductSumProductSum\
    \ = productMagnitudesSumSumProductSumProduct.sum\n        val productMagnitudesSumSumProductSumProductSumProduct\
    \ = productMagnitudesSumSumProductSumProductSum * product\n        val productMagnitudesSumSumProductSumProductSumProductSum\
    \ = productMagnitudesSumSumProductSumProductSum * product\n        val productMagnitudesSumSumProductSumProductSumProductSum\
    \ = productMagnitudesSumSumProductSumProductSum * product\n        val productMagnitudesSumSumProductSumProductSumProductSumProduct\
    \ = productMagnitudesSumSumProductSumProductSumProductSum * product\n        val\
    \ productMagnitudesSumSumProductSumProductSumProductSumProduct = productMagnitudesSumSumProductSumProductSumProductSum\
    \ * product\n        val productMagnitudesSumSumProductSumProductSumProductSumProductSum\
    \ = productMagnitudesSumSumProductSumProductSumProductSum * product\n        val\
    \ productMagnitudesSumSumProductSumProductSumProductSumProductSum = productMagnitudesSumSumProductSumProductSumProductSum\
    \ * product\n        val productMagnitudesSumSumProductSumProductSumProductSumProductSumProduct\
    \ = productMagnitudesSumSumProductSumProductSumProductSumProductSum * product\n\
    \        val productMagnitudesSumSumProductSumProductSumProductSumProduct", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x) * product)\n        magnitudes.sum", "        val product = arr.foldLeft(1L)\
    \ { (product, num) =>\n            product * num\n        }\n        val signs\
    \ = arr.map(num => if (num > 0) 1 else -1)\n        val magnitudes = signs.map(num\
    \ => math.abs(num))\n        magnitudes.foldLeft(product) { (product, magnitude)\
    \ =>\n            product * magnitude\n        }", "        val product = arr.foldLeft(1L)\
    \ { (product, value) => product * value }\n        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product) { (product,\
    \ sign) => product * sign }", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.product\n        val\
    \ magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.product\n        val\
    \ magnitudes = signs.map(x => math.abs(x)).sum\n        val sum = magnitudes *\
    \ product\n        Some(sum)", "        val m = arr.map(_.abs).sum\n        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.product\n        Some(signs.map(x => x * product).sum * m)", "     \
    \   val m = arr.map(_.abs).sum\n        val n = arr.map(_.signum).sum\n      \
    \  Some(arr.map(x => x * m / n).sum)", "        val signs = arr.map(x => if (x\
    \ < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        val magnitude = product.map(x => math.abs(x))\n        val sum = magnitude.sum\n\
    \        Some(sum)", "        val product = arr.foldLeft(1L) { (product, value)\
    \ =>\n            product * value }\n        val signs = arr.map(x => if (x <\
    \ 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        Some(sum * product)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.getOrElse(0))\n        val sum = product.sum\n    \
    \    val mag = product.map(x => math.abs(x)).sum\n        mag match {\n      \
    \      case 0 => None\n            case x if x == 0 => Some(sum)\n           \
    \ case x => Some(sum - mag)\n        }", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.foldLeft(1L)(_ * _)\n        Some(signs.map(x => x\
    \ * product).sum * m)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum", " \
    \       val m = arr.map(x => math.abs(x)).sum\n        val n = arr.map(x => math.signum(x)).sum\n\
    \        Some(m * n)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   product.sum", "        val product = arr.foldLeft(1L)(_ * _)\n        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)((x,\
    \ y) => x * y)", "        val m = arr.map(_.abs).sum\n        val n = arr.map(_.signum).sum\n\
    \        val product = arr.map(x => x * x * x).sum\n        Some((m * n * product).abs)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x\
    \ => math.abs(x))\n        magnitudes.sum", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x =>\
    \ x * signs.sum)\n        val magnitudes = product.map(x => math.abs(x))\n   \
    \     magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   product.sum", "        val m = arr.map(x => math.abs(x)).sum\n        val\
    \ s = arr.map(x => math.signum(x)).sum\n        Some(m * s)", "        val m =\
    \ arr.map(x => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n\
    \        Some(s * m)", "        val product = arr.foldLeft(1L) { (product, value)\
    \ => product * value }\n        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n  \
    \      magnitudes.zip(product).map(x => x._1 * x._2)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitude = product.map(x => math.abs(x))\n \
    \       magnitude.sum", "        val m = arr.map(_.abs).sum\n        val n = arr.map(_.signum).sum\n\
    \        Some(m * n)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n     \
    \   val sum = product.sum\n        val magnitude = product.map(x => math.abs(x)).sum\n\
    \        val result = if (magnitude == 0) None else Some(magnitude)\n        result",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        val productOfSigns\
    \ = product.map(x => x * signs.sum)\n        val productOfMagnitudes = productOfSigns.map(x\
    \ => math.abs(x))\n        val productOfMagnitudesSum = productOfMagnitudes.sum\n\
    \        val productOfMagnitudesProduct = productOfMagnitudes.map(x => x * signs.sum)\n\
    \        val productOfMagnitudesProductSum = productOfMagnitudesProduct.sum\n\
    \        val productOfMagnitudesProductProduct = productOfMagnitudesProduct.map(x\
    \ => x * signs.sum)\n        val productOfMagnitudesProductProductSum = productOfMagnitudesProductProduct.sum\n\
    \        val productOfMagnitudesProductProductProduct = productOfMagnitudesProductProduct.map(x\
    \ => x * signs.sum)\n        val productOfMagnitudesProductProductProductSum =\
    \ productOfMagnitudesProductProductProduct.sum\n        val productOfMagnitudesProductProductProductProduct\
    \ = productOfMagnitudesProductProductProduct.map(x => x * signs.sum)\n       \
    \ val productOfMagnitudesProductProductProductProductSum = productOfMagnitudesProductProductProductProduct.sum\n\
    \        val productOfMagnitudesProductProductProductProductProduct = productOfMagnitudesProductProductProductProduct.map(x\
    \ => x * signs.sum)\n        val productOfMagnitudesProductProductProductProductSum\
    \ = productOfMagnitudesProductProductProductProduct.sum\n        val productOfMagnitudesProductProductProductProductProduct\
    \ = productOfMagnitudesProductProductProductProduct.map(x => x * signs.sum)\n\
    \        val productOfMagnitudesProductProductProductProductProductSum = productOfMagnitudesProductProductProductProductProduct.sum\n\
    \        val productOfMagnitudesProductProductProductProductProduct = productOfMagnitudesProductProductProductProductProduct.map(x\
    \ => x * signs.sum)\n        val productOfMagnitudesProductProductProductProductProductSum\
    \ = productOfMagnitudesProductProductProductProductProduct.sum\n        val productOfMagnitudesProductProductProductProductProductProduct\
    \ = productOfMagnitudesProduct", "        val m = arr.map(_.abs).sum\n       \
    \ val n = arr.map(_.signum).sum\n        Some(arr.map(x => x * m / n).sum)", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        magnitudes.sum", "        val product = arr.foldLeft(1L){ (product, value)\
    \ => product * value }\n        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        signs.foldLeft(product){ (product, sign) => product\
    \ * sign }", "        val result = arr.foldLeft(0L) { (sum, num) =>\n        \
    \    val sign = if (num < 0) -1 else 1\n            sum + sign * math.abs(num)\n\
    \        }\n        if (result > 0) Some(result) else None", "        val m =\
    \ arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n        Some(signs.sum\
    \ * product / m)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ magnitudes = product.map(math.abs)\n        magnitudes.sum", "        val m\
    \ = arr.map(x => math.abs(x)).sum\n        val s = arr.map(x => math.signum(x)).sum\n\
    \        Some(m * s)", "        val product = arr.foldLeft(1L)(_ * _)\n      \
    \  val signs = arr.map(x => if (x < 0) -1 else 1)\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        magnitudes.map(x => product * x)", "        val product\
    \ = arr.foldLeft(1L) { (product, elem) => product * elem * signOfInt(elem) }\n\
    \        val magnitudes = arr.map(x => math.abs(x))\n        val signs = arr.map(x\
    \ => signOfInt(x))\n        magnitudes.zip(signs).map { case (mag, sign) => mag\
    \ * sign * product }", "        val product = arr.foldLeft(1L)(_ * _)\n      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_\
    \ * _)", "        val product = arr.foldLeft(1L) { (product, value) => product\
    \ * value }\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map(x\
    \ => x._1 * x._2).sum", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n       \
    \ val magnitudes = arr.map(x => math.abs(x) * product)\n        magnitudes.sum",
  "        val product = arr.foldLeft(1L) { (product, value) => product * value }\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val magnitudes = signs.map(x => math.abs(x))\n        magnitudes.zip(product).map(x\
    \ => x._1 * x._2)", "        val m = arr.map(_.abs).sum\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs * m * math.signum(arr.sum))",
  "        val m = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n\
    \        Some(signs.map(x => x * product).sum * m)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.map(x => x * magnitudes.getOrElse(0)).sum\n\
    \        Some(product)", "        val product = arr.foldLeft(1L) { (product, value)\
    \ =>\n            product * value\n        }\n        val signs = arr.map(x =>\
    \ if (x == 0) -1 else if (x == 1) 1 else 0)\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        magnitudes.zip(product).map(x => x._1 * x._2)", " \
    \       val m = arr.map(_.abs).sum\n        val n = arr.map(_.signum).sum\n  \
    \      Some(arr.map(x => x * m * n).sum)", "        val result = arr.foldLeft(0L)\
    \ { (sum, num) =>\n            val sign = if (num < 0) -1 else 1\n           \
    \ sum + sign * math.abs(num)\n        }\n        val product = arr.foldLeft(1L)\
    \ { (product, num) =>\n            product * math.signum(num)\n        }\n   \
    \     Some(math.abs(result) * product)", "        val product = arr.foldLeft(1L){\
    \ (product, elem) => product * elem }\n        val signs = arr.map(elem => if\
    \ (elem < 0) -1 else if (elem > 0) 1 else 0)\n        signs.foldLeft(product){\
    \ (product, sign) => product * sign }", "        val product = arr.map(x => x\
    \ * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else\
    \ 0).sum\n        Some(signs * product)", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n  \
    \      val product = signs.foldLeft(1L)(_ * _)\n        Some(signs.map(x => x\
    \ * product).sum / m)", "        val signs = arr.map(x => if (x < 0) -1 else if\
    \ (x > 0) 1 else 0)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val product = signs.zip(magnitudes).map(x => x._1 * x._2)\n        magnitudes.zip(product).map(x\
    \ => x._1 + x._2)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = signs.reduce(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.reduce(_ + _)\n  \
    \      Some(sum * product)", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n    \
    \    val magnitudes = arr.map(x => math.abs(x))\n        magnitudes.map(x => x\
    \ * product).sum", "        val m = arr.map(x => math.abs(x)).sum\n        val\
    \ s = arr.map(x => math.signum(x)).sum\n        val p = arr.map(x => math.signum(x)\
    \ * math.signum(x)).sum\n        Some(math.abs(m) * math.abs(s) * math.abs(p))",
  "        val product = arr.map(x => x * x).sum\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.reduce(_ * _)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        val sum = magnitudes.reduce(_ + _)\n        val productSign\
    \ = signs.reduce(_ * _)\n        if (sum == product) {\n            Some(product)\n\
    \        } else if (sum < product) {\n            Some(productSign)\n        }\
    \ else {\n            None\n        }", "        val m = arr.map(x => math.abs(x)).sum\n\
    \        val n = arr.map(x => math.signum(x)).sum\n        Some(m * n)", "   \
    \     val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n     \
    \   val magnitudes = arr.map(x => math.abs(x))\n        val product = signs.map(x\
    \ => x * magnitudes.getOrElse(0)).sum\n        val sum = magnitudes.map(x => x\
    \ * product).sum\n        Some(sum)", "        val product = arr.foldLeft(1L)\
    \ { (product, value) => product * value }\n        val signs = arr.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x =>\
    \ math.abs(x))\n        magnitudes.zip(product).map { case (mag, prod) => mag\
    \ * prod }", "        val product = arr.foldLeft(1L) { (product, num) =>\n   \
    \         product * num\n        }\n        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x => math.abs(x))\n\
    \        val sum = magnitudes.sum\n        val productOfSigns = signs.foldLeft(1L)\
    \ { (product, sign) =>\n            product * sign\n        }\n        Some(sum\
    \ * productOfSigns)", "        val m = arr.map(x => math.abs(x)).sum\n       \
    \ val s = arr.map(x => math.signum(x)).sum\n        Some(m * s)", "        val\
    \ result = arr.foldLeft(0L) {\n            (acc, x) => acc + (math.abs(x) * math.signum(x))\n\
    \        }\n        if (result > 0) Some(result) else None", "        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.product\n        val magnitudes = signs.map(x => math.abs(x))\n    \
    \    magnitudes.sum * product", "        val product = arr.foldLeft(1L) { (product,\
    \ value) => product * value }\n        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        signs.foldLeft(product) { (product, sign)\
    \ => product * sign }", "        val product = arr.foldLeft(1L) { (product, elem)\
    \ => product * elem }\n        val signs = arr.map(elem => if (elem < 0) -1 else\
    \ if (elem > 0) 1 else 0)\n        val magnitudes = signs.map(elem => math.abs(elem))\n\
    \        magnitudes.zip(product).map(elem => elem._1 * elem._2).sum", "      \
    \  val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val\
    \ product = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x =>\
    \ math.abs(x))\n        val productMagnitudes = product.zip(magnitudes)\n    \
    \    productMagnitudes.foldLeft(0)((acc, x) => acc + x._1 * x._2)", "        val\
    \ signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        val productMagnitudes = product.zip(magnitudes)\n        productMagnitudes.foldLeft(0)((acc,\
    \ x) => acc * x._1 * x._2)", "        val m = arr.map(_.abs).sum\n        val\
    \ n = arr.map(_.signum).sum\n        Some(arr.map(x => x * x * m * n).sum)", " \
    \       val m = arr.map(x => math.abs(x)).foldLeft(0)(_ * _)\n        val signs\
    \ = arr.map(x => math.signum(x))\n        signs.foldLeft(0)((x, y) => x * y)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(math.abs)\n\
    \        magnitudes.sum", "        val signs = arr.map(x => if (x < 0) -1 else\
    \ if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n  \
    \      val magnitudes = product.map(x => math.abs(x))\n        magnitudes.sum",
  "        val product = arr.foldLeft(1L)(_ * _)\n        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        signs.foldLeft(product)(_ *\
    \ _)", "        val product = arr.map(x => x * x).sum\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs * product)",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        product.sum", "      \
    \  val m = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L) { (x, y)\
    \ => x * y }\n        Some(signs.map(x => x * product).sum / m)", "        val\
    \ m = arr.map(_.abs).sum\n        val n = arr.map(_.signum).sum\n        val signs\
    \ = arr.map(_.signum).map(_.toInt)\n        val product = signs.product\n    \
    \    Some(signs.map(m / product).sum)", "        val m = arr.map(_.abs).sum\n\
    \        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n\
    \        Some(signs * m * math.signum(arr.sum))", "        val product = arr.foldLeft(1L)\
    \ { (product, num) => product * num }\n        val signs = arr.map(num => if (num\
    \ < 0) -1 else if (num > 0) 1 else 0)\n        val magnitudes = signs.map(num\
    \ => math.abs(num))\n        magnitudes.zip(product).map(x => x._1 * x._2).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.sum\n        val productOfSigns\
    \ = product.map(x => x * signs.sum)\n        val productOfMagnitudes = productOfSigns.map(x\
    \ => math.abs(x))\n        val productOfMagnitudesSum = productOfMagnitudes.sum\n\
    \        if (productOfMagnitudesSum == sum)\n            Some(productOfMagnitudesSum)\n\
    \        else\n            None", "        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n\
    \        product.sum", "        val m = arr.map(_.abs).sum\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product\
    \ = signs.product\n        Some(signs.map(x => x * product).sum * m)", "     \
    \   val m = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0) -1\
    \ else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n\
    \        Some(signs.map(x => x * product).sum)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = arr.map(x\
    \ => x * signs.sum)\n        val magnitudes = arr.map(x => math.abs(x))\n    \
    \    val sum = magnitudes.sum\n        val productSigns = product.map(x => if\
    \ (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudesSigns = magnitudes.map(x\
    \ => math.abs(x))\n        val magnitudesSignsSum = magnitudesSigns.sum\n    \
    \    val productSignsSum = productSigns.sum\n        if (sum == productSignsSum)\
    \ {\n            Some(magnitudesSignsSum)\n        } else {\n            None\n\
    \        }", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        val sum = magnitudes.foldLeft(0L)(_ + _)\n\
    \        Some(sum * product)", "        val m = arr.map(x => math.abs(x)).sum\n\
    \        val s = arr.map(x => math.signum(x)).sum\n        Some(s * m)", "   \
    \     val m = arr.map(_.abs).sum\n        val signs = arr.map(x => if (x < 0)\
    \ -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_ * _)\n\
    \        Some(signs.map(x => x * product).sum * m)", "        val product = arr.foldLeft(1L)\
    \ {\n            (acc, x) => acc * x\n        }\n        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = signs.map(x\
    \ => math.abs(x))\n        val sum = magnitudes.foldLeft(product) {\n        \
    \    (acc, x) => acc * x\n        }\n        Some(sum)", "        val signs =\
    \ arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product =\
    \ signs.foldLeft(1L)(_ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n\
    \        magnitudes.map(x => x * product).sum", "        val product = arr.foldLeft(1L)\
    \ { (product, elem) => product * elem }\n        val signs = arr.map(elem => if\
    \ (elem < 0) -1 else if (elem > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign }", "        val product = arr.foldLeft(1L)\
    \ { (product, value) =>\n            product * math.signum(value)\n        }\n\
    \        val magnitude = arr.map(math.abs).sum\n        val signs = arr.map(math.signum).sum\n\
    \        Some(magnitude * signs * product)", "        val signs = arr.map(x =>\
    \ if (x < 0) -1 else if (x > 0) 1 else 0)\n        val product = signs.foldLeft(1L)(_\
    \ * _)\n        val magnitudes = arr.map(x => math.abs(x))\n        val sum =\
    \ magnitudes.sum\n        val productSign = signs.foldLeft(1L)(_ * _)\n      \
    \  val magnitudesSign = magnitudes.map(x => math.signum(x))\n        val magnitudesSignSum\
    \ = magnitudesSign.sum\n        val productSignSum = productSign.sum\n       \
    \ val productSignProduct = productSign * product\n        val productSignMagnitudes\
    \ = productSign * magnitudes\n        val productSignMagnitudesSum = productSignMagnitudes.sum\n\
    \        val productSignMagnitudesProduct = productSignMagnitudes.product\n  \
    \      val productSignMagnitudesProductSum = productSignMagnitudesProduct.sum\n\
    \        val productSignMagnitudesProductProduct = productSignMagnitudesProduct\
    \ * product\n        val productSignMagnitudesProductProductSum = productSignMagnitudesProductProduct\
    \ * product\n        val productSignMagnitudesProductProductProduct = productSignMagnitudesProductProduct\
    \ * product\n        val productSignMagnitudesProductProductProductSum = productSignMagnitudesProductProductProduct\
    \ * product\n        val productSignMagnitudesProductProductProductProduct = productSignMagnitudesProductProductProduct\
    \ * product\n        val productSignMagnitudesProductProductProductProductSum\
    \ = productSignMagnitudesProductProductProductProduct * product\n        val productSignMagnitudesProductProductProductProductProduct\
    \ = productSignMagnitudesProductProductProductProduct * product\n        val productSignMagnitudesProductProductProductProductProductSum\
    \ = productSignMagnitudesProductProductProductProductProduct * product\n     \
    \   val productSignMagnitudesProductProductProductProductProductProduct = productSignMagnitudesProductProductProductProductProduct\
    \ * product\n        val productSignMagnitudesProductProductProductProductProductSum\
    \ = productSignMagnitudesProductProductProductProductProduct * product\n     \
    \   val productSignMagnitudesProductProductProductProductProductProduct = productSignMagnitudesProductProductProductProductProduct\
    \ * product\n        val productSignMagnitudesProductProductProductProductProductProductSum\
    \ = productSignMagnitudesProductProductProductProductProductProduct * product",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = arr.map(x => x * signs.sum)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val productMagnitudes = product.zip(magnitudes)\n \
    \       productMagnitudes.foldLeft(0)((acc, x) => acc * x._1 * x._2)", "     \
    \   val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n       \
    \ val product = signs.foldLeft(1L) { (x, y) => x * y }\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.zip(signs).map(x => x * product).sum",
  "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n    \
    \    val product = signs.product\n        val magnitudes = signs.map(x => math.abs(x)).sum\n\
    \        Some(magnitudes * product)", "        val product = arr.foldLeft(1L)\
    \ { (product, elem) => product * elem }\n        val signs = arr.map(elem => if\
    \ (elem < 0) -1 else if (elem > 0) 1 else 0)\n        signs.foldLeft(product)\
    \ { (product, sign) => product * sign }", "        val product = arr.map(x =>\
    \ x * x).sum\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1\
    \ else 0).sum\n        Some(signs * product)", "        val signs = arr.map(x\
    \ => if (x < 0) -1 else if (x > 0) 1 else 0)\n        val magnitudes = arr.map(x\
    \ => math.abs(x))\n        val product = signs.zip(magnitudes).map(x => x._1 *\
    \ x._2)\n        magnitudes.map(x => math.abs(x) * product.getOrElse(0))", " \
    \       val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n   \
    \     val product = arr.map(x => x * signs.sum)\n        val magnitudes = product.map(x\
    \ => math.abs(x))\n        magnitudes.sum", "        val product = arr.map(x =>\
    \ x * x).sum\n        val signs = arr.map(x => if (x == 0) 0 else (x < 0 ? -1\
    \ : 1)).sum\n        Some(signs * product)", "        val product = arr.foldLeft(1L)\
    \ { (product, elem) => product * elem }\n        val signs = arr.map(elem => if\
    \ (elem < 0) -1 else if (elem > 0) 1 else 0)\n        val magnitudes = signs.map(elem\
    \ => math.pow(elem, 2))\n        magnitudes.zip(product).map(elem => elem._1 *\
    \ elem._2).sum", "        val product = arr.map(x => x * x).sum\n        val signs\
    \ = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0).sum\n        Some(signs\
    \ * product)", "        val signs = arr.map(x => if (x < 0) -1 else if (x > 0)\
    \ 1 else 0)\n        val product = signs.reduceLeft(_ * _)\n        val magnitudes\
    \ = arr.map(x => math.abs(x))\n        magnitudes.map(x => x * product).sum",
  "        val product = arr.foldLeft(1L) { (product, num) => product * num }\n  \
    \      val signs = arr.map(num => if (num < 0) -1 else if (num > 0) 1 else 0)\n\
    \        val magnitudes = signs.map(num => math.abs(num))\n        magnitudes.zip(product).map(x\
    \ => x._1 * x._2)", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ magnitude = product.map(x => math.abs(x))\n        val sum = magnitude.sum\n\
    \        Some(sum)", "        val product = arr.foldLeft(1L) { (product, elem)\
    \ => product * elem }\n        val signs = arr.map(elem => if (elem < 0) -1 else\
    \ if (elem > 0) 1 else 0)\n        signs.foldLeft(product) { (product, sign) =>\
    \ product * sign }", "        val signs = arr.map(x => if (x < 0) -1 else if (x\
    \ > 0) 1 else 0)\n        val product = arr.map(x => x * signs.sum)\n        val\
    \ magnitudes = arr.map(x => math.abs(x))\n        val productMagnitudes = product.zip(magnitudes)\n\
    \        productMagnitudes.foldLeft(0)((acc, x) => acc + x._1 * x._2)", "    \
    \    val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n      \
    \  val product = arr.map(x => x * signs.sum)\n        val sum = product.sum\n\
    \        val mag = product.map(x => math.abs(x)).sum\n        val result = mag\
    \ if sum == 0 else mag / sum\n        Some(result)", "        val product = arr.foldLeft(1L)\
    \ { (product, value) =>\n            product * value\n        }\n        val signs\
    \ = arr.map(x => if (x == 0) -1 else if (x == 1) 1 else 0)\n        val magnitudes\
    \ = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n        val\
    \ productSigns = signs.map(x => x * product)\n        val productMagnitudes =\
    \ magnitudes.map(x => x * product)\n        val productSum = productSigns.sum\n\
    \        val productProductSigns = productSigns.map(x => x * product)\n      \
    \  val productProductMagnitudes = productMagnitudes.map(x => x * product)\n  \
    \      val productProductSum = productProductSigns.sum\n        val productProductProductSigns\
    \ = productProductSigns.map(x => x * product)\n        val productProductProductMagnitudes\
    \ = productProductMagnitudes.map(x => x * product)\n        val productProductProductSum\
    \ = productProductProductSigns.sum\n        val productProductProductProductSigns\
    \ = productProductProductSigns.map(x => x * product)\n        val productProductProductProductMagnitudes\
    \ = productProductProductMagnitudes.map(x => x * product)\n        val productProductProductProductSum\
    \ = productProductProductProductSigns.sum\n        val productProductProductProductProductSigns\
    \ = productProductProductProductSigns.map(x => x * product)\n        val productProductProductProductProductMagnitudes\
    \ = productProductProductProductMagnitudes.map(x => x * product)\n        val\
    \ productProductProductProductProductSum = productProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductProductSigns = productProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductProductMagnitudes =\
    \ productProductProductProductProductMagnitudes.map(x => x * product)\n      \
    \  val productProductProductProductProductProductSum = productProductProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductProductProductSigns = productProductProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductProductProductMagnitudes\
    \ = productProductProductProductProductMagnitudes.map(x => x * product)\n    \
    \    val productProductProductProductProductProductSum = productProductProductProductProductProductSigns.sum\n\
    \        val productProductProductProductProductProductProductSigns = productProductProductProductProductProductSigns.map(x\
    \ => x * product)\n        val productProductProductProductProductProductMag",
  "        val product = arr.foldLeft(1L) { (product, element) => product * element\
    \ }\n        val signs = arr.map(x => if (x < 0) -1 else if (x > 0) 1 else 0)\n\
    \        val magnitudes = signs.map(x => math.abs(x))\n        val sum = magnitudes.sum\n\
    \        val productOfSigns = signs.foldLeft(1L) { (product, element) => product\
    \ * element }\n        val productOfMagnitudes = magnitudes.foldLeft(1L) { (product,\
    \ element) => product * element }\n        val productOfSum = sum * productOfSigns\n\
    \        val productOfMagnitudesAndSum = productOfMagnitudes * productOfSum\n\
    \        val productOfMagnitudesAndSumAndProductOfSigns = productOfMagnitudesAndSum\
    \ * productOfSigns\n        val productOfMagnitudesAndSumAndProductOfSignsAndProductOfSigns\
    \ = productOfMagnitudesAndSumAndProductOfSigns * productOfSigns\n        val productOfMagnitudesAndSumAndProductOfSignsAndProductOfSignsAndProductOfSigns\
    \ = productOfMagnitudesAndSumAndProductOfSignsAndProductOfSigns * productOfSigns\n\
    \        val productOfMagnitudesAndSumAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSigns\
    \ = productOfMagnitudesAndSumAndProductOfSignsAndProductOfSignsAndProductOfSigns\
    \ * productOfSigns\n        val productOfMagnitudesAndSumAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSigns\
    \ = productOfMagnitudesAndSumAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSigns\
    \ * productOfSigns\n        val productOfMagnitudesAndSumAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSigns\
    \ = productOfMagnitudesAndSumAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSigns\
    \ * productOfSigns\n        val productOfMagnitudesAndSumAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSigns\
    \ = productOfMagnitudesAndSumAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSignsAndProductOfSigns\
    \ * productOfSigns\n        val productOfMagnitudesAndSumAnd"]
stop_tokens:
- "\n    }\n"
