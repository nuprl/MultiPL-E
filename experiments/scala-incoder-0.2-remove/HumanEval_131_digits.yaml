name: HumanEval_131_digits
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Given a positive integer n, return the product of the odd digits.\n    //\
  \ Return 0 if all digits are even.\n    // For example:\n    def digits(n : Long)\
  \ : Long = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(digits((5l)) == (5l));\n\
  \    assert(digits((54l)) == (5l));\n    assert(digits((120l)) == (1l));\n    assert(digits((5014l))\
  \ == (5l));\n    assert(digits((98765l)) == (315l));\n    assert(digits((5576543l))\
  \ == (2625l));\n    assert(digits((2468l)) == (0l));\n    }\n\n}\n"
completions: ["        var product = 1\n        var digits = n.toString.toList\n \
    \       while (digits.nonEmpty) {\n            product *= digits.head.toInt\n\
    \            digits = digits.tail\n        }\n        if (product == 0) 0\n  \
    \      else product", "        val digits = mutable.ListBuffer[Long]()\n     \
    \   val remainder = n % 10\n        n /= 10\n        digits += remainder\n   \
    \     while (n>0) {\n            val remainder = n % 10\n            n /= 10\n\
    \            digits += remainder\n        }\n        digits.reverse.foldLeft(1L)\
    \ { (acc, digit) => acc * digit }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits.append(n % 10)\n            n /= 10\n\
    \        }\n        digits.reverse.foldLeft(1L){ (acc, digit) => acc * digit}",
  "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1L)\
    \ { (acc, digit) => acc * digit }", "        val product = n.toString.toLong.map(_.toInt).foldLeft(1L)(_\
    \ * _)\n        if (product % 2 == 0) product else 0L", "        val digits =\
    \ mutable.ArrayBuffer.empty[Long]\n        while(n > 0){\n            digits +=\
    \ n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L)(_\
    \ * _)", "        var product = 1\n        var digits = n.toString.toList\n  \
    \      for(i <- 0 until digits.length)\n            if(digits(i) % 2 == 1)\n \
    \               product *= digits(i)\n        return product", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        var product = 1\n        while(n > 0)\
    \ {\n            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(x\
    \ => product *= x)\n        product", "        var sum = 0\n        var product\
    \ = 1\n        for(i <- 0 until n) {\n            val digit = n % 10\n       \
    \     sum += digit\n            product *= digit\n            n /= 10\n      \
    \  }\n        if (sum % 2 == 0) product else 0", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.Long.MaxValue\n        while(n > 0) {\n       \
    \     digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(product)\
    \ { (product, digit) => product * digit }", "        val d = n % 10\n        n\
    \ / 10\n        if (d % 2 == 0) d * digits(n / 10) else 0", "        var result\
    \ = 1\n        var digits = n.toString.toInt\n        while (digits > 0) {\n \
    \           result *= digits\n            digits /= 10\n        }\n        if\
    \ (digits == 0) {\n            return 0\n        }\n        return result", " \
    \       val product = n.toString.toLong * n.toString.toLong * n.toString.toLong\n\
    \        if (product % 2 == 0) product else 0", "        val product = n.toString.toLong\
    \ * 2\n        val digits = n.toString.toLong / 10\n        if (digits == 0) product\
    \ else product", "        var res = 1\n        for(i <- 0 until n){\n        \
    \    res *= i\n            if(res % 2 == 1)\n                res /= 2\n      \
    \  }\n        if(res == 0)\n            return 0\n        else\n            return\
    \ res", "        val digits = mutable.ArrayBuffer.empty[Long]\n        val product\
    \ = mutable.Long.empty\n        while(n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product += _)\n\
    \        product", "        var product = 1\n        var digits = n.toString.reverse\n\
    \        while(digits.length > 0) {\n            val digit = digits.head.toInt\n\
    \            digits =\n                digits.tail.filter(x => x % 2 != 0).map(x\
    \ => x * digit).toList\n            product *= digit\n        }\n        product",
  "        val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0)\n        {\n            digits += n % 10\n            product\
    \ *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\n   \
    \         product = 0\n        product", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(0)(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0)\n        {\n            digits\
    \ += n % 10\n            product *= n % 10\n            n /= 10\n        }\n \
    \       if (digits.isEmpty) 0\n        else digits.reduceLeft(_ * _)", "     \
    \   val digits = mutable.ArrayBuffer.empty[Long]\n        while(n > 0){\n    \
    \        digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L){\
    \ (product, digit) => product * digit }", "        var product = 1\n        var\
    \ digits = n.toString.reverse.grouped(2).toList\n        digits.foreach(x => product\
    \ *= x)\n        product", "        var product = 1\n        var digits = n.toString.reverse\n\
    \        while(digits.nonEmpty) {\n            val digit = digits.head\n     \
    \       digits = digits.tail\n            product *= digit\n        }\n      \
    \  if (product % 2 == 0) product else 0", "        val product = n.toString.toLong\
    \ * n.toString.toLong * n.toString.toLong\n        product - (product % 2)", " \
    \       var product = 1\n        var digits = n.toString.toInt\n        while\
    \ (digits > 0) {\n            product *= digits\n            digits -= 1\n   \
    \     }\n        if (digits == 0) product *= 0\n        product", "        val\
    \ product = n.toString.toList.map(_.toInt).foldLeft(1L) { (product, digit) =>\
    \ product * digit }\n        if (product % 2 == 0) product else 0", "        val\
    \ digits = mutable.ListBuffer[Long]()\n        while(n > 0){\n            digits\
    \ += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L){\
    \ (product, digit) => product * digit}", "        var result = 1\n        for\
    \ (i <- 0 until n) {\n            result *= n % 10\n            n /= 10\n    \
    \    }\n        result", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L)(_ * _)", "        val product =\
    \ n.toString.map(_.toInt).product\n        product % 2 == 0 ? product : product",
  "        var product = 1\n        var digits = n.toString.toList\n        while(digits.length\
    \ > 0) {\n            val digit = digits.head\n            digits = digits.tail\n\
    \            product *= digit\n        }\n        if(product % 2 == 0) 0 else\
    \ product", "        val digits = mutable.ArrayBuffer.empty[Long]\n        var\
    \ product = 1\n        while (n > 0)\n        {\n            digits += n % 10\n\
    \            product *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.sum", "        var result = 1\n        var remainder\
    \ = n\n        while (remainder > 0) {\n            result *= (remainder % 10)\n\
    \            remainder /= 10\n        }\n        if (remainder == 0) {\n     \
    \       result\n        } else {\n            result\n        }", "        val\
    \ digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1L)\
    \ { (a, b) => a * b}", "        var product = 1\n        var digits = n.toString.toInt\n\
    \        while (digits > 0) {\n            product *= digits\n            digits\
    \ /= 10\n        }\n        if (digits == 0) {\n            product = 0\n    \
    \    }\n        product", "        val product = n.toString.map(_.toInt).foldLeft(1L)\
    \ {\n            case (acc, digit) => acc * digit\n        }\n        if (product\
    \ % 2 == 0) product else 0", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L)(_ * _)", "        val product =\
    \ n.toString.reverse.foldLeft(1L) {\n            case (acc, digit) => acc * digit.toLong\n\
    \        }\n        if (product % 2 == 0) product else 0", "        var product\
    \ = 1\n        var digits = n.toString.reverse\n        while(digits.nonEmpty)\
    \ {\n            val digit = digits.head\n            digits -= digit\n      \
    \      product *= digit\n        }\n        if (product == 0) 0\n        else\
    \ product", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while(n > 0) {\n            digits += n % 10\n            n /=\
    \ 10\n        }\n        digits.reverse.foreach(product *= _)\n        product",
  "        val digits = mutable.ArrayBuffer.empty[Long]\n        for (i <- 0 until\
    \ n) {\n            digits += math.pow(2, i)\n        }\n        digits.sum",
  "        val digits = mutable.ListBuffer[Long]()\n        while(n > 0) {\n     \
    \       digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L)\
    \ { (product, digit) => product * digit}", "        val product = n.toString.map(_.toInt).foldLeft(1L)\
    \ { (product, digit) => product * digit }\n        if (product % 2 == 0) product\
    \ else 0", "        val product = n.toString.toLong * n.toString.toLong * n.toString.toLong\n\
    \        if (product % 2 == 0) product else 0", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.ArrayBuffer.empty[Long]\n        while(n > 0) {\n\
    \            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ += _)\n        product.reverse.foldLeft(1L)((x, y) => x * y)", "        val\
    \ digits = mutable.ListBuffer[Long]()\n        var product = 1\n        while\
    \ (n > 0) {\n            digits += n % 10\n            n /= 10\n        }\n  \
    \      digits.reverse.foldLeft(product) { (product, digit) => product * digit\
    \ }", "        val product = n.toString.map(_.toInt).filter(_ % 2 == 1).foldLeft(1L)\
    \ { (product, digit) => product * digit }\n        if (product == 0L) 0\n    \
    \    else product", "        val digits = mutable.ArrayBuffer.empty[Long]\n  \
    \      while(n > 0) {\n            digits += n % 10\n            n /= 10\n   \
    \     }\n        digits.reverse.foldLeft(1L)(_ * _)", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_\
    \ * _)\n        if (product % 2 == 0) product else 0", "        val product =\
    \ n.toString.toInt\n        val digits = product.toString.toInt\n        val odd\
    \ = digits % 2\n        if (odd > 0) product * digits(odd - 1)\n        else 0",
  "        val digits = mutable.ListBuffer[Long]()\n        val remainder = n % 10\n\
    \        n /= 10\n        while(n > 0) {\n            digits += n\n          \
    \  n /= 10\n        }\n        digits.reverse.foldLeft(1L) { (acc, digit) => acc\
    \ * digit } * remainder", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(1L)(_ * _)", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.Long.empty\n        while(n > 0) {\n          \
    \  digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ += _)\n        product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0)\n        {\n            digits\
    \ += n % 10\n            product = product * n % 10\n            n /= 10\n   \
    \     }\n        if (digits.isEmpty) 0\n        else digits.reverse.foldLeft(product)((product,\
    \ digit) => product * digit)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foldLeft(product) { (product,\
    \ digit) =>\n            if (digit % 2 == 1) product * digit\n            else\
    \ product\n        }", "        val digits = mutable.ListBuffer[Long]()\n    \
    \    var product = 1\n        while (n > 0){\n            digits += n % 10\n \
    \           product *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty)\
    \ 0\n        else digits.reverse.foldLeft(product){ (product, digit) => product\
    \ * digit }", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while(n > 0){\n            digits.append(n % 10)\n            n\
    \ /= 10\n        }\n        digits.reverse.foreach(x => product *= x)\n      \
    \  product", "        val digits = mutable.ArrayBuffer.empty[Long]\n        while(n\
    \ > 0){\n            digits += n % 10\n            n /= 10\n        }\n      \
    \  digits.reverse.foldLeft(1L){ (acc, digit) => acc * digit}", "        val product\
    \ = n.toString.toInt\n        val digits = product.toString.reverse.grouped(2).toList\n\
    \        digits.foldLeft(1L) { (product, digit) => product * digit.toLong }",
  "        val digits = mutable.ListBuffer[Long]()\n        while(n > 0){\n      \
    \      digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L)(_\
    \ * _)", "        val digits = mutable.ArrayBuffer.empty[Long]\n        while(n\
    \ > 0) {\n            digits += n % 10\n            n /= 10\n        }\n     \
    \   digits.reverse.foldLeft(1L)(_ * _)", "        val product = n.toString.toLong\
    \ * 2\n        val digits = product.toString.toLong / 10\n        if (digits ==\
    \ 0) 0 else digits", "        val product = n.toString.toList.map(_.toInt).product\n\
    \        if (product % 2 == 0) product else 0", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val product = mutable.Long.empty\n        while(n > 0) {\n          \
    \  digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach(product\
    \ *= _)\n        product", "        val product = n.toString.toInt\n        val\
    \ digits = product.toString.toInt\n        val oddDigits = digits % 2\n      \
    \  if (oddDigits == 0) {\n            product\n        } else {\n            0\n\
    \        }", "        var product = 1\n        var digits = n.toString.reverse\n\
    \        for(i <- 0 until digits.length)\n            product *= digits(i)\n \
    \       product", "        val d = n.toString.reverse\n        val even = d.filter(x\
    \ => x % 2 == 0)\n        val odd = d.filter(x => x % 2 != 0)\n        val product\
    \ = even.foldLeft(1L) { (x, y) => x * y }\n        product * odd.sum", "     \
    \   val digits = mutable.ListBuffer[Long]()\n        var product = 1\n       \
    \ while (n > 0) {\n            digits += n % 10\n            n /= 10\n       \
    \ }\n        digits.reverse.foldLeft(product) { (product, digit) => product *\
    \ digit }", "        val product = n.toString.toList.map(_.toInt).product\n  \
    \      if (product % 2 == 0) product else 0", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foldLeft(product) { (product,\
    \ digit) =>\n            if (digit % 2 == 1) {\n                product *= digit\n\
    \            }\n        }\n        product", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L){ (a, b) => a * b + a }", "     \
    \   val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_ * _)\n       \
    \ product % 2 == 0 ? product : product.toLong", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val remainder = n % 10\n        n /= 10\n        digits += remainder\n\
    \        n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += remainder\n        n /= 10\n        digits += remainder\n \
    \       n /= 10\n        digits += remainder\n        n /= 10\n        digits\
    \ += remainder\n        n /= 10\n        digits += remainder\n        n /= 10\n\
    \        digits += ", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)\
    \ {\n            (product, digit) => product * digit\n        }\n        if (product\
    \ % 2 == 0) product else 0L", "        val d = n.toString.reverse\n        val\
    \ even = d.filter(_ % 2 == 0)\n        val odd = d.filter(_ % 2 != 0)\n      \
    \  even.foldLeft(0)(_ * _) + odd.foldLeft(0)(_ * _)", "        var result = 1\n\
    \        var i = 2\n        while (i <= n) {\n            if (n % i == 0) {\n\
    \                result *= i\n            }\n            i += 1\n        }\n \
    \       result", "        val digits = mutable.ListBuffer.empty[Long]\n      \
    \  var product = 1\n        while (n > 0) {\n            digits += n % 10\n  \
    \          n /= 10\n        }\n        digits.reverse.foldLeft(product) { (product,\
    \ digit) =>\n            if (digit % 2 == 1) product * digit\n            else\
    \ product\n        }", "        var sum : Long = 1\n        var sumOfEvenDigits\
    \ : Long = 0\n        var sumOfOddDigits : Long = 0\n        while (n > 0){\n\
    \            val digit = n % 10\n            if (digit % 2 == 0){\n          \
    \      sumOfEvenDigits *= digit\n            }\n            else{\n          \
    \      sumOfOddDigits *= digit\n            }\n            n /= 10\n        }\n\
    \        sumOfEvenDigits + sumOfOddDigits", "        val product = n.toString.map(_.toInt).foldLeft(1L)(_\
    \ * _)\n        if (product % 2 == 0) product else 0", "        var product =\
    \ 1\n        var digits = n.toString.toInt\n        while (digits > 0) {\n   \
    \         product *= digits\n            digits /= 10\n        }\n        if (digits\
    \ == 0) {\n            product = 0\n        }\n        return product", "    \
    \    var product = 1\n        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        for (i <- 0 until digits.length) {\n            product *= digits(i)\n\
    \        }\n        if (product % 2 == 0) 0 else product", "        val product\
    \ = n.toString.toLong * 2\n        val digits = n.toString.toLong / 10\n     \
    \   if (digits == 0) product else product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foldLeft(product) { (product,\
    \ digit) =>\n            if (digit % 2 == 0) product * digit\n            else\
    \ product\n        }", "        val digits = mutable.ListBuffer[Long]()\n    \
    \    while(n > 0) {\n            digits += n % 10\n            n /= 10\n     \
    \   }\n        digits.reverse.foldLeft(1L)(_ * _)", "        val product = n.toString.map(_.toInt).foldLeft(1L)\
    \ { (product, digit) => product * digit }\n        if (product % 2 == 0) product\
    \ else 0", "        var product = 1\n        for(i <- 0 until n / 10) {\n    \
    \        product *= n % 10\n            n /= 10\n        }\n        if(n % 2 ==\
    \ 0) product *= 2\n        product", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val i = 2\n        while(i <= n){\n            digits += i\n        \
    \    i += 2\n        }\n        digits.reduce(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L){ (acc, digit) => acc * digit }",
  "        val digits = mutable.ListBuffer[Long]()\n        val remainder = n % 10\n\
    \        n /= 10\n        digits += remainder\n        while (n>0) {\n       \
    \     val remainder = n % 10\n            n /= 10\n            digits += remainder\n\
    \        }\n        if (digits.isEmpty) 0\n        else digits.reduceLeft(_ *\
    \ _)", "        val digits = mutable.ListBuffer[Long]()\n        while(n > 0){\n\
    \            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L)(_\
    \ * _)", "        var product = 1\n        var digits = n.toString.reverse\n \
    \       for(i <- 0 until digits.length)\n            product *= digits(i)\n  \
    \      product", "        var result = 1\n        for(i <- 0 until n){\n     \
    \       result *= i\n            result %= 10\n        }\n        result", " \
    \       val digits = mutable.ArrayBuffer.empty[Long]\n        val digit = n.toString.reverse.dropWhile(_\
    \ == '0').drop(1)\n        val digitLength = digit.length\n        val digits\
    \ = digit.reverse.dropWhile(_ == '0').drop(digitLength)\n        digits.reverse.foldLeft(1L)\
    \ { (product, digit) =>\n            product * digit.toLong\n        }", "   \
    \     val product = n.toString.map(_.toInt).foldLeft(1L) { (product, digit) =>\
    \ product * digit }\n        if (product % 2 == 0) product else 0", "        var\
    \ product = 1\n        var digits = n.toString.toInt\n        while (digits >\
    \ 0) {\n            product *= digits\n            digits -= 1\n        }\n  \
    \      if (digits == 0) {\n            product = 0\n        }\n        return\
    \ product", "        val digits = n.toString.reverse.map(_.toInt)\n        val\
    \ odd = digits.filter(_ % 2 != 0)\n        odd.length * odd.product", "      \
    \  val d = n % 10\n        val r = n % 10\n        val l = n % 10\n        val\
    \ m = n % 10\n        val n = n % 10\n        val p = d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d *\
    \ d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * d * ", "   \
    \     var product = 1\n        for(i <- 0 until n){\n            product *= i\n\
    \            if(product % 2 == 1){\n                product /= 2\n           \
    \ }\n        }\n        product", "        val digits = n.toString.reverse.map(_.toInt)\n\
    \        val product = digits.product\n        product % 2 == 0 ? product : product",
  "        val digits = mutable.ArrayBuffer.empty[Long]\n        var product = 1\n\
    \        while (n > 0) {\n            digits += n % 10\n            n /= 10\n\
    \        }\n        digits.reverse.foldLeft(product) { (product, digit) =>\n \
    \           if (digit % 2 == 1) product * digit\n            else product\n  \
    \      }", "        var product = 1\n        var digits = n.toString.reverse\n\
    \        for(i <- 0 until digits.length)\n            product *= digits(i)\n \
    \       product", "        val product = n.toString.reverse.foldLeft(1L){\n  \
    \          (product, digit) => product * digit.toLong\n        }\n        product\
    \ % 2 == 0 ? product : product.toLong", "        val product = n.toString.map(_.toInt).foldLeft(1L)\
    \ { (product, digit) => product * digit }\n        if (product % 2 == 0) product\
    \ else 0", "        val digits = mutable.ArrayBuffer.empty[Long]\n        var\
    \ product = 1\n        while (n > 0) {\n            digits += n % 10\n       \
    \     n /= 10\n        }\n        digits.reverse.foldLeft(product) { (product,\
    \ digit) =>\n            if (digit % 2 == 1) {\n                product *= digit\n\
    \            }\n        }\n        product", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        val remainder = n % 10\n        val digit = n % 10\n        n /= 10\n\
    \        digits += digit\n        digits(digit) = remainder\n        digits",
  "        val digits = mutable.ArrayBuffer.empty[Long]\n        for (i <- 0 until\
    \ n) {\n            digits += math.floor(n/Math.pow(2, i))\n        }\n      \
    \  digits.sum", "        val digits = mutable.ListBuffer[Long]()\n        while(n\
    \ > 0) {\n            digits += n % 10\n            n /= 10\n        }\n     \
    \   digits.reverse.foldLeft(1L)(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L)(_ * _)", "        val d = n % 10\n\
    \        val r = n % 10\n        val m = n % 10\n        val s = n % 10\n    \
    \    val t = n % 10\n        val u = n % 10\n        val v = n % 10\n        val\
    \ w = n % 10\n        val x = n % 10\n        val y = n % 10\n        val z =\
    \ n % 10\n        val a = n % 10\n        val b = n % 10\n        val c = n %\
    \ 10\n        val d = n % 10\n        val e = n % 10\n        val f = n % 10\n\
    \        val g = n % 10\n        val h = n % 10\n        val i = n % 10\n    \
    \    val j = n % 10\n        val k = n % 10\n        val l = n % 10\n        val\
    \ m = n % 10\n        val n = n % 10\n        val o = n % 10\n        val p =\
    \ n % 10\n        val q = n % 10\n        val r = n % 10\n        val s = n %\
    \ 10\n        val t = n % 10\n        val u = n % 10\n        val v = n % 10\n\
    \        val w = n % 10\n        val x = n % 10\n        val y = n % 10\n    \
    \    val z = n % 10\n        val a = n % 10\n        val b = n % 10\n        val\
    \ c = n % 10\n        val d = n % 10\n        val e = n % 10\n        val f =\
    \ n % 10\n        val g = n % 10\n        val h = n % 10\n        val i = n %\
    \ 10\n        val j = n % 10\n        val k = n % 10\n        val l = n % 10\n\
    \        val m = n % 10\n        val n = n % 10\n        val o = n % 10\n    \
    \    val p = n % 10\n        val q = n % 10\n        val r = n % 10\n        val\
    \ s = n % 10\n        val t = n % 10\n        val u = n % 10\n        val v =\
    \ n % 10\n        val w = n % 10\n        val x = n % 10\n        val y = n %\
    \ 10\n        val z = n % 10\n        val a = n % 10\n        val b = n % 10\n\
    \        val c = n % 10\n        val d = n % 10\n        val e = n % 10\n    \
    \    val f = n % 10\n        val g = n % 10\n        val h = n % 10\n        val\
    \ i = n % 10\n        val j = n % 10\n        val k = n % 10\n        val l =\
    \ n % 10\n        val m = n % 10\n        val n = n % 10\n        val o = n %\
    \ 10\n        val p = n % 10\n        val q = n % 10\n        val r = n % 10\n\
    \        val s = n % 10\n        val t = n % 10\n        val u = n % 10\n    \
    \    val v = n % 10\n        val ", "        var product = 1\n        var digits\
    \ = n.toString.reverse.grouped(2).map(_.toInt)\n        for (i <- 0 until digits.length)\
    \ {\n            product *= digits(i)\n        }\n        product", "        var\
    \ result = 1\n        for(i <- 0 until n){\n            result *= i\n        }\n\
    \        result", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)(_\
    \ * _)\n        if (product % 2 == 0) product else 0", "        var product =\
    \ 1\n        var digits = n.toString.toInt\n        while (digits > 0) {\n   \
    \         product *= digits\n            digits -= 1\n        }\n        if (digits\
    \ == 0) {\n            product = 0\n        }\n        return product", "    \
    \    val digits = mutable.ListBuffer[Long]()\n        var product = 1\n      \
    \  while (n > 0){\n            digits += n % 10\n            product = product\
    \ * n % 10\n            n /= 10\n        }\n        if (digits.isEmpty) 0\n  \
    \      else digits.reverse.foldLeft(product){ (product, digit) => product * digit\
    \ }", "        val digits = mutable.ListBuffer[Long]()\n        while(n > 0){\n\
    \            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L){\
    \ (acc, x) => acc * x }", "        val product = n.toString.toList.map(_.toInt).foldLeft(1L)\
    \ { (product, digit) => product * digit }\n        if (product % 2 == 0) product\
    \ else 0", "        val product = n.toString.map(_.toInt).product\n        if\
    \ (product % 2 == 0) product else 0", "        val digits = mutable.ArrayBuffer.empty[Long]\n\
    \        while(n > 0) {\n            digits += n % 10\n            n /= 10\n \
    \       }\n        digits.reverse.foldLeft(1L)(_ * _)", "        val digits =\
    \ n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1L)(_ *\
    \ _)", "        var product = 1\n        var digits = n.toString.toList\n    \
    \    while(digits.length >= 2) {\n            product *= digits(digits.length\
    \ - 2)\n            digits -= 2\n        }\n        if(digits.length == 1) product\
    \ *= digits(0)\n        product", "        var result = 1\n        var digits\
    \ = n.toString.toInt\n        while (digits > 0) {\n            result *= digits\n\
    \            digits -= 1\n        }\n        result", "        val digits = mutable.ListBuffer[Long]()\n\
    \        val product = mutable.Long(0)\n        while (n > 0) {\n            digits\
    \ += n % 10\n            n /= 10\n        }\n        digits.reverse.foreach {\
    \ d => product *= d }\n        product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L){ (product, digit) => product * digit}",
  "        val digits = mutable.ArrayBuffer.empty[Long]\n        while(n > 0) {\n\
    \            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L)(_\
    \ * _)", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while (n > 0) {\n            digits += n % 10\n            product\
    \ *= n % 10\n            n /= 10\n        }\n        if (digits.isEmpty) product\
    \ else product", "        val product = n.toString.toList.map(_.toInt).product\n\
    \        if (product % 2 == 0) product else 0", "        val product = n.toString.map(_.toInt).foldLeft(1L)\
    \ {\n            case (acc, digit) => acc * digit\n        }\n        if (product\
    \ % 2 == 0) product else 0L", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foldLeft(product) { (product,\
    \ digit) =>\n            product * digit\n        }", "        var res = 1\n \
    \       var digits = n.toString.toInt\n        while (digits > 0) {\n        \
    \    res = res * digits\n            digits -= 1\n        }\n        if (res ==\
    \ 0) 0\n        else res", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L){ (product, digit) => product * digit}",
  "        var product = 1\n        var digits = n.toString.reverse.grouped(2).toList\n\
    \        for (d <- digits) {\n            product *= d\n        }\n        if\
    \ (digits.isEmpty) {\n            return 0\n        }\n        product", "   \
    \     val digits = mutable.ListBuffer[Long]()\n        var product = 1\n     \
    \   while(n > 0){\n            digits += n % 10\n            product *= n % 10\n\
    \            n /= 10\n        }\n        if(digits.isEmpty) product else product",
  "        val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while(n > 0) {\n            digits += n % 10\n            n /= 10\n     \
    \   }\n        digits.reverse.foreach(product *= _)\n        product", "     \
    \   val digits = n.toString.reverse.grouped(2).map(_.toInt)\n        digits.foldLeft(0)((acc,\
    \ digit) => acc * digit)", "        val digits = mutable.ListBuffer.empty[Long]\n\
    \        var product = 1\n        while(n > 0){\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foldLeft(product){\n \
    \           case (acc, digit) => acc * digit\n        }", "        var product\
    \ = 1\n        var digits = n.toString.toInt\n        var evenDigits = 0\n   \
    \     while (digits > 0) {\n            evenDigits += digits % 2\n           \
    \ digits /= 2\n        }\n        if (evenDigits == 0) {\n            return product\n\
    \        }\n        else {\n            return 0\n        }", "        val digits\
    \ = mutable.ListBuffer[Long]()\n        val n = n.toInt\n        while(n > 0){\n\
    \            digits += n%10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L){\
    \ (acc, digit) => acc*digit}", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0){\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foldLeft(product){ (product,\
    \ digit) =>\n            if (digit % 2 == 1){\n                product *= digit\n\
    \            }\n        }\n        product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            product = product * n % 10\n            n /= 10\n        }\n    \
    \    if (digits.isEmpty) 0\n        else digits.reverse.foldLeft(product) { (product,\
    \ digit) => product * digit }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L){ (product, digit) => product * digit}",
  "        val digits = mutable.ArrayBuffer.empty[Long]\n        val remainder = n\
    \ % 10\n        val quotient = n / 10\n        while (quotient > 0) {\n      \
    \      digits.append(quotient)\n            quotient = quotient / 10\n       \
    \ }\n        if (remainder == 0) {\n            digits.reverse\n        } else\
    \ {\n            digits.append(remainder)\n        }\n        digits.foldLeft(1L)\
    \ { (a, b) => a * b}", "        val digits = mutable.ListBuffer[Long]()\n    \
    \    while(n > 0) {\n            digits += n % 10\n            n /= 10\n     \
    \   }\n        digits.reverse.foldLeft(1L) { (acc, digit) => acc * digit }", " \
    \       val digits = mutable.ArrayBuffer.empty[Long]\n        while(n > 0) {\n\
    \            digits += n % 10\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L)(_\
    \ * _)", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while (n > 0) {\n            digits += n % 10\n            n /=\
    \ 10\n        }\n        digits.reverse.foldLeft(product) { (product, digit) =>\
    \ product * digit }", "        val digits = mutable.ListBuffer[Long]()\n     \
    \   var product = 1\n        while(n > 0){\n            digits.append(n % 10)\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        product", "        val digits = mutable.ListBuffer[Long]()\n   \
    \     var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        if (digits.isEmpty) 0\n        else product", "        val digits\
    \ = mutable.ArrayBuffer.empty[Long]\n        var product = 1\n        var remainder\
    \ = n\n        while(n > 0){\n            digits += n\n            n /= 10\n \
    \       }\n        digits.reverse.foreach(n => {\n            product *= n\n \
    \       })\n        if(digits.isEmpty) 0\n        else product", "        val\
    \ digits = mutable.ListBuffer[Long]()\n        var product = 1\n        while\
    \ (n > 0) {\n            digits += n % 10\n            n /= 10\n        }\n  \
    \      digits.reverse.foldLeft(product) { (product, digit) => product * digit\
    \ }", "        val digits = mutable.ArrayBuffer.empty[Long]\n        var product\
    \ = 1\n        while (n > 0) {\n            digits += n % 10\n            n /=\
    \ 10\n        }\n        digits.reverse.foldLeft(product) { (product, digit) =>\n\
    \            product * digit\n        }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            product = product * n % 10\n            n /= 10\n        }\n    \
    \    if (digits.isEmpty) 0\n        else digits.reverse.foldLeft(product) { (product,\
    \ digit) => product * digit }", "        val product = n.toString.toInt\n    \
    \    val oddDigits = product % 2\n        product - oddDigits", "        val product\
    \ = n.toString.toList.map(_.toInt).foldLeft(1L)(_ * _)\n        if (product %\
    \ 2 == 0) product else 0", "        var result = 1\n        var i = 2\n      \
    \  while (i <= n) {\n            result *= i\n            i += 2\n        }\n\
    \        result", "        val product = n.toString.toLong.map(_.toInt).product\n\
    \        product % 2 == 0 ? product : product.toLong", "        var product =\
    \ 1\n        var digits = n.toString.toList\n        while(digits.length > 0)\
    \ {\n            val digit = digits.head\n            digits = digits.tail\n \
    \           product *= digit\n        }\n        if (product % 2 == 0) 0 else\
    \ product", "        val product = n.toString.map(_.toInt).foldLeft(1L) { (product,\
    \ digit) => product * digit }\n        if (product % 2 == 0) product else 0",
  "        val digits = mutable.ListBuffer[Long]()\n        while(n > 0) {\n     \
    \       digits.append(n % 10)\n            n /= 10\n        }\n        digits.reverse.foldLeft(1L)\
    \ { (acc, digit) => acc * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toLong)\n\
    \        digits.foldLeft(1L) { (product, digit) => product * digit }", "     \
    \   val product = n.toString.toLong * 2\n        val digits = n.toString.toLong\
    \ / 10\n        val oddDigits = n.toString.toLong % 10\n        if (oddDigits\
    \ == 0) {\n            product\n        } else {\n            product * digits\n\
    \        }", "        val digits = mutable.ArrayBuffer.empty[Long]\n        var\
    \ product = 1\n        while(n > 0) {\n            digits += n % 10\n        \
    \    n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n      \
    \  product", "        val product = n.toString.map(_.toInt).foldLeft(1L) { (product,\
    \ digit) => product * digit }\n        if (product % 2 == 0) product else 0L",
  "        val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0){\n            digits.append(n % 10)\n            n /= 10\n\
    \        }\n        digits.reverse.foreach(product *= _)\n        product", " \
    \       val product = n.toString.toList.map(_.toInt).foldLeft(1L) {\n        \
    \    case (acc, digit) => acc * digit\n        }\n        if (product % 2 == 0)\
    \ product else 0", "        val digits = mutable.ListBuffer[Long]()\n        while(n\
    \ > 0){\n            digits.append(n % 10)\n            n /= 10\n        }\n \
    \       digits.reverse.foldLeft(1L){ (product, digit) => product * digit}", " \
    \       val digits = mutable.ListBuffer[Long]()\n        var product = 1\n   \
    \     while (n > 0) {\n            digits += n % 10\n            n /= 10\n   \
    \     }\n        digits.reverse.foreach(product *= _)\n        product", "   \
    \     var product = 1\n        for(i <- 1 to n.toInt) {\n            product *=\
    \ i\n        }\n        if(product % 2 == 0) {\n            return 0\n       \
    \ }\n        product", "        val digits = mutable.ListBuffer[Long]()\n    \
    \    var product = 1\n        while(n > 0) {\n            digits.append(n % 10)\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(x => product *=\
    \ x)\n        digits.reverse.foreach(x => product /= x)\n        product", " \
    \       val product = n.toString.map(_.toInt).product\n        if (product % 2\
    \ == 0) product else 0", "        val digits = mutable.ListBuffer[Long]()\n  \
    \      val remainder = n % 10\n        val quotient = n / 10\n        while (quotient\
    \ > 0) {\n            digits.append(quotient)\n            quotient = quotient\
    \ / 10\n        }\n        digits.append(remainder)\n        digits.reverse.foldLeft(1L)\
    \ { (product, digit) => product * digit }", "        val product = n.toString.map(_.toInt).foldLeft(1L)\
    \ { (product, digit) => product * digit }\n        if (product % 2 == 0) product\
    \ else 0", "        val digits = n.toString.toInt\n        val odd = digits %\
    \ 2\n        digits - odd", "        val product = n.toString.map(_.toInt).foldLeft(1L)\
    \ { (product, digit) => product * digit }\n        if (product % 2 == 0) product\
    \ else 0", "        var product = 1\n        var digits = n.toString.toCharArray\n\
    \        for(i <- 0 until digits.length)\n            product *= digits(i)\n \
    \       product", "        val digits = mutable.ListBuffer[Long]()\n        while(n\
    \ > 0){\n            digits += n % 10\n            n /= 10\n        }\n      \
    \  digits.reverse.foldLeft(1L)(_ * _)", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while (n > 0) {\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foldLeft(product) { (product,\
    \ digit) =>\n            product * digit\n        }", "        val product = n.toString.toLong.dropWhile(_\
    \ < '0').dropWhile(_ < '1').dropWhile(_ < '2').dropWhile(_ < '3').dropWhile(_\
    \ < '4').dropWhile(_ < '5').dropWhile(_ < '6').dropWhile(_ < '7').dropWhile(_\
    \ < '8').dropWhile(_ < '9').dropWhile(_ < '0').dropWhile(_ < '1').dropWhile(_\
    \ < '2').dropWhile(_ < '3').dropWhile(_ < '4').dropWhile(_ < '5').dropWhile(_\
    \ < '6').dropWhile(_ < '7').dropWhile(_ < '8').dropWhile(_ < '9').dropWhile(_\
    \ < '0').dropWhile(_ < '1').dropWhile(_ < '2').dropWhile(_ < '3').dropWhile(_\
    \ < '4').dropWhile(_ < '5').dropWhile(_ < '6').dropWhile(_ < '7').dropWhile(_\
    \ < '8').dropWhile(_ < '9').dropWhile(_ < '0').dropWhile(_ < '1').dropWhile(_\
    \ < '2').dropWhile(_ < '3').dropWhile(_ < '4').dropWhile(_ < '5').dropWhile(_\
    \ < '6').dropWhile(_ < '7').dropWhile(_ < '8').dropWhile(_ < '9').dropWhile(_\
    \ < '0').dropWhile(_ < '1').dropWhile(_ < '2').dropWhile(_ < '3').dropWhile(_\
    \ < '4').dropWhile(_ < '5').dropWhile(_ < '6').dropWhile(_ < '7').dropWhile(_\
    \ < '8').dropWhile(_ < '9').dropWhile(_ < '0').dropWhile(_ < '1').dropWhile(_\
    \ < '2').dropWhile(_ < '3').dropWhile(_ < '4').dropWhile(_ < '5').dropWhile(_\
    \ < '6').dropWhile(_ < '7').dropWhile(_ < '8').dropWhile(_ < '9').dropWhile(_\
    \ < '0').dropWhile(_ < '1').dropWhile(_ < '2').dropWhile(_ < '3').dropWhile(_\
    \ < '4').dropWhile(_ < '5').dropWhile(_ < '6').dropWhile(_ < '7').dropWhile(_\
    \ < '8').dropWhile(_ < '9').dropWhile(_ < '0').dropWhile(_ < '", "        val\
    \ digits = mutable.ArrayBuffer.empty[Long]\n        val product = mutable.Long.MaxValue\n\
    \        while(n > 0) {\n            digits += n % 10\n            n /= 10\n \
    \       }\n        digits.reverse.foldLeft(product) { (product, digit) => product\
    \ * digit }", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while (n > 0) {\n            digits += n % 10\n            n /=\
    \ 10\n        }\n        digits.reverse.foldLeft(product) { (product, digit) =>\n\
    \            if (digit % 2 == 1) product * digit\n            else product\n \
    \       }", "        var product = 1\n        val digits = n.toString.toInt\n\
    \        for (i <- 0 until digits) {\n            product *= (digits % 2 == 0)\
    \ ? digits(i / 2) : 0\n        }\n        product", "        val digits = mutable.ListBuffer[Long]()\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foldLeft(1L){ (a, b) => a * b + a }", "     \
    \   val digits = n.toString.reverse.grouped(2).map(_.toLong)\n        digits.foldLeft(1L)\
    \ { (acc, digit) => acc * digit }", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while(n > 0){\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        var product = 1\n        var digits = n.toString.toInt\n\
    \        while (digits > 0) {\n            product *= digits\n            digits\
    \ -= 1\n        }\n        if (digits == 0) product *= 0\n        return product",
  "        val digits = mutable.ListBuffer[Long]()\n        var product = 1\n    \
    \    while (n > 0) {\n            digits += n % 10\n            n /= 10\n    \
    \    }\n        digits.reverse.foldLeft(product) { (product, digit) =>\n     \
    \       product * digit\n        }", "        val d = n % 10\n        val r =\
    \ n % 10\n        val r2 = n % 10\n        val r3 = n % 10\n        val r4 = n\
    \ % 10\n        val r5 = n % 10\n        val r6 = n % 10\n        val r7 = n %\
    \ 10\n        val r8 = n % 10\n        val r9 = n % 10\n        val r10 = n %\
    \ 10\n        val r11 = n % 10\n        val r12 = n % 10\n        val r13 = n\
    \ % 10\n        val r14 = n % 10\n        val r15 = n % 10\n        val r16 =\
    \ n % 10\n        val r17 = n % 10\n        val r18 = n % 10\n        val r19\
    \ = n % 10\n        val r20 = n % 10\n        val r21 = n % 10\n        val r22\
    \ = n % 10\n        val r23 = n % 10\n        val r24 = n % 10\n        val r25\
    \ = n % 10\n        val r26 = n % 10\n        val r27 = n % 10\n        val r28\
    \ = n % 10\n        val r29 = n % 10\n        val r30 = n % 10\n        val r31\
    \ = n % 10\n        val r32 = n % 10\n        val r33 = n % 10\n        val r34\
    \ = n % 10\n        val r35 = n % 10\n        val r36 = n % 10\n        val r37\
    \ = n % 10\n        val r38 = n % 10\n        val r39 = n % 10\n        val r40\
    \ = n % 10\n        val r41 = n % 10\n        val r42 = n % 10\n        val r43\
    \ = n % 10\n        val r44 = n % 10\n        val r45 = n % 10\n        val r46\
    \ = n % 10\n        val r47 = n % 10\n        val r48 = n % 10\n        val r49\
    \ = n % 10\n        val r50 = n % 10\n        val r51 = n % 10\n        val r52\
    \ = n % 10\n        val r53 = n % 10\n        val r54 = n % 10\n        val r55\
    \ = n % 10\n        val r56 = n % 10\n        val r57 = n % 10\n        val r58\
    \ = n % 10\n        val r59 = n % 10\n        val r60 = n % 10\n        val r61\
    \ = n % 10\n        val r62 = n % 10\n        val r63 = n % 10\n        val r64\
    \ = n % 10\n        val r65 = n % 10\n", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        for (i <- 0 until n) {\n            if (i %\
    \ 2 == 1) {\n                digits += i\n            }\n        }\n        digits.reverse.foldLeft(product)\
    \ { (product, digit) => product * digit }", "        val digits = n.toString.reverse.grouped(2).map(_.toInt)\n\
    \        digits.foldLeft(1L)(_ * _)", "        var product = 1\n        var digits\
    \ = n.toString.toList\n        while(digits.nonEmpty) {\n            val digit\
    \ = digits.head\n            digits = digits.tail\n            product *= digit\n\
    \        }\n        if(product % 2 == 0) 0 else product", "        val product\
    \ = n.toString.toList.map(_.toInt).foldLeft(1L)(_ * _)\n        if (product %\
    \ 2 == 0) product else 0", "        val digits = n.toString.reverse.grouped(2).map(_.toInt).toList\n\
    \        val odd = digits.filter(x => x % 2 != 0)\n        val even = digits.filter(x\
    \ => x % 2 == 0)\n        odd.foldLeft(0)(_ * _) + even.foldLeft(0)(_ * _)", " \
    \       val digits = mutable.ArrayBuffer.empty[Long]\n        val product = mutable.Long.empty\n\
    \        while(n > 0){\n            digits += n % 10\n            n /= 10\n  \
    \      }\n        digits.reverse.foreach(product += _)\n        product", "  \
    \      val product = n.toString.dropRight(n.toString.length).map(_.toInt).product\n\
    \        if (product % 2 == 0) product else 0", "        var product = 1\n   \
    \     var digits = n.toString.toInt\n        var evenDigits = false\n        while\
    \ (digits > 0) {\n            if (digits % 2 == 0) {\n                evenDigits\
    \ = true\n            }\n            product *= digits\n            digits /=\
    \ 10\n        }\n        if (evenDigits) {\n            return 0\n        }\n\
    \        return product", "        var product = 1\n        var digits = n.toString.toList\n\
    \        while(digits.nonEmpty) {\n            val digit = digits.head\n     \
    \       digits = digits.tail\n            product *= digit\n        }\n      \
    \  if (product % 2 == 0) product else 0", "        val digits = mutable.ListBuffer[Long]()\n\
    \        var product = 1\n        while(n > 0){\n            digits += n % 10\n\
    \            n /= 10\n        }\n        digits.reverse.foreach(product *= _)\n\
    \        product", "        val product = n.toString.reverse.foldLeft(1L) { (product,\
    \ digit) => product * 10 + digit.toLong }\n        if (product % 2 == 0) product\
    \ else 0", "        val digits = n.toString.toInt\n        val product = digits\
    \ * digits(digits/2)\n        product % 2 == 0 ? product : 0", "        val digits\
    \ = mutable.ArrayBuffer.empty[Long]\n        var product = 1\n        while (n\
    \ > 0) {\n            digits += n % 10\n            n /= 10\n        }\n     \
    \   digits.reverse.foldLeft(product) { (product, digit) => product * digit }",
  "        var product = 1\n        var digits = n.toString.toInt\n        while (digits\
    \ > 0) {\n            product *= digits\n            digits -= 1\n        }\n\
    \        if (digits == 0) {\n            product = 0\n        }\n        return\
    \ product", "        val digits = mutable.ListBuffer[Long]()\n        var product\
    \ = 1\n        while (n > 0) {\n            digits += n % 10\n            n /=\
    \ 10\n        }\n        digits.reverse.foldLeft(product) { (product, digit) =>\
    \ product * digit }"]
stop_tokens:
- "\n    }\n"
