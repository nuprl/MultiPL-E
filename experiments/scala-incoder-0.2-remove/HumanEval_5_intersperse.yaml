name: HumanEval_5_intersperse
language: scala
prompt: "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n\
  \    // Insert a number 'delimeter' between every two consecutive elements of input\
  \ list `numbers'\n    def intersperse(numbers : List[Long], delimeter : Long) :\
  \ List[Long] = {\n"
tests: "    }\n    def main(args: Array[String]) = {\n    assert(intersperse((List[Long]()),\
  \ (7l)).equals((List[Long]())));\n    assert(intersperse((List[Long](5l.toLong,\
  \ 6l.toLong, 3l.toLong, 2l.toLong)), (8l)).equals((List[Long](5l.toLong, 8l.toLong,\
  \ 6l.toLong, 8l.toLong, 3l.toLong, 8l.toLong, 2l.toLong))));\n    assert(intersperse((List[Long](2l.toLong,\
  \ 2l.toLong, 2l.toLong)), (2l)).equals((List[Long](2l.toLong, 2l.toLong, 2l.toLong,\
  \ 2l.toLong, 2l.toLong))));\n    }\n\n}\n"
completions: ["        val result = new mutable.ListBuffer[Long]()\n        var i\
    \ = 0\n        while (i < numbers.size) {\n            result.append(numbers(i))\n\
    \            result.append(delimeter)\n            result.append(numbers(i + 1))\n\
    \            i += 2\n        }\n        result.toList", "        val result =\
    \ numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n        result.dropRight(1)",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (index != 0) {\n                result\
    \ += delimeter\n            }\n            result += number\n        }\n     \
    \   result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => x :: acc)\n        val newResult = result.map((_, delimeter))\n      \
    \  newResult.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => {\n            val newAcc = acc :+ elem\n            val newElem =\
    \ elem + delimeter\n            newAcc :+ newElem\n        })\n        result",
  "        val result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter\
    \ + x)\n        result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n    \
    \        result += number\n            result += delimeter\n        }\n      \
    \  result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < numbers.size)\
    \ {\n            result.append(numbers(i))\n            result.append(delimeter)\n\
    \            result.append(numbers(i + 1))\n            i += 2\n        }\n  \
    \      result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.zipWithIndex.foreach { case (number, index) =>\n            if\
    \ (index > 0) {\n                result += delimeter\n            }\n        \
    \    result += number\n        }\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => {\n            val newElem =\
    \ elem + delimeter\n            acc :+ newElem\n        })\n        result", " \
    \       val result = numbers.foldLeft(List[Long]())((acc, elem) => {\n       \
    \     val newElem = elem + delimeter\n            acc :+ newElem\n        })\n\
    \        result", "        val result = new mutable.ListBuffer[Long]()\n     \
    \   numbers.zipWithIndex.foreach { case (number, index) =>\n            if (index\
    \ != 0) {\n                result += delimeter\n            }\n            result\
    \ += number\n        }\n        result.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var current = 0\n        var previous = 0\n        numbers.foreach {\
    \ n =>\n            if (current != previous) {\n                result += delimeter\n\
    \            }\n            result += n\n            previous = current\n    \
    \        current = n\n        }\n        result.toList", "        val result =\
    \ new mutable.ListBuffer[Long]()\n        var last = 0\n        numbers.foreach\
    \ { n =>\n            if (last != 0) {\n                result += delimeter\n\
    \            }\n            result += n\n            last = n\n        }\n   \
    \     result.toList", "        val result = new mutable.ListBuffer[Long]()\n \
    \       var index = 0\n        while (index < numbers.length) {\n            result.append(numbers(index))\n\
    \            result.append(delimeter)\n            index += 1\n        }\n   \
    \     result.toList", "        val result = new mutable.ListBuffer[Long]()\n \
    \       var i = 0\n        while (i < numbers.size) {\n            result.append(numbers(i))\n\
    \            result.append(delimeter)\n            result.append(numbers(i + 1))\n\
    \            i += 1\n        }\n        result.toList", "        val newList =\
    \ mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n          \
    \  newList += number\n            newList += delimeter\n        }\n        newList.drop(1).dropRight(1).reverse",
  "        val result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter\
    \ + x)\n        result.dropRight(1)", "        val newList = mutable.ListBuffer.empty[Long]\n\
    \        for (i <- 0 until numbers.size - 1) {\n            newList += numbers(i)\n\
    \            newList += delimeter\n            newList += numbers(i + 1)\n   \
    \     }\n        newList.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < numbers.size) {\n            result.append(numbers(i))\n\
    \            result.append(delimeter)\n            result.append(numbers(i + 1))\n\
    \            i += 2\n        }\n        result.toList", "        val result =\
    \ numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n        result.dropRight(1)",
  "        val result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter\
    \ + x)\n        result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var current = 0\n        numbers.foreach(x => {\n            if (current\
    \ != 0) {\n                result += delimeter\n            }\n            result\
    \ += x\n            current = x\n        })\n        result.toList", "       \
    \ val result = numbers.foldLeft(List[Long]())((acc, n) => {\n            val newAcc\
    \ = acc :+ n\n            if (newAcc.length == 2) {\n                newAcc :+\
    \ delimeter\n            } else {\n                newAcc\n            }\n   \
    \     })\n        result", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => {\n            val newAcc =\
    \ acc :+ elem\n            if (newAcc.length < numbers.length)\n             \
    \   newAcc :+ delimeter\n            else\n                newAcc\n        })\n\
    \        result", "        val result = numbers.foldLeft(List[Long]())((acc, x)\
    \ => x :: acc ++ List(x))\n        val result2 = result.map(x => delimeter ::\
    \ x).reverse\n        result2.reverse", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => result += x)\n        numbers.foreach(x => result\
    \ += delimeter)\n        result + numbers.last", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result :+ delimeter", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < numbers.size) {\n            result.append(numbers(i))\n\
    \            result.append(delimeter)\n            result.append(numbers(i + 1))\n\
    \            i += 2\n        }\n        result.toList", "        val result =\
    \ numbers.foldLeft(List[Long]())((acc, elem) => {\n            acc :+ elem\n \
    \           acc :+ delimeter\n        })\n        result", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result.reverse", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result :+ delimeter", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.zipWithIndex.foreach { case (number, index) =>\n            if\
    \ (index > 0) {\n                result += delimeter\n            }\n        \
    \    result += number\n        }\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.zipWithIndex.foreach { case (number, index) =>\n            if\
    \ (index > 0) {\n                result.add(delimeter)\n            }\n      \
    \      result.add(number)\n        }\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => x :: acc ++ List(delimeter))\n        result.dropRight(1)", "        val\
    \ result = numbers.foldLeft(List[Long]())((acc, elem) => acc :+ elem + delimeter)\n\
    \        result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => x :: acc)\n        result.takeWhile(x => x != delimeter).reverse.drop(1).reverse.take(numbers.size\
    \ - 1).reverse.head :: result", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ number) => {\n            val newAcc = acc :+ number\n            val newAcc2\
    \ = newAcc :+ delimeter\n            newAcc2 :: newAcc\n        })\n        result",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (index > 0) {\n                result\
    \ += delimeter\n            }\n            result += number\n        }\n     \
    \   result.toList", "        val result = new mutable.ListBuffer[Long]()\n   \
    \     numbers.zipWithIndex.foreach { case (n, i) => result += n.toString + delimeter\
    \ + i.toString }\n        result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => x :: acc)\n        result.takeWhile(_\
    \ != delimeter).reverse.drop(1).reverse.take(numbers.size)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => acc :+ elem + delimeter)\n \
    \       result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result.reverse", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < numbers.size) {\n            result.append(numbers(i))\n\
    \            result.append(delimeter)\n            result.append(numbers(i + 1))\n\
    \            i += 2\n        }\n        result.toList", "        val result =\
    \ numbers.foldLeft(List[Long]())((acc, number) => {\n            val newAcc =\
    \ acc :+ number\n            val newAcc = newAcc :+ delimeter\n            newAcc\n\
    \        })\n        result", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result :+ delimeter", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result :+ delimeter", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach{ number =>\n            result += number\n          \
    \  result += delimeter\n        }\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => x :: acc)\n        val result2\
    \ = result.map(x => delimeter + x)\n        result2", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach { case\
    \ (number, index) =>\n            if (index > 0) {\n                result +=\
    \ delimeter\n            }\n            result += number\n        }\n        result.toList",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (index > 0) {\n                result\
    \ += delimeter\n            }\n            result += number\n        }\n     \
    \   result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        var current = 0L\n        var last\
    \ = 0L\n        numbers.foreach { n =>\n            current += n\n           \
    \ if (current > last) {\n                result += delimeter * (current - last)\n\
    \                last = current\n            }\n            result += n\n    \
    \    }\n        result ++= numbers.tail.take(numbers.size - 1).map(n => delimeter\
    \ * (n - last))\n        result", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => {\n            acc :+ delimeter\
    \ + n\n        })\n        result :+ delimeter", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach { case\
    \ (number, index) =>\n            if (index > 0) {\n                result +=\
    \ delimeter\n            }\n            result += number\n        }\n        result.toList",
  "        val result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter\
    \ + x)\n        result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            result += number\n         \
    \   result += delimeter\n        }\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, number) => {\n            val newAcc\
    \ = acc :+ number\n            val newAcc = newAcc :+ delimeter\n            newAcc\n\
    \        })\n        result", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result :+ delimeter", "        val newList\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.zipWithIndex.foreach { case\
    \ (number, index) =>\n            if (index > 0) {\n                newList +=\
    \ delimeter\n            }\n            newList += number\n        }\n       \
    \ newList.toList", "        val result = new mutable.ListBuffer[Long]()\n    \
    \    numbers.zipWithIndex.foreach { case (n, i) => result += n + delimeter * i}\n\
    \        result.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var i = 0\n        while (i < numbers.size) {\n            result.append(numbers(i))\n\
    \            result.append(delimeter)\n            result.append(numbers(i + 1))\n\
    \            i += 2\n        }\n        result.toList", "        val result =\
    \ new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach { case\
    \ (number, index) =>\n            if (index > 0) {\n                result +=\
    \ delimeter\n            }\n            result += number\n        }\n        result.toList",
  "        val result = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter\
    \ + n)\n        result :+ delimeter", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        var last = 0L\n        var i = 0\n\
    \        while (i < numbers.size) {\n            val current = numbers(i)\n  \
    \          if (current != last) {\n                result += delimeter\n     \
    \       }\n            result += current\n            last = current\n       \
    \     i += 1\n        }\n        result.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var last = 0L\n        numbers.foreach(n => {\n            if (last !=\
    \ 0L) {\n                result += delimeter\n            }\n            result\
    \ += n\n            last = n\n        })\n        result.toList", "        val\
    \ result = numbers.foldLeft(List[Long]())((acc, elem) => {\n            val newAcc\
    \ = acc :+ elem\n            newAcc :+ delimeter\n        })\n        result",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.foreach {\
    \ number =>\n            result.add(number)\n            result.add(delimeter)\n\
    \        }\n        result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.reverse", "        val result =\
    \ numbers.foldLeft(List[Long]())((acc, n) => {\n            val last = acc.last\n\
    \            acc :+ last + delimeter + n\n        })\n        result.dropRight(1)",
  "        val result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter\
    \ + x)\n        result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.zipWithIndex.foreach { case (number, index) =>\n            if\
    \ (index > 0) {\n                result += delimeter\n            }\n        \
    \    result += number\n        }\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => acc :+ elem + delimeter)\n \
    \       result :+ numbers.last", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => acc :+ delimeter + elem)\n        result.dropRight(1)", "        val\
    \ result = numbers.foldLeft(List[Long]())((acc, elem) => {\n            acc :+\
    \ elem\n            acc :+ delimeter\n        })\n        result", "        val\
    \ result = numbers.foldLeft(List[Long]())((acc, elem) => acc :+ elem + delimeter)\n\
    \        result :+ numbers.last", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => x :: acc ++ delimeter :: acc)\n        result.takeRight(numbers.size)",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (index > 0) {\n                result\
    \ += delimeter\n            }\n            result += number\n        }\n     \
    \   result.toList", "        val result = new mutable.ListBuffer[Long]()\n   \
    \     var last = 0L\n        numbers.foreach(n => {\n            if (last != 0L)\
    \ {\n                result += delimeter\n            }\n            result +=\
    \ n\n            last = n\n        })\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => {\n            acc :+ elem\n\
    \            acc :+ delimeter\n        })\n        result", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => x :: acc)\n        result.takeRight(numbers.size - 1).zip(numbers.drop(numbers.size\
    \ - 1)).map(x => x._1 ++ delimeter ++ x._2).reverse", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        val result2 = result.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ x)\n        result2", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => {\n            acc match {\n\
    \                case Nil => List(elem)\n                case head :: tail =>\
    \ head :: delimeter :: tail\n            }\n        })\n        result.reverse",
  "        val result = numbers.foldLeft(List[Long]())((acc, elem) => acc :+ elem\
    \ + delimeter)\n        result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => {\n            val newElem =\
    \ elem + delimeter\n            acc :+ newElem\n        })\n        result", " \
    \       val result = numbers.foldLeft(List[Long]())((acc, n) => {\n          \
    \  val newAcc = acc.take(acc.size - 1) + delimeter + n\n            acc.dropRight(1)\
    \ :+ newAcc\n        })\n        result", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val newList\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach { number =>\n    \
    \        newList += number\n            newList += delimeter\n        }\n    \
    \    newList.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => {\n            acc :+ elem\n\
    \            acc :+ delimeter\n        })\n        result", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach { case\
    \ (number, index) =>\n            if (index > 0) {\n                result +=\
    \ delimeter\n            }\n            result += number\n        }\n        result.toList",
  "        val result = numbers.foldLeft(List[Long]())((acc, elem) => acc :+ elem\
    \ + delimeter)\n        result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => {\n            val newElem = elem + delimeter\n            acc :+ newElem\n\
    \        })\n        result", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach { number =>\n            result += number\n         \
    \   result += delimeter\n        }\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => x :: acc ++ List(x))\n        result.takeRight(numbers.size)",
  "        val result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter\
    \ + x)\n        result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => {\n            val newElem =\
    \ elem + delimeter\n            acc :+ newElem\n        })\n        result", " \
    \       val result = new mutable.ListBuffer[Long]()\n        var last = 0L\n \
    \       for (n <- numbers) {\n            if (last != 0) {\n                result\
    \ += delimeter\n            }\n            result += n\n            last = n\n\
    \        }\n        result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        val result2 = result.dropRight(1)\n   \
    \     result2.reverse", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.zipWithIndex.foreach { case (number, index) =>\n            if\
    \ (index > 0) {\n                result += delimeter\n            }\n        \
    \    result += number\n        }\n        result.toList", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach{ number =>\n     \
    \       result += number\n            result += delimeter\n        }\n       \
    \ result.toList", "        val result = new mutable.ListBuffer[Long]()\n     \
    \   numbers.foreach { number =>\n            result.add(number)\n            result.add(delimeter)\n\
    \        }\n        result.result()", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => {\n            val newElem =\
    \ elem + delimeter\n            acc :+ newElem\n        })\n        result", " \
    \       val result = numbers.foldLeft(List[Long]())((acc, elem) => {\n       \
    \     val newAcc = acc :+ elem\n            if (newAcc.length == 2) {\n      \
    \          newAcc :+ delimeter\n            }\n            else {\n          \
    \      newAcc\n            }\n        })\n        result", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.zipWithIndex.foreach { case (n, i) => result += n + delimeter\
    \ * i}\n        result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => {\n            acc match {\n                case Nil => List(elem)\n\
    \                case head :: tail => head :: delimeter :: tail\n            }\n\
    \        })\n        result.reverse", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        val result2 = result.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result2", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach(n => result += n)\n\
    \        result += delimeter\n        result += numbers.last\n        result.toList",
  "        val result = new mutable.ListBuffer[Long]()\n        var current = 0L\n\
    \        var last = 0L\n        for (i <- 0 until numbers.size) {\n          \
    \  current += numbers(i)\n            if (current > last) {\n                result\
    \ += delimeter\n                last = current\n            }\n            result\
    \ += numbers(i)\n        }\n        result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => acc :+ elem + delimeter)\n        result.dropRight(1)", "        val\
    \ result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n\
    \        result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => {\n            val newElem = elem + delimeter\n            acc :+ newElem\n\
    \        })\n        result", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => x :: acc)\n        val result2\
    \ = result.map(x => x + delimeter)\n        result2", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach { case\
    \ (number, index) =>\n            if (index > 0) {\n                result +=\
    \ delimeter\n            }\n            result += number\n        }\n        result.toList",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (index != 0) {\n                result\
    \ += delimeter\n            }\n            result += number\n        }\n     \
    \   result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result :+ delimeter", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => x :: acc)\n        val result2\
    \ = result.map(x => delimeter + x)\n        result2.reverse", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((res, number) => {\n            res ::: List(number).zip(res).map(x\
    \ => x._1 + delimeter + x._2)\n        })\n        result.dropRight(1)", "   \
    \     val result = numbers.foldLeft(List[Long]())((acc, n) => {\n            val\
    \ newAcc = acc :+ n\n            if (newAcc.length == 2) {\n                newAcc\
    \ :+ delimeter\n            } else {\n                newAcc\n            }\n\
    \        })\n        result", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => x :: acc)\n        val result2\
    \ = result.map(x => delimeter + x)\n        result2.reverse", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        val result2 = result.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ x)\n        result2", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => acc :+ elem + delimeter)\n        result.dropRight(1)", "        val\
    \ result = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (index > 0) {\n                result\
    \ += delimeter\n            }\n            result += number\n        }\n     \
    \   result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => {\n            val newElem =\
    \ elem + delimeter\n            acc :+ newElem\n        })\n        result", " \
    \       val result = new mutable.ListBuffer[Long]()\n        numbers.foreach(number\
    \ => result += delimeter + number)\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val newNumbers\
    \ = mutable.ListBuffer.empty[Long]\n        numbers.foreach{ number =>\n     \
    \       newNumbers += number\n            newNumbers += delimeter\n        }\n\
    \        newNumbers.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        var current = 0L\n        var i = 0\n        while (i < numbers.size)\
    \ {\n            result += numbers.take(i).map(x => current + x).takeWhile(_ <\
    \ delimeter).map(x => current + x)\n            result += numbers.take(i + 1).map(x\
    \ => current + x).takeWhile(_ < delimeter).map(x => current + x)\n           \
    \ i += 1\n            current += delimeter\n        }\n        result.toList",
  "        val result = numbers.foldLeft(List[Long]())((acc, elem) => {\n        \
    \    val newElem = elem + delimeter\n            acc :+ newElem\n        })\n\
    \        result", "        val result = new mutable.ListBuffer[Long]()\n     \
    \   numbers.foreach { number =>\n            result.add(number)\n            result.add(delimeter)\n\
    \        }\n        result.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.zipWithIndex.foreach { case (number, index) =>\n            if\
    \ (index != 0) {\n                result += delimeter\n            }\n       \
    \     result += number\n        }\n        result.toList", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, elem) => acc :+ elem + delimeter)\n \
    \       result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => {\n            acc :+ elem\n            acc :+ delimeter\n        })\n\
    \        result", "        val result = new mutable.ListBuffer[Long]()\n     \
    \   var last = 0L\n        numbers.foreach(n => {\n            if (last != 0L)\
    \ {\n                result += delimeter\n            }\n            result +=\
    \ n\n            last = n\n        })\n        result.toList", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        var last = 0L\n        numbers.foreach\
    \ { n =>\n            if (last != 0L) {\n                result += delimeter\n\
    \            }\n            result += n\n            last = n\n        }\n   \
    \     result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ x) => acc :+ delimeter + x)\n        result.dropRight(1)", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n       \
    \ result.dropRight(1)", "        val newNumbers = mutable.ListBuffer.empty[Long]\n\
    \        numbers.foreach(number => {\n            newNumbers += number\n     \
    \       newNumbers += delimeter\n        })\n        newNumbers.toList", "   \
    \     val result = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (index > 0) {\n                result\
    \ += delimeter\n            }\n            result += number\n        }\n     \
    \   result.toList", "        val result = new mutable.ListBuffer[Long]()\n   \
    \     numbers.foreach { number =>\n            result += number\n            result\
    \ += delimeter\n        }\n        result.toList", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.zipWithIndex.foreach { case (n, i) => result += n + delimeter\
    \ * i }\n        result.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result.dropRight(1)", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach { case\
    \ (number, index) =>\n            if (index != 0) {\n                result +=\
    \ delimeter\n            }\n            result += number\n        }\n        result.toList",
  "        val result = new mutable.ListBuffer[Long]()\n        numbers.zipWithIndex.foreach\
    \ { case (number, index) =>\n            if (index != 0) {\n                result\
    \ += delimeter\n            }\n            result += number\n        }\n     \
    \   result.toList", "        val result = new mutable.ListBuffer[Long]()\n   \
    \     numbers.foreach { number =>\n            val newNumber = number + delimeter\n\
    \            result += newNumber\n        }\n        result.toList", "       \
    \ val result = numbers.foldLeft(List[Long]())((acc, x) => acc :+ delimeter + x)\n\
    \        result.dropRight(1)", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => acc :+ delimeter + elem)\n        result.dropRight(1)", "        val\
    \ newNumbers = mutable.ListBuffer.empty[Long]\n        numbers.foreach(n => {\n\
    \            newNumbers += n\n            newNumbers += delimeter\n        })\n\
    \        newNumbers.toList", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ elem) => {\n            val newAcc = acc :+ elem\n            newAcc :+ delimeter\n\
    \        })\n        result", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.foreach(x => result += x)\n        numbers.foreach(x => result\
    \ += delimeter)\n        result + numbers.last", "        val result = numbers.foldLeft(List[Long]())((acc,\
    \ n) => acc :+ delimeter + n)\n        result :+ delimeter", "        val result\
    \ = numbers.foldLeft(List[Long]())((acc, n) => acc :+ delimeter + n)\n       \
    \ result.dropRight(1)", "        val result = new mutable.ListBuffer[Long]()\n\
    \        numbers.zipWithIndex.foreach { case (number, index) =>\n            if\
    \ (index > 0) {\n                result += delimeter\n            }\n        \
    \    result += number\n        }\n        result.toList", "        val result\
    \ = new mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n    \
    \        result += number\n            result += delimeter\n        }\n      \
    \  result.toList"]
stop_tokens:
- "\n    }\n"
