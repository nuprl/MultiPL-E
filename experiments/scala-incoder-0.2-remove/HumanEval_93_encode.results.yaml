language: scala
name: HumanEval_93_encode
results:
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message\n\
    \        val newMessageList = newMessage.split(\"\")\n        val newMessageList2\
    \ = newMessageList.map(x => alphabet(alphabet.indexOf(x) + 1))\n        val newMessageList3\
    \ = newMessageList2.map(x => vowels(vowels.indexOf(x) + 1))\n        newMessageList3.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptmy_mddw.scala:20)\n\tat Problem.main(tmptmy_mddw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => vowels.indexOf(letter) match {\n            case\
    \ -1 => letter\n            case i => vowels(i + 2)\n        })\n        val newMessage\
    \ = newMessageArray.toList\n        val newMessageString = newMessage.toString\n\
    \        val newMessageString2 = newMessageString.replace(\"[\", \"\")\n     \
    \   val newMessageString3 = newMessageString2.replace(\"]\", \"\")\n        val\
    \ newMessageString4 = newMessageString3.replace(\",\", \"\")\n        val newMessageString5\
    \ = newMessageString4.replace(\"[\", \"\")\n        val newMessageString6 = newMessageString5.replace(\"\
    ]\", \"\")\n        val newMessageString7 = newMessageString6.replace(\",\", \"\
    \")\n        val newMessageString8 = newMessageString7.replace(\"[\", \"\")\n\
    \        val newMessageString9 = newMessageString8.replace(\"]\", \"\")\n    \
    \    val newMessageString10 = newMessageString9.replace(\",\", \"\")\n       \
    \ val newMessageString11 = newMessageString10.replace(\"[\", \"\")\n        val\
    \ newMessageString12 = newMessageString11.replace(\"]\", \"\")\n        val newMessageString13\
    \ = newMessageString12.replace(\",\", \"\")\n        val newMessageString14 =\
    \ newMessageString13.replace(\"[\", \"\")\n        val newMessageString15 = newMessageString14.replace(\"\
    ]\", \"\")\n        val newMessageString16 = newMessageString15.replace(\",\"\
    , \"\")\n        val newMessageString17 = newMessageString16.replace(\"[\", \"\
    \")\n        val newMessageString18 = newMessageString17.replace(\"]\", \"\")\n\
    \        val newMessageString19 = newMessageString18.replace(\",\", \"\")\n  \
    \      val newMessageString20 = newMessageString19.replace(\"[\", \"\")\n    \
    \    val newMessageString21 = newMessageString20.replace(\"]\", \"\")\n      \
    \  val newMessageString22 = newMessageString21.replace(\",\", \"\")\n        val\
    \ newMessageString23 = newMessageString22.replace(\"[\", \"\")\n        val newMessageString24\
    \ = newMessageString23.replace(\"]\", \"\")\n        val newMessageString25 =\
    \ newMessageString24.replace(\",\", \"\")\n        val newMessageString26 = newMessageString25.replace(\"\
    [\", \"\")\n        val newMessageString27 = newMessageString26.replace(\"]\"\
    , \"\")\n        val newMessageString28 = newMessageString27.replace(\",\", \"\
    \")\n        val newMessageString29 = newMessageString28.replace(\"[\", \"\")\n\
    \        val newMessageString30 = newMessageString29.replace(\"]\", \"\")\n  \
    \      val newMessageString31 = newMessageString30.replace(\",\", \"\")\n    \
    \    val newMessageString32 = newMessageString31.replace(\"[\", \"\")\n      \
    \  val newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp49qmby7s.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp49qmby7s.scala:51:5 ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val vowelIndex = index + 1\n\
    \                if (vowelIndex < vowels.length) vowels(vowelIndex) else letter\n\
    \            } else {\n                letter\n            }\n        })\n   \
    \     newMessageArray.toString.toUpperCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplzcxex0b.scala:25)\n\tat Problem.main(tmplzcxex0b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageWithVowels\
    \ = message.toLowerCase.foldLeft(\"\")( (acc, c) => acc + (if (vowels.contains(c))\
    \ c else alphabet(alphabet.indexOf(c) + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowel\
    \ = messageWithVowels.foldLeft(\"\")( (acc, c) => acc + (if (vowels.contains(c))\
    \ c else alphabet(alphabet.indexOf(c) + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowel.foldLeft(\"\")( (acc, c) => acc\
    \ + (if (vowels.contains(c)) c else alphabet(alphabet.indexOf(c) + 2)))\n    \
    \    val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c else alphabet(alphabet.indexOf(c)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c else alphabet(alphabet.indexOf(c)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoA\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp1g5tcje.scala:19:4 ----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpp1g5tcje.scala:17:128\
    \ --------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\e\
    [31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c))\
    \ c \e[33melse\e[0m alphabet(alphabet.indexOf(c) + \e[31m2\e[0m)))\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpp1g5tcje.scala:19:5 ---------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageList =\
    \ message.split(\"\")\n        val newMessage = messageList.map(letter => \n \
    \           letter match {\n                case 'a' -> alphabet(0)\n        \
    \        case 'b' -> alphabet(1)\n                case 'c' -> alphabet(2)\n  \
    \              case 'd' -> alphabet(3)\n                case 'e' -> alphabet(4)\n\
    \                case 'f' -> alphabet(5)\n                case 'g' -> alphabet(6)\n\
    \                case 'h' -> alphabet(7)\n                case 'i' -> alphabet(8)\n\
    \                case 'j' -> alphabet(9)\n                case 'k' -> alphabet(10)\n\
    \                case 'l' -> alphabet(11)\n                case 'm' -> alphabet(12)\n\
    \                case 'n' -> alphabet(13)\n                case 'o' -> alphabet(14)\n\
    \                case 'p' -> alphabet(15)\n                case 'q' -> alphabet(16)\n\
    \                case 'r' -> alphabet(17)\n                case 's' -> alphabet(18)\n\
    \                case 't' -> alphabet(19)\n                case 'u' -> alphabet(20)\n\
    \                case 'v' -> alphabet(21)\n                case 'w' -> alphabet(22)\n\
    \                case 'x' -> alphabet(23)\n                case 'y' -> alphabet(24)\n\
    \                case 'z' -> alphabet(25)\n                case _ -> letter\n\
    \            }\n        ).mkString(\"\")\n        val newMessageList = newMessage.split(\"\
    \")\n        val newAlphabet = alphabet.map(letter => \n            letter match\
    \ {\n                case 'a' -> alphabet(0)\n                case 'b' -> alphabet(1)\n\
    \                case 'c' -> alphabet(2)\n                case 'd' -> alphabet(3)\n\
    \                case 'e' -> alphabet(4)\n                case 'f' -> alphabet(5)\n\
    \                case 'g' -> alphabet(6)\n                case 'h' -> alphabet(7)\n\
    \                case 'i' -> alphabet(8)\n                case 'j' -> alphabet(9)\n\
    \                case 'k' -> alphabet(10)\n                case 'l' -> alphabet(11)\n\
    \                case 'm' -> alphabet(12)\n                case 'n' -> alphabet(13)\n\
    \                case 'o' -> alphabet(14)\n                case 'p' -> alphabet(15)\n\
    \                case 'q' -> alphabet(16)\n                case 'r' -> alphabet(17)\n\
    \                case 's' -> alphabet(18)\n                case 't' -> alphabet(19)\n\
    \                case 'u' -> alphabet(20)\n                case 'v' -> alphabet(21)\n\
    \                case 'w' \n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe3mzrptg.scala:17:16 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'b'\e[0m -> alphabet(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m \
    \               '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpe3mzrptg.scala:19:16 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m                \e[33mcase\e[0m \e[31m'd'\e[0m -> alphabet(\e[31m3\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m        \
    \        '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpe3mzrptg.scala:21:16 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m                \e[33mcase\e[0m \e[31m'f'\e[0m -> alphabet(\e[31m5\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m              \
    \  '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe3mzrptg.scala:23:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e\
    [0m \e[31m'h'\e[0m -> alphabet(\e[31m7\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                '=>' expected, but 'case' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe3mzrptg.scala:25:16 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mcase\e[0m \e[31m'j'\e[0m -> alphabet(\e\
    [31m9\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m \
    \               '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpe3mzrptg.scala:27:16 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m                \e[33mcase\e[0m \e[31m'l'\e[0m -> alphabet(\e[31m11\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m        \
    \        '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpe3mzrptg.scala:29:16 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                \e[33mcase\e[0m \e[31m'n'\e[0m -> alphabet(\e[31m13\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m        \
    \        '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpe3mzrptg.scala:31:16 --"
  stdout: ''
  timestamp: 1659978910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message\n\
    \        val newMessageList = newMessage.split(\"\")\n        val newMessageList2\
    \ = newMessageList.map(x => alphabet(alphabet.indexOf(x) + 1))\n        val newMessageList3\
    \ = newMessageList2.map(x => vowels(vowels.indexOf(x) + 1))\n        val newMessageList4\
    \ = newMessageList3.map(x => alphabet(alphabet.indexOf(x) + 1))\n        newMessageList4.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp92nkeix8.scala:21)\n\tat Problem.main(tmp92nkeix8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message.toLowerCase\n\
    \        val newMessageList = newMessage.split(\"\")\n        val newMessageList2\
    \ = newMessageList.map(x => alphabet(alphabet.indexOf(x) + 1))\n        val newMessageList3\
    \ = newMessageList2.map(x => vowels(vowels.indexOf(x) + 1))\n        val newMessageList4\
    \ = newMessageList3.map(x => alphabet(alphabet.indexOf(x) + 1))\n        val newMessageList5\
    \ = newMessageList4.map(x => vowels(vowels.indexOf(x) + 1))\n        newMessageList5.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgjvtcgpg.scala:22)\n\tat Problem.main(tmpgjvtcgpg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => \n            vowels.indexOf(letter) match {\n\
    \                case -1 => letter\n                case i => vowels(i + 2)\n\
    \            }\n        )\n        val newMessage = newMessageArray.toList\n \
    \       val newMessageString = newMessage.toString\n        val newMessageStringArray\
    \ = newMessageString.split(\"\")\n        val newMessageStringArrayLength = newMessageStringArray.length\n\
    \        val newMessageStringArrayLength2 = newMessageStringArrayLength / 2\n\
    \        val newMessageStringArrayLength3 = newMessageStringArrayLength - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength4 = newMessageStringArrayLength3 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength5 = newMessageStringArrayLength4 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength6 = newMessageStringArrayLength5 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength7 = newMessageStringArrayLength6 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength8 = newMessageStringArrayLength7 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength9 = newMessageStringArrayLength8 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength10 = newMessageStringArrayLength9 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength11 = newMessageStringArrayLength10 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength12 = newMessageStringArrayLength11 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength13 = newMessageStringArrayLength12 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength14 = newMessageStringArrayLength13 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength15 = newMessageStringArrayLength14 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength16 = newMessageStringArrayLength15 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength17 = newMessageStringArrayLength16 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength18 = newMessageStringArrayLength17 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength19 = newMessageStringArrayLength18 - newMessageStringArrayLength2\n\
    \        val newMessageStringArrayLength20 = newMessageStringArrayLength19 - newMessageStringArrayLength2\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7kr2uwiy.scala:43:5\
    \ ---------------------\e[0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    .toCharArray\n        val messageArray = message.toCharArray\n        val newMessage\
    \ = messageArray.map {\n            case c if vowels.contains(c) => vowels(vowels.indexOf(c)\
    \ + 2)\n            case c => c\n        }\n        new String(newMessage)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsq01jb0v.scala:20)\n\tat Problem.main(tmpsq01jb0v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val encodedMessage = messageArray.map(letter\
    \ => \n            letter match {\n                case vowel => vowel\n     \
    \           case letter => alphabet.indexOf(letter) + alphabet.indexOf(vowel)\
    \ + 2\n            }\n        ).mkString(\"\")\n        encodedMessage\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiney9ln2.scala:17:75 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m letter => alphabet.indexOf(letter)\
    \ + alphabet.indexOf(vowel) + \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m            \
    \                                                               ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                        Not found:\
    \ vowel\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978906
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(letter => letters.indexOf(letter) + letters.indexOf(vowels.charAt(0))\
    \ + 1)\n        val newMessage2 = newMessage.map(letter => letters.indexOf(letter)\
    \ + letters.indexOf(vowels.charAt(1)) + 1)\n        newMessage2.map(letter =>\
    \ letters.indexOf(letter) + letters.indexOf(vowels.charAt(2)) + 1)\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgxevo4r9.scala:15:23\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        newMessage2.map(\e[36mletter\e\
    [0m => letters.indexOf(letter) + letters.indexOf(vowels.charAt(\e[31m2\e[0m))\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    IndexedSeq[Int]\n\e[31m   |\e[0m       \
    \ Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message.map(letter\
    \ => vowels.indexOf(letter) + alphabet(vowels.indexOf(letter) + 1))\n        newMessage.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6o_rjg4d.scala:17)\n\tat Problem.main(tmp6o_rjg4d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map { letter =>\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val nextVowel = vowels(index\
    \ + 1)\n                letter.toUpperCase(Locale.ROOT) + nextVowel\n        \
    \    } else {\n                letter\n            }\n        }\n        newMessageArray.toSeq.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp30hlosb5.scala:17:35 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                letter.toUpperCase(Locale.ROOT) + nextVowel\n\
    \e[31m\e[31m   |\e[0m                                   ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                   Not found: Locale\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978906
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    .toCharArray\n        val messageArray = message.toCharArray\n        val result\
    \ = new StringBuilder\n        for(i <- 0 until messageArray.length){\n      \
    \      val currentChar = messageArray(i)\n            val nextChar = messageArray(i+1)\n\
    \            if(vowels.contains(currentChar)){\n                val index = vowels.indexOf(currentChar)\n\
    \                val nextIndex = vowels.indexOf(nextChar)\n                if(index\
    \ != -1){\n                    result.append(vowels(index+1))\n              \
    \  }\n            }\n            result.append(currentChar)\n        }\n     \
    \   return result.toString\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.ArrayIndexOutOfBoundsException: Index 4 out of bounds for length\
    \ 4\n\tat Problem$.encode$$anonfun$1(tmpgzv1dmep.scala:16)\n\tat Problem$.encode$$anonfun$adapted$1(tmpgzv1dmep.scala:25)\n\
    \tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.encode(tmpgzv1dmep.scala:25)\n\
    \tat Problem$.main(tmpgzv1dmep.scala:29)\n\tat Problem.main(tmpgzv1dmep.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message\n        val newMessageList = newMessage.split(\"\")\n        val\
    \ newMessageList2 = newMessageList.map(letter => letter.toUpperCase)\n       \
    \ val newMessageList3 = newMessageList2.map(letter => letter.replace(vowels, letters.charAt(letters.indexOf(letter)\
    \ + 2)))\n        val newMessageList4 = newMessageList3.map(letter => letter.replace(vowels.charAt(0),\
    \ letters.charAt(letters.indexOf(letter) + 2)))\n        val newMessageList5 =\
    \ newMessageList4.map(letter => letter.replace(vowels.charAt(1), letters.charAt(letters.indexOf(letter)\
    \ + 2)))\n        val newMessageList6 = newMessageList5.map(letter => letter.replace(vowels.charAt(2),\
    \ letters.charAt(letters.indexOf(letter) + 2)))\n        val newMessageList7 =\
    \ newMessageList6.map(letter => letter.replace(vowels.charAt(3), letters.charAt(letters.indexOf(letter)\
    \ + 2)))\n        val newMessageList8 = newMessageList7.map(letter => letter.replace(vowels.charAt(4),\
    \ letters.charAt(letters.indexOf(letter) + 2)))\n        val newMessageList9 =\
    \ newMessageList8.map(letter => letter.replace(vowels.charAt(5), letters.charAt(letters.indexOf(letter)\
    \ + 2)))\n        val newMessageList10 = newMessageList9.map(letter => letter.replace(vowels.charAt(6),\
    \ letters.charAt(letters.indexOf(letter) + 2)))\n        val newMessageList11\
    \ = newMessageList10.map(letter => letter.replace(vowels.charAt(7), letters.charAt(letters.indexOf(letter)\
    \ + 2)))\n        val newMessageList12 = newMessageList11.map(letter => letter.replace(vowels.charAt(8),\
    \ letters.charAt(letters.indexOf(letter) + 2)))\n        val newMessageList13\
    \ = newMessageList12.map(letter => letter.replace(vowels.charAt(9), letters.charAt(letters.indexOf(letter)\
    \ + 2)))\n        val newMessageList14 = newMessageList13.map(letter => letter.replace(vowels.charAt(10),\
    \ letters.charAt(letters.indexOf(letter) + 2)))\n        val newMessageList15\
    \ = newMessageList14.map(letter => letter.replace(vowels.charAt(11), letters.charAt(letters.indexOf(letter)\
    \ + 2)))\n        val newMessageList16 = newMessageList15.map(letter => letter.replace(vowels.charAt(12),\
    \ letters.charAt(letters.indexOf(letter) + 2)))\n        val newMessageList17\
    \ = newMessageList16.map(letter => letter.replace(vowels.charAt(13), letters.charAt(letters.indexOf(letter)\
    \ + 2)))\n        val newMessageList18 = newMessageList17.map(letter => letter.replace(vowels.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2wz4baga.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmp2wz4baga.scala:16:67 -----------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mnewMessageList3\e[0m = newMessageList2.map(\e\
    [36mletter\e[0m => letter.replace(vowels, letters.charAt(letters.indexOf(letter)\
    \ + \e[31m2\e[0m)))\n\e[31m\e[31m   |\e[0m                                   \
    \                         ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35mreplace\e[0m in \e[33mclass\e[0m \e\
    [35mString\e[0m with types\n\e[31m   |\e[0m (x$0: CharSequence, x$1: CharSequence):\
    \ String\n\e[31m   |\e[0m (x$0: Char, x$1: Char): String\n\e[31m   |\e[0mmatch\
    \ arguments ((vowels : String), Char)\n\e[31m\e[31m-- Error: /tmp/tmp2wz4baga.scala:16:128\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e\
    [33mval\e[0m \e[36mnewMessageList3\e[0m = newMessageList2.map(\e[36mletter\e[0m\
    \ => letter.replace(vowels, letters.charAt(letters.indexOf(letter) + \e[31m2\e\
    [0m)))\n\e[31m\e[31m   |\e[0m                                                \
    \                                                                            \
    \    ^\e[0m\n\e[31m   |\e[0m                                          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \                where:    B is a type variable\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2wz4baga.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase.foldLeft(\"\")( (acc, letter)\
    \ => acc + (if (vowels.contains(letter)) letter else vowels(vowels.indexOf(letter)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowel = messageWithVowels.foldLeft(\"\
    \")( (acc, letter) => acc + (if (vowels.contains(letter)) letter else vowels(vowels.indexOf(letter)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowel.foldLeft(\"\")( (acc, letter) =>\
    \ acc + (if (vowels.contains(letter)) letter else vowels(vowels.indexOf(letter)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\"\
    \")( (acc, letter) => acc + (if (vowels.contains(letter)) letter else vowels(vowels.indexOf(letter)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\"\
    \")( (acc, letter) => acc + (if (vowels.contains(letter)) letter else vowels(vowels.indexOf(letter)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVow\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9mg1xwe_.scala:15:104 --------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\e\
    [31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mletter\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(letter))\
    \ letter \e[33melse\e[0m vowels(vowels.indexOf(letter) + \e[31m2\e[0m)))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                        ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp9mg1xwe_.scala:16:128 --------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\e\
    [31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mletter\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(letter))\
    \ letter \e[33melse\e[0m vowels(vowels.indexOf(letter) + \e[31m2\e[0m)))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp9mg1xwe_.scala:17:152 -----------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVo"
  stdout: ''
  timestamp: 1659978909
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageWithVowels = message.toLowerCase.foldLeft(\"\")( (acc, letter)\
    \ => acc + (if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter))\
    \ + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter)) + 1)))\
    \ \n        val messageWithVowelsAndVowelsTwoAheadOfVowel = messageWithVowels.foldLeft(\"\
    \")( (acc, letter) => acc + (if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter))\
    \ + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter)) + 1) +\
    \ 1))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowel.foldLeft(\"\")( (acc, letter) =>\
    \ acc + (if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter))\
    \ + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter)) + 1) +\
    \ 1) + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter))\
    \ + 1) + 1) + 1))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\"\
    \")( (acc, letter) => acc + (if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter))\
    \ + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter)) + 1) +\
    \ 1) + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter))\
    \ + 1) + 1) + 1) + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter))\
    \ + 1) + 1) + 1) + 1))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVow\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsu0qf3fc.scala:13:8 ----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowel\e\
    [0m = messageWithVowels.foldLeft(\e[31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mletter\e\
    [0m) => acc + (\e[33mif\e[0m (vowels.contains(letter)) letter \e[33melse\e[0m\
    \ vowels.charAt(vowels.indexOf(letter)) + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter))\
    \ + \e[31m1\e[0m) + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e\
    [31m   |\e[0m        ')' expected, but 'val' found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpsu0qf3fc.scala:26:1 ---------------------\e[0m\e[0m\n\
    \e[31m26 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(letter => letters.indexOf(letter) + letters.indexOf(vowels.charAt(0))\
    \ + 1)\n        val newMessage2 = newMessage.map(letter => letters.indexOf(letter)\
    \ + letters.indexOf(vowels.charAt(1)) + 1)\n        newMessage2.toString.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpn54ax22q.scala:18)\n\tat Problem.main(tmpn54ax22q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val encodedMessage = messageArray.map { x => \n            val index\
    \ = alphabet.indexOf(x)\n            if (index != -1) alphabet(index) else x\n\
    \        }\n        val vowelsArray = vowels.map(x => \n            val index\
    \ = alphabet.indexOf(x)\n            if (index != -1) alphabet(index) else x\n\
    \        )\n        val vowelsArrayLength = vowelsArray.length\n        val encodedMessageLength\
    \ = encodedMessage.length\n        val encodedMessageArray = encodedMessage.map\
    \ { x => \n            if (x == vowels(vowelsArrayLength - 1)) vowelsArray(vowelsArrayLength\
    \ - 1) else x\n        }\n        val encodedMessageArrayLength = encodedMessageArray.length\n\
    \        val encodedMessageArrayLength = encodedMessageArray.length\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength\n        val encodedMessageArrayLength = encodedMessageArrayLength\n\
    \        val encodedMessageArrayLength = encodedMessageArrayLength\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength\n        val encodedMessageArrayLength = encodedMessageArrayLength\n\
    \        val encodedMessageArrayLength = encodedMessageArrayLength\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength\n        val encodedMessageArrayLength = encodedMessageArrayLength\n\
    \        val encodedMessageArrayLength = encodedMessageArrayLength\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength\n        val encodedMessageArrayLength = encodedMessageArrayLength\n\
    \        val encodedMessageArrayLength = encodedMessageArrayLength\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength\n        val encodedMessageArrayLength = encodedMessageArrayLength\n\
    \        val encodedMessageArrayLength = encodedMessageArrayLength\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength\n        val encodedMessageArrayLength = encodedMessageArrayLength\n\
    \        val encodedMessageArrayLength = encodedMessageArrayLength\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfc9jpdus.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageArrayLength\e\
    [0m = encodedMessageArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mencodedMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mencodedMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfc9jpdus.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageArrayLength\e\
    [0m = encodedMessageArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mencodedMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mencodedMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfc9jpdus.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageArrayLength\e\
    [0m = encodedMessageArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mencodedMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mencodedMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfc9jpdus.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageArrayLength\e\
    [0m = encodedMessageArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mencodedMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mencodedMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel defini"
  stdout: ''
  timestamp: 1659978909
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => \n            if (vowels.contains(letter)) letter\
    \ else vowels.indexOf(letter) + 1)\n        encodedMessage.toString.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj7rsq2dl.scala:18)\n\tat Problem.main(tmpj7rsq2dl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(letter => \n            if (vowels.contains(letter)) letter else\
    \ \n                alphabet.charAt(alphabet.indexOf(letter) + 2))\n        newMessage.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4zasby7j.scala:19)\n\tat Problem.main(tmp4zasby7j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => \n            if (vowels.contains(letter)) letter\
    \ else \n                vowels.indexOf(vowels.find(letter => letter != letter\
    \ - 2))\n        )\n        encodedMessage.toList.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz6uzyh12.scala:20)\n\tat Problem.main(tmpz6uzyh12.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case i => vowels(i + 2)\n        }).mkString(\"\")\n        newMessage\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8w6s7clq.scala:20)\n\tat Problem.main(tmp8w6s7clq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val newMessageArray = messageArray.map(letter => \n            letter\
    \ match {\n                case 'a' => alphabet(0)\n                case 'b' =>\
    \ alphabet(1)\n                case 'c' => alphabet(2)\n                case 'd'\
    \ => alphabet(3)\n                case 'e' => alphabet(4)\n                case\
    \ 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n              \
    \  case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n        \
    \        case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n \
    \               case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case _ => letter\n\
    \            }\n        )\n        val newMessageString = newMessageArray.toList.toString\n\
    \        val newMessageArray2 = newMessageString.split(\"\")\n        val newMessageArray3\
    \ = newMessageArray2.map(letter => \n            letter match {\n            \
    \    case 'a' => vowels(0)\n                case 'b' => vowels(1)\n          \
    \      case 'c' => vowels(2)\n                case 'd' => vowels(3)\n        \
    \        case 'e' => vowels(4)\n                case 'f' => vowels(5)\n      \
    \          case 'g' => vowels(6)\n                case 'h' => vowels(7)\n    \
    \            case 'i' => vowels(8)\n                case 'j' => vowels(9)\n  \
    \              case 'k' => vowels(10)\n                case 'l' => vowels(11)\n\
    \                case 'm' => vowels(12)\n                case 'n' => vowels(13)\n\
    \                case 'o' => vowels(14)\n                case 'p' => vowels(15)\n\
    \                case 'q' => vowels(16)\n                case 'r' => vowels(17)\n\
    \                case 's' => vowels(18)\n                case 't' => vowels(19)\n\
    \                case 'u' => vowels(20)\n                case 'v' => vowels(21)\n\
    \                case 'w' => vowels(22)\n                case 'x' => vowels(23)\n\
    \                case 'y' => vowels(24)\n                case 'z' => vowels(\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpte3t57w1.scala:74:35 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mcase\e[0m \e[31m'z'\e[0m => vowels(\n\
    \e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \                                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpte3t57w1.scala:76:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpte3t57w1.scala:85:0 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- Error: /tmp/tmpte3t57w1.scala:16:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mcase\e[0m \e[31m'a'\e[0m => alphabet(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpte3t57w1.scala:17:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'b'\e[0m => alphabet(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpte3t57w1.scala:18:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m \e[31m'c'\e[0m => alphabet(\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpte3t57w1.scala:19:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m \e[31m'd'\e[0m => alphabet(\e\
    [31m3\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of t"
  stdout: ''
  timestamp: 1659978921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        var result = \"\"\n     \
    \   for (i <- 0 until message.length) {\n            val c = message.charAt(i)\n\
    \            val l = c.toLowerCase \n            if (l.equals(\"a\") || l.equals(\"\
    e\") || l.equals(\"i\") || l.equals(\"o\") || l.equals(\"u\")) {\n           \
    \     result += l\n            } else if (l.equals(\"b\")) {\n               \
    \ result += \"b\"\n            } else if (l.equals(\"c\")) {\n               \
    \ result += \"c\"\n            } else if (l.equals(\"d\")) {\n               \
    \ result += \"d\"\n            } else if (l.equals(\"f\")) {\n               \
    \ result += \"f\"\n            } else if (l.equals(\"g\")) {\n               \
    \ result += \"g\"\n            } else if (l.equals(\"h\")) {\n               \
    \ result += \"h\"\n            } else if (l.equals(\"j\")) {\n               \
    \ result += \"j\"\n            } else if (l.equals(\"k\")) {\n               \
    \ result += \"k\"\n            } else if (l.equals(\"l\")) {\n               \
    \ result += \"l\"\n            } else if (l.equals(\"m\")) {\n               \
    \ result += \"m\"\n            } else if (l.equals(\"n\")) {\n               \
    \ result += \"n\"\n            } else if (l.equals(\"p\")) {\n               \
    \ result += \"p\"\n            } else if (l.equals(\"q\")) {\n               \
    \ result += \"q\"\n            } else if (l.equals(\"r\")) {\n               \
    \ result += \"r\"\n            } else if (l.equals(\"s\")) {\n               \
    \ result += \"s\"\n            } else if (l.equals(\"t\")) {\n               \
    \ result += \"t\"\n            } else if (l.equals(\"v\")) {\n               \
    \ result += \"v\"\n            } else if (l.equals(\"w\")) {\n               \
    \ result += \"w\"\n            } else if (l.equals(\"x\")) {\n               \
    \ result += \"x\"\n            } else if (l.equals(\"y\")) {\n               \
    \ result += \"y\"\n            } else if (l.equals(\"z\")) {\n               \
    \ result += \"z\"\n            }\n        }\n        return result\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm0wnngyq.scala:14:22 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = c.toLowerCase\
    \ \n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                    value toLowerCase is not a member of Char\n1 error found\n"
  stdout: ''
  timestamp: 1659978916
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val vowelIndex = index + 1\n\
    \                vowels(vowelIndex) == letter \n                    ? vowels(index)\n\
    \                    : vowels(vowelIndex)\n            } else {\n            \
    \    letter\n            }\n        }).mkString(\"\")\n        encodedMessage\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpitftpj28.scala:19:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    : vowels(vowelIndex)\n\e[31m\e[31m\
    \   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m                \
    \            end of statement expected but '(' found\n\e[31m\e[31m-- Error: /tmp/tmpitftpj28.scala:20:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \     } \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m              ^^^^\e[0m\n\e[31m\
    \   |\e[0m              end of statement expected but 'else' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpitftpj28.scala:23:9 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        }).mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m  \
    \ |\e[0m         ^\e[0m\n\e[31m   |\e[0m         eof expected, but ')' found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpitftpj28.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                vowels(vowelIndex) == letter \n\e[31m18\
    \ |\e[0m                    ? vowels(index)\n\e[31m\e[31m   |\e[0m           \
    \                           ^\e[0m\n\e[31m   |\e[0m            value ? is not\
    \ a member of String.\n\e[31m   |\e[0m            Note that `?` is treated as\
    \ an infix operator in Scala 3.\n\e[31m   |\e[0m            If you do not want\
    \ that, insert a `;` or empty line in front\n\e[31m   |\e[0m            or drop\
    \ any spaces behind the operator.\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpitftpj28.scala:20:13 --------------------\e[0m\e[0m\n\e[31m20 |\e[0m\
    \            } \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e\
    [31m   |\e[0m             Found:    Unit\n\e[31m   |\e[0m             Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1659978919
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message.map(letter\
    \ => \n            if (vowels.contains(letter)) letter else alphabet(alphabet.indexOf(letter)\
    \ + 2))\n        newMessage.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpp0g8j77m.scala:18)\n\tat Problem.main(tmpp0g8j77m.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => \n            letter match {\n                case vowel => vowel\n     \
    \           case letter => alphabet.indexOf(letter) + 2\n            }\n     \
    \   )\n        val newMessage = newMessageArray.toList.mkString(\"\")\n      \
    \  return newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo5k1ehrl.scala:24)\n\tat Problem.main(tmpo5k1ehrl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978920
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map\
    \ {\n            case letter if (vowels.contains(letter)) => letter.toUpperCase\n\
    \            case letter => letter\n        }\n        val newMessageString =\
    \ newMessage.toString.replaceAll(\"[aeiouAEIOU]\", \"$0\")\n        val newMessageArray\
    \ = newMessageString.split(\"\")\n        val newMessageArrayLength = newMessageArray.length\n\
    \        val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphgpttrzz.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArrayLength\e\
    [0m = newMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnewMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphgpttrzz.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArrayLength\e\
    [0m = newMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnewMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphgpttrzz.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArrayLength\e\
    [0m = newMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnewMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphgpttrzz.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArrayLength\e\
    [0m = newMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnewMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Nami"
  stdout: ''
  timestamp: 1659978919
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageWithVowels\
    \ = message.map(letter => vowels.indexOf(letter) match {\n            case -1\
    \ => letter\n            case i => alphabet(i + 2)\n        })\n        val messageWithVowelsAndLetters\
    \ = messageWithVowels.map(letter => alphabet.indexOf(letter) match {\n       \
    \     case -1 => letter\n            case i => alphabet(i + 2)\n        })\n \
    \       val messageWithVowelsAndLettersAndLetters = messageWithVowelsAndLetters.map(letter\
    \ => alphabet.indexOf(letter) match {\n            case -1 => letter\n       \
    \     case i => alphabet(i + 2)\n        })\n        val messageWithVowelsAndLettersAndLettersAndLetters\
    \ = messageWithVowelsAndLettersAndLetters.map(letter => alphabet.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case i => alphabet(i + 2)\n\
    \        })\n        val messageWithVowelsAndLettersAndLettersAndLettersAndLetters\
    \ = messageWithVowelsAndLettersAndLettersAndLetters.map(letter => alphabet.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case i => alphabet(i + 2)\n\
    \        })\n        val messageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLetters\
    \ = messageWithVowelsAndLettersAndLettersAndLettersAndLetters.map(letter => alphabet.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case i => alphabet(i + 2)\n\
    \        })\n        val messageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters\
    \ = messageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLetters.map(letter\
    \ => alphabet.indexOf(letter) match {\n            case -1 => letter\n       \
    \     case i => alphabet(i + 2)\n        })\n        val messageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters\
    \ = messageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters.map(letter\
    \ => alphabet.indexOf(letter) match {\n            case -1 => letter\n       \
    \     case i => alphabet(i + 2)\n        })\n        val messageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5_53umm4.scala:45:111 --------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                                               ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5_53umm4.scala:41:102\
    \ --------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmessageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters\e\
    [0m = messageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters.map(\e\
    [36mletter\e[0m => alphabet.indexOf(letter) \e[33mmatch\e[0m {\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \                                  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndLettersAndLettersAndLettersAndLettersAndLettersAndLettersAndLetters\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5_53umm4.scala:46:5 ---------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => \n            vowels.indexOf(letter) match {\n  \
    \              case -1 => letter\n                case i => vowels(i + 2)\n  \
    \          }\n        )\n        val newMessageString = newMessageArray.toList.toString.mkString(\"\
    \")\n        newMessageString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbi5j2lzi.scala:23)\n\tat Problem.main(tmpbi5j2lzi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978920
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val encodedMessage = messageArray.map(letter\
    \ => {\n            val index = alphabet.indexOf(letter)\n            val vowelIndex\
    \ = vowels.indexOf(letter)\n            if (vowelIndex != -1)\n              \
    \  alphabet(vowelIndex + 2)\n            else\n                alphabet(index)\n\
    \        }).mkString\n        encodedMessage\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat scala.collection.StringOps$.apply$extension(StringOps.scala:185)\n\tat Problem$.$anonfun$1(tmpxdgkq6te.scala:20)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.encode(tmpxdgkq6te.scala:21)\n\
    \tat Problem$.main(tmpxdgkq6te.scala:25)\n\tat Problem.main(tmpxdgkq6te.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => {\n            if (vowels.contains(letter)) {\n \
    \               val vowelIndex = vowels.indexOf(letter)\n                val vowel2Index\
    \ = vowels.indexOf(vowels.charAt(vowelIndex + 1))\n                vowels.charAt(vowelIndex\
    \ + 1) match {\n                    case vowel => vowel\n                    case\
    \ _ => vowels.charAt(vowel2Index + 1)\n                }\n            } else {\n\
    \                letter\n            }\n        }).mkString(\"\")\n        encodedMessage\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg3iyaqqm.scala:28)\n\tat Problem.main(tmpg3iyaqqm.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message\n\
    \        val newMessageList = newMessage.split(\"\")\n        val newMessageList2\
    \ = newMessageList.map(x => if (x == 'a') 'b' else if (x == 'e') 'f' else if (x\
    \ == 'i') 'j' else if (x == 'o') 'm' else if (x == 'u') 'n' else 'x')\n      \
    \  newMessageList2.foreach(x => newMessage = newMessage.replace(x, alphabet(alphabet.indexOf(x)\
    \ + 2)))\n        newMessage\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp0ix_1qao.scala:15:58 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnewMessageList2\e[0m = newMessageList.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m'a'\e[0m) \e[31m'b'\e[0m \e[33melse\e\
    [0m \e[33mif\e[0m (x == \e[31m'e'\e[0m) \e[31m'f'\e[0m \e[33melse\e[0m \e[33mif\e\
    [0m (x == \e[31m'i'\e[0m) \e[31m'j'\e[0m \e[33melse\e[0m \e[33mif\e[0m (x == \e\
    [31m'o'\e[0m) \e[31m'm'\e[0m \e[33melse\e[0m \e[33mif\e[0m (x == \e[31m'u'\e[0m)\
    \ \e[31m'n'\e[0m \e[33melse\e[0m \e[31m'x'\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                                                    ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types String and Char cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp0ix_1qao.scala:15:81 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnewMessageList2\e[0m = newMessageList.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m'a'\e[0m) \e[31m'b'\e[0m \e[33melse\e\
    [0m \e[33mif\e[0m (x == \e[31m'e'\e[0m) \e[31m'f'\e[0m \e[33melse\e[0m \e[33mif\e\
    [0m (x == \e[31m'i'\e[0m) \e[31m'j'\e[0m \e[33melse\e[0m \e[33mif\e[0m (x == \e\
    [31m'o'\e[0m) \e[31m'm'\e[0m \e[33melse\e[0m \e[33mif\e[0m (x == \e[31m'u'\e[0m)\
    \ \e[31m'n'\e[0m \e[33melse\e[0m \e[31m'x'\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                                                                           ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp0ix_1qao.scala:15:104 ----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnewMessageList2\e[0m = newMessageList.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x == \e[31m'a'\e[0m) \e[31m'b'\e[0m \e[33melse\e\
    [0m \e[33mif\e[0m (x == \e[31m'e'\e[0m) \e[31m'f'\e[0m \e[33melse\e[0m \e[33mif\e\
    [0m (x == \e[31m'i'\e[0m) \e[31m'j'\e[0m \e[33melse\e[0m \e[33mif\e[0m (x == \e\
    [31m'o'\e[0m) \e[31m'm'\e[0m \e[33melse\e[0m \e[33mif\e[0m (x == \e[31m'u'\e[0m)\
    \ \e[31m'n'\e[0m \e[33melse\e[0m \e[31m'x'\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \                                                                            \
    \                      ^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of typ"
  stdout: ''
  timestamp: 1659978920
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = mutable.StringBuilder()\n        val vowelIndexes = mutable.Map[String, Int]()\n\
    \        for (i <- 0 until message.length) {\n            val index = alphabet.indexOf(message.charAt(i))\n\
    \            if (index != -1) {\n                val nextIndex = alphabet.indexOf(message.charAt(i+1))\n\
    \                if (nextIndex != -1) {\n                    val nextVowel = alphabet.charAt(nextIndex+1)\n\
    \                    if (vowels.contains(nextVowel)) {\n                     \
    \   val vowelIndex = vowelIndexes.getOrElse(nextVowel, -1)\n                 \
    \       if (vowelIndex == -1) {\n                            vowelIndexes.put(nextVowel,\
    \ i)\n                        } else {\n                            vowelIndexes.put(nextVowel,\
    \ vowelIndex + 1)\n                        }\n                    }\n        \
    \        }\n            }\n        }\n        for (vowel <- vowels) {\n      \
    \      val vowelIndex = vowelIndexes.getOrElse(vowel, -1)\n            if (vowelIndex\
    \ != -1) {\n                newMessage.append(vowel)\n                newMessage.append(message.substring(vowelIndex\
    \ + 1, vowelIndex + 2))\n                newMessage.append(vowel)\n          \
    \  }\n        }\n        newMessage.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmptqqrbdih.scala:13:25 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mnewMessage\e[0m = mutable.StringBuilder()\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmptqqrbdih.scala:14:27 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mvowelIndexes\e[0m = mutable.Map[\e\
    [35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978917
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val vowel = vowels(index)\n \
    \               val vowelIndex = vowels.indexOf(vowel)\n                val vowel2\
    \ = vowels(vowelIndex + 1)\n                val newLetter = if (vowelIndex ==\
    \ 0) letter else vowel2\n                println(s\"$letter -> $vowel -> $vowel2\"\
    )\n                letter\n            } else {\n                letter\n    \
    \        }\n        })\n        val newMessage = String.join(\"\", newMessageArray)\n\
    \        println(s\"$message -> $newMessage\")\n        newMessage\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpool7y9xp.scala:26:32 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnewMessage\e[0m = String.join(\e\
    [31m\"\"\e[0m, newMessageArray)\n\e[31m\e[31m   |\e[0m                       \
    \  ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e\
    [33mmethod\e[0m \e[35mjoin\e[0m in \e[33mobject\e[0m \e[35mString\e[0m with types\n\
    \e[31m   |\e[0m (x$0: CharSequence, x$1: Iterable[? <: CharSequence]): String\n\
    \e[31m   |\e[0m (x$0: CharSequence, x$1: CharSequence*): String\n\e[31m   |\e\
    [0mmatch arguments ((\e[32m\"\"\e[0m : String), (newMessageArray : Array[String]))\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978918
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => letters.indexOf(letter) + letters.indexOf(vowels.charAt(0)) + 1)\n      \
    \  val newMessage = newMessageArray.toArray\n        val newMessageString = newMessage.toString\n\
    \        newMessageString.toUpperCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkubt5ssz.scala:20)\n\tat Problem.main(tmpkubt5ssz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => vowels.indexOf(letter) + 1).mkString(\"\")\n    \
    \    encodedMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnqozum6k.scala:17)\n\tat Problem.main(tmpnqozum6k.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message.map(letter\
    \ => alphabet(alphabet.indexOf(letter)) + vowels(vowels.indexOf(letter)) + alphabet(alphabet.indexOf(letter)\
    \ + 1))\n        newMessage.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmp12tczykg.scala:13)\n\tat Problem$.$anonfun$adapted$1(tmp12tczykg.scala:13)\n\
    \tat scala.collection.StringOps$.map$extension(StringOps.scala:206)\n\tat Problem$.encode(tmp12tczykg.scala:13)\n\
    \tat Problem$.main(tmp12tczykg.scala:17)\n\tat Problem.main(tmp12tczykg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978921
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageList =\
    \ message.split(\"\")\n        val newMessage = messageList.map(x => \n      \
    \      x match {\n                case 'a' => alphabet(0)\n                case\
    \ 'b' => alphabet(1)\n                case 'c' => alphabet(2)\n              \
    \  case 'd' => alphabet(3)\n                case 'e' => alphabet(4)\n        \
    \        case 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n  \
    \              case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n\
    \                case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n\
    \                case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case _ => x\n     \
    \       }\n        ).mkString(\"\")\n        val newMessageList = newMessage.split(\"\
    \")\n        val newMessageList2 = newMessageList.map(x => \n            x match\
    \ {\n                case 'a' => vowels(0)\n                case 'b' => vowels(1)\n\
    \                case 'c' => vowels(2)\n                case 'd' => vowels(3)\n\
    \                case 'e' => vowels(4)\n                case 'f' => vowels(5)\n\
    \                case 'g' => vowels(6)\n                case 'h' => vowels(7)\n\
    \                case 'i' => vowels(8)\n                case 'j' => vowels(9)\n\
    \                case 'k' => vowels(10)\n                case 'l' => vowels(11)\n\
    \                case 'm' => vowels(12)\n                case 'n' => vowels(13)\n\
    \                case 'o' => vowels(14)\n                case 'p' => vowels(15)\n\
    \                case 'q' => vowels(16)\n                case 'r' => vowels(17)\n\
    \                case 's' => vowels(18)\n                case 't' => vowels(19)\n\
    \                case 'u' => vowels(20)\n                case 'v' => vowels(21)\n\
    \                case 'w' => vowels(22)\n                case 'x' => vowels(23)\n\
    \                case 'y' => vowels(24)\n                case 'z' => vowels(25)\n\
    \                case _ => x\n            }\n        ).mkString(\"\")\n      \
    \  \n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpjw53kzfa.scala:16:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mcase\e[0m \e[31m'a'\e[0m => alphabet(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpjw53kzfa.scala:17:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'b'\e[0m => alphabet(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpjw53kzfa.scala:18:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m \e[31m'c'\e[0m => alphabet(\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpjw53kzfa.scala:19:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m \e[31m'd'\e[0m => alphabet(\e\
    [31m3\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpjw53kzfa.scala:20:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e[0m \e[31m'e'\e[0m => alphabet(\e\
    [31m4\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpjw53kzfa.scala:21:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                \e[33mcase\e[0m \e[31m'f'\e[0m => alphabet(\e\
    [31m5\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpjw53kzfa.scala:22:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mcase\e[0m \e[31m'g'\e[0m => alphabet(\e\
    [31m6\e[0"
  stdout: ''
  timestamp: 1659978926
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    .toList\n        val messageList = message.split(\"\")\n        val encodedMessage\
    \ = messageList.map(letter => {\n            val vowelIndex = vowels.indexOf(letter)\n\
    \            if (vowelIndex != -1)\n                vowels(vowelIndex + 2)\n \
    \           else\n                letter\n        }).mkString(\"\")\n        encodedMessage\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgwaa6n59.scala:23)\n\tat Problem.main(tmpgwaa6n59.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase.foldLeft(\"\") { (acc, c)\
    \ =>\n            val index = vowels.indexOf(c)\n            if (index != -1)\
    \ {\n                acc + (if (index == 0) c else vowels(index - 1))\n      \
    \      } else {\n                acc + c\n            }\n        }\n        val\
    \ messageWithVowelsAndVowelsTwoAhead = (messageWithVowels + \"a\").foldLeft(\"\
    \") { (acc, c) =>\n            val index = vowels.indexOf(c)\n            if (index\
    \ != -1) {\n                acc + (if (index == 0) c else vowels(index - 2))\n\
    \            } else {\n                acc + c\n            }\n        }\n   \
    \     val messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAhead = (messageWithVowelsAndVowelsTwoAhead\
    \ + \"e\").foldLeft(\"\") { (acc, c) =>\n            val index = vowels.indexOf(c)\n\
    \            if (index != -1) {\n                acc + (if (index == 0) c else\
    \ vowels(index - 3))\n            } else {\n                acc + c\n        \
    \    }\n        }\n        val messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\
    \ = (messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAhead + \"i\").foldLeft(\"\"\
    ) { (acc, c) =>\n            val index = vowels.indexOf(c)\n            if (index\
    \ != -1) {\n                acc + (if (index == 0) c else vowels(index - 4))\n\
    \            } else {\n                acc + c\n            }\n        }\n   \
    \     val messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\
    \ = (messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\
    \ + \"o\").foldLeft(\"\") { (acc, c) =>\n            val index = vowels.indexOf(c)\n\
    \            if (index != -1) {\n                acc + (if (index == 0) c else\
    \ vowels(index - 5))\n            } else {\n                acc + c\n        \
    \    }\n        }\n        val messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVow\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplu8g8ya7.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplu8g8ya7.scala:44:101\
    \ --------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmessageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\e\
    [0m = (messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\
    \ + \e[31m\"o\"\e[0m).foldLeft(\e[31m\"\"\e[0m) { (\e[36macc\e[0m, \e[36mc\e[0m)\
    \ =>\n\e[31m\e[31m   |\e[0m                                                  \
    \                                                   ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmplu8g8ya7.scala:53:5 ---------------------\e[0m\e[0m\n\e[31m53\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978921
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(letter => \n            if (vowels.contains(letter)) \n      \
    \          alphabet.indexOf(vowels.indexOf(letter)) + 1 else \n              \
    \  alphabet.indexOf(letter) + 1)\n        val newMessageString = newMessage.toString\n\
    \        val newMessageStringLength = newMessageString.length\n        val newMessageStringWithVowels\
    \ = newMessageString.substring(0, newMessageStringLength - newMessageStringLength\
    \ % 2)\n        val newMessageStringWithVowelsAndVowels = newMessageStringWithVowels\
    \ + newMessageStringWithVowels.substring(newMessageStringLength - newMessageStringLength\
    \ % 2)\n        newMessageStringWithVowelsAndVowels\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo1z0jpf4.scala:24)\n\tat Problem.main(tmpo1z0jpf4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978922
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index >= 0) {\n                val vowelIndex = index + 1\n \
    \               if (vowelIndex < vowels.length) vowels(vowelIndex) else letter\n\
    \            } else {\n                letter\n            }\n        }).mkString(\"\
    \")\n        encodedMessage\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps5xiqp71.scala:25)\n\tat Problem.main(tmps5xiqp71.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = mutable.StringBuilder()\n        for (letter <- message) {\n            if\
    \ (vowels.contains(letter)) {\n                val index = vowels.indexOf(letter)\n\
    \                val nextLetter = letters.charAt(index + 1)\n                newMessage.append(nextLetter)\n\
    \            } else {\n                newMessage.append(letter)\n           \
    \ }\n        }\n        return newMessage.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt0uukces.scala:13:25 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mnewMessage\e[0m = mutable.StringBuilder()\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978919
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase.foldLeft(\"\")( (acc, letter)\
    \ => acc + (if (vowels.contains(letter)) letter else vowels(vowels.indexOf(letter)+1))\
    \ + letter )\n        val messageWithVowelsAndVowelsTwoAhead = (messageWithVowels.toCharArray.zipWithIndex.filter(\
    \ _._2 % 2 == 1).map( _._1 ).mkString(\"\") + messageWithVowels.toCharArray.zipWithIndex.filter(\
    \ _._2 % 2 == 0).map( _._1 ).mkString(\"\"))\n        val messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAhead\
    \ = (messageWithVowelsAndVowelsTwoAhead + messageWithVowels.toCharArray.zipWithIndex.filter(\
    \ _._2 % 2 == 1).map( _._1 ).mkString(\"\") + messageWithVowels.toCharArray.zipWithIndex.filter(\
    \ _._2 % 2 == 0).map( _._1 ).mkString(\"\"))\n        val messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\
    \ = (messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAhead + messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\
    \ + messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead)\n\
    \        val messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoA\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbhiya7sy.scala:17:4 ----------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbhiya7sy.scala:15:138\
    \ --------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmessageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\e\
    [0m = (messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAhead + messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\
    \ + messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \      ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmessageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbhiya7sy.scala:15:209\
    \ -----------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mmessageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\e[0m\
    \ = (messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAhead + messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\
    \ + messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                                                            \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: messageWithVowelsAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAheadAndVowelsTwoAhead\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbhiya7sy.scala:17:5\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m "
  stdout: ''
  timestamp: 1659978922
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val vowelIndex = index + 1\n\
    \                vowels(vowelIndex) == letter \n                    ? vowels(vowelIndex)\
    \ \n                    : vowels(vowelIndex) + letter\n            } else {\n\
    \                letter\n            }\n        })\n        newMessageArray.toString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp262oxn5j.scala:19:28 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    : vowels(vowelIndex) + letter\n\e\
    [31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m       \
    \                     end of statement expected but '(' found\n\e[31m\e[31m--\
    \ Error: /tmp/tmp262oxn5j.scala:20:14 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            } \e[33melse\e[0m {\n\e[31m\e[31m   |\e[0m\
    \              ^^^^\e[0m\n\e[31m   |\e[0m              end of statement expected\
    \ but 'else' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp262oxn5j.scala:23:9\
    \ ----------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        })\n\e[31m\e\
    [31m   |\e[0m         ^\e[0m\n\e[31m   |\e[0m         eof expected, but ')' found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp262oxn5j.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                vowels(vowelIndex) == letter \n\e[31m18\
    \ |\e[0m                    ? vowels(vowelIndex) \n\e[31m\e[31m   |\e[0m     \
    \                                 ^\e[0m\n\e[31m   |\e[0m            value ? is\
    \ not a member of String.\n\e[31m   |\e[0m            Note that `?` is treated\
    \ as an infix operator in Scala 3.\n\e[31m   |\e[0m            If you do not want\
    \ that, insert a `;` or empty line in front\n\e[31m   |\e[0m            or drop\
    \ any spaces behind the operator.\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp262oxn5j.scala:19:43\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                    : vowels(vowelIndex)\
    \ + letter\n\e[31m\e[31m   |\e[0m                                           ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                           Not found: letter\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp262oxn5j.scala:20:13\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m            } \e[33melse\e[0m\
    \ {\n\e[31m\e[31m   |\e[0m             ^\e[0m\n\e[31m   |\e[0m             Found:\
    \    Unit\n\e[31m   |\e[0m             Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when comp"
  stdout: ''
  timestamp: 1659978927
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase.foldLeft(\"\")( (acc, c)\
    \ => acc + (if (vowels.contains(c)) c.toUpperCase() else c))\n        val messageWithVowelsAndTwoLettersBeforeVowel\
    \ = messageWithVowels.foldLeft(\"\")( (acc, c) => acc + (if (vowels.contains(c))\
    \ c.toUpperCase() else c))\n        val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowel\
    \ = messageWithVowelsAndTwoLettersBeforeVowel.foldLeft(\"\")( (acc, c) => acc\
    \ + (if (vowels.contains(c)) c.toUpperCase() else c))\n        val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel\
    \ = messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowel.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c))\n   \
    \     val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel\
    \ = messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c))\n   \
    \     val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel\
    \ = messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c))\n   \
    \     val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz6meppij.scala:19:4 ----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz6meppij.scala:12:111\
    \ -----------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mmessageWithVowels\e[0m = message.toLowerCase.foldLeft(\e[31m\"\"\e[0m)( (\e\
    [36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase()\
    \ \e[33melse\e[0m c))\n\e[31m\e[31m   |\e[0m                                 \
    \                                                                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz6meppij.scala:13:133\
    \ -----------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mmessageWithVowelsAndTwoLettersBeforeVowel\e[0m = messageWithVowels.foldLeft(\e\
    [31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c))\
    \ c.toUpperCase() \e[33melse\e[0m c))\n\e[31m\e[31m   |\e[0m                 \
    \                                                                            \
    \                                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                            value toUpperCase is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpz6meppij.scala:14:180 -----------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowel\e\
    [0m = messageWithVowelsAndTwoLettersBeforeVowel.foldLeft(\e[31m\"\"\e[0m)( (\e\
    [36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase()\
    \ \e[33melse\e[0m c))\n\e[31m\e[31m   |\e[0m                                 \
    \                                                                            \
    \                                                                     ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz6meppij.s"
  stdout: ''
  timestamp: 1659978928
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => \n            vowels.indexOf(letter) match {\n\
    \                case -1 => letter\n                case i => vowels(i + 2)\n\
    \            }\n        )\n        val newMessage = newMessageArray.toArray\n\
    \        val newMessageString = newMessage.toString\n        val newMessageStringArray\
    \ = newMessageString.split(\"\")\n        val newMessageStringArrayLength = newMessageStringArray.length\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessageStringArrayLength = newMessageStringArrayLength - 1\n  \
    \      val newMessageStringArrayLength = newMessageStringArrayLength - 1\n   \
    \     val newMessageStringArrayLength = newMessageStringArrayLength - 1\n    \
    \    val newMessageStringArrayLength = newMessageStringArrayLength - 1\n     \
    \   val newMessageStringArrayLength = newMessageStringArrayLength - 1\n      \
    \  val newMessageStringArrayLength = newMessageStringArrayLength - 1\n       \
    \ val newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val\
    \ newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength\
    \ - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength -\
    \ 1\n        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessageStringArrayLength = newMessageStringArrayLength - 1\n  \
    \      val newMessageStringArrayLength = newMessageStringArrayLength - 1\n   \
    \     val newMessageStringArrayLength = newMessageStringArrayLength - 1\n    \
    \    val newMessageStringArrayLength = newMessageStringArrayLength - 1\n     \
    \   val newMessageStringArrayLength = newMessageStringArrayLength - 1\n      \
    \  val newMessageStringArrayLength = newMessageStringArrayLength - 1\n       \
    \ val newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val\
    \ newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength\
    \ - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength -\
    \ 1\n        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvgc9icmk.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvgc9icmk.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnewMessageStringArrayLength\e[0m = newMessageStringArrayLength - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvgc9icmk.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvgc9icmk.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvgc9icmk.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1659978929
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val messageArrayLength\
    \ = messageArray.length\n        val encodedMessage = messageArray.map(letter\
    \ => \n            if (vowels.contains(letter)) letter else \n               \
    \ (vowels.indexOf(letter) + 2).toChar)\n        val encodedMessageString = encodedMessage.toList\n\
    \        encodedMessageString.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcb78tddb.scala:21)\n\tat Problem.main(tmpcb78tddb.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => \n            if (vowels.contains(letter)) letter\
    \ else vowels.indexOf(letter) + 2)\n        val newMessage = messageArray.mkString(\"\
    \")\n        newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp75eq7a2p.scala:19)\n\tat Problem.main(tmp75eq7a2p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessage = messageArray.map { letter =>\n\
    \            val index = alphabet.indexOf(letter)\n            if (index != -1)\
    \ alphabet(index - 1) else letter\n        }.mkString(\"\")\n        val newMessageArray\
    \ = newMessage.split(\"\")\n        val newMessageArray2 = newMessageArray.map\
    \ { letter =>\n            val index = vowels.indexOf(letter)\n            if\
    \ (index != -1) vowels(index - 1) else letter\n        }.mkString(\"\")\n    \
    \    newMessageArray2.reverse.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdo6_fsvf.scala:26)\n\tat Problem.main(tmpdo6_fsvf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessage = messageArray.map(letter => \n\
    \            if (vowels.contains(letter)) letter else alphabet(alphabet.indexOf(letter)\
    \ + 2))\n        newMessage.toString.toUpperCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpor9_6zmp.scala:19)\n\tat Problem.main(tmpor9_6zmp.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val newMessage =\
    \ message.map(letter => alphabet.indexOf(letter) + vowels.indexOf(letter) + 1)\n\
    \        newMessage.map(letter => alphabet(letter))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi90b3mm2.scala:14:22\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        newMessage.map(\e[36mletter\e\
    [0m => alphabet(letter))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    IndexedSeq[Char]\n\e[31m   |\e[0m      \
    \  Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978930
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('o','a','e','i','u')\n        val newMessage = message.map(letter\
    \ => alphabet(alphabet.indexOf(letter)) + vowels(vowels.indexOf(letter)) + alphabet(alphabet.indexOf(letter)\
    \ + 1))\n        newMessage.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmpkcdto2g0.scala:13)\n\tat Problem$.$anonfun$adapted$1(tmpkcdto2g0.scala:13)\n\
    \tat scala.collection.StringOps$.map$extension(StringOps.scala:206)\n\tat Problem$.encode(tmpkcdto2g0.scala:13)\n\
    \tat Problem$.main(tmpkcdto2g0.scala:17)\n\tat Problem.main(tmpkcdto2g0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978932
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val newMessage =\
    \ message.map(letter => alphabet(alphabet.indexOf(letter) + 1))\n        val newMessage2\
    \ = message.map(letter => vowels(vowels.indexOf(letter) + 1))\n        newMessage\
    \ ++ newMessage2\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2xvg8pyo.scala:18)\n\tat Problem.main(tmp2xvg8pyo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978932
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        var result = \"\"\n     \
    \   for (letter <- message) {\n            val index = english.indexOf(letter)\n\
    \            if (index != -1) {\n                val nextIndex = index + 2\n \
    \               if (nextIndex < english.length) {\n                    result\
    \ += english(nextIndex)\n                } else {\n                    result\
    \ += letter\n                }\n            } else {\n                result +=\
    \ letter\n            }\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcyi2tf_n.scala:13:24 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m            \e[33mval\e[0m \e[36mindex\e[0m = english.indexOf(letter)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: english\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpcyi2tf_n.scala:17:27 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                    result += english(nextIndex)\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of String - did you mean String.!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpcyi2tf_n.scala:17:30 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                    result += english(nextIndex)\n\e[31m\e\
    [31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                         Not found: english\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978930
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val newMessage = messageArray.map(letter => {\n            val index\
    \ = alphabet.indexOf(letter)\n            val vowelIndex = vowels.indexOf(letter)\n\
    \            if(index != -1 && vowelIndex != -1) {\n                val vowel\
    \ = vowels(vowelIndex)\n                val vowel2 = alphabet(vowelIndex+1)\n\
    \                val newLetter = vowel + vowel2\n                alphabet(index)\
    \ = newLetter\n            }\n            letter\n        }).mkString\n      \
    \  newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbpf_5647.scala:21:16 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                alphabet(index) = newLetter\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue update is not\
    \ a member of List[Char] - did you mean alphabet.updated?\n1 error found\n"
  stdout: ''
  timestamp: 1659978931
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        var result = \"\"\n     \
    \   var vowels = \"aeiouAEIOU\"\n        var letters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var vowelsCount = new mutable.HashMap[String, Int]()\n        var lettersCount\
    \ = new mutable.HashMap[String, Int]()\n        for (letter <- message) {\n  \
    \          val index = letters.indexOf(letter)\n            if (index != -1) {\n\
    \                lettersCount.put(letter, lettersCount.getOrElse(letter, 0) +\
    \ 1)\n            }\n        }\n        for (letter <- letters) {\n          \
    \  val index = vowels.indexOf(letter)\n            if (index != -1) {\n      \
    \          vowelsCount.put(letter, vowelsCount.getOrElse(letter, 0) + 1)\n   \
    \         }\n        }\n        for (letter <- vowels) {\n            val index\
    \ = lettersCount.getOrElse(letter, 0)\n            val vowelsCount = vowelsCount.getOrElse(letter,\
    \ 0)\n            if (index == vowelsCount) {\n                result += letter\n\
    \            }\n        }\n        return result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpan4f3b74.scala:14:30 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mvar\e[0m \e[36mvowelsCount\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                              ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpan4f3b74.scala:15:31 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mvar\e[0m \e[36mlettersCount\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mInt\e[0m]()\n\e[31m\e[31m   |\e[0m                    \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978928
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageList =\
    \ message.split(\"\")\n        val newMessage = messageList.foldLeft(\"\")( (acc,\
    \ elem) => {\n            val index = alphabet.indexOf(elem)\n            val\
    \ nextIndex = index + 2\n            val nextLetter = alphabet(nextIndex)\n  \
    \          acc + (if (vowels.contains(elem)) nextLetter else elem)\n        })\n\
    \        newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdcty540b.scala:23)\n\tat Problem.main(tmpdcty540b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978933
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = Set(\"a\", \"\
    e\", \"i\", \"o\", \"u\")\n        val messageArray = message.split(\"\")\n  \
    \      val newMessageArray = messageArray.map(letter => \n            vowels.contains(letter)\
    \ ? letter : \n            vowels.find(letter => letter != letter + 2) match {\n\
    \                case Some(vowel) => vowel\n                case None => letter\n\
    \            }\n        )\n        val newMessage = messageArray.toList.mkString(\"\
    \")\n        val newMessageArray2 = newMessageArray.toList.map(letter => \n  \
    \          vowels.contains(letter) ? letter : \n            vowels.find(letter\
    \ => letter != letter + 2) match {\n                case Some(vowel) => vowel\n\
    \                case None => letter\n            }\n        )\n        val newMessage2\
    \ = newMessageArray2.toList.mkString(\"\")\n        val newMessage3 = newMessage2.toList.mkString(\"\
    \")\n        val newMessage4 = newMessage3.toList.mkString(\"\")\n        val\
    \ newMessage5 = newMessage4.toList.mkString(\"\")\n        val newMessage6 = newMessage5.toList.mkString(\"\
    \")\n        val newMessage7 = newMessage6.toList.mkString(\"\")\n        val\
    \ newMessage8 = newMessage7.toList.mkString(\"\")\n        val newMessage9 = newMessage8.toList.mkString(\"\
    \")\n        val newMessage10 = newMessage9.toList.mkString(\"\")\n        val\
    \ newMessage11 = newMessage10.toList.mkString(\"\")\n        val newMessage12\
    \ = newMessage11.toList.mkString(\"\")\n        val newMessage13 = newMessage12.toList.mkString(\"\
    \")\n        val newMessage14 = newMessage13.toList.mkString(\"\")\n        val\
    \ newMessage15 = newMessage14.toList.mkString(\"\")\n        val newMessage16\
    \ = newMessage15.toList.mkString(\"\")\n        val newMessage17 = newMessage16.toList.mkString(\"\
    \")\n        val newMessage18 = newMessage17.toList.mkString(\"\")\n        val\
    \ newMessage19 = newMessage18.toList.mkString(\"\")\n        val newMessage20\
    \ = newMessage19.toList.mkString(\"\")\n        val newMessage21 = newMessage20.toList.mkString(\"\
    \")\n        val newMessage22 = newMessage21.toList.mkString(\"\")\n        val\
    \ newMessage23 = newMessage22.toList.mkString(\"\")\n        val newMessage24\
    \ = newMessage23.toList.mkString(\"\")\n        val newMessage25 = newMessage24.toList.mkString(\"\
    \")\n        val newMessage26 = newMessage25.toList.mkString(\"\")\n        val\
    \ newMessage27 = newMessage26.toList.mkString(\"\")\n        val new\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpnfde24wl.scala:15:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            vowels.find(\e[36mletter\e[0m => letter !=\
    \ letter + \e[31m2\e[0m) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m           \
    \            ^\e[0m\n\e[31m   |\e[0m                       end of statement expected\
    \ but '(' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnfde24wl.scala:19:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        )\n\e[31m\e[31m\
    \   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '}' expected, but unindent found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnfde24wl.scala:14:36 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            vowels.contains(letter) ? letter : \n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \       value ? is not a member of Boolean\n\e[31m\e[31m-- Error: /tmp/tmpnfde24wl.scala:15:55\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \     vowels.find(\e[36mletter\e[0m => letter != letter + \e[31m2\e[0m) \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m                                                 \
    \      ^\e[0m\n\e[31m   |\e[0m                                          No ClassTag\
    \ available for B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                          \
    \                where:    B is a type variable\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpnfde24wl.scala:16:36 ------------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m                \e[33mcase\e[0m Some(vowel) => vowel\n\e[31m\e[31m   |\e\
    [0m                                    ^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                         Not found: vowel\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpnfde24wl.scala:17:29 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m None => letter\n\e[31m\e[31m\
    \   |\e[0m                             ^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                   Not found: letter\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type "
  stdout: ''
  timestamp: 1659978932
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageList = message.split('')\n\
    \        val encodedMessage = messageList.map(letter => \n            letter match\
    \ {\n                case 'a' => alphabet(0)\n                case 'b' => alphabet(1)\n\
    \                case 'c' => alphabet(2)\n                case 'd' => alphabet(3)\n\
    \                case 'e' => alphabet(4)\n                case 'f' => alphabet(5)\n\
    \                case 'g' => alphabet(6)\n                case 'h' => alphabet(7)\n\
    \                case 'i' => alphabet(8)\n                case 'j' => alphabet(9)\n\
    \                case 'k' => alphabet(10)\n                case 'l' => alphabet(11)\n\
    \                case 'm' => alphabet(12)\n                case 'n' => alphabet(13)\n\
    \                case 'o' => alphabet(14)\n                case 'p' => alphabet(15)\n\
    \                case 'q' => alphabet(16)\n                case 'r' => alphabet(17)\n\
    \                case 's' => alphabet(18)\n                case 't' => alphabet(19)\n\
    \                case 'u' => alphabet(20)\n                case 'v' => alphabet(21)\n\
    \                case 'w' => alphabet(22)\n                case 'x' => alphabet(23)\n\
    \                case 'y' => alphabet(24)\n                case 'z' => alphabet(25)\n\
    \                case _ => letter\n            }\n        ).mkString(\"\")\n \
    \       val vowelsMap = vowels.zip(vowels.tail).map(x => x._1 -> x._2)\n     \
    \   val encodedMessageMap = encodedMessage.zip(vowelsMap).map(x => x._1 -> x._2)\n\
    \        val encodedMessageMap2 = encodedMessage.zip(vowelsMap).map(x => x._1\
    \ -> x._2)\n        val encodedMessageMap3 = encodedMessage.zip(vowelsMap).map(x\
    \ => x._1 -> x._2)\n        val encodedMessageMap4 = encodedMessage.zip(vowelsMap).map(x\
    \ => x._1 -> x._2)\n        val encodedMessageMap5 = encodedMessage.zip(vowelsMap).map(x\
    \ => x._1 -> x._2)\n        val encodedMessageMap6 = encodedMessage.zip(vowelsMap).map(x\
    \ => x._1 -> x._2)\n        val encodedMessageMap7 = encodedMessage.zip(vowelsMap).map(x\
    \ => x._1 -> x._2)\n        val encodedMessageMap8 = encodedMessage.zip(vowelsMap).map(x\
    \ => x._1 -> x._2)\n        val encodedMessageMap9 = encodedMessage.zip(vowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp5kjuacsn.scala:13:40 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmessageList\e[0m = message.split('')\n\
    \e[31m\e[31m   |\e[0m                                        ^\e[0m\n\e[31m  \
    \ |\e[0m                                        empty character literal\n\e[31m\e\
    [31m-- [E018] Syntax Error: /tmp/tmp5kjuacsn.scala:14:27 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mencodedMessage\e[0m = messageList.map(\e\
    [36mletter\e[0m => \n\e[31m\e[31m   |\e[0m                           ^\e[0m\n\e\
    [31m   |\e[0m                           expression expected but \e[31m=\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5kjuacsn.scala:55:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    ')' expected, but '}' found\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5kjuacsn.scala:14:8 -------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mencodedMessage\e[0m = messageList.map(\e\
    [36mletter\e[0m => \n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m  \
    \      Not found: 'val\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5kjuacsn.scala:46:32\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e\
    [36mencodedMessageMap\e[0m = encodedMessage.zip(vowelsMap).map(\e[36mx\e[0m =>\
    \ x._1 -> x._2)\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: encodedMessage\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5kjuacsn.scala:47:33\
    \ ------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e\
    [36mencodedMessageMap2\e[0m = encodedMessage.zip(vowelsMap).map(\e[36mx\e[0m =>\
    \ x._1 -> x._2)\n\e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m             "
  stdout: ''
  timestamp: 1659978931
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => {\n            if (vowels.contains(letter)) {\n \
    \               val vowelIndex = vowels.indexOf(letter)\n                val vowel2Index\
    \ = vowels.indexOf(vowels.charAt(vowelIndex + 1))\n                vowels.charAt(vowelIndex\
    \ + 1) match {\n                    case vowel => vowel\n                    case\
    \ _ => vowels.charAt(vowel2Index + 1)\n                }\n            } else {\n\
    \                letter\n            }\n        }).mkString(\"\")\n        encodedMessage\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwzh223ty.scala:28)\n\tat Problem.main(tmpwzh223ty.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessage = messageArray.foldLeft(\"\
    \") {\n            case (acc, elem) => acc + (elem.toUpperCase + elem.toLowerCase\
    \ + vowels.indexOf(elem.toUpperCase))\n        }\n        newMessage\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmparm8bfwf.scala:19)\n\tat Problem.main(tmparm8bfwf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978933
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => {\n            val index = alphabet.indexOf(letter)\n            val nextIndex\
    \ = alphabet.indexOf(vowels, index + 1)\n            alphabet(index) match {\n\
    \                case vowel => vowel\n                case _ => alphabet(nextIndex)\n\
    \            }\n        })\n        newMessageArray.toString.toUpperCase\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat scala.collection.StringOps$.apply$extension(StringOps.scala:185)\n\tat Problem$.$anonfun$1(tmpmrj942e_.scala:17)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.encode(tmpmrj942e_.scala:21)\n\
    \tat Problem$.main(tmpmrj942e_.scala:25)\n\tat Problem.main(tmpmrj942e_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978934
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('e','i','o','u')\n        val newMessage = message.toLowerCase\n\
    \        val newMessageList = newMessage.split(\"\")\n        val newMessageList2\
    \ = newMessageList.map(x => alphabet(alphabet.indexOf(x) + 1))\n        val newMessageList3\
    \ = newMessageList2.map(x => vowels(vowels.indexOf(x) + 1))\n        newMessageList3.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphhyfow0t.scala:20)\n\tat Problem.main(tmphhyfow0t.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978935
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => \n            letter match {\n                case 'a' => alphabet(0)\n \
    \               case 'b' => alphabet(1)\n                case 'c' => alphabet(2)\n\
    \                case 'd' => alphabet(3)\n                case 'e' => alphabet(4)\n\
    \                case 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n\
    \                case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n\
    \                case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n\
    \                case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case _ => letter\n\
    \            }\n        )\n        val newMessage = messageArray.mkString(\"\"\
    )\n        val newMessageArray2 = newMessageArray.map(letter => \n           \
    \ letter match {\n                case 'a' => vowels(0)\n                case\
    \ 'b' => vowels(1)\n                case 'c' => vowels(2)\n                case\
    \ 'd' => vowels(3)\n                case 'e' => vowels(4)\n                case\
    \ 'f' => vowels(5)\n                case 'g' => vowels(6)\n                case\
    \ 'h' => vowels(7)\n                case 'i' => vowels(8)\n                case\
    \ 'j' => vowels(9)\n                case 'k' => vowels(10)\n                case\
    \ 'l' => vowels(11)\n                case 'm' => vowels(12)\n                case\
    \ 'n' => vowels(13)\n                case 'o' => vowels(14)\n                case\
    \ 'p' => vowels(15)\n                case 'q' => vowels(16)\n                case\
    \ 'r' => vowels(17)\n                case 's' => vowels(18)\n                case\
    \ 't' => vowels(19)\n                case 'u' => vowels(20)\n                case\
    \ 'v' => vowels(21)\n                case 'w' => vowels(22)\n                case\
    \ 'x' => vowels(23)\n                case 'y' => vowels(24)\n                case\
    \ 'z' => vowels(25)\n                case _ => letter\n            }\n       \
    \ )\n        val newMessage\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_5_jdhcp.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp_5_jdhcp.scala:16:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'a'\e[0m => alphabet(\e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp_5_jdhcp.scala:17:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'b'\e[0m => alphabet(\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp_5_jdhcp.scala:18:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'c'\e[0m => alphabet(\e[31m2\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp_5_jdhcp.scala:19:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'd'\e[0m => alphabet(\e[31m3\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp_5_jdhcp.scala:20:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'e'\e[0m => alphabet(\e[31m4\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmp_5_jdhcp.scala:21:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'f'\e[0m => alphabet(\e[31m5\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared"
  stdout: ''
  timestamp: 1659978935
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val newMessageArray = messageArray.map { x =>\n            val index\
    \ = alphabet.indexOf(x)\n            val vowelIndex = vowels.indexOf(x)\n    \
    \        val nextVowelIndex = vowelIndex + 2\n            if (index >= 0 && vowelIndex\
    \ >= 0) {\n                if (nextVowelIndex >= 0 && nextVowelIndex < alphabet.length)\
    \ {\n                    alphabet(index)\n                } else {\n         \
    \           alphabet(index)\n                }\n            } else {\n       \
    \         x\n            }\n        }\n        newMessageArray.toList.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpwvfdem92.scala:31)\n\tat Problem.main(tmpwvfdem92.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978934
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => \n            vowels.indexOf(letter) match {\n  \
    \              case -1 => letter\n                case i => vowels(i + 2)\n  \
    \          }\n        )\n        val newMessage = newMessageArray.toList\n   \
    \     val newMessageString = newMessage.toString\n        val newMessageStringArray\
    \ = newMessageString.split(\"\")\n        val newMessageStringArrayLength = newMessageStringArray.length\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessageStringArrayLength = newMessageStringArrayLength - 1\n  \
    \      val newMessageStringArrayLength = newMessageStringArrayLength - 1\n   \
    \     val newMessageStringArrayLength = newMessageStringArrayLength - 1\n    \
    \    val newMessageStringArrayLength = newMessageStringArrayLength - 1\n     \
    \   val newMessageStringArrayLength = newMessageStringArrayLength - 1\n      \
    \  val newMessageStringArrayLength = newMessageStringArrayLength - 1\n       \
    \ val newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val\
    \ newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength\
    \ - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength -\
    \ 1\n        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessageStringArrayLength = newMessageStringArrayLength - 1\n  \
    \      val newMessageStringArrayLength = newMessageStringArrayLength - 1\n   \
    \     val newMessageStringArrayLength = newMessageStringArrayLength - 1\n    \
    \    val newMessageStringArrayLength = newMessageStringArrayLength - 1\n     \
    \   val newMessageStringArrayLength = newMessageStringArrayLength - 1\n      \
    \  val newMessageStringArrayLength = newMessageStringArrayLength - 1\n       \
    \ val newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val\
    \ newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength\
    \ - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength -\
    \ 1\n        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessageStringArrayLength = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp7wfdbwtw.scala:52:41 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                         ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7wfdbwtw.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnewMessageStringArrayLength\e[0m = newMessageStringArrayLength - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7wfdbwtw.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7wfdbwtw.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e"
  stdout: ''
  timestamp: 1659978937
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val newMessage = messageArray.map(letter => \n            if (vowels.contains(letter))\
    \ letter else alphabet(alphabet.indexOf(letter) + 2))\n        newMessage.toString.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4y9xesig.scala:19)\n\tat Problem.main(tmp4y9xesig.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978938
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase.map(letter => vowels.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case 0 => letter\n     \
    \       case 1 => vowels.charAt(letter - 1) + letter\n            case 2 => vowels.charAt(letter\
    \ - 1) + vowels.charAt(letter - 2)\n            case _ => letter\n        })\n\
    \        val messageWithVowelsReversed = messageWithVowels.reverse\n        val\
    \ messageWithVowelsReversedWithVowelsReplaced = messageWithVowelsReversed.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case 0 => letter\n            case 1 => vowels.charAt(letter - 1) + letter\n\
    \            case 2 => vowels.charAt(letter - 1) + vowels.charAt(letter - 2)\n\
    \            case _ => letter\n        })\n        val messageWithVowelsReversedWithVowelsReplacedReversed\
    \ = messageWithVowelsReversedWithVowelsReplaced.reverse\n        val messageWithVowelsReversedWithVowelsReplacedReversedWithVowelsReplaced\
    \ = messageWithVowelsReversedWithVowelsReplacedReversed.map(letter => vowels.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case 0 => letter\n     \
    \       case 1 => vowels.charAt(letter - 1) + letter\n            case 2 => vowels.charAt(letter\
    \ - 1) + vowels.charAt(letter - 2)\n            case _ => letter\n        })\n\
    \        val messageWithVowelsReversedWithVowelsReplacedReversedWithVowelsReplacedReversed\
    \ = messageWithVowelsReversedWithVowelsReplacedReversedWithVowelsReplacedReversed.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case 0 => letter\n            case 1 => vowels.charAt(letter - 1) + letter\n\
    \            case 2 => vowels.charAt(letter - 1) + vowels.charAt(letter - 2)\n\
    \            case _ => letter\n        })\n        val messageWithVowelsReversedWithVowelsReplacedReversedWithVowelsReplacedReversedWithVowelsReplacedReversed\
    \ = messageWithVowelsReversedWithVowelsReplacedReversedWithVowelsReplacedReversedWithVowelsReplacedReversed.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case 0 => letter\n            case \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpbal7va6u.scala:45:16 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m            \e[33mcase\e[0m \n\e[31m\e[31m   |\e[0m \
    \               ^\e[0m\n\e[31m   |\e[0m                pattern expected\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbal7va6u.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpbal7va6u.scala:56:0 ----------------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbal7va6u.scala:23:43 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m \e[31m1\e[0m => vowels.charAt(letter\
    \ - \e[31m1\e[0m) + letter\n\e[31m\e[31m   |\e[0m                            \
    \        ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of AnyVal, but\
    \ could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mOne of the following imports might make progress towards fixing the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpbal7va6u.scala:24:43 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m            \e[33mcase\e[0m \e[31m2\e[0m => vowels.charAt(letter\
    \ - \e[31m1\e[0m) + vowels.charAt(letter - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                                    ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is\
    \ not a member of AnyVal, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import m"
  stdout: ''
  timestamp: 1659978942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageList =\
    \ message.split(\"\")\n        val encodedMessage = messageList.foldLeft(\"\"\
    ) { (result, current) =>\n            val index = alphabet.indexOf(current)\n\
    \            val vowelIndex = vowels.indexOf(current)\n            if (index !=\
    \ -1 && vowelIndex != -1) {\n                val nextIndex = index + vowelIndex\n\
    \                val nextChar = alphabet(nextIndex)\n                result +\
    \ nextChar\n            } else {\n                result + current\n         \
    \   }\n        }\n        encodedMessage\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7sn7a4f0.scala:28)\n\tat Problem.main(tmp7sn7a4f0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978940
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageLength\
    \ = message.length\n        val encodedMessage = mutable.StringBuilder()\n   \
    \     var i = 0\n        while (i < messageLength) {\n            val currentChar\
    \ = message.charAt(i)\n            val currentCharIndex = alphabet.indexOf(currentChar)\n\
    \            val currentCharNext = message.charAt(i + 1)\n            val currentCharNextIndex\
    \ = alphabet.indexOf(currentCharNext)\n            val currentCharPreviousIndex\
    \ = alphabet.indexOf(currentChar - 2)\n            val currentCharPreviousNextIndex\
    \ = alphabet.indexOf(currentChar + 2)\n            val currentCharPreviousNextPreviousIndex\
    \ = alphabet.indexOf(currentChar + 3)\n            val currentCharPreviousNextPreviousNextIndex\
    \ = alphabet.indexOf(currentChar + 4)\n            val currentCharPreviousNextPreviousNextNextIndex\
    \ = alphabet.indexOf(currentChar + 5)\n            val currentCharPreviousNextPreviousNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 6)\n            val currentCharPreviousNextPreviousNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 7)\n            val currentCharPreviousNextPreviousNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 8)\n            val currentCharPreviousNextPreviousNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 9)\n            val currentCharPreviousNextPreviousNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 10)\n            val currentCharPreviousNextPreviousNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 11)\n            val currentCharPreviousNextPreviousNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 12)\n            val currentCharPreviousNextPreviousNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 13)\n            val currentCharPreviousNextPreviousNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 14)\n            val currentCharPreviousNextPreviousNextNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 15)\n            val currentCharPreviousNextPreviousNextNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 16)\n            val currentCharPreviousNextPreviousNextNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 17)\n            val currentCharPreviousNextPreviousNextNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 18)\n            val currentCharPreviousNextPreviousNextNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 19)\n            val currentCharPreviousNextPreviousNextNextNextNextNextNextIndex\
    \ = alphabet.indexOf(currentChar + 20)\n            val currentCharPreviousNextPreviousNextNextNextNextNextNextIndex\
    \ = alphabet.indexOf(\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1bwjtoay.scala:41:96 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m            \e[33mval\e[0m \e[36mcurrentCharPreviousNextPreviousNextNextNextNextNextNextIndex\e\
    [0m = alphabet.indexOf(\n\e[31m\e[31m   |\e[0m                               \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1bwjtoay.scala:52:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m52 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp1bwjtoay.scala:14:29 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mencodedMessage\e[0m = mutable.StringBuilder()\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp1bwjtoay.scala:28:16 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mcurrentCharPreviousNextPreviousNextNextNextNextIndex\e\
    [0m = alphabet.indexOf(currentChar + \e[31m8\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcurrentCharPreviousNextPreviousNextNextNextNextIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mcurrentCharPreviousNextPreviousNextNextNextNextIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1bwjtoay.scala:29:16 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m            \e[33mval\e[0m \e[36mcurrentCharPreviousNextPreviousNextNextNextNextIndex\e\
    [0m = alphabet.indexOf(currentChar + \e[31m9\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659978941
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = Set(\"a\", \"\
    e\", \"i\", \"o\", \"u\")\n        val messageArray = message.split(\"\")\n  \
    \      val newMessage = messageArray.map(letter => \n            vowels.contains(letter)\
    \ ? letter : \n            vowels.find(letter => letter != letter - 2) match {\n\
    \                case Some(vowel) => vowel\n                case None => letter\n\
    \            }\n        ).mkString(\"\")\n        newMessage\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpvqcufqv1.scala:15:23 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            vowels.find(\e[36mletter\e[0m => letter !=\
    \ letter - \e[31m2\e[0m) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m           \
    \            ^\e[0m\n\e[31m   |\e[0m                       end of statement expected\
    \ but '(' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqcufqv1.scala:19:8\
    \ ----------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        ).mkString(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        '}'\
    \ expected, but unindent found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvqcufqv1.scala:14:36\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m            vowels.contains(letter)\
    \ ? letter : \n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m            value ? is not a member of Boolean\n\e[31m\e[31m--\
    \ Error: /tmp/tmpvqcufqv1.scala:15:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            vowels.find(\e[36mletter\e[0m => letter !=\
    \ letter - \e[31m2\e[0m) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e[0m           \
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \                                 No ClassTag available for B\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m                                          where:    B is a type\
    \ variable\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvqcufqv1.scala:16:36\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m                \e[33mcase\e\
    [0m Some(vowel) => vowel\n\e[31m\e[31m   |\e[0m                              \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                                    Not found:\
    \ vowel\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvqcufqv1.scala:17:29\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e\
    [0m None => letter\n\e[31m\e[31m   |\e[0m                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             Not found: letter\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[3"
  stdout: ''
  timestamp: 1659978941
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageWithVowels\
    \ = message.toLowerCase.map(letter => \n            if (vowels.contains(letter))\
    \ letter else alphabet.charAt(alphabet.indexOf(letter) + 2))\n        val messageWithVowelsAndVowelsReplaced\
    \ = messageWithVowels.map(letter => \n            if (vowels.contains(letter))\
    \ letter else vowels.charAt(vowels.indexOf(letter) + 1))\n        val messageWithVowelsAndVowelsReplacedAndVowelsReplaced\
    \ = messageWithVowelsAndVowelsReplaced.map(letter => \n            if (vowels.contains(letter))\
    \ letter else vowels.charAt(vowels.indexOf(letter) + 1))\n        val messageWithVowelsAndVowelsReplacedAndVowelsReplacedAndVowelsReplaced\
    \ = messageWithVowelsAndVowelsReplacedAndVowelsReplaced.map(letter => \n     \
    \       if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter)\
    \ + 1))\n        val messageWithVowelsAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplaced\
    \ = messageWithVowelsAndVowelsReplacedAndVowelsReplacedAndVowelsReplaced.map(letter\
    \ => \n            if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter)\
    \ + 1))\n        val messageWithVowelsAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplaced\
    \ = messageWithVowelsAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp59mwwyh2.scala:23:117 -----------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplaced\e\
    [0m = messageWithVowelsAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowel\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: messageWithVowelsAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowelsReplacedAndVowel\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp59mwwyh2.scala:24:5\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978941
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => \n            letter match {\n                case vowel => vowels.indexOf(vowel)\n\
    \                case _ => letter\n            }\n        ).mkString(\"\")\n \
    \       val newMessageArray = newMessage.split(\"\")\n        val newMessageArray2\
    \ = newMessageArray.map(letter => \n            letter match {\n             \
    \   case vowel => vowels.indexOf(vowel)\n                case _ => letter\n  \
    \          }\n        ).mkString(\"\")\n        val newMessageArray3 = newMessageArray2.split(\"\
    \")\n        val newMessageArray4 = newMessageArray3.map(letter => \n        \
    \    letter match {\n                case vowel => vowels.indexOf(vowel)\n   \
    \             case _ => letter\n            }\n        ).mkString(\"\")\n    \
    \    val newMessageArray5 = newMessageArray4.split(\"\")\n        val newMessageArray6\
    \ = newMessageArray5.map(letter => \n            letter match {\n            \
    \    case vowel => vowels.indexOf(vowel)\n                case _ => letter\n \
    \           }\n        ).mkString(\"\")\n        val newMessageArray7 = newMessageArray6.split(\"\
    \")\n        val newMessageArray8 = newMessageArray7.map(letter => \n        \
    \    letter match {\n                case vowel => vowels.indexOf(vowel)\n   \
    \             case _ => letter\n            }\n        ).mkString(\"\")\n    \
    \    val newMessageArray9 = newMessageArray8.split(\"\")\n        val newMessageArray10\
    \ = newMessageArray9.map(letter => \n            letter match {\n            \
    \    case vowel => vowels.indexOf(vowel)\n                case _ => letter\n \
    \           }\n        ).mkString(\"\")\n        val newMessageArray11 = newMessageArray10.split(\"\
    \")\n        val newMessageArray12 = newMessageArray11.map(letter => \n      \
    \      letter match {\n                case vowel => vowels.indexOf(vowel)\n \
    \               case _ => letter\n            }\n        ).mkString(\"\")\n  \
    \      val newMessageArray13 = newMessageArray12.split(\"\")\n        val newMessageArray14\
    \ = newMessageArray13.map(letter => \n            letter match {\n           \
    \     case vowel => vowels.indexOf(vowel)\n                case _ => letter\n\
    \            }\n        ).mkString(\"\")\n        val newMessageArray15 = newMessageArray14.split(\"\
    \")\n        val newMessageArray16 = newMessageArray15.map(letter => \n      \
    \      letter match {\n                case vowel => vowels.indexOf(vowel)\n \
    \               case _ => letter\n            }\n        ).mkString(\"\")\n  \
    \      val newMessageArray17 = newMessageArray16.split(\"\")\n        val newMessageArray18\
    \ = newMessageArray17.map(letter => \n            letter \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmputv_qj4t.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmputv_qj4t.scala:78:5 ---------------------\e[0m\e[0m\n\e[31m78 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(letter => letters.indexOf(letter) + letters.indexOf(vowels.charAt(0))\
    \ + 1).map(letter => letters.charAt(letter))\n        newMessage.toString\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmps7mqnefr.scala:17)\n\tat Problem.main(tmps7mqnefr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val newMessage = messageArray.map(letter => alphabet(alphabet.indexOf(letter))\
    \ + vowels(vowels.indexOf(letter)) + alphabet(alphabet.indexOf(letter) + 1))\n\
    \        newMessage.toString\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\
    \tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\
    \tat Problem$.$anonfun$1(tmppd80l5w7.scala:14)\n\tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\
    \tat Problem$.encode(tmppd80l5w7.scala:14)\n\tat Problem$.main(tmppd80l5w7.scala:18)\n\
    \tat Problem.main(tmppd80l5w7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native\
    \ Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase.filter(letter => vowels.contains(letter))\n\
    \        val messageWithVowelsAndTwoLettersBefore = messageWithVowels.map(letter\
    \ => vowels.indexOf(letter) + 2)\n        val messageWithVowelsAndTwoLettersAfter\
    \ = messageWithVowels.map(letter => vowels.indexOf(letter) + 1)\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBefore\
    \ = messageWithVowelsAndTwoLettersAfter.map(letter => vowels.indexOf(letter) -\
    \ 1)\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfter\
    \ = messageWithVowelsAndTwoLettersAfterAndOneLetterBefore.map(letter => vowels.indexOf(letter)\
    \ + 1)\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBefore\
    \ = messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfter.map(letter\
    \ => vowels.indexOf(letter) + 2)\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfter\
    \ = messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBefore.map(letter\
    \ => vowels.indexOf(letter) + 3)\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBefore\
    \ = messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfter.map(letter\
    \ => vowels.indexOf(letter) + 4)\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfter\
    \ = messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBefore.map(letter\
    \ => vowels.indexOf(letter) + 5)\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfter\
    \ = messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOne\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnuptnnzx.scala:21:190 -----------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfter\e\
    [0m = messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOne\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfterAndOne\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnuptnnzx.scala:22:5\
    \ ---------------------\e[0m\e[0m\n\e[31m22 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => {\n            val index = vowels.indexOf(letter)\n            if (index\
    \ != -1) {\n                vowels(index - 1) + vowels(index)\n            } else\
    \ {\n                letter\n            }\n        }).mkString(\"\")\n      \
    \  newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv4m6ix62.scala:24)\n\tat Problem.main(tmpv4m6ix62.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978944
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => \n            letter match {\n                case\
    \ vowels(0) => vowels(1)\n                case vowels(1) => vowels(0)\n      \
    \          case _ => letter\n            }\n        )\n        val newMessage\
    \ = messageArray.toList.mkString(\"\")\n        val newMessageArray2 = newMessageArray.toList.map(letter\
    \ => \n            letter match {\n                case vowels(0) => vowels(1)\n\
    \                case vowels(1) => vowels(0)\n                case _ => letter\n\
    \            }\n        )\n        val newMessage2 = newMessageArray2.toList.mkString(\"\
    \")\n        val newMessageArray3 = newMessage2.split(\"\")\n        val newMessage3\
    \ = newMessageArray3.map(letter => \n            letter match {\n            \
    \    case vowels(0) => vowels(1)\n                case vowels(1) => vowels(0)\n\
    \                case _ => letter\n            }\n        )\n        val newMessage4\
    \ = newMessage3.toList.mkString(\"\")\n        val newMessageArray5 = newMessage4.split(\"\
    \")\n        val newMessage5 = newMessageArray5.map(letter => \n            letter\
    \ match {\n                case vowels(0) => vowels(1)\n                case vowels(1)\
    \ => vowels(0)\n                case _ => letter\n            }\n        )\n \
    \       val newMessage6 = newMessage5.toList.mkString(\"\")\n        val newMessageArray7\
    \ = newMessage6.split(\"\")\n        val newMessage7 = newMessageArray7.map(letter\
    \ => \n            letter match {\n                case vowels(0) => vowels(1)\n\
    \                case vowels(1) => vowels(0)\n                case _ => letter\n\
    \            }\n        )\n        val newMessage8 = newMessage7.toList.mkString(\"\
    \")\n        val newMessageArray9 = newMessage8.split(\"\")\n        val newMessage9\
    \ = newMessageArray9.map(letter => \n            letter match {\n            \
    \    case vowels(0) => vowels(1)\n                case vowels(1) => vowels(0)\n\
    \                case _ => letter\n            }\n        )\n        val newMessage10\
    \ = newMessage9.toList.mkString(\"\")\n        val newMessageArray11 = newMessage10.split(\"\
    \")\n        val newMessage11 = newMessageArray11.map(letter => \n           \
    \ letter match {\n                case vowels(0) => vowels(1)\n              \
    \  case vowels(1) => vowels(0)\n                case _ => letter\n           \
    \ }\n        )\n        val newMessage12 = newMessage11.toList.mkString(\"\")\n\
    \        val newMessageArray13 = newMessage12.split(\"\")\n        val newMessage13\
    \ = newMessageArray13.\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmpmn_iu_.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpmpmn_iu_.scala:76:5 ---------------------\e[0m\e[0m\n\e[31m76\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978942
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val newMessage =\
    \ message\n        val newMessageList = newMessage.split(\"\")\n        val newMessageList2\
    \ = newMessageList.map(x => alphabet(alphabet.indexOf(x) + 1))\n        val newMessageList3\
    \ = newMessageList2.map(x => vowels(vowels.indexOf(x) + 1))\n        newMessageList3.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzkfr29vv.scala:20)\n\tat Problem.main(tmpzkfr29vv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978945
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case 0 => letter\n            case 1 => vowels(letter - 1) + letter\n    \
    \        case 2 => vowels(letter - 1) + vowels(letter - 2)\n            case _\
    \ => letter\n        }).mkString(\"\")\n        newMessage\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmprvcf0q5j.scala:16:36 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mcase\e[0m \e[31m1\e[0m => vowels(letter\
    \ - \e[31m1\e[0m) + letter\n\e[31m\e[31m   |\e[0m                            \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmprvcf0q5j.scala:17:36 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m \e[31m2\e[0m => vowels(letter\
    \ - \e[31m1\e[0m) + vowels(letter - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                        ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmprvcf0q5j.scala:17:57 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m \e[31m2\e[0m => vowels(letter\
    \ - \e[31m1\e[0m) + vowels(letter - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                                             ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ - is not a member of String, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits"
  stdout: ''
  timestamp: 1659978945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val newMessage =\
    \ message.map(letter => alphabet(alphabet.indexOf(letter) + 1))\n        val newVowels\
    \ = vowels.map(letter => alphabet(alphabet.indexOf(letter) + 2))\n        newMessage.zip(newVowels).map(x\
    \ => x._1 + \"-\" + x._2).mkString\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmptp5soad2.scala:18)\n\tat Problem.main(tmptp5soad2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978945
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val newMessage =\
    \ message.map(letter => alphabet(alphabet.indexOf(letter) + 1))\n        val newVowels\
    \ = vowels.map(letter => alphabet(alphabet.indexOf(letter) + 1))\n        newMessage.zip(newVowels).map(x\
    \ => x.swap).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ope4wod.scala:18)\n\tat Problem.main(tmp9ope4wod.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978945
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => \n            letter match {\n                case\
    \ vowels(0) => vowels(1)\n                case vowels(1) => vowels(0)\n      \
    \          case _ => letter\n            }\n        )\n        val newMessage\
    \ = messageArray.toList.mkString(\"\")\n        val newMessageArray2 = newMessage.split(\"\
    \")\n        val newMessageArray3 = newMessageArray2.map(letter => \n        \
    \    letter match {\n                case vowels(0) => vowels(1)\n           \
    \     case vowels(1) => vowels(0)\n                case _ => letter\n        \
    \    }\n        )\n        val newMessage2 = newMessageArray3.toList.mkString(\"\
    \")\n        val newMessageArray4 = newMessage2.split(\"\")\n        val newMessageArray5\
    \ = newMessageArray4.map(letter => \n            letter match {\n            \
    \    case vowels(0) => vowels(1)\n                case vowels(1) => vowels(0)\n\
    \                case _ => letter\n            }\n        )\n        val newMessage3\
    \ = newMessageArray5.toList.mkString(\"\")\n        val newMessageArray6 = newMessage3.split(\"\
    \")\n        val newMessageArray7 = newMessageArray6.map(letter => \n        \
    \    letter match {\n                case vowels(0) => vowels(1)\n           \
    \     case vowels(1) => vowels(0)\n                case _ => letter\n        \
    \    }\n        )\n        val newMessage4 = newMessageArray7.toList.mkString(\"\
    \")\n        val newMessageArray8 = newMessage4.split(\"\")\n        val newMessageArray9\
    \ = newMessageArray8.map(letter => \n            letter match {\n            \
    \    case vowels(0) => vowels(1)\n                case vowels(1) => vowels(0)\n\
    \                case _ => letter\n            }\n        )\n        val newMessage5\
    \ = newMessageArray9.toList.mkString(\"\")\n        val newMessageArray10 = newMessage5.split(\"\
    \")\n        val newMessageArray11 = newMessageArray10.map(letter => \n      \
    \      letter match {\n                case vowels(0) => vowels(1)\n         \
    \       case vowels(1) => vowels(0)\n                case _ => letter\n      \
    \      }\n        )\n        val newMessage6 = newMessageArray11.toList.mkString(\"\
    \")\n        val newMessageArray12 = newMessage6.split(\"\")\n        val newMessageArray13\
    \ = newMessageArray12.map(letter => \n            letter match {\n           \
    \     case vowels(0) => vowels(1)\n                case vowels(1) => vowels(0)\n\
    \                case _ => letter\n            }\n        )\n        val newMessage7\
    \ = newMessageArray13.toList.mkString(\"\")\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpisy5h072.scala:76:5\
    \ ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978944
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessage = messageArray.foldLeft(\"\"){\
    \ (acc, elem) =>\n            val index = alphabet.indexOf(elem)\n           \
    \ val nextIndex = index + 2\n            val nextElem = alphabet(nextIndex)\n\
    \            acc + (if (vowels.contains(elem)) elem else nextElem)\n        }\n\
    \        newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfisc15li.scala:23)\n\tat Problem.main(tmpfisc15li.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978946
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => \n            vowels.indexOf(letter) match {\n                case -1 =>\
    \ letter\n                case i => vowels(i + 2)\n            }\n        ).mkString(\"\
    \")\n        newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9ug237b0.scala:22)\n\tat Problem.main(tmp9ug237b0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageList =\
    \ message.split(\"\")\n        val encodedMessage = messageList.map(letter =>\
    \ {\n            val index = alphabet.indexOf(letter)\n            if (index !=\
    \ -1) {\n                val vowelIndex = vowels.indexOf(letter)\n           \
    \     if (vowelIndex != -1) {\n                    val vowel = vowels(vowelIndex)\n\
    \                    val vowelIndex = vowels.indexOf(vowel)\n                \
    \    val vowelIndex = vowelIndex + 2\n                    alphabet(vowelIndex)\
    \ match {\n                        case 'a' => letter\n                      \
    \  case 'e' => letter\n                        case 'i' => letter\n          \
    \              case 'o' => letter\n                        case 'u' => letter\n\
    \                        case _ => letter\n                    }\n           \
    \     } else {\n                    alphabet(index)\n                }\n     \
    \       } else {\n                letter\n            }\n        }).mkString(\"\
    \")\n        encodedMessage\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2mm9hcx8.scala:21:24 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    \e[33mval\e[0m \e[36mvowelIndex\e\
    [0m = vowelIndex + \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelIndex is already defined as \e[33mvalue\e[0m \e[35mvowelIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic\
    \ Error: /tmp/tmp2mm9hcx8.scala:20:52 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m                    \e[33mval\e[0m \e[36mvowelIndex\e[0m = vowels.indexOf(vowel)\n\
    \e[31m\e[31m   |\e[0m                                                    ^\e[0m\n\
    \e[31m   |\e[0m                                        Recursive \e[33mvalue\e\
    [0m \e[35mvowel\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978943
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => \n            letter match {\n                case\
    \ vowel => vowel\n                case _ => vowels.indexOf(letter) + 2\n     \
    \       }\n        )\n        val newMessageString = newMessageArray.toList.toString.mkString(\"\
    \")\n        val newMessageStringArray = Array(newMessageString).map(_.toChar)\n\
    \        newMessageStringArray.mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdz3n7dzw.scala:20:66 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArray\e\
    [0m = Array(newMessageString).map(_.toChar)\n\e[31m\e[31m   |\e[0m           \
    \                                                     ^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                                  value toChar is not a member of String\n\
    \e[31m\e[31m-- Error: /tmp/tmpdz3n7dzw.scala:20:73 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArray\e\
    [0m = Array(newMessageString).map(_.toChar)\n\e[31m\e[31m   |\e[0m           \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0m                                          No ClassTag available for\
    \ B\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                        \
    \  where:    B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978947
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = mutable.StringBuilder()\n        val messageLength = message.length\n    \
    \    val vowelCount = message.count(vowels)\n        val vowelPositions = message.map(letter\
    \ => letters.indexOf(letter))\n        val vowelPositionsSorted = vowelPositions.toSeq.sortBy(_)\n\
    \        val vowelPositionsSortedLength = vowelPositionsSorted.length\n      \
    \  val vowelPositionsSortedLength = vowelPositionsSorted.length\n        val vowelPositionsSortedLength\
    \ = vowelPositionsSorted.length\n        val vowelPositionsSortedLength = vowelPositionsSorted.length\n\
    \        val vowelPositionsSortedLength = vowelPositionsSorted.length\n      \
    \  val vowelPositionsSortedLength = vowelPositionsSorted.length\n        val vowelPositionsSortedLength\
    \ = vowelPositionsSorted.length\n        val vowelPositionsSortedLength = vowelPositionsSorted.length\n\
    \        val vowelPositionsSortedLength = vowelPositionsSorted.length\n      \
    \  val vowelPositionsSortedLength = vowelPositionsSorted.length\n        val vowelPositionsSortedLength\
    \ = vowelPositionsSorted.length\n        val vowelPositionsSortedLength = vowelPositionsSorted.length\n\
    \        val vowelPositionsSortedLength = vowelPositionsSorted.length\n      \
    \  val vowelPositionsSortedLength = vowelPositionsSorted.length\n        val vowelPositionsSortedLength\
    \ = vowelPositionsSorted.length\n        val vowelPositionsSortedLength = vowelPositionsSorted.length\n\
    \        val vowelPositionsSortedLength = vowelPositionsSorted.length\n      \
    \  val vowelPositionsSortedLength = vowelPositionsSorted.length\n        val vowelPositionsSortedLength\
    \ = vowelPositionsSorted.length\n        val vowelPositionsSortedLength = vowelPositionsSorted.length\n\
    \        val vowelPositionsSortedLength = vowelPositionsSorted.length\n      \
    \  val vowelPositionsSortedLength = vowelPositionsSorted.length\n        val vowelPositionsSortedLength\
    \ = vowelPositionsSorted.length\n        val vowelPositionsSortedLength = vowelPositionsSorted.length\n\
    \        val vowelPositionsSortedLength = vowelPositionsSorted.length\n      \
    \  val vowelPositionsSortedLength = vowelPositionsSorted.length\n        val vowelPositionsSortedLength\
    \ = vowelPositionsSorted.length\n        val vowelPositionsSortedLength = vowelPositionsSorted.length\n\
    \        val vowelPositionsSortedLength = vowelPositionsSorted.length\n      \
    \  val vowelPositionsSortedLength = vowelPositionsSorted.length\n        val vowelPosition\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcbggdv09.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcbggdv09.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mvowelPositionsSortedLength\e[0m = vowelPositionsSorted.length\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelPositionsSortedLength is already defined as \e[33mvalue\e\
    [0m \e[35mvowelPositionsSortedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcbggdv09.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mvowelPositionsSortedLength\e\
    [0m = vowelPositionsSorted.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelPositionsSortedLength is already defined as \e[33mvalue\e\
    [0m \e[35mvowelPositionsSortedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcbggdv09.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mvowelPositionsSortedLength\e\
    [0m = vowelPositionsSorted.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvowelPositionsSortedLength is already defined as \e[33mvalue\e\
    [0m \e[35mvowelPositionsSortedLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcbggdv09.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mvowelPositionsSortedLength\e\
    [0m = vowelPositionsSorted.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31"
  stdout: ''
  timestamp: 1659978948
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        val vowelIndex\
    \ = alphabet.indexOf(\"a\")\n        val newMessage = message.toLowerCase\n  \
    \      val newMessageList = newMessage.split(\"\")\n        val newMessageList2\
    \ = newMessageList.map(x => if (vowels.contains(x)) x else vowels(vowelIndex))\n\
    \        val newMessageList3 = newMessageList2.map(x => if (vowels.contains(x))\
    \ x else vowels(vowelIndex + 1))\n        newMessageList3.mkString(\"\")\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfpmwv7cn.scala:21)\n\tat Problem.main(tmpfpmwv7cn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageWithVowels\
    \ = message.toLowerCase\n        val messageWithVowelsAndLetters = messageWithVowels.replaceAll(vowels,\
    \ letters)\n        val messageWithVowelsAndLettersAndVowels = messageWithVowelsAndLetters.replaceAll(\"\
    [aeiou]\", \"[\" + letters.charAt(0) + \"]\")\n        val messageWithVowelsAndLettersAndVowelsAndLetters\
    \ = messageWithVowelsAndLettersAndVowels.replaceAll(\"[aeiou]\", \"[\" + letters.charAt(0)\
    \ + \"]\")\n        val messageWithVowelsAndLettersAndVowelsAndLettersAndVowels\
    \ = messageWithVowelsAndLettersAndVowelsAndLetters.replaceAll(\"[aeiou]\", \"\
    [\" + letters.charAt(0) + \"]\")\n        val messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLetters\
    \ = messageWithVowelsAndLettersAndVowelsAndLettersAndVowels.replaceAll(\"[aeiou]\"\
    , \"[\" + letters.charAt(0) + \"]\")\n        val messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowels\
    \ = messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLetters.replaceAll(\"\
    [aeiou]\", \"[\" + letters.charAt(0) + \"]\")\n        val messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowelsAndLetters\
    \ = messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowels.replaceAll(\"\
    [aeiou]\", \"[\" + letters.charAt(0) + \"]\")\n        val messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowels\
    \ = messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowelsAndLetters.replaceAll(\"\
    [aeiou]\", \"[\" + letters.charAt(0) + \"]\")\n        val messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowelsAndLetters\
    \ = messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAnd\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp2p1cpc_.scala:22:118 -----------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAndVowelsAndLetters\e\
    [0m = messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAnd\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: messageWithVowelsAndLettersAndVowelsAndLettersAndVowelsAndLettersAnd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpp2p1cpc_.scala:23:5\
    \ ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978949
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase\n        val messageWithVowelsAndVowelsTwoPlaces\
    \ = messageWithVowels.replaceAll(vowels, vowels.replaceAllIn(messageWithVowels,\
    \ vowels.indexOf(_) + 2))\n        val messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlace\
    \ = messageWithVowelsAndVowelsTwoPlaces.replaceAll(vowels, vowels.replaceAllIn(messageWithVowelsAndVowelsTwoPlaces,\
    \ vowels.indexOf(_) + 1))\n        val messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlaceAndVowelsOnePlace\
    \ = messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlace.replaceAll(vowels, vowels.replaceAllIn(messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlace,\
    \ vowels.indexOf(_) + 1))\n        val messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlaceAndVowelsOnePlaceAndVowelsOnePlace\
    \ = messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlaceAndVowelsOnePlace.replaceAll(vowels,\
    \ vowels.replaceAllIn(messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlaceAndVowelsOnePlace,\
    \ vowels.indexOf(_) + 1))\n        val messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlaceAndVowelsOnePlaceAndVowelsOnePlaceAndVowelsOnePlace\
    \ = messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlaceAndVowelsOnePlaceAndVowelsOnePlaceAndVowelsOnePlace.replaceAll(vowels,\
    \ vowels.replaceAllIn(messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlaceAndVowelsOnePlaceAndVowelsOnePlaceAndVowelsOnePlaceAndVowelsOnePlace,\
    \ vowels.indexOf(_) + 1))\n        val messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlaceAndVowelsOnePlaceAndVow\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9lyp1050.scala:19:4 ----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9lyp1050.scala:13:94\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mmessageWithVowelsAndVowelsTwoPlaces\e[0m = messageWithVowels.replaceAll(vowels,\
    \ vowels.replaceAllIn(messageWithVowels, vowels.indexOf(_) + \e[31m2\e[0m))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \                             ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue replaceAllIn\
    \ is not a member of String - did you mean vowels.replaceAll?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9lyp1050.scala:14:129 -----------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlace\e\
    [0m = messageWithVowelsAndVowelsTwoPlaces.replaceAll(vowels, vowels.replaceAllIn(messageWithVowelsAndVowelsTwoPlaces,\
    \ vowels.indexOf(_) + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                  \
    \                                                                            \
    \                            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue replaceAllIn\
    \ is not a member of String - did you mean vowels.replaceAll?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9lyp1050.scala:15:163 -----------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlaceAndVowelsOnePlace\e\
    [0m = messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlace.replaceAll(vowels,\
    \ vowels.replaceAllIn(messageWithVowelsAndVowelsTwoPlacesAndVowelsOnePlace, vowels.indexOf(_)\
    \ + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                    \
    \                                                                            \
    \                                            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue replaceAllIn is not a member of String - did you mean vowels.replaceAll?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9lyp1050.scala:16:197"
  stdout: ''
  timestamp: 1659978951
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index >= 0) {\n                val vowelIndex = index + 1\n \
    \               val vowel = vowels(vowelIndex)\n                val newLetter\
    \ = vowel.charAt(0) + letter.charAt(1)\n                vowels(vowelIndex) = newLetter\n\
    \                newLetter\n            } else {\n                letter\n   \
    \         }\n        })\n        newMessageArray.toString.replace(\",\", \"\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjxtr495u.scala:18:38 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mval\e[0m \e[36mnewLetter\e[0m =\
    \ vowel.charAt(\e[31m0\e[0m) + letter.charAt(\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                        value charAt is not a member of Char\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpjxtr495u.scala:19:16 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                vowels(vowelIndex) = newLetter\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ update is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978952
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => \n            letter match {\n                case 'a' => alphabet(0)\n \
    \               case 'b' => alphabet(1)\n                case 'c' => alphabet(2)\n\
    \                case 'd' => alphabet(3)\n                case 'e' => alphabet(4)\n\
    \                case 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n\
    \                case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n\
    \                case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n\
    \                case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case _ => letter\n\
    \            }\n        )\n        val newMessageString = newMessageArray.toList.toString\n\
    \        val newMessageArray2 = newMessageString.split(\"\")\n        val newMessageArray3\
    \ = newMessageArray2.map(letter => \n            letter match {\n            \
    \    case 'a' => vowels(0)\n                case 'b' => vowels(1)\n          \
    \      case 'c' => vowels(2)\n                case 'd' => vowels(3)\n        \
    \        case 'e' => vowels(4)\n                case 'f' => vowels(5)\n      \
    \          case 'g' => vowels(6)\n                case 'h' => vowels(7)\n    \
    \            case 'i' => vowels(8)\n                case 'j' => vowels(9)\n  \
    \              case 'k' => vowels(10)\n                case 'l' => vowels(11)\n\
    \                case 'm' => vowels(12)\n                case 'n' => vowels(13)\n\
    \                case 'o' => vowels(14)\n                case 'p' => vowels(15)\n\
    \                case 'q' => vowels(16)\n                case 'r' => vowels(17)\n\
    \                case 's' => vowels(18)\n                case 't' => vowels(19)\n\
    \                case 'u' => vowels(20)\n                case 'v' => vowels(21)\n\
    \                case 'w' => vowels(22)\n                case 'x' => vowels(23)\n\
    \                case 'y' => vowels(24)\n                case 'z' => vowels(25)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqc1xr7cs.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpqc1xr7cs.scala:85:0 ----------------------------\e[0m\e[0m\n\e[31m85\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- Error: /tmp/tmpqc1xr7cs.scala:16:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mcase\e[0m \e[31m'a'\e[0m => alphabet(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpqc1xr7cs.scala:17:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'b'\e[0m => alphabet(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpqc1xr7cs.scala:18:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m \e[31m'c'\e[0m => alphabet(\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpqc1xr7cs.scala:19:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m \e[31m'd'\e[0m => alphabet(\e\
    [31m3\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpqc1xr7cs.scala:20:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e[0m \e[31m'e'\e[0m => alphabet(\e\
    [31m4\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpqc1xr7cs.s"
  stdout: ''
  timestamp: 1659978958
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageArray\
    \ = message.split(\"\")\n        val newMessage = messageArray.map(x => alphabet(x).toLowerCase\
    \ + vowels(alphabet.indexOf(x) + 1))\n        newMessage.toString\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0y25tnuq.scala:14:56\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnewMessage\e\
    [0m = messageArray.map(\e[36mx\e[0m => alphabet(x).toLowerCase + vowels(alphabet.indexOf(x)\
    \ + \e[31m1\e[0m))\n\e[31m\e[31m   |\e[0m                                    \
    \                    ^\e[0m\n\e[31m   |\e[0m                                 \
    \                 Found:    (x : String)\n\e[31m   |\e[0m                    \
    \                              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp0y25tnuq.scala:14:105 ----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnewMessage\e[0m = messageArray.map(\e\
    [36mx\e[0m => alphabet(x).toLowerCase + vowels(alphabet.indexOf(x) + \e[31m1\e\
    [0m))\n\e[31m\e[31m   |\e[0m                                                 \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0m                                          No ClassTag available for B\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                          where:  \
    \  B is a type variable\n2 errors found\n"
  stdout: ''
  timestamp: 1659978951
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => \n            letter match {\n                case\
    \ vowel => vowels.indexOf(letter) + 2\n                case letter => vowels.indexOf(letter)\
    \ + 1\n            }\n        )\n        val newMessage = messageArray.toList.mkString(\"\
    \")\n        val newMessageArray2 = newMessageArray.toList.map(letter => \n  \
    \          vowels.indexOf(letter) + 2\n        )\n        newMessageArray2.toList.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv4sx8lz_.scala:26)\n\tat Problem.main(tmpv4sx8lz_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val vowelsMap :\
    \ Map[Char, Char] = Map('a' => \"e\", 'e' => \"a\", 'i' => \"o\", 'o' => \"i\"\
    , 'u' => \"u\", 'y' => \"i\", 'a' => \"e\", 'e' => \"a\", 'i' => \"o\", 'o' =>\
    \ \"i\", 'u' => \"u\", 'y' => \"i\")\n        val lettersMap : Map[Char, Char]\
    \ = Map('a' => \"a\", 'b' => \"b\", 'c' => \"c\", 'd' => \"d\", 'e' => \"e\",\
    \ 'f' => \"f\", 'g' => \"g\", 'h' => \"h\", 'i' => \"i\", 'j' => \"j\", 'k' =>\
    \ \"k\", 'l' => \"l\", 'm' => \"m\", 'n' => \"n\", 'o' => \"o\", 'p' => \"p\"\
    , 'q' => \"q\", 'r' => \"r\", 's' => \"s\", 't' => \"t\", 'u' => \"u\", 'v' =>\
    \ \"v\", 'w' => \"w\", 'x' => \"x\", 'y' => \"y\", 'z' => \"z\")\n        val\
    \ vowelsMap2 = Map('a' => \"e\", 'e' => \"a\", 'i' => \"o\", 'o' => \"i\", 'u'\
    \ => \"u\", 'y' => \"i\", 'a' => \"e\", 'e' => \"a\", 'i' => \"o\", 'o' => \"\
    i\", 'u' => \"u\", 'y' => \"i\")\n        val lettersMap2 = Map('a' => \"a\",\
    \ 'b' => \"b\", 'c' => \"c\", 'd' => \"d\", 'e' => \"e\", 'f' => \"f\", 'g' =>\
    \ \"g\", 'h' => \"h\", 'i' => \"i\", 'j' => \"j\", 'k' => \"k\", 'l' => \"l\"\
    , 'm' => \"m\", 'n' => \"n\", 'o' => \"o\", 'p' => \"p\", 'q' => \"q\", 'r' =>\
    \ \"r\", 's' => \"s\", 't' => \"t\", 'u' => \"u\", 'v' => \"v\", 'w' => \"w\"\
    , 'x' => \"x\", 'y' => \"y\", 'z' => \"z\")\n        val vowelsMap3 = Map('a'\
    \ => \"e\", 'e' => \"a\", 'i' => \"o\", 'o' => \"i\", 'u' => \"u\", 'y' => \"\
    i\", 'a' => \"e\", 'e' => \"a\", 'i' => \"o\", 'o' => \"i\", 'u' => \"u\", 'y'\
    \ => \"i\")\n        val letters\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpcy2tpzq9.scala:13:46 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mvowelsMap\e[0m : \e[35mMap\e\
    [0m[\e[35mChar\e[0m, \e[35mChar\e[0m] = Map(\e[31m'a'\e[0m => \e[31m\"e\"\e[0m,\
    \ \e[31m'e'\e[0m => \e[31m\"a\"\e[0m, \e[31m'i'\e[0m => \e[31m\"o\"\e[0m, \e[31m'o'\e\
    [0m => \e[31m\"i\"\e[0m, \e[31m'u'\e[0m => \e[31m\"u\"\e[0m, \e[31m'y'\e[0m =>\
    \ \e[31m\"i\"\e[0m, \e[31m'a'\e[0m => \e[31m\"e\"\e[0m, \e[31m'e'\e[0m => \e[31m\"\
    a\"\e[0m, \e[31m'i'\e[0m => \e[31m\"o\"\e[0m, \e[31m'o'\e[0m => \e[31m\"i\"\e\
    [0m, \e[31m'u'\e[0m => \e[31m\"u\"\e[0m, \e[31m'y'\e[0m => \e[31m\"i\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                              ^^^\e[0m\n\e\
    [31m   |\e[0m                                            not a legal formal parameter\n\
    \e[31m\e[31m-- Error: /tmp/tmpcy2tpzq9.scala:13:58 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mvowelsMap\e[0m : \e[35mMap\e\
    [0m[\e[35mChar\e[0m, \e[35mChar\e[0m] = Map(\e[31m'a'\e[0m => \e[31m\"e\"\e[0m,\
    \ \e[31m'e'\e[0m => \e[31m\"a\"\e[0m, \e[31m'i'\e[0m => \e[31m\"o\"\e[0m, \e[31m'o'\e\
    [0m => \e[31m\"i\"\e[0m, \e[31m'u'\e[0m => \e[31m\"u\"\e[0m, \e[31m'y'\e[0m =>\
    \ \e[31m\"i\"\e[0m, \e[31m'a'\e[0m => \e[31m\"e\"\e[0m, \e[31m'e'\e[0m => \e[31m\"\
    a\"\e[0m, \e[31m'i'\e[0m => \e[31m\"o\"\e[0m, \e[31m'o'\e[0m => \e[31m\"i\"\e\
    [0m, \e[31m'u'\e[0m => \e[31m\"u\"\e[0m, \e[31m'y'\e[0m => \e[31m\"i\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \  ^^^\e[0m\n\e[31m   |\e[0m                                            not a\
    \ legal formal parameter\n\e[31m\e[31m-- Error: /tmp/tmpcy2tpzq9.scala:13:70 -----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mvowelsMap\e[0m : \e[35mMap\e\
    [0m[\e[35mChar\e[0m, \e[35mChar\e[0m] = Map(\e[31m'a'\e[0m => \e[31m\"e\"\e[0m,\
    \ \e[31m'e'\e[0m => \e[31m\"a\"\e[0m, \e[31m'i'\e[0m => \e[31m\"o\"\e[0m, \e[31m'o'\e\
    [0m => \e[31m\"i\"\e[0m, \e[31m'u'\e[0m => \e[31m\"u\"\e[0m, \e[31m'y'\e[0m =>\
    \ \e[31m\"i\"\e[0m, \e[31m'a'\e[0m => \e[31m\"e\"\e[0m, \e[31m'e'\e[0m => \e[31m\"\
    a\"\e[0m, \e[31m'i'\e[0m => \e[31m\"o\"\e[0m, \e[31m'o'\e[0m => \e[31m\"i\"\e\
    [0m, \e[31m'u'\e[0m => \e[31m\"u\"\e[0m, \e[31m'y'\e[0m => \e[31m\"i\"\e[0m)\n\
    \e[31m\e[31m   |\e[0m             "
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => {\n            val index = vowels.indexOf(letter)\n            if (index\
    \ >= 0) {\n                vowels(index - 1) + vowels(index)\n            } else\
    \ {\n                letter\n            }\n        }).mkString(\"\")\n      \
    \  newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgjvq3m6v.scala:24)\n\tat Problem.main(tmpgjvq3m6v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageWithVowels\
    \ = message.toLowerCase\n        val messageWithVowelsAndVowelsTwoAheadOfVowel\
    \ = messageWithVowels.replaceAll(vowels, vowels.charAt(2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowel.replaceAll(vowels, vowels.charAt(2))\n\
    \        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowel = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowel.replaceAll(vowels,\
    \ vowels.charAt(2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowel.replaceAll(vowels,\
    \ vowels.charAt(2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowel.replaceAll(vowels,\
    \ vowels.charAt(2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowelAndVowel.replaceAll(vowels,\
    \ vowels.charAt(2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowelAndVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowelAndVowelAndVowel.replaceAll(vowels,\
    \ vowels.charAt(2))\n        val messageWithVowelsAndVowelsTwo\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\"\
    )));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi8g75t2_.scala:22:4 ----------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpi8g75t2_.scala:14:106 -------------------\e[0m\e[0m\n\e[31m14 |\e[0m\
    \        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowel\e[0m =\
    \ messageWithVowels.replaceAll(vowels, vowels.charAt(\e[31m2\e[0m))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                             ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                                               Found:    Char\n\e[31m   |\e[0m\
    \                                                        Required: String\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi8g75t2_.scala:15:138\
    \ -------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowel.replaceAll(vowels, vowels.charAt(\e\
    [31m2\e[0m))\n\e[31m\e[31m   |\e[0m                                          \
    \                                                                            \
    \       ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \                         Found:    Char\n\e[31m   |\e[0m                    \
    \                                    Required: String\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpi8g75t2_.scala:16:154 -------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowel.replaceAll(vowels, vowels.charAt(\e\
    [31m2\e[0m))\n\e[31m\e[31m   |\e[0m                                          \
    \                                                                            \
    \                       ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \       "
  stdout: ''
  timestamp: 1659978955
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index >= 0) {\n                val vowelIndex = index + 1\n \
    \               vowels(vowelIndex) match {\n                    case \"a\" =>\
    \ \"b\"\n                    case \"e\" => \"f\"\n                    case \"\
    i\" => \"j\"\n                    case \"o\" => \"k\"\n                    case\
    \ \"u\" => \"l\"\n                    case \"y\" => \"m\"\n                  \
    \  case \"A\" => \"B\"\n                    case \"E\" => \"F\"\n            \
    \        case \"I\" => \"J\"\n                    case \"O\" => \"K\"\n      \
    \              case \"U\" => \"L\"\n                    case \"Y\" => \"M\"\n\
    \                    case \"a\" => \"b\"\n                    case \"e\" => \"\
    f\"\n                    case \"i\" => \"j\"\n                    case \"o\" =>\
    \ \"k\"\n                    case \"u\" => \"l\"\n                    case \"\
    y\" => \"m\"\n                    case \"A\" => \"B\"\n                    case\
    \ \"E\" => \"F\"\n                    case \"I\" => \"J\"\n                  \
    \  case \"O\" => \"K\"\n                    case \"U\" => \"L\"\n            \
    \        case \"Y\" => \"M\"\n                    case \"0\" => \"1\"\n      \
    \              case \"1\" => \"2\"\n                    case \"2\" => \"3\"\n\
    \                    case \"3\" => \"4\"\n                    case \"4\" => \"\
    5\"\n                    case \"5\" => \"6\"\n                    case \"6\" =>\
    \ \"7\"\n                    case \"7\" => \"8\"\n                    case \"\
    8\" => \"9\"\n                    case \"9\" => \"0\"\n                    case\
    \ \"+\" => \"-\"\n                    case \"-\" => \"+\"\n                  \
    \  case \"/\" => \"/\"\n                    case \"*\" => \"*\"\n            \
    \        case \"?\" => \"?\"\n                    case \"!\" => \"!\"\n      \
    \              case \"@\" => \"@\"\n                    case \"#\" => \"#\"\n\
    \                    case \"$\" => \"$\"\n                    case \"%\" => \"\
    %\"\n                    case \"^\" => \"^\"\n                    case \"&\" =>\
    \ \"&\"\n                    case \"*\" => \"*\"\n                    case \"\
    ?\" => \"?\"\n                    case \"!\" => \"!\"\n                    case\
    \ \"@\" => \"@\"\n                    case \"#\" => \"#\"\n                  \
    \  case \"$\" => \"$\"\n                    case \"%\" => \"%\"\n            \
    \        case \"^\" => \"^\"\n                    case \"&\" => \"&\"\n      \
    \              case \"*\" => \"*\"\n                    case \"?\" => \"?\"\n\
    \                    case \"!\" => \"!\"\n                    case \"@\" => \"\
    @\"\n                    case \"#\" => \"#\"\n                    case \"$\" =>\
    \ \"$\"\n\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf96ag3kk.scala:90:0 ----------------------------\e\
    [0m\e[0m\n\e[31m90 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- Error: /tmp/tmpf96ag3kk.scala:18:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                    \e[33mcase\e[0m \e[31m\"a\"\e[0m\
    \ => \e[31m\"b\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types String and Char cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpf96ag3kk.scala:19:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                    \e[33mcase\e[0m \e[31m\"e\"\e[0m\
    \ => \e[31m\"f\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types String and Char cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpf96ag3kk.scala:20:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    \e[33mcase\e[0m \e[31m\"i\"\e[0m\
    \ => \e[31m\"j\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types String and Char cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpf96ag3kk.scala:21:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                    \e[33mcase\e[0m \e[31m\"o\"\e[0m\
    \ => \e[31m\"k\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types String and Char cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpf96ag3kk.scala:22:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                    \e[33mcase\e[0m \e[31m\"u\"\e[0m\
    \ => \e[31m\"l\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types String and Char cannot be compared with\
    \ == or !=\n\e[31m\e[31m-- Error: /tmp/tmpf96ag3kk.scala:23:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    \e[33mcase\e[0m \e[31m\"y\"\e[0m\
    \ => \e[31m\"m\"\e[0m\n\e[31m\e[31m   |\e[0m                         ^^^\e[0m\n\
    \e[31m   |\e[0m        Values of types String and Char cannot be compared with\
    \ == or !"
  stdout: ''
  timestamp: 1659978961
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val newMessage = messageArray.map(letter => \n            letter\
    \ match {\n                case 'a' -> alphabet(0)\n                case 'b' ->\
    \ alphabet(1)\n                case 'c' -> alphabet(2)\n                case 'd'\
    \ -> alphabet(3)\n                case 'e' -> alphabet(4)\n                case\
    \ 'f' -> alphabet(5)\n                case 'g' -> alphabet(6)\n              \
    \  case 'h' -> alphabet(7)\n                case 'i' -> alphabet(8)\n        \
    \        case 'j' -> alphabet(9)\n                case 'k' -> alphabet(10)\n \
    \               case 'l' -> alphabet(11)\n                case 'm' -> alphabet(12)\n\
    \                case 'n' -> alphabet(13)\n                case 'o' -> alphabet(14)\n\
    \                case 'p' -> alphabet(15)\n                case 'q' -> alphabet(16)\n\
    \                case 'r' -> alphabet(17)\n                case 's' -> alphabet(18)\n\
    \                case 't' -> alphabet(19)\n                case 'u' -> alphabet(20)\n\
    \                case 'v' -> alphabet(21)\n                case 'w' -> alphabet(22)\n\
    \                case 'x' -> alphabet(23)\n                case 'y' -> alphabet(24)\n\
    \                case 'z' -> alphabet(25)\n                case _ -> letter\n\
    \            }\n        ).mkString(\"\")\n        val newMessageArray = newMessage.split(\"\
    \")\n        val newAlphabet = alphabet.map(letter => \n            letter match\
    \ {\n                case 'a' -> alphabet(0)\n                case 'b' -> alphabet(1)\n\
    \                case 'c' -> alphabet(2)\n                case 'd' -> alphabet(3)\n\
    \                case 'e' -> alphabet(4)\n                case 'f' -> alphabet(5)\n\
    \                case 'g' -> alphabet(6)\n                case 'h' -> alphabet(7)\n\
    \                case 'i' -> alphabet(8)\n                case 'j' -> alphabet(9)\n\
    \                case 'k' -> alphabet(10)\n                case 'l' -> alphabet(11)\n\
    \                case 'm' -> alphabet(12)\n                case 'n' -> alphabet(13)\n\
    \                case 'o' -> alphabet(14)\n                case 'p' -> alphabet(15)\n\
    \                case 'q' -> alphabet(16)\n                case 'r' -> alphabet(17)\n\
    \                case 's' -> alphabet(18)\n                case 't' -> alphabet(19)\n\
    \                case 'u' -> alphabet(20)\n                case 'v' -> alphabet(21)\n\
    \                case '\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr6vayca_.scala:17:16 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'b'\e[0m -> alphabet(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m \
    \               '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpr6vayca_.scala:19:16 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m                \e[33mcase\e[0m \e[31m'd'\e[0m -> alphabet(\e[31m3\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m        \
    \        '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpr6vayca_.scala:21:16 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m                \e[33mcase\e[0m \e[31m'f'\e[0m -> alphabet(\e[31m5\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m              \
    \  '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr6vayca_.scala:23:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e\
    [0m \e[31m'h'\e[0m -> alphabet(\e[31m7\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                '=>' expected, but 'case' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr6vayca_.scala:25:16 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mcase\e[0m \e[31m'j'\e[0m -> alphabet(\e\
    [31m9\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m \
    \               '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmpr6vayca_.scala:27:16 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m                \e[33mcase\e[0m \e[31m'l'\e[0m -> alphabet(\e[31m11\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m        \
    \        '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpr6vayca_.scala:29:16 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                \e[33mcase\e[0m \e[31m'n'\e[0m -> alphabet(\e[31m13\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m        \
    \        '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpr6vayca_.scala:31:16 --"
  stdout: ''
  timestamp: 1659978954
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => vowels.indexOf(letter) match {\n            case\
    \ -1 => letter\n            case i => vowels(i + 2)\n        }).mkString(\"\"\
    )\n        encodedMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxmio9o7_.scala:20)\n\tat Problem.main(tmpxmio9o7_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978957
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => vowels.indexOf(letter) match {\n            case\
    \ -1 => letter\n            case i => vowels(i + 2)\n        }).mkString(\"\"\
    )\n        encodedMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxmio9o7_.scala:20)\n\tat Problem.main(tmpxmio9o7_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageList = message.split(\"\")\n        val encodedMessage =\
    \ messageList.foldLeft(\"\")( (acc, elem) => {\n            val index = vowels.indexOf(elem)\n\
    \            if (index != -1) {\n                val nextVowel = vowels(index\
    \ + 1)\n                acc + (if (nextVowel == elem) elem.toUpperCase else elem.toLowerCase\
    \ + nextVowel)\n            } else {\n                acc + elem\n           \
    \ }\n        })\n        encodedMessage\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpwl_9r_hf.scala:17:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                acc + (\e[33mif\e[0m (nextVowel == elem)\
    \ elem.toUpperCase \e[33melse\e[0m elem.toLowerCase + nextVowel)\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \       Values of types Char and String cannot be compared with == or !=\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1659978956
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => {\n            val index = vowels.indexOf(letter)\n            if (index\
    \ >= 0) {\n                val vowelIndex = vowels.indexOf(vowels(index + 1))\n\
    \                if (vowelIndex >= 0) {\n                    vowels(index) = vowels(vowelIndex\
    \ + 1)\n                } else {\n                    vowels(index) = letter\n\
    \                }\n            } else {\n                letter\n           \
    \ }\n        }).mkString(\"\")\n        newMessage\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmph8wjdwpo.scala:18:20 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                    vowels(index) = vowels(vowelIndex\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    value update is not a member of String\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmph8wjdwpo.scala:20:20 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                    vowels(index) = letter\n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \    value update is not a member of String\n2 errors found\n"
  stdout: ''
  timestamp: 1659978957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => \n            letter match {\n                case vowel => letters.indexOf(vowel)\
    \ + 2\n                case letter => letters.indexOf(letter) + 2\n          \
    \  }\n        )\n        val newMessage = newMessageArray.toArray\n        val\
    \ newMessageString = newMessage.toString\n        val newMessageString2 = newMessageString.replace(\"\
    [\", \"\")\n        val newMessageString3 = newMessageString2.replace(\"]\", \"\
    \")\n        val newMessageString4 = newMessageString3.replace(\",\", \"\")\n\
    \        val newMessageString5 = newMessageString4.replace(\"[\", \"\")\n    \
    \    val newMessageString6 = newMessageString5.replace(\"]\", \"\")\n        val\
    \ newMessageString7 = newMessageString6.replace(\",\", \"\")\n        val newMessageString8\
    \ = newMessageString7.replace(\"[\", \"\")\n        val newMessageString9 = newMessageString8.replace(\"\
    ]\", \"\")\n        val newMessageString10 = newMessageString9.replace(\",\",\
    \ \"\")\n        val newMessageString11 = newMessageString10.replace(\"[\", \"\
    \")\n        val newMessageString12 = newMessageString11.replace(\"]\", \"\")\n\
    \        val newMessageString13 = newMessageString12.replace(\",\", \"\")\n  \
    \      val newMessageString14 = newMessageString13.replace(\"[\", \"\")\n    \
    \    val newMessageString15 = newMessageString14.replace(\"]\", \"\")\n      \
    \  val newMessageString16 = newMessageString15.replace(\",\", \"\")\n        val\
    \ newMessageString17 = newMessageString16.replace(\"[\", \"\")\n        val newMessageString18\
    \ = newMessageString17.replace(\"]\", \"\")\n        val newMessageString19 =\
    \ newMessageString18.replace(\",\", \"\")\n        val newMessageString20 = newMessageString19.replace(\"\
    [\", \"\")\n        val newMessageString21 = newMessageString20.replace(\"]\"\
    , \"\")\n        val newMessageString22 = newMessageString21.replace(\",\", \"\
    \")\n        val newMessageString23 = newMessageString22.replace(\"[\", \"\")\n\
    \        val newMessageString24 = newMessageString23.replace(\"]\", \"\")\n  \
    \      val newMessageString25 = newMessageString24.replace(\",\", \"\")\n    \
    \    val newMessageString26 = newMessageString25.replace(\"[\", \"\")\n      \
    \  val newMessageString27 = newMessageString26.replace(\"]\", \"\")\n        val\
    \ newMessageString28 = newMessageString27.replace(\",\", \"\")\n        val newMessageString29\
    \ = newMessageString28.replace(\"[\", \"\")\n        val newMessageString30 =\
    \ newMessageString29.replace(\"]\", \"\")\n        val newMessageString31 = new\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo0ifnfev.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpo0ifnfev.scala:52:5 ---------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => \n            vowels.indexOf(letter) match {\n\
    \                case -1 => letter\n                case 0 => letter\n       \
    \         case 1 => vowels(letter - 1) + letter\n                case 2 => vowels(letter\
    \ - 1) + vowels(letter - 2)\n            }\n        )\n        val newMessage\
    \ = newMessageArray.toList\n        val newMessageString = newMessage.toString\n\
    \        newMessageString\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp99wyl6aa.scala:17:40 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m1\e[0m => vowels(letter\
    \ - \e[31m1\e[0m) + letter\n\e[31m\e[31m   |\e[0m                            \
    \     ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of String, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp99wyl6aa.scala:18:40 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m \e[31m2\e[0m => vowels(letter\
    \ - \e[31m1\e[0m) + vowels(letter - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                            ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of String, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp99wyl6aa.scala:18:61 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m \e[31m2\e[0m => vowels(letter\
    \ - \e[31m1\e[0m) + vowels(letter - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                                                 ^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue - is not a member of String, but could be made available as an extension\
    \ method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might\
    \ make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  impor"
  stdout: ''
  timestamp: 1659978959
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => {\n            val index = alphabet.indexOf(letter)\n            val nextIndex\
    \ = alphabet.indexOf(vowels, index + 1)\n            alphabet(index) match {\n\
    \                case vowel => vowel\n                case letter => alphabet(nextIndex)\n\
    \            }\n        })\n        newMessageArray.toString\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.StringIndexOutOfBoundsException: String index out of range: -1\n\
    \tat java.base/java.lang.StringLatin1.charAt(StringLatin1.java:48)\n\tat java.base/java.lang.String.charAt(String.java:1515)\n\
    \tat scala.collection.StringOps$.apply$extension(StringOps.scala:185)\n\tat Problem$.$anonfun$1(tmpnq727luv.scala:17)\n\
    \tat scala.collection.ArrayOps$.map$extension(ArrayOps.scala:929)\n\tat Problem$.encode(tmpnq727luv.scala:21)\n\
    \tat Problem$.main(tmpnq727luv.scala:25)\n\tat Problem.main(tmpnq727luv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978960
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageWithVowels\
    \ = message.toLowerCase.foldLeft(\"\")( (acc, c) => acc + (if (vowels.contains(c))\
    \ c else alphabet(alphabet.indexOf(c) + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowel\
    \ = messageWithVowels.foldLeft(\"\")( (acc, c) => acc + (if (vowels.contains(c))\
    \ c else alphabet(alphabet.indexOf(c) + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowel.toLowerCase.foldLeft(\"\")( (acc,\
    \ c) => acc + (if (vowels.contains(c)) c else alphabet(alphabet.indexOf(c) + 2)))\n\
    \        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.toLowerCase.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c else alphabet(alphabet.indexOf(c)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.toLowerCase.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c else alphabet(alphabet.indexOf(c)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowel\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\"\
    )));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6aie6lza.scala:19:4 ----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6aie6lza.scala:17:128\
    \ --------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.toLowerCase.foldLeft(\e\
    [31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c))\
    \ c \e[33melse\e[0m alphabet(alphabet.indexOf(c) + \e[31m2\e[0m)))\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6aie6lza.scala:19:5 ---------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978957
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = Set(\"a\", \"\
    e\", \"i\", \"o\", \"u\")\n        val messageArray = message.split(\"\")\n  \
    \      val newMessage = messageArray.map { letter =>\n            val index =\
    \ vowels.indexOf(letter)\n            if (index != -1) {\n                vowels(index\
    \ - 1) + letter\n            } else {\n                letter\n            }\n\
    \        }\n        newMessage.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpswxer6ap.scala:14:31 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mindex\e[0m = vowels.indexOf(letter)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m   value indexOf is not a member of scala.collection.mutable.Set[String]\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpswxer6ap.scala:16:34 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                vowels(index - \e[31m1\e[0m) + letter\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue\
    \ + is not a member of Boolean, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978959
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.map(letter => vowels.indexOf(letter)\
    \ + 1).map(letter => vowels.charAt(letter))\n        val messageWithVowelsAnd2LettersBefore\
    \ = messageWithVowels.map(letter => vowels.indexOf(letter) + 2).map(letter =>\
    \ vowels.charAt(letter))\n        val messageWithVowelsAnd2LettersBeforeAnd2LettersAfter\
    \ = messageWithVowelsAnd2LettersBefore.map(letter => vowels.indexOf(letter) +\
    \ 3).map(letter => vowels.charAt(letter))\n        val messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersAfter\
    \ = messageWithVowelsAnd2LettersBeforeAnd2LettersAfter.map(letter => vowels.indexOf(letter)\
    \ + 4).map(letter => vowels.charAt(letter))\n        val messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersAfterAnd2LettersAfter\
    \ = messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersAfter.map(letter\
    \ => vowels.indexOf(letter) + 5).map(letter => vowels.charAt(letter))\n      \
    \  val messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersAfterAnd2LettersAfterAnd2LettersAfter\
    \ = messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersAfterAnd2LettersAfter.map(letter\
    \ => vowels.indexOf(letter) + 6).map(letter => vowels.charAt(letter))\n      \
    \  val messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersAfterAnd2LettersAfterAnd2LettersAfterAnd2LettersAfter\
    \ = messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersAfterAnd2LettersAfterAnd2LettersAfter.map(letter\
    \ => vowels.indexOf(letter) + 7).map(letter => vowels.charAt(letter))\n      \
    \  val messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersAfterAnd2LettersAfterAnd2LettersAfterAnd2LettersAfterAnd2LettersAfter\
    \ = messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersAfterAnd2LettersAfterAnd2LettersAfterAnd2LettersAfter.map(letter\
    \ => vowels.indexOf(letter) + 8).map(letter => vowels.charAt(letter))\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp61x9x_e3.scala:20:5\
    \ ---------------------\e[0m\e[0m\n\e[31m20 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978959
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(letter => \n            if (vowels.contains(letter)) letter else\
    \ \n                alphabet(alphabet.indexOf(letter) + 2))\n        newMessage.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz92joqav.scala:19)\n\tat Problem.main(tmpz92joqav.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978960
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message.map(x\
    \ => alphabet.indexOf(x) + 1)\n        val newVowels = vowels.map(x => alphabet.indexOf(x)\
    \ + 1)\n        newMessage.zip(newVowels).map(x => alphabet(x._1) + alphabet(x._2))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpksaskm3b.scala:15:37\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        newMessage.zip(newVowels).map(\e\
    [36mx\e[0m => alphabet(x._1) + alphabet(x._2))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    IndexedSeq[Int]\n\e[31m   |\e[0m       \
    \ Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978960
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        var result = \"\"\n     \
    \   for(i <- 0 until message.length){\n            val c = message.charAt(i)\n\
    \            val l = c.toLowerCase \n            val vowels = \"aeiou\"\n    \
    \        val vowelsIndex = vowels.indexOf(c)\n            val vowelsIndex2 = vowels.indexOf(l,\
    \ vowelsIndex + 1)\n            val vowelsIndex3 = vowels.indexOf(l, vowelsIndex\
    \ + 2)\n            val vowelsIndex4 = vowels.indexOf(l, vowelsIndex + 3)\n  \
    \          val vowelsIndex5 = vowels.indexOf(l, vowelsIndex + 4)\n           \
    \ val vowelsIndex6 = vowels.indexOf(l, vowelsIndex + 5)\n            val vowelsIndex7\
    \ = vowels.indexOf(l, vowelsIndex + 6)\n            val vowelsIndex8 = vowels.indexOf(l,\
    \ vowelsIndex + 7)\n            val vowelsIndex9 = vowels.indexOf(l, vowelsIndex\
    \ + 8)\n            val vowelsIndex10 = vowels.indexOf(l, vowelsIndex + 9)\n \
    \           val vowelsIndex11 = vowels.indexOf(l, vowelsIndex + 10)\n        \
    \    val vowelsIndex12 = vowels.indexOf(l, vowelsIndex + 11)\n            val\
    \ vowelsIndex13 = vowels.indexOf(l, vowelsIndex + 12)\n            val vowelsIndex14\
    \ = vowels.indexOf(l, vowelsIndex + 13)\n            val vowelsIndex15 = vowels.indexOf(l,\
    \ vowelsIndex + 14)\n            val vowelsIndex16 = vowels.indexOf(l, vowelsIndex\
    \ + 15)\n            val vowelsIndex17 = vowels.indexOf(l, vowelsIndex + 16)\n\
    \            val vowelsIndex18 = vowels.indexOf(l, vowelsIndex + 17)\n       \
    \     val vowelsIndex19 = vowels.indexOf(l, vowelsIndex + 18)\n            val\
    \ vowelsIndex20 = vowels.indexOf(l, vowelsIndex + 19)\n            val vowelsIndex21\
    \ = vowels.indexOf(l, vowelsIndex + 20)\n            val vowelsIndex22 = vowels.indexOf(l,\
    \ vowelsIndex + 21)\n            val vowelsIndex23 = vowels.indexOf(l, vowelsIndex\
    \ + 22)\n            val vowelsIndex24 = vowels.indexOf(l, vowelsIndex + 23)\n\
    \            val vowelsIndex25 = vowels.indexOf(l, vowelsIndex + 24)\n       \
    \     val vowelsIndex26 = vowels.indexOf(l, vowelsIndex + 25)\n            val\
    \ vowelsIndex27 = vowels.indexOf(l, vowelsIndex + 26)\n            val vowelsIndex28\
    \ = vowels.indexOf(l, vowelsIndex + 27)\n            val vowelsIndex29 = vowels.indexOf(l,\
    \ vowelsIndex\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjw2c2uyp.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjw2c2uyp.scala:55:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m55 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpjw2c2uyp.scala:14:22 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m            \e[33mval\e[0m \e[36ml\e[0m = c.toLowerCase \n\e[31m\e\
    [31m   |\e[0m                    ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           value toLowerCase is not a member of Char\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpjw2c2uyp.scala:54:1 ---------------------\e[0m\e[0m\n\
    \e[31m54 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpjw2c2uyp.scala:46:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m46 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659978963
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => \n            if (vowels.contains(letter)) {\n  \
    \              val vowelIndex = vowels.indexOf(letter)\n                val vowel2Index\
    \ = vowels.indexOf(vowels.charAt(vowelIndex + 1))\n                vowels.charAt(vowelIndex\
    \ + 1) \n            } else if (letter.equals(\"a\")) {\n                \"b\"\
    \n            } else if (letter.equals(\"e\")) {\n                \"f\"\n    \
    \        } else if (letter.equals(\"i\")) {\n                \"g\"\n         \
    \   } else if (letter.equals(\"o\")) {\n                \"h\"\n            } else\
    \ if (letter.equals(\"u\")) {\n                \"j\"\n            } else {\n \
    \               letter\n            }\n        )\n        newMessageArray.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz24bur4p.scala:35)\n\tat Problem.main(tmpz24bur4p.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978964
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('o','a','e','i','u')\n        val messageArray = message.split(\"\
    \")\n        val encodedMessage = messageArray.map(letter => \n            letter\
    \ match {\n                case 'a' => alphabet(0)\n                case 'b' =>\
    \ alphabet(1)\n                case 'c' => alphabet(2)\n                case 'd'\
    \ => alphabet(3)\n                case 'e' => alphabet(4)\n                case\
    \ 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n              \
    \  case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n        \
    \        case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n \
    \               case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case letter => letter\n\
    \            }\n        ).mkString(\"\")\n        val vowelsArray = vowels.map(letter\
    \ => \n            letter match {\n                case 'o' => alphabet(14)\n\
    \                case 'a' => alphabet(14)\n                case 'e' => alphabet(14)\n\
    \                case 'i' => alphabet(14)\n                case 'u' => alphabet(14)\n\
    \                case letter => letter\n            }\n        ).mkString(\"\"\
    )\n        val vowelsArray2 = vowels.map(letter => \n            letter match\
    \ {\n                case 'o' => alphabet(15)\n                case 'a' => alphabet(15)\n\
    \                case 'e' => alphabet(15)\n                case 'i' => alphabet(15)\n\
    \                case 'u' => alphabet(15)\n                case letter => letter\n\
    \            }\n        ).mkString(\"\")\n        val vowelsArray3 = vowels.map(letter\
    \ => \n            letter match {\n                case 'o' => alphabet(16)\n\
    \                case 'a' => alphabet(16)\n                case 'e' => alphabet(16)\n\
    \                case 'i' => alphabet(16)\n                case 'u' => alphabet(16)\n\
    \                case letter => letter\n            }\n        ).mkString(\"\"\
    )\n        val vowelsArray4 = vowels.map(letter => \n            letter match\
    \ {\n                case 'o' => alphabet(17)\n                case 'a' => alphabet(17)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw3pq2iqc.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpw3pq2iqc.scala:89:0 ----------------------------\e[0m\e[0m\n\e[31m89\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- Error: /tmp/tmpw3pq2iqc.scala:16:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mcase\e[0m \e[31m'a'\e[0m => alphabet(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpw3pq2iqc.scala:17:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'b'\e[0m => alphabet(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpw3pq2iqc.scala:18:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mcase\e[0m \e[31m'c'\e[0m => alphabet(\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpw3pq2iqc.scala:19:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m \e[31m'd'\e[0m => alphabet(\e\
    [31m3\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpw3pq2iqc.scala:20:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e[0m \e[31m'e'\e[0m => alphabet(\e\
    [31m4\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmpw3pq2iqc.s"
  stdout: ''
  timestamp: 1659978967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessage = messageArray.map(letter => letters.indexOf(letter)\
    \ + vowels.indexOf(vowels.charAt(letter)) + letters.indexOf(vowels.charAt(letter))\
    \ + 1)\n        newMessage.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3m32v94f.scala:14:107\
    \ -------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnewMessage\e\
    [0m = messageArray.map(\e[36mletter\e[0m => letters.indexOf(letter) + vowels.indexOf(vowels.charAt(letter))\
    \ + letters.indexOf(vowels.charAt(letter)) + \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                 ^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                              Found:    (letter : String)\n\e[31m   |\e[0m  \
    \                                           Required: Int\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3m32v94f.scala:14:148 -------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnewMessage\e[0m = messageArray.map(\e\
    [36mletter\e[0m => letters.indexOf(letter) + vowels.indexOf(vowels.charAt(letter))\
    \ + letters.indexOf(vowels.charAt(letter)) + \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                                                          ^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    (letter\
    \ : String)\n\e[31m   |\e[0m                                             Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978962
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => \n            vowels.indexOf(letter) match {\n                case -1 =>\
    \ letter\n                case i => vowels(i + 2)\n            }\n        ).mkString(\"\
    \")\n        newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvql98k9b.scala:22)\n\tat Problem.main(tmpvql98k9b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message\n\
    \        val newAlphabet = alphabet\n        val newVowels = vowels\n        val\
    \ newAlphabet2 = newAlphabet\n        val newVowels2 = newVowels\n        val\
    \ newAlphabet3 = newAlphabet\n        val newVowels3 = newVowels\n        val\
    \ newAlphabet4 = newAlphabet\n        val newVowels4 = newVowels\n        val\
    \ newAlphabet5 = newAlphabet\n        val newVowels5 = newVowels\n        val\
    \ newAlphabet6 = newAlphabet\n        val newVowels6 = newVowels\n        val\
    \ newAlphabet7 = newAlphabet\n        val newVowels7 = newVowels\n        val\
    \ newAlphabet8 = newAlphabet\n        val newVowels8 = newVowels\n        val\
    \ newAlphabet9 = newAlphabet\n        val newVowels9 = newVowels\n        val\
    \ newAlphabet10 = newAlphabet\n        val newVowels10 = newVowels\n        val\
    \ newAlphabet11 = newAlphabet\n        val newVowels11 = newVowels\n        val\
    \ newAlphabet12 = newAlphabet\n        val newVowels12 = newVowels\n        val\
    \ newAlphabet13 = newAlphabet\n        val newVowels13 = newVowels\n        val\
    \ newAlphabet14 = newAlphabet\n        val newVowels14 = newVowels\n        val\
    \ newAlphabet15 = newAlphabet\n        val newVowels15 = newVowels\n        val\
    \ newAlphabet16 = newAlphabet\n        val newVowels16 = newVowels\n        val\
    \ newAlphabet17 = newAlphabet\n        val newVowels17 = newVowels\n        val\
    \ newAlphabet18 = newAlphabet\n        val newVowels18 = newVowels\n        val\
    \ newAlphabet19\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1lewj7_l.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp1lewj7_l.scala:51:5 ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978965
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => \n            if (vowels.contains(letter)) letter\
    \ else \n                vowels.indexOf(letter) + 2)\n        val newMessage =\
    \ newMessageArray.toArray\n        val newMessageString = newMessage.toString\n\
    \        val newMessageStringArray = newMessageString.split(\"\")\n        val\
    \ newMessageStringArrayLength = newMessageStringArray.length\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength\
    \ - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength -\
    \ 1\n        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessageStringArrayLength = newMessageStringArrayLength - 1\n  \
    \      val newMessageStringArrayLength = newMessageStringArrayLength - 1\n   \
    \     val newMessageStringArrayLength = newMessageStringArrayLength - 1\n    \
    \    val newMessageStringArrayLength = newMessageStringArrayLength - 1\n     \
    \   val newMessageStringArrayLength = newMessageStringArrayLength - 1\n      \
    \  val newMessageStringArrayLength = newMessageStringArrayLength - 1\n       \
    \ val newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val\
    \ newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength\
    \ - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength -\
    \ 1\n        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessageStringArrayLength = newMessageStringArrayLength - 1\n  \
    \      val newMessageStringArrayLength = newMessageStringArrayLength - 1\n   \
    \     val newMessageStringArrayLength = newMessageStringArrayLength - 1\n    \
    \    val newMessageStringArrayLength = newMessageStringArrayLength - 1\n     \
    \   val newMessageStringArrayLength = newMessageStringArrayLength - 1\n      \
    \  val newMessageStringArrayLength = newMessageStringArrayLength - 1\n       \
    \ val newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val\
    \ newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpn2t3n58s.scala:50:11 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpn2t3n58s.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn2t3n58s.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn2t3n58s.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpn2t3n58s.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33"
  stdout: ''
  timestamp: 1659978967
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = Set(\"a\", \"\
    e\", \"i\", \"o\", \"u\")\n        val messageArray = message.split(\"\")\n  \
    \      val newMessageArray = messageArray.map(letter => vowels.contains(letter)\
    \ ? letter : letter.swapCase)\n        val newMessageString = newMessageArray.toList.toString\n\
    \        newMessageString\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp5iszcvrc.scala:13:99 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArray\e[0m = messageArray.map(\e\
    [36mletter\e[0m => vowels.contains(letter) ? letter : letter.swapCase)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \                      type swapCase is not a member of String\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp5iszcvrc.scala:13:81 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArray\e[0m = messageArray.map(\e\
    [36mletter\e[0m => vowels.contains(letter) ? letter : letter.swapCase)\n\e[31m\e\
    [31m   |\e[0m                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                      value ? is not a member\
    \ of Boolean\n\e[31m\e[31m-- Error: /tmp/tmp5iszcvrc.scala:13:108 ----------------------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArray\e[0m = messageArray.map(\e\
    [36mletter\e[0m => vowels.contains(letter) ? letter : letter.swapCase)\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \                                 No ClassTag available for B\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m                                          where:    B is a type\
    \ variable\n3 errors found\n"
  stdout: ''
  timestamp: 1659978968
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => \n            letter match {\n                case\
    \ vowel => vowels.indexOf(vowel) + 2\n                case _ => vowels.indexOf(letter)\
    \ + 2\n            }\n        )\n        val newMessage = messageArray.toList.mkString(\"\
    \")\n        val newMessageArray2 = newMessageArray.toList.map(letter => \n  \
    \          vowels.indexOf(letter) + 2\n        )\n        newMessageArray2.toList.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdjtrlp8g.scala:26)\n\tat Problem.main(tmpdjtrlp8g.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageList = message.split(\"\
    \")\n        val newMessageList = messageList.map(letter => \n            letter\
    \ match {\n                case 'a' => alphabet(0)\n                case 'b' =>\
    \ alphabet(1)\n                case 'c' => alphabet(2)\n                case 'd'\
    \ => alphabet(3)\n                case 'e' => alphabet(4)\n                case\
    \ 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n              \
    \  case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n        \
    \        case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n \
    \               case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case _ => letter\n\
    \            }\n        )\n        val newMessage = messageList.mkString(\"\"\
    )\n        val newMessageList = newMessageList.map(letter => \n            letter\
    \ match {\n                case 'a' => alphabet(0)\n                case 'b' =>\
    \ alphabet(1)\n                case 'c' => alphabet(2)\n                case 'd'\
    \ => alphabet(3)\n                case 'e' => alphabet(4)\n                case\
    \ 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n              \
    \  case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n        \
    \        case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n \
    \               case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case _ => letter\n\
    \            }\n        )\n        val newMessage = messageList.mkString(\"\"\
    )\n        \n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp919vp186.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mnewMessageList\e[0m = newMessageList.map(\e\
    [36mletter\e[0m => \n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mnewMessageList\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewMessageList\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m47 |\e[0m            letter \e[33mmatch\e\
    [0m {\n\e[31m48 |\e[0m                \e[33mcase\e[0m \e[31m'a'\e[0m => alphabet(\e\
    [31m0\e[0m)\n\e[31m49 |\e[0m                \e[33mcase\e[0m \e[31m'b'\e[0m =>\
    \ alphabet(\e[31m1\e[0m)\n\e[31m50 |\e[0m                \e[33mcase\e[0m \e[31m'c'\e\
    [0m => alphabet(\e[31m2\e[0m)\n\e[31m51 |\e[0m                \e[33mcase\e[0m\
    \ \e[31m'd'\e[0m => alphabet(\e[31m3\e[0m)\n\e[31m52 |\e[0m                \e\
    [33mcase\e[0m \e[31m'e'\e[0m => alphabet(\e[31m4\e[0m)\n\e[31m53 |\e[0m      \
    \          \e[33mcase\e[0m \e[31m'f'\e[0m => alphabet(\e[31m5\e[0m)\n\e[31m54\
    \ |\e[0m                \e[33mcase\e[0m \e[31m'g'\e[0m => alphabet(\e[31m6\e[0m)\n\
    \e[31m55 |\e[0m                \e[33mcase\e[0m \e[31m'h'\e[0m => alphabet(\e[31m7\e\
    [0m)\n\e[31m56 |\e[0m                \e[33mcase\e[0m \e[31m'i'\e[0m => alphabet(\e\
    [31m8\e[0m)\n\e[31m57 |\e[0m                \e[33mcase\e[0m \e[31m'j'\e[0m =>\
    \ alphabet(\e[31m9\e[0m)\n\e[31m58 |\e[0m                \e[33mcase\e[0m \e[31m'k'\e\
    [0m => alphabet(\e[31m10\e[0m)\n\e[31m59 |\e[0m                \e[33mcase\e[0m\
    \ \e[31m'l'\e[0m => alphabet(\e[31m11\e[0m)\n\e[31m60 |\e[0m                \e\
    [33mcase\e[0m \e[31m'm'\e[0m => alphabet(\e[31m12\e[0m)\n\e[31m61 |\e[0m     \
    \           \e[33mcase\e[0m \e[31m'n'\e[0m => alphabet(\e[31m13\e[0m)\n\e[31m62\
    \ |\e[0m                \e[33mcase\e[0m \e[31m'o'\e[0m => alphabet(\e[31m14\e\
    [0m)\n\e[31m63 |\e[0m                \e[33mcase\e[0m \e[31m'p'\e[0m => alphabet(\e\
    [31m15\e[0m)\n\e[31m64 |\e[0m                \e[33mcase\e[0m \e[31m'q'\e[0m =>\
    \ alphabet(\e[31m16\e[0m)\n\e[31m65 |\e[0m                \e[33mcase\e[0m \e[31m'r'\e\
    [0m => alphabet(\e[31m17\e[0m)\n\e[31m66 |\e[0m                \e[33mcase\e[0m\
    \ \e[31m's'\e[0m => alphabet(\e[31m18\e[0m)\n\e[31m67 |\e[0m                \e\
    [33"
  stdout: ''
  timestamp: 1659978971
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    .toCharArray\n        val messageArray = message.toCharArray\n        val newMessage\
    \ = new mutable.Array[Char](messageArray.length)\n        val newMessageArray\
    \ = new mutable.Array[Char](messageArray.length)\n        var i = 0\n        while\
    \ (i < messageArray.length) {\n            val currentChar = messageArray(i)\n\
    \            if (vowels(i) == currentChar) {\n                newMessage(i) =\
    \ vowels(i)\n                newMessageArray(i) = vowels(i)\n            } else\
    \ {\n                newMessage(i) = vowels(i)\n                newMessageArray(i)\
    \ = vowels(i) + vowels(i + 1)\n            }\n            i += 1\n        }\n\
    \        newMessage.toString.toUpperCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx9geidif.scala:13:29 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mnewMessage\e[0m = \e[33mnew\e\
    [0m mutable.Array[\e[35mChar\e[0m](messageArray.length)\n\e[31m\e[31m   |\e[0m\
    \                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpx9geidif.scala:14:34 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m        \e[33mval\e[0m \e[36mnewMessageArray\e[0m = \e[33mnew\e[0m mutable.Array[\e\
    [35mChar\e[0m](messageArray.length)\n\e[31m\e[31m   |\e[0m                   \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978964
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index >= 0) {\n                val nextVowel = vowels(index +\
    \ 1)\n                val nextIndex = vowels.indexOf(nextVowel)\n            \
    \    if (nextIndex >= 0) {\n                    nextVowel\n                } else\
    \ {\n                    letter\n                }\n            } else {\n   \
    \             letter\n            }\n        })\n        newMessageArray.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmproa3e7uv.scala:30)\n\tat Problem.main(tmproa3e7uv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message\n\
    \        val newAlphabet = alphabet.map(x => x.toUpperCase)\n        val newVowels\
    \ = vowels.map(x => x.toUpperCase)\n        val newVowelsIndex = newVowels.zipWithIndex.filter(x\
    \ => x._2 == 0)\n        val newVowelsIndex2 = newVowelsIndex.map(x => x._1)\n\
    \        val newVowelsIndex3 = newVowelsIndex2.map(x => x.toUpperCase)\n     \
    \   val newVowelsIndex4 = newVowelsIndex3.map(x => x.toUpperCase)\n        val\
    \ newVowelsIndex5 = newVowelsIndex4.map(x => x.toUpperCase)\n        val newVowelsIndex6\
    \ = newVowelsIndex5.map(x => x.toUpperCase)\n        val newVowelsIndex7 = newVowelsIndex6.map(x\
    \ => x.toUpperCase)\n        val newVowelsIndex8 = newVowelsIndex7.map(x => x.toUpperCase)\n\
    \        val newVowelsIndex9 = newVowelsIndex8.map(x => x.toUpperCase)\n     \
    \   val newVowelsIndex10 = newVowelsIndex9.map(x => x.toUpperCase)\n        val\
    \ newVowelsIndex11 = newVowelsIndex10.map(x => x.toUpperCase)\n        val newVowelsIndex12\
    \ = newVowelsIndex11.map(x => x.toUpperCase)\n        val newVowelsIndex13 = newVowelsIndex12.map(x\
    \ => x.toUpperCase)\n        val newVowelsIndex14 = newVowelsIndex13.map(x =>\
    \ x.toUpperCase)\n        val newVowelsIndex15 = newVowelsIndex14.map(x => x.toUpperCase)\n\
    \        val newVowelsIndex16 = newVowelsIndex15.map(x => x.toUpperCase)\n   \
    \     val newVowelsIndex17 = newVowels\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdgk70627.scala:14:46 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnewAlphabet\e[0m = alphabet.map(\e\
    [36mx\e[0m => x.toUpperCase)\n\e[31m\e[31m   |\e[0m                          \
    \                  ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \        value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpdgk70627.scala:15:42 ------------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnewVowels\e[0m = vowels.map(\e[36mx\e\
    [0m => x.toUpperCase)\n\e[31m\e[31m   |\e[0m                                 \
    \       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                               value\
    \ toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpdgk70627.scala:18:57 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mnewVowelsIndex3\e[0m = newVowelsIndex2.map(\e\
    [36mx\e[0m => x.toUpperCase)\n\e[31m\e[31m   |\e[0m                          \
    \                             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                value toUpperCase is not a member of Nothing\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdgk70627.scala:19:57 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mnewVowelsIndex4\e[0m = newVowelsIndex3.map(\e\
    [36mx\e[0m => x.toUpperCase)\n\e[31m\e[31m   |\e[0m                          \
    \                             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                value toUpperCase is not a member of Nothing\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdgk70627.scala:20:57 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnewVowelsIndex5\e[0m = newVowelsIndex4.map(\e\
    [36mx\e[0m => x.toUpperCase)\n\e[31m\e[31m   |\e[0m                          \
    \                             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                value toUpperCase is not a member of Nothing\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdgk70627.scala:21:57 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnewVowelsIndex6\e[0m = newVowelsI"
  stdout: ''
  timestamp: 1659978971
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    .toCharArray\n        val messageArray = message.toCharArray\n        val newMessage\
    \ = messageArray.map {\n            case c if vowels.contains(c) => vowels(vowels.indexOf(c)\
    \ + 2)\n            case c => c\n        }\n        new String(newMessage)\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpsq01jb0v.scala:20)\n\tat Problem.main(tmpsq01jb0v.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978910
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index >= 0) {\n                val vowelIndex = index + 1\n \
    \               val vowel = vowels(vowelIndex)\n                vowel\n      \
    \      } else {\n                letter\n            }\n        })\n        val\
    \ newMessage = newMessageArray.toList\n        newMessage.reverse.mkString(\"\"\
    )\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmprj5sicdy.scala:27)\n\tat Problem.main(tmprj5sicdy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978970
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.map(letter => vowels.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case 0 => letter\n     \
    \       case 1 => vowels(letter - 1) + letter\n            case 2 => vowels(letter\
    \ - 1) + vowels(letter - 2)\n            case _ => letter\n        })\n      \
    \  val messageWithVowelsAndVowels2 = messageWithVowels.map(letter => vowels.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case 0 => letter\n     \
    \       case 1 => vowels(letter - 1) + letter\n            case 2 => vowels(letter\
    \ - 1) + vowels(letter - 2)\n            case _ => letter\n        })\n      \
    \  val messageWithVowelsAndVowels3 = messageWithVowelsAndVowels2.map(letter =>\
    \ vowels.indexOf(letter) match {\n            case -1 => letter\n            case\
    \ 0 => letter\n            case 1 => vowels(letter - 1) + letter\n           \
    \ case 2 => vowels(letter - 1) + vowels(letter - 2)\n            case _ => letter\n\
    \        })\n        val messageWithVowelsAndVowels4 = messageWithVowelsAndVowels3.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case 0 => letter\n            case 1 => vowels(letter - 1) + letter\n    \
    \        case 2 => vowels(letter - 1) + vowels(letter - 2)\n            case _\
    \ => letter\n        })\n        val messageWithVowelsAndVowels5 = messageWithVowelsAndVowels4.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case 0 => letter\n            case 1 => vowels(letter - 1) + letter\n    \
    \        case 2 => vowels(letter - 1) + vowels(letter - 2)\n            case _\
    \ => letter\n        })\n        val messageWithVowelsAndVowels6 = messageWithVowelsAndVowels5.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case 0 => letter\n            case 1 => vowels(letter - 1) + letter\n    \
    \        case 2 => vowels(letter - 1) + vowels(letter - 2)\n            case _\
    \ => letter\n        })\n        val messageWithVowelsAndVowels7 = messageWithVowelsAndVowels6.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case 0 => letter\n            case 1 => vowels(letter - 1) + letter\n    \
    \        case 2 => vowels(letter - 1) + vowels(letter - 2)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo599amkq.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpo599amkq.scala:69:0 ----------------------------\e[0m\e[0m\n\e[31m69\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo599amkq.scala:22:36 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m            \e[33mcase\e[0m \e[31m1\e[0m => vowels(letter\
    \ - \e[31m1\e[0m) + letter\n\e[31m\e[31m   |\e[0m                            \
    \ ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of AnyVal, but could be\
    \ made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpo599amkq.scala:23:36 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m \e[31m2\e[0m => vowels(letter\
    \ - \e[31m1\e[0m) + vowels(letter - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \                        ^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member\
    \ of AnyVal, but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpo599amkq.scala:23:57 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mcase\e[0m \e[31m2\e[0m => vowels(letter\
    \ - \e[31m1\e[0m) + vowels(letter - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m     "
  stdout: ''
  timestamp: 1659978974
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        var newMessage = message\n\
    \        val vowels = \"aeiou\"\n        val vowelsMap = new mutable.HashMap[String,\
    \ String]()\n        vowels.foreach(vowel => {\n            vowelsMap(vowel) =\
    \ vowel\n        })\n        val vowelsMap2 = new mutable.HashMap[String, String]()\n\
    \        val vowelsMap3 = new mutable.HashMap[String, String]()\n        val vowelsMap4\
    \ = new mutable.HashMap[String, String]()\n        val vowelsMap5 = new mutable.HashMap[String,\
    \ String]()\n        val vowelsMap6 = new mutable.HashMap[String, String]()\n\
    \        val vowelsMap7 = new mutable.HashMap[String, String]()\n        val vowelsMap8\
    \ = new mutable.HashMap[String, String]()\n        val vowelsMap9 = new mutable.HashMap[String,\
    \ String]()\n        val vowelsMap10 = new mutable.HashMap[String, String]()\n\
    \        val vowelsMap11 = new mutable.HashMap[String, String]()\n        val\
    \ vowelsMap12 = new mutable.HashMap[String, String]()\n        val vowelsMap13\
    \ = new mutable.HashMap[String, String]()\n        val vowelsMap14 = new mutable.HashMap[String,\
    \ String]()\n        val vowelsMap15 = new mutable.HashMap[String, String]()\n\
    \        val vowelsMap16 = new mutable.HashMap[String, String]()\n        val\
    \ vowelsMap17 = new mutable.HashMap[String, String]()\n        val vowelsMap18\
    \ = new mutable.HashMap[String, String]()\n        val vowelsMap19 = new mutable.HashMap[String,\
    \ String]()\n        val vowelsMap20 = new mutable.HashMap[String, String]()\n\
    \        val vowelsMap21 = new mutable.HashMap[String, String]()\n        val\
    \ vowelsMap22 = new mutable.HashMap[String, String]()\n        val vowelsMap23\
    \ = new mutable.HashMap[String, String]()\n        val vowelsMap24 = new mutable.HashMap[String,\
    \ String]()\n        val vowelsMap25 = new mutable.HashMap[String, String]()\n\
    \        val vowelsMap26 = new mutable.HashMap[String, String]()\n        val\
    \ vowelsMap27 = new mutable.HashMap[String, String]()\n        val vowelsMap28\
    \ = new mutable.HashMap[String, String]()\n        val vowelsMap29 = new mutable.HashMap[String,\
    \ String]()\n        val vowelsMap30 = new mutable.HashMap[String, String]()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprw7e7hao.scala:13:28 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mvowelsMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprw7e7hao.scala:17:29 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        \e[33mval\e[0m \e[36mvowelsMap2\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmprw7e7hao.scala:18:29\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mvowelsMap3\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmprw7e7hao.scala:19:29 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mvowelsMap4\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mString\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmprw7e7hao.scala:20:29 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m        \e[33mval\e[0m \e[36mvowelsMap5\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found:\
    \ mutable"
  stdout: ''
  timestamp: 1659978969
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val encodedMessage = messageArray.map(letter => {\n            val\
    \ index = alphabet.indexOf(letter)\n            val vowelIndex = vowels.indexOf(letter)\n\
    \            val nextLetter = alphabet(index+1)\n            val nextVowel = alphabet(vowelIndex+1)\n\
    \            if(index != vowelIndex) letter else nextLetter\n        }).mkString(\"\
    \")\n        encodedMessage\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbmhh39nd.scala:24)\n\tat Problem.main(tmpbmhh39nd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase.foldLeft(message){\n   \
    \         (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c)\n\
    \        }\n        val messageWithVowelsAndTwoLettersBefore = messageWithVowels.foldLeft(messageWithVowels){\n\
    \            (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c)\n\
    \        }\n        val messageWithVowelsAndTwoLettersAfter = messageWithVowelsAndTwoLettersBefore.foldLeft(messageWithVowelsAndTwoLettersBefore){\n\
    \            (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c)\n\
    \        }\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBefore\
    \ = messageWithVowelsAndTwoLettersAfter.foldLeft(messageWithVowelsAndTwoLettersAfter){\n\
    \            (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c)\n\
    \        }\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfter\
    \ = messageWithVowelsAndTwoLettersAfterAndOneLetterBefore.foldLeft(messageWithVowelsAndTwoLettersAfterAndOneLetterBefore){\n\
    \            (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c)\n\
    \        }\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBefore\
    \ = messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfter.foldLeft(messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfter){\n\
    \            (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c)\n\
    \        }\n        val messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBeforeAndOneLetterAfter\
    \ = messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBefore.foldLeft(messageWithVowelsAndTwoLettersAfterAndOneLetterBeforeAndOneLetterAfterAndOneLetterBefore){\n\
    \            (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c)\n\
    \        }\n        val messageWithVowelsAndTwoLettersAfterAndOneLetter\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp91y8dcon.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp91y8dcon.scala:13:57\
    \ ------------------------\e[0m\e[0m\n\e[31m13 |\e[0m            (\e[36macc\e\
    [0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase()\
    \ \e[33melse\e[0m c)\n\e[31m\e[31m   |\e[0m                                  \
    \                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \           value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp91y8dcon.scala:16:57 ------------------------\e[0m\e[0m\n\
    \e[31m16 |\e[0m            (\e[36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e\
    [0m (vowels.contains(c)) c.toUpperCase() \e[33melse\e[0m c)\n\e[31m\e[31m   |\e\
    [0m                                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toUpperCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp91y8dcon.scala:19:57\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            (\e[36macc\e\
    [0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase()\
    \ \e[33melse\e[0m c)\n\e[31m\e[31m   |\e[0m                                  \
    \                     ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \           value toUpperCase is not a member of Char\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp91y8dcon.scala:22:57 ------------------------\e[0m\e[0m\n\
    \e[31m22 |\e[0m            (\e[36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e\
    [0m (vowels.contains(c)) c.toUpperCase() \e[33melse\e[0m c)\n\e[31m\e[31m   |\e\
    [0m                                                       ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                               value toUpperCase is not a member\
    \ of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp91y8dcon.scala:25:57\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            (\e[36macc\e\
    [0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase()\
    \ \e[33melse\e[0m c)\n\e[31m\e[31m   |"
  stdout: ''
  timestamp: 1659978972
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageWithVowels\
    \ = message.toLowerCase.foldLeft(\"\")( (acc, letter) => acc + (if (vowels.contains(letter))\
    \ letter else alphabet(alphabet.indexOf(letter) + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowel\
    \ = messageWithVowels.foldLeft(\"\")( (acc, letter) => acc + (if (vowels.contains(letter))\
    \ letter else alphabet(alphabet.indexOf(letter) + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowel.foldLeft(\"\")( (acc, letter) =>\
    \ acc + (if (vowels.contains(letter)) letter else alphabet(alphabet.indexOf(letter)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\"\
    \")( (acc, letter) => acc + (if (vowels.contains(letter)) letter else alphabet(alphabet.indexOf(letter)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\"\
    \")( (acc, letter) => acc + (if (vowels.contains(letter)) letter else alphabet(alphabet.indexOf(letter)\
    \ + 2)))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoA\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpio5u9664.scala:19:4 ----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpio5u9664.scala:17:128\
    \ --------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.foldLeft(\e\
    [31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mletter\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(letter))\
    \ letter \e[33melse\e[0m alphabet(alphabet.indexOf(letter) + \e[31m2\e[0m)))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                        ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpio5u9664.scala:19:5 ---------------------\e[0m\e[0m\n\e[31m19\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659978970
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    .toList\n        val messageList = message.split(\"\")\n        val newMessage\
    \ = messageList.map(letter => \n            vowels.indexOf(letter) match {\n \
    \               case -1 => letter\n                case 0 => letter\n        \
    \        case 1 => vowels(vowels.indexOf(letter) + 1)\n            }\n       \
    \ ).mkString(\"\")\n        newMessage\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8z7qzxr5.scala:23)\n\tat Problem.main(tmp8z7qzxr5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978973
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val result = new\
    \ StringBuilder\n        for(i <- 0 until message.length){\n            val c\
    \ = message.charAt(i)\n            val l = letters.indexOf(c)\n            val\
    \ vowel = vowels.indexOf(c)\n            if(l != -1){\n                val a =\
    \ letters.charAt(l - 1)\n                val b = letters.charAt(l - 2)\n     \
    \           val c = letters.charAt(l - 3)\n                val d = letters.charAt(l\
    \ - 4)\n                val e = letters.charAt(l - 5)\n                val f =\
    \ letters.charAt(l - 6)\n                val g = letters.charAt(l - 7)\n     \
    \           val h = letters.charAt(l - 8)\n                val i = letters.charAt(l\
    \ - 9)\n                val j = letters.charAt(l - 10)\n                val k\
    \ = letters.charAt(l - 11)\n                val l = letters.charAt(l - 12)\n \
    \               val m = letters.charAt(l - 13)\n                val n = letters.charAt(l\
    \ - 14)\n                val o = letters.charAt(l - 15)\n                val p\
    \ = letters.charAt(l - 16)\n                val q = letters.charAt(l - 17)\n \
    \               val r = letters.charAt(l - 18)\n                val s = letters.charAt(l\
    \ - 19)\n                val t = letters.charAt(l - 20)\n                val u\
    \ = letters.charAt(l - 21)\n                val v = letters.charAt(l - 22)\n \
    \               val w = letters.charAt(l - 23)\n                val x = letters.charAt(l\
    \ - 24)\n                val y = letters.charAt(l - 25)\n                val z\
    \ = letters.charAt(l - 26)\n                val a = letters.charAt(l - 27)\n \
    \               val b = letters.charAt(l - 28)\n                val c = letters.charAt(l\
    \ - 29)\n                val d = letters.charAt(l - 30)\n                val e\
    \ = letters.charAt(l - 31)\n                val f = letters.charAt(l - 32)\n \
    \               val g = letters.charAt(l - 33)\n                val h = letters.charAt(l\
    \ - 34)\n                val i = letters.charAt(l - 35)\n                val j\
    \ = letters.charAt(l - 36)\n                val k = letters.charAt(l - 37)\n \
    \               val l = letters.charAt(l - 38)\n                val m = letters.charAt(l\
    \ - 39)\n                val n = letters.charAt(l - 40)\n                val o\
    \ = letters.charAt(l - 41)\n                val p = letters.charAt(l - 42)\n \
    \               val q = letters.\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0yxlleu8.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp0yxlleu8.scala:72:0 ----------------------------\e[0m\e[0m\n\e[31m72\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0yxlleu8.scala:45:20 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                \e[33mval\e[0m \e[36ma\e[0m = letters.charAt(l\
    \ - \e[31m27\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0ma is already defined as \e[33mvalue\e[0m \e[35ma\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0yxlleu8.scala:46:20 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m                \e[33mval\e[0m \e[36mb\e[0m = letters.charAt(l - \e[31m28\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mb is already defined as \e[33mvalue\e[0m \e[35mb\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0yxlleu8.scala:47:20 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m                \e[33mval\e[0m \e[36mc\e[0m = letters.charAt(l - \e[31m29\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mc is already defined as \e[33mvalue\e[0m \e[35mc\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0yxlleu8.scala:48:20 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m                \e[33mval\e[0m \e[36md\e[0m = letters.charAt(l - \e[31m30\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overlo"
  stdout: ''
  timestamp: 1659978969
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val vowelMap :\
    \ Map[Char, Char] = Map(vowels -> letters.charAt(0), vowels.toLowerCase -> letters.charAt(1))\n\
    \        val letterMap : Map[Char, Char] = Map(letters.toLowerCase -> letters.charAt(0),\
    \ letters.toUpperCase -> letters.charAt(1))\n        val messageMap : Map[Char,\
    \ Char] = message.toLowerCase -> message.charAt(0)\n        val result = message.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowelMap.contains(c)) vowelMap(c) else letterMap(c))\
    \ )\n        val resultMap : Map[Char, Char] = result.toLowerCase -> result.charAt(0)\n\
    \        val finalResult = result.foldLeft(\"\")( (acc, c) => acc + (if (resultMap.contains(c))\
    \ resultMap(c) else c))\n        finalResult\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphu9iyzxe.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mvowelMap\e\
    [0m : \e[35mMap\e[0m[\e[35mChar\e[0m, \e[35mChar\e[0m] = Map(vowels -> letters.charAt(\e\
    [31m0\e[0m), vowels.toLowerCase -> letters.charAt(\e[31m1\e[0m))\n\e[31m\e[31m\
    \   |\e[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    (\e\
    [1m\e[31mString\e[0m, Char)\n\e[31m   |\e[0m                                 \
    \            Required: (\e[1m\e[32mChar\e[0m, Char)\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmphu9iyzxe.scala:13:74 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mvowelMap\e[0m : \e[35mMap\e\
    [0m[\e[35mChar\e[0m, \e[35mChar\e[0m] = Map(vowels -> letters.charAt(\e[31m0\e\
    [0m), vowels.toLowerCase -> letters.charAt(\e[31m1\e[0m))\n\e[31m\e[31m   |\e\
    [0m                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                Found:   \
    \ (\e[1m\e[31mString\e[0m, Char)\n\e[31m   |\e[0m                            \
    \                    Required: (\e[1m\e[32mChar\e[0m, Char)\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphu9iyzxe.scala:14:46 --------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mletterMap\e[0m : \e[35mMap\e\
    [0m[\e[35mChar\e[0m, \e[35mChar\e[0m] = Map(letters.toLowerCase -> letters.charAt(\e\
    [31m0\e[0m), letters.toUpperCase -> letters.charAt(\e[31m1\e[0m))\n\e[31m\e[31m\
    \   |\e[0m                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                              Found:    (\e\
    [1m\e[31mString\e[0m, Char)\n\e[31m   |\e[0m                                 \
    \             Required: (\e[1m\e[32mChar\e[0m, Char)\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compili"
  stdout: ''
  timestamp: 1659978972
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message.map(letter\
    \ => alphabet(alphabet.indexOf(letter) + 1))\n        val newVowels = vowels.map(letter\
    \ => alphabet(alphabet.indexOf(letter) + 2))\n        newMessage.zip(newVowels).map(x\
    \ => x._1 + \"-\" + x._2).mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1nqwv0ol.scala:18)\n\tat Problem.main(tmp1nqwv0ol.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(letter => \n            letter match {\n                case vowel\
    \ => vowels.indexOf(letter) + alphabet.length\n                case _ => alphabet.indexOf(letter)\
    \ + alphabet.length\n            }\n        )\n        val result = newMessage.toList\n\
    \        result.map(_.toString).mkString(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnxg6h200.scala:23)\n\tat Problem.main(tmpnxg6h200.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val vowelIndex = index + 1\n\
    \                val vowel = vowels(vowelIndex)\n                vowel\n     \
    \       } else {\n                letter\n            }\n        })\n        newMessageArray.toString.replace(\"\
    [\", \"\").replace(\"]\", \"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpan1yd5vz.scala:26)\n\tat Problem.main(tmpan1yd5vz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978975
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val encodedMessage = messageArray.map(letter\
    \ => \n            if (vowels.contains(letter)) \n                alphabet(alphabet.indexOf(letter)\
    \ + 2)\n            else letter)\n        encodedMessage.toString.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3wvjod8n.scala:21)\n\tat Problem.main(tmp3wvjod8n.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val encodedMessage = messageArray.map(letter\
    \ => \n            if (vowels.contains(letter)) letter else \n               \
    \ alphabet(alphabet.indexOf(letter) + 2))\n        encodedMessage.toString.replace(\"\
    ,\", \"\")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz_s1t77d.scala:20)\n\tat Problem.main(tmpz_s1t77d.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => letters.indexOf(letter) + vowels.indexOf(vowels.charAt(letter)) + letters.indexOf(vowels.charAt(letter))\
    \ + 1)\n        val newMessage = messageArray.join(\"\")\n        newMessageArray.join(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiuworsre.scala:14:112\
    \ -------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArray\e\
    [0m = messageArray.map(\e[36mletter\e[0m => letters.indexOf(letter) + vowels.indexOf(vowels.charAt(letter))\
    \ + letters.indexOf(vowels.charAt(letter)) + \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                      ^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                   Found:    (letter : String)\n\e[31m   |\e\
    [0m                                             Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiuworsre.scala:14:153 -------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArray\e[0m = messageArray.map(\e\
    [36mletter\e[0m => letters.indexOf(letter) + vowels.indexOf(vowels.charAt(letter))\
    \ + letters.indexOf(vowels.charAt(letter)) + \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                                                            \
    \   ^^^^^^\e[0m\n\e[31m   |\e[0m                                             Found:\
    \    (letter : String)\n\e[31m   |\e[0m                                      \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpiuworsre.scala:15:38\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mnewMessage\e[0m = messageArray.join(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \                         ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue join is\
    \ not a member of Array[String] - did you mean messageArray.wait?\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpiuworsre.scala:16:24 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        newMessageArray.join(\e[31m\"\"\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue join is not\
    \ a member of Array[Int] - "
  stdout: ''
  timestamp: 1659978977
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = Set(\"a\", \"\
    e\", \"i\", \"o\", \"u\")\n        val messageArray = message.split(\"\")\n  \
    \      val newMessage = messageArray.foldLeft(\"\") { (acc, c) =>\n          \
    \  val index = vowels.indexOf(c)\n            if (index != -1) {\n           \
    \     val newIndex = index - 2\n                acc + (if (newIndex < 0) c else\
    \ vowels(newIndex))\n            } else {\n                acc + c\n         \
    \   }\n        }\n        newMessage\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgg52_ev1.scala:14:31 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mindex\e[0m = vowels.indexOf(c)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m   value indexOf is not a member of scala.collection.mutable.Set[String]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978978
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => letters.indexOf(letter) + letters.indexOf(vowels.charAt(letters.indexOf(letter)\
    \ + 1)) % 26)\n        val newMessage = newMessageArray.toArray\n        val newMessageString\
    \ = newMessage.toString\n        newMessageString.toUpperCase\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\"\
    )));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgas2ok1q.scala:20)\n\tat Problem.main(tmpgas2ok1q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => vowels.indexOf(letter) match {\n            case\
    \ -1 => letter\n            case i => vowels(i + 2)\n        })\n        val newMessage\
    \ = newMessageArray.toSeq.mkString(\"\")\n        val newMessageArray2 = newMessage.split(\"\
    \")\n        val newMessageArray3 = newMessageArray2.map(letter => vowels.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case i => vowels(i + 2)\n\
    \        })\n        val newMessage2 = newMessageArray3.toSeq.mkString(\"\")\n\
    \        val newMessageArray4 = newMessage2.split(\"\")\n        val newMessageArray5\
    \ = newMessageArray4.map(letter => vowels.indexOf(letter) match {\n          \
    \  case -1 => letter\n            case i => vowels(i + 2)\n        })\n      \
    \  val newMessage3 = newMessageArray5.toSeq.mkString(\"\")\n        val newMessageArray6\
    \ = newMessage3.split(\"\")\n        val newMessageArray7 = newMessageArray6.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case i => vowels(i + 2)\n        })\n        val newMessage4 = newMessageArray7.toSeq.mkString(\"\
    \")\n        val newMessageArray8 = newMessage4.split(\"\")\n        val newMessageArray9\
    \ = newMessageArray8.map(letter => vowels.indexOf(letter) match {\n          \
    \  case -1 => letter\n            case i => vowels(i + 2)\n        })\n      \
    \  val newMessage5 = newMessageArray9.toSeq.mkString(\"\")\n        val newMessageArray10\
    \ = newMessage5.split(\"\")\n        val newMessageArray11 = newMessageArray10.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case i => vowels(i + 2)\n        })\n        val newMessage6 = newMessageArray11.toSeq.mkString(\"\
    \")\n        val newMessageArray12 = newMessage6.split(\"\")\n        val newMessageArray13\
    \ = newMessageArray12.map(letter => vowels.indexOf(letter) match {\n         \
    \   case -1 => letter\n            case i => vowels(i + 2)\n        })\n     \
    \   val newMessage7 = newMessageArray13.toSeq.mkString(\"\")\n        val newMessageArray14\
    \ = newMessage7.split(\"\")\n        val newMessageArray15 = newMessageArray14.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case i => vowels(i + 2)\n        })\n        val newMessage8 = newMessageArray15.toSeq.mk\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmphwfv70sj.scala:59:50 ------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mnewMessage8\e[0m = newMessageArray15.toSeq.mk\n\
    \e[31m\e[31m   |\e[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          value mk is not a member of Seq[Matchable]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphwfv70sj.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageWithVowels\
    \ = message.toLowerCase\n        val messageWithVowelsAndVowelsTwoAheadOfVowel\
    \ = messageWithVowels.replaceAllIn(vowels, vowels.map(_ + 2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowel.replaceAllIn(vowels, vowels.map(_\
    \ + 2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowel.replaceAllIn(vowels, vowels.map(_\
    \ + 2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowel.replaceAllIn(vowels,\
    \ vowels.map(_ + 2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowel.replaceAllIn(vowels,\
    \ vowels.map(_ + 2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowelAndVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowelAndVowel.replaceAllIn(vowels,\
    \ vowels.map(_ + 2))\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpknrt29mg.scala:21:4 ----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpknrt29mg.scala:14:74\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mmessageWithVowelsAndVowelsTwoAheadOfVowel\e[0m = messageWithVowels.replaceAllIn(vowels,\
    \ vowels.map(_ + \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m                       \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue replaceAllIn is not a member of String - did you mean messageWithVowels.replaceAll?\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpknrt29mg.scala:18:88 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowel.replaceAllIn(vowels,\
    \ vowels.map(_ + \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m                       \
    \                                                                 ^\e[0m\n\e[31m\
    \   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowel\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpknrt29mg.scala:19:96\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowelAndVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowelAndVowel.replaceAllIn(vowels,\
    \ vowels.map(_ + \e[31m2\e[0m))\n\e[31m\e[31m   |\e[0m                       \
    \                                                                         ^\e\
    [0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelAndVowelAndVowelAndVowelAndVowel\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling "
  stdout: ''
  timestamp: 1659978979
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message.toLowerCase\n\
    \        val newAlphabet = alphabet.map(x => x.toLowerCase)\n        val newVowels\
    \ = vowels.map(x => x.toLowerCase)\n        val newVowelsMap = newVowels.zipWithIndex.map(x\
    \ => (x._1, x._2))\n        val newAlphabetMap = newAlphabet.zipWithIndex.map(x\
    \ => (x._1, x._2))\n        val newMessageMap = newMessage.zipWithIndex.map(x\
    \ => (x._1, x._2))\n        val newMessageMap2 = newMessageMap.map(x => (x._1,\
    \ x._2))\n        val newAlphabetMap2 = newAlphabetMap.map(x => (x._1, x._2))\n\
    \        val newVowelsMap2 = newVowelsMap.map(x => (x._1, x._2))\n        val\
    \ newMessageMap3 = newMessageMap2.map(x => (x._1, x._2))\n        val newAlphabetMap3\
    \ = newAlphabetMap2.map(x => (x._1, x._2))\n        val newVowelsMap3 = newVowelsMap2.map(x\
    \ => (x._1, x._2))\n        val newMessageMap4 = newMessageMap3.map(x => (x._1,\
    \ x._2))\n        val newAlphabetMap4 = newAlphabetMap3.map(x => (x._1, x._2))\n\
    \        val newVowelsMap4 = newVowelsMap3.map(x => (x._1, x._2))\n        val\
    \ newMessageMap5 = newMessageMap4.map(x => (x._1, x._2))\n        val newAlphabetMap5\
    \ = newAlphabetMap4.map(x => (x._1, x._2))\n        val newVowelsMap5 = newVowelsMap4.map(x\
    \ => (x._1, x._2))\n        val newMessageMap6 = newMessageMap5.map(x => (x._1,\
    \ x._2))\n        val newAlphabetMap6 = newAlphabetMap5.map(x => (x._1, x._2))\n\
    \        val newVowelsMap6 = newVowelsMap5.map(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp25an89_k.scala:33:46 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mnewVowelsMap6\e[0m = newVowelsMap5.map(\n\
    \e[31m\e[31m   |\e[0m                                              ^\e[0m\n\e\
    [31m   |\e[0m                                       expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp25an89_k.scala:14:46\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mnewAlphabet\e[0m = alphabet.map(\e[36mx\e[0m => x.toLowerCase)\n\e[31m\e[31m\
    \   |\e[0m                                            ^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                               value toLowerCase is not a member of\
    \ Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp25an89_k.scala:15:42 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mnewVowels\e[0m = vowels.map(\e\
    [36mx\e[0m => x.toLowerCase)\n\e[31m\e[31m   |\e[0m                          \
    \              ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \    value toLowerCase is not a member of Char\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp25an89_k.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659978981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val newMessage = messageArray.map(letter => \n\
    \            letter match {\n                case vowel => alphabet(alphabet.indexOf(vowel)\
    \ + 2)\n                case _ => letter\n            }\n        ).mkString(\"\
    \")\n        newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9k0bxovu.scala:23)\n\tat Problem.main(tmp9k0bxovu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('e','i','o','u')\n        val messageList = message.split(\"\
    \")\n        val newMessageList = messageList.map(letter => letter match {\n \
    \           case letter if letter != vowels(0) => alphabet(alphabet.indexOf(letter)\
    \ + 1)\n            case letter => letter\n        })\n        newMessageList.mkString(\"\
    \")\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpq5zw0dmk.scala:15:27 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            \e[33mcase\e[0m letter \e[33mif\e[0m letter\
    \ != vowels(\e[31m0\e[0m) => alphabet(alphabet.indexOf(letter) + \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n1 error found\n"
  stdout: ''
  timestamp: 1659978981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    .toCharArray\n        val messageArray = message.toCharArray\n        val encodedMessage\
    \ = messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val nextVowel = vowels(index\
    \ + 1)\n                if (nextVowel != letter) {\n                    letter\n\
    \                } else {\n                    nextVowel\n                }\n\
    \            } else {\n                letter\n            }\n        }).mkString\n\
    \        encodedMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp31bi00nd.scala:29)\n\tat Problem.main(tmp31bi00nd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978982
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase.foldLeft(\"\")( (acc, c)\
    \ => acc + (if (vowels.contains(c)) c.toUpperCase else c) )\n        val messageWithVowelsAnd2LettersBefore\
    \ = messageWithVowels.foldLeft(\"\")( (acc, c) => acc + (if (vowels.contains(c))\
    \ c.toUpperCase else c) + (if (vowels.contains(c.charAt(2)) c.charAt(2) else c)\
    \ )\n        val messageWithVowelsAnd2LettersBeforeAnd2LettersAfter = messageWithVowelsAnd2LettersBefore.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase else c) + (if (vowels.contains(c.charAt(2))\
    \ c.charAt(2) else c) + (if (vowels.contains(c.charAt(3)) c.charAt(3) else c)\
    \ )\n        val messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersBefore\
    \ = messageWithVowelsAnd2LettersBeforeAnd2LettersAfter.foldLeft(\"\")( (acc, c)\
    \ => acc + (if (vowels.contains(c)) c.toUpperCase else c) + (if (vowels.contains(c.charAt(2))\
    \ c.charAt(2) else c) + (if (vowels.contains(c.charAt(3)) c.charAt(3) else c)\
    \ + (if (vowels.contains(c.charAt(4)) c.charAt(4) else c) )\n        val messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersBeforeAnd2LettersAfter\
    \ = messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersBefore.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase else c) + (if (vowels.contains(c.charAt(2))\
    \ c.charAt(2) else c) + (if (vowels.contains(c.charAt(3)) c.charAt(3) else c)\
    \ + (if (vowels.contains(c.charAt(4)) c.charAt(4) else c) + (if (vowels.contains(c.charAt(5))\
    \ c.charAt(5) else c) )\n        val messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersBeforeAnd2LettersAfterAnd2LettersBefore\
    \ = messageWithVowelsAnd2LettersBeforeAnd2LettersAfterAnd2LettersBeforeAnd2LettersAfter.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase else \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpo2pq85t9.scala:13:183 --------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAnd2LettersBefore\e\
    [0m = messageWithVowels.foldLeft(\e[31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mc\e\
    [0m) => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase \e[33melse\e[0m\
    \ c) + (\e[33mif\e[0m (vowels.contains(c.charAt(\e[31m2\e[0m)) c.charAt(\e[31m2\e\
    [0m) \e[33melse\e[0m c) )\n\e[31m\e[31m   |\e[0m                             \
    \                                                                            \
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'.'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpo2pq85t9.scala:13:202 --------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAnd2LettersBefore\e[0m =\
    \ messageWithVowels.foldLeft(\e[31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mc\e[0m)\
    \ => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase \e[33melse\e[0m c)\
    \ + (\e[33mif\e[0m (vowels.contains(c.charAt(\e[31m2\e[0m)) c.charAt(\e[31m2\e\
    [0m) \e[33melse\e[0m c) )\n\e[31m\e[31m   |\e[0m                             \
    \                                                                            \
    \                                                                            \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \          'then' expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpo2pq85t9.scala:14:8 ----------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAnd2LettersBeforeAnd2LettersAfter\e\
    [0m = messageWithVowelsAnd2LettersBefore.foldLeft(\e[31m\"\"\e[0m)( (\e[36macc\e\
    [0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase\
    \ \e[33melse\e[0m c) + (\e[33mif\e[0m (vowels.contains(c.charAt(\e[31m2\e[0m))\
    \ c.charAt(\e[31m2\e[0m) \e[33melse\e[0m c) + (\e[33mif\e[0m (vowels.contains(c.charAt(\e\
    [31m3\e[0m)) c.charAt(\e[31m3\e"
  stdout: ''
  timestamp: 1659978981
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        var newMessage = message\n\
    \        val vowels = \"aeiouAEIOU\"\n        val vowelsCount = vowels.toList.size\n\
    \        val vowelsMap = new mutable.HashMap[String, Int]()\n        vowels.toList.foreach(vowel\
    \ => {\n            vowelsMap(vowel) = vowelsMap.getOrElse(vowel, 0)\n       \
    \ })\n        val vowelsMapKeys = vowelsMap.keys.toList\n        val vowelsMapValues\
    \ = vowelsMap.values.toList\n        val vowelsMapKeysSorted = vowelsMapKeys.sortWith(_\
    \ < _)\n        val vowelsMapValuesSorted = vowelsMapValues.sortWith(_ < _)\n\
    \        vowelsMapKeys.foreach(vowel => {\n            val vowelsMapKeyIndex =\
    \ vowelsMapKeys.indexOf(vowel)\n            val vowelsMapValueIndex = vowelsMapValues.indexOf(vowelsMapKeyIndex)\n\
    \            val vowelsMapKeyIndex2 = vowelsMapKeys.indexOf(vowel, vowelsMapKeyIndex\
    \ + 1)\n            val vowelsMapValueIndex2 = vowelsMapValues.indexOf(vowelsMapValueIndex,\
    \ vowelsMapKeyIndex + 1)\n            val vowelsMapKeyIndex3 = vowelsMapKeys.indexOf(vowel,\
    \ vowelsMapKeyIndex + 2)\n            val vowelsMapValueIndex3 = vowelsMapValues.indexOf(vowelsMapValueIndex,\
    \ vowelsMapKeyIndex + 2)\n            val vowelsMapKeyIndex4 = vowelsMapKeys.indexOf(vowel,\
    \ vowelsMapKeyIndex + 3)\n            val vowelsMapValueIndex4 = vowelsMapValues.indexOf(vowelsMapValueIndex,\
    \ vowelsMapKeyIndex + 3)\n            val vowelsMapKeyIndex5 = vowelsMapKeys.indexOf(vowel,\
    \ vowelsMapKeyIndex + 4)\n            val vowelsMapValueIndex5 = vowelsMapValues.indexOf(vowelsMapValueIndex,\
    \ vowelsMapKeyIndex + 4)\n            val vowelsMapKeyIndex6 = vowelsMapKeys.indexOf(vowel,\
    \ vowelsMapKeyIndex + 5)\n            val vowelsMapValueIndex6 = vowelsMapValues.indexOf(vowelsMapValueIndex,\
    \ vowelsMapKeyIndex + 5)\n            val vowelsMapKeyIndex7 = vowelsMapKeys.indexOf(vowel,\
    \ vowelsMapKeyIndex + 6)\n            val vowelsMapValueIndex7 = vowelsMapValues.indexOf(vowelsMapValueIndex,\
    \ vowelsMapKeyIndex + 6)\n            val vowelsMapKeyIndex8 = vowelsMapKeys.indexOf(vowel,\
    \ vowelsMapKeyIndex + 7)\n            val vowelsMap\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkiih4wo9.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkiih4wo9.scala:40:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m40 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpkiih4wo9.scala:49:0 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkiih4wo9.scala:14:28\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mvowelsMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mInt\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978978
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val result = new\
    \ StringBuilder\n        for(i <- 0 until message.length){\n            val index\
    \ = message.indexOf(i)\n            val letter = letters.charAt(index)\n     \
    \       val vowel = vowels.charAt(index - 2)\n            val replacement = if\
    \ (letter == vowel) letter.charAt(2) else letter.charAt(1)\n            result.append(replacement)\n\
    \        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpvr6inmpf.scala:18:58 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mreplacement\e[0m = \e\
    [33mif\e[0m (letter == vowel) letter.charAt(\e[31m2\e[0m) \e[33melse\e[0m letter.charAt(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                                           \
    \        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \   value charAt is not a member of Char\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpvr6inmpf.scala:18:80 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m            \e[33mval\e[0m \e[36mreplacement\e[0m = \e[33mif\e[0m (letter ==\
    \ vowel) letter.charAt(\e[31m2\e[0m) \e[33melse\e[0m letter.charAt(\e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                 ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \            value charAt is not a member of Char\n2 errors found\n"
  stdout: ''
  timestamp: 1659978981
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case i => vowels(i + 2)\n        }).mkString(\"\")\n        newMessage\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnouqlu66.scala:20)\n\tat Problem.main(tmpnouqlu66.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978984
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => \n            vowels.indexOf(letter) match {\n\
    \                case -1 => letter\n                case i => vowels(i + 2)\n\
    \            }\n        )\n        val newMessageString = newMessageArray.toList.toString\n\
    \        newMessageString.replace(\"[\", \"\").replace(\"]\", \"\")\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp4t8p9633.scala:23)\n\tat Problem.main(tmp4t8p9633.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978985
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val encodedMessage = messageArray.map(letter => \n            letter\
    \ match {\n                case 'a' => alphabet(0)\n                case 'b' =>\
    \ alphabet(1)\n                case 'c' => alphabet(2)\n                case 'd'\
    \ => alphabet(3)\n                case 'e' => alphabet(4)\n                case\
    \ 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n              \
    \  case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n        \
    \        case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n \
    \               case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case _ => letter\n\
    \            }\n        ).mkString(\"\")\n        val encodedMessageArray = encodedMessage.split(\"\
    \")\n        val encodedMessageArrayLength = encodedMessageArray.length\n    \
    \    val encodedMessageArrayLength = encodedMessageArrayLength - 1\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength - 1\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength - 1\n        val encodedMessageArrayLength = encodedMessageArrayLength\
    \ - 1\n        val encodedMessageArrayLength = encodedMessageArrayLength - 1\n\
    \        val encodedMessageArrayLength = encodedMessageArrayLength - 1\n     \
    \   val encodedMessageArrayLength = encodedMessageArrayLength - 1\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength - 1\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength - 1\n        val encodedMessageArrayLength = encodedMessageArrayLength\
    \ - 1\n        val encodedMessageArrayLength = encodedMessageArrayLength - 1\n\
    \        val encodedMessageArrayLength = encodedMessageArrayLength - 1\n     \
    \   val encodedMessageArrayLength = encodedMessageArrayLength - 1\n        val\
    \ encodedMessageArrayLength = encodedMessageArrayLength - 1\n        val encodedMessageArrayLength\
    \ = encodedMessageArrayLength - 1\n        val encodedMessageArrayLength = encodedMessageArrayLength\
    \ - 1\n        val encodedMessageArrayLength = encodedMessageArray\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4iihm7fh.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageArrayLength\e\
    [0m = encodedMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mencodedMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mencodedMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4iihm7fh.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageArrayLength\e\
    [0m = encodedMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mencodedMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mencodedMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4iihm7fh.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageArrayLength\e\
    [0m = encodedMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mencodedMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mencodedMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp4iihm7fh.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageArrayLength\e\
    [0m = encodedMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mencodedMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mencodedMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloade"
  stdout: ''
  timestamp: 1659978987
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageWithVowels = message.toLowerCase\n        val vowelIndexes\
    \ = messageWithVowels.zipWithIndex.filter(_._2 > 0).map(_._2)\n        val vowelIndexesWithVowels\
    \ = vowelIndexes.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversed\
    \ = vowelIndexesWithVowels.reverse\n        val vowelIndexesWithVowelsReversedWithVowel\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel2\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel3\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel4\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel5\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel6\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel7\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel8\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel9\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel10\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel11\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel12\
    \ = vowelIndexesWithVowelsReversed.map(i => vowels(i))\n        val vowelIndexesWithVowelsReversedWithVowel13\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsib32zvq.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpsib32zvq.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978984
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageArray\
    \ = message.split(\"\")\n        val newMessageArray = messageArray.map(letter\
    \ => \n            letter match {\n                case 'a' => alphabet(0)\n \
    \               case 'b' => alphabet(1)\n                case 'c' => alphabet(2)\n\
    \                case 'd' => alphabet(3)\n                case 'e' => alphabet(4)\n\
    \                case 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n\
    \                case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n\
    \                case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n\
    \                case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case letter => letter\n\
    \            }\n        )\n        val newMessage = messageArray.mkString(\"\"\
    )\n        val newMessageArray2 = newMessageArray.map(letter => \n           \
    \ letter match {\n                case 'a' => vowels(0)\n                case\
    \ 'b' => vowels(1)\n                case 'c' => vowels(2)\n                case\
    \ 'd' => vowels(3)\n                case 'e' => vowels(4)\n                case\
    \ 'f' => vowels(5)\n                case 'g' => vowels(6)\n                case\
    \ 'h' => vowels(7)\n                case 'i' => vowels(8)\n                case\
    \ 'j' => vowels(9)\n                case 'k' => vowels(10)\n                case\
    \ 'l' => vowels(11)\n                case 'm' => vowels(12)\n                case\
    \ 'n' => vowels(13)\n                case 'o' => vowels(14)\n                case\
    \ 'p' => vowels(15)\n                case 'q' => vowels(16)\n                case\
    \ 'r' => vowels(17)\n                case 's' => vowels(18)\n                case\
    \ 't' => vowels(19)\n                case 'u' => vowels(20)\n                case\
    \ 'v' => vowels(21)\n                case 'w' => vowels(22)\n                case\
    \ 'x' => vowels(23)\n                case 'y' => vowels(24)\n                case\
    \ 'z' => vowels(25)\n                case letter => letter\n            }\n  \
    \      )\n        val newMessage\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppjxltjea.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmppjxltjea.scala:16:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m16 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'a'\e[0m => alphabet(\e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmppjxltjea.scala:17:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m17 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'b'\e[0m => alphabet(\e[31m1\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmppjxltjea.scala:18:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'c'\e[0m => alphabet(\e[31m2\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmppjxltjea.scala:19:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'd'\e[0m => alphabet(\e[31m3\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmppjxltjea.scala:20:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m20 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'e'\e[0m => alphabet(\e[31m4\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmppjxltjea.scala:21:21\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m21 |\e[0m       \
    \         \e[33mcase\e[0m \e[31m'f'\e[0m => alphabet(\e[31m5\e[0m)\n\e[31m\e[31m\
    \   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ Char and String cannot be compared"
  stdout: ''
  timestamp: 1659978988
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index >= 0) {\n                val vowelIndex = index + 1\n \
    \               val vowel = vowels(vowelIndex)\n                vowel\n      \
    \      } else {\n                letter\n            }\n        }).mkString(\"\
    \")\n        encodedMessage\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpv_itvo5q.scala:26)\n\tat Problem.main(tmpv_itvo5q.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978986
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageWithVowels = message.toLowerCase.map(letter => vowels.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case i => vowels(i + 2)\n\
    \        })\n        val messageWithVowelsAndVowelsTwoAheadOfVowel = messageWithVowels.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case i => vowels(i + 2)\n        })\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowel.map(letter => vowels.indexOf(letter)\
    \ match {\n            case -1 => letter\n            case i => vowels(i + 2)\n\
    \        })\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case i => vowels(i + 2)\n        })\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case i => vowels(i + 2)\n        })\n        val messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\
    \ = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOf\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\"\
    )));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfgyjyopf.scala:24:104 --------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.map(\e\
    [36mletter\e[0m => vowels.indexOf(letter) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                              ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpfgyjyopf.scala:28:128 --------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel.map(\e\
    [36mletter\e[0m => vowels.indexOf(letter) \e[33mmatch\e[0m {\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                                      ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpfgyjyopf.scala:32:152 -----------------------\e[0m\e[0m\n\e[31m32 |\e\
    [0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOfVowel\e\
    [0m = messageWithVowelsAndVowelsTwoAheadOfVowelAndVowelsTwoAheadOf\n\e[31m\e[31m\
    \   |\e[0m                             "
  stdout: ''
  timestamp: 1659978986
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val encodedMessage = messageArray.map(letter\
    \ => letters.indexOf(letter) + letters.indexOf(vowels.charAt(letters.indexOf(letter)\
    \ + 1)) + vowels.indexOf(letter))\n        encodedMessage.toString.toUpperCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp350z4a6f.scala:18)\n\tat Problem.main(tmp350z4a6f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978987
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message.map(letter\
    \ => alphabet(alphabet.indexOf(letter) + 1))\n        val newVowels = vowels.map(letter\
    \ => alphabet(alphabet.indexOf(letter) + 2))\n        newMessage.zip(newVowels).map(x\
    \ => x.swap).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy3opu_xc.scala:18)\n\tat Problem.main(tmpy3opu_xc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978989
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val vowelIndex = index + 1\n\
    \                val vowel = vowels(vowelIndex)\n                vowel\n     \
    \       } else {\n                letter\n            }\n        }).mkString(\"\
    \")\n        encodedMessage\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg623al7c.scala:26)\n\tat Problem.main(tmpg623al7c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageWithVowels = message.toLowerCase.foldLeft(\"\")( (acc, letter)\
    \ => acc + (if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter))\
    \ + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter)) + 1)))\n\
    \        val messageWithVowelsAndVowelsBefore = messageWithVowels.foldLeft(\"\"\
    )( (acc, letter) => acc + (if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter))\
    \ + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter)) + 1) +\
    \ 1)))\n        val messageWithVowelsAndVowelsBeforeAndVowelsBefore = messageWithVowelsAndVowelsBefore.foldLeft(\"\
    \")( (acc, letter) => acc + (if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter))\
    \ + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter)) + 1) +\
    \ 1) + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter))\
    \ + 1) + 1) + 1)))\n        val messageWithVowelsAndVowelsBeforeAndVowelsBeforeAndVowelsBefore\
    \ = messageWithVowelsAndVowelsBeforeAndVowelsBefore.foldLeft(\"\")( (acc, letter)\
    \ => acc + (if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter))\
    \ + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter)) + 1) +\
    \ 1) + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter))\
    \ + 1) + 1) + 1) + 1)))\n        val messageWithVowelsAndVowelsBeforeAndVowelsBeforeAndVowelsBeforeAndVowelsBefore\
    \ = messageWithVowelsAndVowelsBeforeAndVowelsBeforeAndVowelsBefore.foldLeft(\"\
    \")( (acc, letter) => acc + (if (vowels.contains(letter)) letter else vowels.charAt(vowels.indexOf(letter))\
    \ + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter)) + 1) +\
    \ 1) + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter))\
    \ + 1) + 1) + 1) + 1) + 1)))\n        val messageWithVowelsAndVowelsBeforeAndVowelsBeforeAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp43ogogpz.scala:13:8 ----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndVowelsBefore\e\
    [0m = messageWithVowels.foldLeft(\e[31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mletter\e\
    [0m) => acc + (\e[33mif\e[0m (vowels.contains(letter)) letter \e[33melse\e[0m\
    \ vowels.charAt(vowels.indexOf(letter)) + vowels.charAt(vowels.indexOf(vowels.charAt(vowels.indexOf(letter))\
    \ + \e[31m1\e[0m) + \e[31m1\e[0m)))\n\e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e\
    [31m   |\e[0m        ')' expected, but 'val' found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp43ogogpz.scala:27:1 ---------------------\e[0m\e[0m\n\
    \e[31m27 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978988
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageWithVowels = message.toLowerCase.foldLeft(\"\")( (acc, c)\
    \ => acc + (if (vowels.contains(c)) c.toUpperCase() else c))\n        val messageWithVowelsAndTwoLettersBeforeVowel\
    \ = messageWithVowels.foldLeft(\"\")( (acc, c) => acc + (if (vowels.contains(c))\
    \ c.toUpperCase() else c))\n        val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowel\
    \ = messageWithVowelsAndTwoLettersBeforeVowel.foldLeft(\"\")( (acc, c) => acc\
    \ + (if (vowels.contains(c)) c.toUpperCase() else c))\n        val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel\
    \ = messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowel.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c))\n   \
    \     val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel\
    \ = messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c))\n   \
    \     val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel\
    \ = messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel.foldLeft(\"\
    \")( (acc, c) => acc + (if (vowels.contains(c)) c.toUpperCase() else c))\n   \
    \     val messageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowelAndTwoLettersAfterVowel\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc9t8im5e.scala:19:4 ----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc9t8im5e.scala:12:111\
    \ -----------------------\e[0m\e[0m\n\e[31m12 |\e[0m        \e[33mval\e[0m \e\
    [36mmessageWithVowels\e[0m = message.toLowerCase.foldLeft(\e[31m\"\"\e[0m)( (\e\
    [36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase()\
    \ \e[33melse\e[0m c))\n\e[31m\e[31m   |\e[0m                                 \
    \                                                                            ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc9t8im5e.scala:13:133\
    \ -----------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e\
    [36mmessageWithVowelsAndTwoLettersBeforeVowel\e[0m = messageWithVowels.foldLeft(\e\
    [31m\"\"\e[0m)( (\e[36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c))\
    \ c.toUpperCase() \e[33melse\e[0m c))\n\e[31m\e[31m   |\e[0m                 \
    \                                                                            \
    \                                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                            value toUpperCase is not a member of Char\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpc9t8im5e.scala:14:180 -----------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmessageWithVowelsAndTwoLettersBeforeVowelAndTwoLettersAfterVowel\e\
    [0m = messageWithVowelsAndTwoLettersBeforeVowel.foldLeft(\e[31m\"\"\e[0m)( (\e\
    [36macc\e[0m, \e[36mc\e[0m) => acc + (\e[33mif\e[0m (vowels.contains(c)) c.toUpperCase()\
    \ \e[33melse\e[0m c))\n\e[31m\e[31m   |\e[0m                                 \
    \                                                                            \
    \                                                                     ^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                               value toUpperCase is not a\
    \ member of Char\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpc9t8im5e.s"
  stdout: ''
  timestamp: 1659978990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => vowels.indexOf(letter) + 1).map(letter => vowels.charAt(letter)).mkString(\"\
    \")\n        newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpyuyktdqh.scala:17)\n\tat Problem.main(tmpyuyktdqh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val result = new\
    \ StringBuilder\n        val vowelsCount = message.count(vowels)\n        val\
    \ lettersCount = message.count(letters)\n        val vowelsIndex = message.indexOf(vowels)\n\
    \        val lettersIndex = message.indexOf(letters)\n        val vowelsIndex2\
    \ = message.indexOf(vowels, vowelsIndex + 1)\n        val lettersIndex2 = message.indexOf(letters,\
    \ lettersIndex + 1)\n        val vowelsIndex3 = message.indexOf(vowels, vowelsIndex2\
    \ + 1)\n        val lettersIndex3 = message.indexOf(letters, lettersIndex2 + 1)\n\
    \        val vowelsIndex4 = message.indexOf(vowels, vowelsIndex3 + 1)\n      \
    \  val lettersIndex4 = message.indexOf(letters, lettersIndex3 + 1)\n        val\
    \ vowelsIndex5 = message.indexOf(vowels, vowelsIndex4 + 1)\n        val lettersIndex5\
    \ = message.indexOf(letters, lettersIndex4 + 1)\n        val vowelsIndex6 = message.indexOf(vowels,\
    \ vowelsIndex5 + 1)\n        val lettersIndex6 = message.indexOf(letters, lettersIndex5\
    \ + 1)\n        val vowelsIndex7 = message.indexOf(vowels, vowelsIndex6 + 1)\n\
    \        val lettersIndex7 = message.indexOf(letters, lettersIndex6 + 1)\n   \
    \     val vowelsIndex8 = message.indexOf(vowels, vowelsIndex7 + 1)\n        val\
    \ lettersIndex8 = message.indexOf(letters, lettersIndex7 + 1)\n        val vowelsIndex9\
    \ = message.indexOf(vowels, vowelsIndex8 + 1)\n        val lettersIndex9 = message.indexOf(letters,\
    \ lettersIndex8 + 1)\n        val vowelsIndex10 = message.indexOf(vowels, vowelsIndex9\
    \ + 1)\n        val lettersIndex10 = message.indexOf(letters, lettersIndex9 +\
    \ 1)\n        val vowelsIndex11 = message.indexOf(vowels, vowelsIndex10 + 1)\n\
    \        val lettersIndex11 = message.indexOf(letters, lettersIndex10 + 1)\n \
    \       val vowelsIndex12 = message.indexOf(vowels, vowelsIndex11 + 1)\n     \
    \   val lettersIndex12 = message.indexOf(letters, lettersIndex11 + 1)\n      \
    \  val vowelsIndex13 = message.indexOf(vowels, vowelsIndex12 + 1)\n        val\
    \ lettersIndex13 = message.indexOf(letters, lettersIndex12 + 1)\n        val vowelsIndex14\
    \ = message.indexOf(vowels, vowelsIndex13 + 1)\n        val lettersIndex14 = message.indexOf(letters,\
    \ lettersIndex13 + 1)\n        val vowelsIndex15 = message.indexOf(vowels, vowelsIndex14\
    \ + 1)\n        val lettersIndex15 = message.indexOf(letters, lettersIndex14 +\
    \ 1)\n        val vowelsIndex16 = message.indexOf(vowels, vowelsIndex15\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprux3zgdq.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmprux3zgdq.scala:14:40 --------------------\e[0m\e[0m\n\e[31m14 |\e[0m\
    \        \e[33mval\e[0m \e[36mvowelsCount\e[0m = message.count(vowels)\n\e[31m\e\
    [31m   |\e[0m                                        ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                        Found:    (vowels : String)\n\e[31m\
    \   |\e[0m                                        Required: Char => Boolean\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprux3zgdq.scala:15:41\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mlettersCount\e\
    [0m = message.count(letters)\n\e[31m\e[31m   |\e[0m                          \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \         Found:    (letters : String)\n\e[31m   |\e[0m                      \
    \                   Required: Char => Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmprux3zgdq.scala:47:5 ---------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659978990
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessageArray =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val vowelIndex = index + 1\n\
    \                if (vowelIndex < vowels.length)\n                    vowels(vowelIndex)\n\
    \                else\n                    vowels(0)\n            } else\n   \
    \             letter\n        })\n        val newMessage = newMessageArray.toList\n\
    \        newMessage.toString\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw9503zcx.scala:28)\n\tat Problem.main(tmpw9503zcx.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => \n            letter match {\n                case vowels(0) => vowels(1)\n\
    \                case vowels(1) => vowels(0)\n                case _ => letter\n\
    \            }\n        ).mkString(\"\")\n        val newMessageArray = newMessage.split(\"\
    \")\n        val newMessageArrayLength = newMessageArray.length\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArrayLength = newMessageArrayLength - 1\n        val newMessageArrayLength\
    \ = newMessageArrayLength - 1\n        val newMessageArrayLength = newMessageArrayLength\
    \ - 1\n        val newMessageArrayLength = newMessageArrayLength - 1\n       \
    \ val newMessageArray\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmid10pbk.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmid10pbk.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mnewMessageArrayLength\e[0m = newMessageArrayLength - \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnewMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmid10pbk.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArrayLength\e\
    [0m = newMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnewMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmid10pbk.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArrayLength\e\
    [0m = newMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mnewMessageArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmid10pbk.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mnewMessageArrayLength\e\
    [0m = newMessageArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewMessageArrayLength is already defined "
  stdout: ''
  timestamp: 1659978991
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageArray = message.split(\"\
    \")\n        val newMessageArray = messageArray.map(letter => \n            letter\
    \ match {\n                case 'a' -> alphabet(0)\n                case 'b' ->\
    \ alphabet(1)\n                case 'c' -> alphabet(2)\n                case 'd'\
    \ -> alphabet(3)\n                case 'e' -> alphabet(4)\n                case\
    \ 'f' -> alphabet(5)\n                case 'g' -> alphabet(6)\n              \
    \  case 'h' -> alphabet(7)\n                case 'i' -> alphabet(8)\n        \
    \        case 'j' -> alphabet(9)\n                case 'k' -> alphabet(10)\n \
    \               case 'l' -> alphabet(11)\n                case 'm' -> alphabet(12)\n\
    \                case 'n' -> alphabet(13)\n                case 'o' -> alphabet(14)\n\
    \                case 'p' -> alphabet(15)\n                case 'q' -> alphabet(16)\n\
    \                case 'r' -> alphabet(17)\n                case 's' -> alphabet(18)\n\
    \                case 't' -> alphabet(19)\n                case 'u' -> alphabet(20)\n\
    \                case 'v' -> alphabet(21)\n                case 'w' -> alphabet(22)\n\
    \                case 'x' -> alphabet(23)\n                case 'y' -> alphabet(24)\n\
    \                case 'z' -> alphabet(25)\n                case letter => letter\n\
    \            }\n        )\n        val newMessage = messageArray.mkString(\"\"\
    )\n        val newMessageArray2 = newMessageArray.map(letter => \n           \
    \ letter match {\n                case 'a' -> vowels(0)\n                case\
    \ 'b' -> vowels(1)\n                case 'c' -> vowels(2)\n                case\
    \ 'd' -> vowels(3)\n                case 'e' -> vowels(4)\n                case\
    \ 'f' -> vowels(5)\n                case 'g' -> vowels(6)\n                case\
    \ 'h' -> vowels(7)\n                case 'i' -> vowels(8)\n                case\
    \ 'j' -> vowels(9)\n                case 'k' -> vowels(10)\n                case\
    \ 'l' -> vowels(11)\n                case 'm' -> vowels(12)\n                case\
    \ 'n' -> vowels(13)\n                case 'o' -> vowels(14)\n                case\
    \ 'p' -> vowels(15)\n                case 'q' -> vowels(16)\n                case\
    \ 'r' -> vowels(17)\n                case 's' -> vowels(18)\n                case\
    \ 't' -> vowels(19)\n                case 'u' -> vowels(20)\n                case\
    \ 'v' \n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4_6cvec6.scala:17:16 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m                \e[33mcase\e[0m \e[31m'b'\e[0m -> alphabet(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m \
    \               '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmp4_6cvec6.scala:19:16 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m                \e[33mcase\e[0m \e[31m'd'\e[0m -> alphabet(\e[31m3\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m        \
    \        '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp4_6cvec6.scala:21:16 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m                \e[33mcase\e[0m \e[31m'f'\e[0m -> alphabet(\e[31m5\e[0m)\n\
    \e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m              \
    \  '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4_6cvec6.scala:23:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                \e[33mcase\e\
    [0m \e[31m'h'\e[0m -> alphabet(\e[31m7\e[0m)\n\e[31m\e[31m   |\e[0m          \
    \      ^^^^\e[0m\n\e[31m   |\e[0m                '=>' expected, but 'case' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4_6cvec6.scala:25:16 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mcase\e[0m \e[31m'j'\e[0m -> alphabet(\e\
    [31m9\e[0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m \
    \               '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax\
    \ Error: /tmp/tmp4_6cvec6.scala:27:16 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m                \e[33mcase\e[0m \e[31m'l'\e[0m -> alphabet(\e[31m11\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m        \
    \        '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp4_6cvec6.scala:29:16 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                \e[33mcase\e[0m \e[31m'n'\e[0m -> alphabet(\e[31m13\e\
    [0m)\n\e[31m\e[31m   |\e[0m                ^^^^\e[0m\n\e[31m   |\e[0m        \
    \        '=>' expected, but 'case' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp4_6cvec6.scala:31:16 --"
  stdout: ''
  timestamp: 1659978991
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => {\n            val index = vowels.indexOf(letter)\n\
    \            if (index != -1) {\n                val vowelIndex = index + 1\n\
    \                val vowel = vowels(vowelIndex)\n                vowel\n     \
    \       } else {\n                letter\n            }\n        }).mkString(\"\
    \")\n        encodedMessage\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg623al7c.scala:26)\n\tat Problem.main(tmpg623al7c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978990
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => vowels.indexOf(letter) match {\n            case -1 => letter\n         \
    \   case 0 => letter\n            case 1 => vowels(letter - 2)\n            case\
    \ 2 => vowels(letter - 2)\n            case 3 => vowels(letter - 2)\n        \
    \    case 4 => vowels(letter - 2)\n            case 5 => vowels(letter - 2)\n\
    \            case 6 => vowels(letter - 2)\n            case 7 => vowels(letter\
    \ - 2)\n            case 8 => vowels(letter - 2)\n            case 9 => vowels(letter\
    \ - 2)\n            case _ => vowels(letter - 2)\n        }).mkString(\"\")\n\
    \        newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmplm1suhjh.scala:16:36 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mcase\e[0m \e[31m1\e[0m => vowels(letter\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmplm1suhjh.scala:17:36 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m            \e[33mcase\e[0m \e[31m2\e[0m => vowels(letter\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmplm1suhjh.scala:18:36 ------------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m            \e[33mcase\e[0m \e[31m3\e[0m => vowels(letter\
    \ - \e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of String, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e\
    [0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import\
    \ math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmplm1suhjh.scala"
  stdout: ''
  timestamp: 1659978996
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(letter => letters.indexOf(letter) + letters.indexOf(vowels.charAt(0))\
    \ + 1)\n        newMessage.map(letter => letters.charAt(letter))\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\"\
    )));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwc3o_k1_.scala:14:22\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        newMessage.map(\e[36mletter\e\
    [0m => letters.charAt(letter))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    IndexedSeq[Char]\n\e[31m   |\e[0m      \
    \  Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978992
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageArray\
    \ = message.split(\"\")\n        val encodedMessage = messageArray.map(letter\
    \ => \n            letter match {\n                case letter if letter != vowels(0)\
    \ => \n                    letter match {\n                        case letter\
    \ if letter != vowels(1) => \n                            letter match {\n   \
    \                             case letter if letter != vowels(2) => \n       \
    \                             letter match {\n                               \
    \         case letter if letter != vowels(3) => \n                           \
    \                 letter match {\n                                           \
    \     case letter if letter != vowels(4) => \n                               \
    \                     letter match {\n                                       \
    \                 case letter if letter != vowels(5) => \n                   \
    \                                         letter match {\n                   \
    \                                             case letter if letter != vowels(6)\
    \ => \n                                                                    letter\
    \ match {\n                                                                  \
    \      case letter if letter != vowels(7) => \n                              \
    \                                              letter match {\n              \
    \                                                                  case letter\
    \ if letter != vowels(8) => \n                                               \
    \                                     letter match {\n                       \
    \                                                                 case letter\
    \ if letter != vowels(9) => \n                                               \
    \                                             letter match {\n               \
    \                                                                            \
    \     case letter if letter != vowels(10) => \n                              \
    \                                                                      letter\
    \ match {\n                                                                  \
    \                                      case letter if letter != vowels(11) =>\
    \ \n                                                                         \
    \                                   letter match {\n                         \
    \                                                                            \
    \           case letter if letter != vowels(12) => \n                        \
    \                                                                            \
    \                letter match {\n                                            \
    \                                                                            case\
    \ letter if letter != vowels(13) => \n                                       \
    \                                                                            \
    \         letter match {\n                                                   \
    \                                                                            \
    \ case letter if letter != vowels(14) => \n                                  \
    \                                                                            \
    \                      letter match {\n                                      \
    \                                                                            \
    \                      case letter if letter != vowels(15) => \n             \
    \                                                                            \
    \                                                   letter match {\n         \
    \                                                                            \
    \                                                           case letter if letter\
    \ != vowels(16) => \n                                                        \
    \                                                                            \
    \                letter match {\n                                            \
    \                                                                            \
    \                                case letter if letter != vowels(17) => \n   \
    \                                                                            \
    \                                                                            \
    \ letter match {\n                                                           \
    \                                                                            \
    \                         case letter if letter != vowels(18) => \n          \
    \                                                                            \
    \                                                                            \
    \  letter match {\n                                                          \
    \                                                                            \
    \                                  case letter if letter != vowels(19) => \n \
    \                                                                            \
    \                                                                            \
    \                   letter match {\n                                         \
    \                                                                            \
    \                                                           case letter if letter\
    \ != vowels(20) => \n                                                        \
    \                                                                            \
    \                                                letter match {\n            \
    \                                                                            \
    \                                                                            \
    \                    case letter if letter != vowels(21) => \n               \
    \                                                                            \
    \                                                                            \
    \                     letter match {\n                                       \
    \                                                                            \
    \                                                                            \
    \ case letter if letter != vowels(22) => \n                                  \
    \                                                                            \
    \                                                                            \
    \          letter \n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmrr0qiew.scala:72:0 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- Error: /tmp/tmpmrr0qiew.scala:16:31 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mcase\e[0m letter \e[33mif\e[0m\
    \ letter != vowels(\e[31m0\e[0m) => \n\e[31m\e[31m   |\e[0m                  \
    \             ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Values of types\
    \ String and Char cannot be compared with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpmrr0qiew.scala:18:39\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m18 |\e[0m       \
    \                 \e[33mcase\e[0m letter \e[33mif\e[0m letter != vowels(\e[31m1\e\
    [0m) => \n\e[31m\e[31m   |\e[0m                                       ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpmrr0qiew.scala:20:47 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                                \e[33mcase\e[0m letter\
    \ \e[33mif\e[0m letter != vowels(\e[31m2\e[0m) => \n\e[31m\e[31m   |\e[0m    \
    \                                           ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m        Values of types String and Char cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- Error: /tmp/tmpmrr0qiew.scala:22:55 -----------------------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                                        \e[33mcase\e\
    [0m letter \e[33mif\e[0m letter != vowels(\e[31m3\e[0m) => \n\e[31m\e[31m   |\e\
    [0m                                                       ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of types String and Char cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- Error: /tmp/tmpmrr0qiew.scala:24:63 -----------------------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                                                \e[33mcase\e\
    [0m letter \e[33mif\e[0m letter != vowels(\e[31m4\e[0m) => \n\e[31m\e[31m   |\e\
    [0m                                                               ^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Values of "
  stdout: ''
  timestamp: 1659978996
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(c => if (vowels.contains(c)) c else alphabet.indexOf(c) + 2)\n\
    \        newMessage.toString\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppvx52lrl.scala:17)\n\tat Problem.main(tmppvx52lrl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = List(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\",\
    \ \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\"\
    , \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\")\n        val result\
    \ = new StringBuilder()\n        val vowelsCount = message.split(\"\").map(x =>\
    \ vowels.indexOf(x)).sum\n        val vowelsIndex = (message.split(\"\").map(x\
    \ => vowels.indexOf(x)).sum - vowelsCount) / 2\n        val vowelsIndex2 = vowelsIndex\
    \ + 1\n        val vowelsIndex3 = vowelsIndex + 2\n        val vowelsIndex4 =\
    \ vowelsIndex + 3\n        val vowelsIndex5 = vowelsIndex + 4\n        val vowelsIndex6\
    \ = vowelsIndex + 5\n        val vowelsIndex7 = vowelsIndex + 6\n        val vowelsIndex8\
    \ = vowelsIndex + 7\n        val vowelsIndex9 = vowelsIndex + 8\n        val vowelsIndex10\
    \ = vowelsIndex + 9\n        val vowelsIndex11 = vowelsIndex + 10\n        val\
    \ vowelsIndex12 = vowelsIndex + 11\n        val vowelsIndex13 = vowelsIndex +\
    \ 12\n        val vowelsIndex14 = vowelsIndex + 13\n        val vowelsIndex15\
    \ = vowelsIndex + 14\n        val vowelsIndex16 = vowelsIndex + 15\n        val\
    \ vowelsIndex17 = vowelsIndex + 16\n        val vowelsIndex18 = vowelsIndex +\
    \ 17\n        val vowelsIndex19 = vowelsIndex + 18\n        val vowelsIndex20\
    \ = vowelsIndex + 19\n        val vowelsIndex21 = vowelsIndex + 20\n        val\
    \ vowelsIndex22 = vowelsIndex + 21\n        val vowelsIndex23 = vowelsIndex +\
    \ 22\n        val vowelsIndex24 = vowelsIndex + 23\n        val vowelsIndex25\
    \ = vowelsIndex + 24\n        val vowelsIndex26 = vowelsIndex + 25\n        val\
    \ vowelsIndex27 = vowelsIndex + 26\n        val vowelsIndex28 = vowelsIndex +\
    \ 27\n        val vowelsIndex29 = vowelsIndex + 28\n        val vowelsIndex30\
    \ = vowelsIndex + 29\n        val vowelsIndex31 = vowelsIndex + 30\n        val\
    \ vowelsIndex32 = vowelsIndex + 31\n        val vowelsIndex33 = vowelsIndex +\
    \ 32\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\"\
    )).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmperx8vzat.scala:48:5\
    \ ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659978993
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = Set(\"a\", \"\
    e\", \"i\", \"o\", \"u\")\n        val letters = Set(\"a\", \"b\", \"c\", \"d\"\
    , \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\"\
    , \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"\
    )\n        val newMessage = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter))\n\
    \        val newMessage2 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage3 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage4 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage5 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage6 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage7 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage8 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage9 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage10 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage11 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage12 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage13 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage14 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage15 = message.map(letter => letters.find(letter => vowels.contains(letter)).getOrElse(letter)).mkString(\"\
    \")\n        val newMessage16 = message.map(letter => letters.\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\"\
    )));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpse16pt0t.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpse16pt0t.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659978994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = Set(\"a\", \"\
    e\", \"i\", \"o\", \"u\")\n        val messageArray = message.split(\"\")\n  \
    \      val newMessage = messageArray.map { x =>\n            val index = vowels.indexOf(x)\n\
    \            if (index != -1) vowels(index) else x\n        }\n        newMessage.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpin80i9mc.scala:14:31 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            \e[33mval\e[0m \e[36mindex\e[0m = vowels.indexOf(x)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m   value indexOf is not a member of scala.collection.mutable.Set[String]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1659978994
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => \n            if (vowels.contains(letter)) letter\
    \ else \n            vowels.indexOf(letter) + 2)\n        val newMessage = messageArray.join(\"\
    \")\n        newMessageArray.join(\"\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm7dn0oix.scala:16:38 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mnewMessage\e[0m = messageArray.join(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue join is not a member of Array[String] - did you mean\
    \ messageArray.wait?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpm7dn0oix.scala:17:24\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        newMessageArray.join(\e\
    [31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue join is not a member of Array[Matchable] - did you mean newMessageArray.wait?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1659978995
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val messageList = message.split(\"\
    \")\n        val encodedMessage = messageList.foldLeft(\"\"){ (result, currentChar)\
    \ =>\n            val index = alphabet.indexOf(currentChar)\n            if (index\
    \ != -1) {\n                val nextIndex = index + 2\n                if (nextIndex\
    \ < alphabet.length) {\n                    val nextChar = alphabet(nextIndex)\n\
    \                    result + vowels(index) + nextChar\n                } else\
    \ {\n                    result + vowels(index)\n                }\n         \
    \   } else {\n                result + currentChar\n            }\n        }\n\
    \        encodedMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpw59j0mwl.scala:31)\n\tat Problem.main(tmpw59j0mwl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => \n            if (vowels.contains(letter)) letter\
    \ else \n                vowels.indexOf(letter) + 2)\n        val newMessage =\
    \ newMessageArray.toArray\n        val newMessageString = newMessage.toString\n\
    \        val newMessageStringArray = newMessageString.split(\"\")\n        val\
    \ newMessageStringArrayLength = newMessageStringArray.length\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength\
    \ - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength -\
    \ 1\n        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessageStringArrayLength = newMessageStringArrayLength - 1\n  \
    \      val newMessageStringArrayLength = newMessageStringArrayLength - 1\n   \
    \     val newMessageStringArrayLength = newMessageStringArrayLength - 1\n    \
    \    val newMessageStringArrayLength = newMessageStringArrayLength - 1\n     \
    \   val newMessageStringArrayLength = newMessageStringArrayLength - 1\n      \
    \  val newMessageStringArrayLength = newMessageStringArrayLength - 1\n       \
    \ val newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val\
    \ newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength\
    \ - 1\n        val newMessageStringArrayLength = newMessageStringArrayLength -\
    \ 1\n        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n\
    \        val newMessageStringArrayLength = newMessageStringArrayLength - 1\n \
    \       val newMessageStringArrayLength = newMessageStringArrayLength - 1\n  \
    \      val newMessageStringArrayLength = newMessageStringArrayLength - 1\n   \
    \     val newMessageStringArrayLength = newMessageStringArrayLength - 1\n    \
    \    val newMessageStringArrayLength = newMessageStringArrayLength - 1\n     \
    \   val newMessageStringArrayLength = newMessageStringArrayLength - 1\n      \
    \  val newMessageStringArrayLength = newMessageStringArrayLength - 1\n       \
    \ val newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val\
    \ newMessageStringArrayLength = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength\
    \ = newMessageStringArrayLength - 1\n        val newMessageStringArrayLength =\
    \ newMessageStringArrayLength - 1\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdtfrwo0s.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdtfrwo0s.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdtfrwo0s.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdtfrwo0s.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mnewMessageStringArrayLength\e\
    [0m = newMessageStringArrayLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mnewMessageStringArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mnewMessageStringArrayLength\e[0"
  stdout: ''
  timestamp: 1659978997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val messageArray\
    \ = message.split(\"\")\n        val encodedMessage = messageArray.map { letter\
    \ =>\n            val index = letters.indexOf(letter)\n            if (index !=\
    \ -1) {\n                val nextIndex = index + 2\n                if (nextIndex\
    \ < letters.length) letters(nextIndex) else letter\n            } else letter\n\
    \        }.mkString(\"\")\n        encodedMessage\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7_gb78us.scala:24)\n\tat Problem.main(tmp7_gb78us.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val messageArray\
    \ = message.split(\"\")\n        val encodedMessage = messageArray.map(letter\
    \ => alphabet(alphabet.indexOf(letter) + 2))\n        val encodedMessageString\
    \ = encodedMessage.toList\n        val encodedMessageString = encodedMessageString.mkString(\"\
    \")\n        val encodedMessageString = encodedMessageString.replaceAll(\"[aeiou]\"\
    , \"z\")\n        encodedMessageString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7tdtb7xr.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageString\e[0m\
    \ = encodedMessageString.mkString(\e[31m\"\"\e[0m)\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mencodedMessageString is already defined as \e[33mvalue\e[0m \e[35mencodedMessageString\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7tdtb7xr.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mencodedMessageString\e[0m = encodedMessageString.replaceAll(\e\
    [31m\"[aeiou]\"\e[0m, \e[31m\"z\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mencodedMessageString is already defined as \e[33mvalue\e[0m\
    \ \e[35mencodedMessageString\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp7tdtb7xr.scala:18:8 ---------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        encodedMessageString\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (encodedMessageString\
    \ : List[Char])\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659978997
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val vowelMap :\
    \ Map[Char, Int] = \n            Map(a -> 1, e -> 1, i -> 1, o -> 1, u -> 1, y\
    \ -> 1, \n                y -> 1, o -> 1, i -> 1, e -> 1, a -> 1, i -> 1, \n \
    \               o -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n           \
    \     o -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n                o -> 1,\
    \ u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n                o -> 1, u -> 1, y\
    \ -> 1, o -> 1, a -> 1, i -> 1, \n                o -> 1, u -> 1, y -> 1, o ->\
    \ 1, a -> 1, i -> 1, \n                o -> 1, u -> 1, y -> 1, o -> 1, a -> 1,\
    \ i -> 1, \n                o -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n\
    \                o -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n          \
    \      o -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n                o ->\
    \ 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n                o -> 1, u -> 1,\
    \ y -> 1, o -> 1, a -> 1, i -> 1, \n                o -> 1, u -> 1, y -> 1, o\
    \ -> 1, a -> 1, i -> 1, \n                o -> 1, u -> 1, y -> 1, o -> 1, a ->\
    \ 1, i -> 1, \n                o -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1,\
    \ \n                o -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n       \
    \         o -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n                o\
    \ -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i -> 1, \n                o -> 1, u ->\
    \ 1, y -> 1, o -> 1, a -> 1, i -> 1, \n                o -> 1, u -> 1, y -> 1,\
    \ o -> 1, a -> 1, i -> 1, \n                o -> 1, u -> 1, y -> 1, o -> 1, a\
    \ -> 1, i -> 1, \n                o -> 1, u -> 1, y -> 1, o -> 1, a -> 1, i ->\
    \ 1, \n                o -> 1, u -> 1, y -> 1, o -> 1, a -> \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpefjqf1b3.scala:37:52 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                o -> \e[31m1\e[0m, u -> \e[31m1\e[0m,\
    \ y -> \e[31m1\e[0m, o -> \e[31m1\e[0m, a -> \n\e[31m\e[31m   |\e[0m         \
    \                                           ^\e[0m\n\e[31m   |\e[0m          \
    \                             expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpefjqf1b3.scala:14:16\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m            Map(a -> \e[31m1\e\
    [0m, e -> \e[31m1\e[0m, i -> \e[31m1\e[0m, o -> \e[31m1\e[0m, u -> \e[31m1\e[0m,\
    \ y -> \e[31m1\e[0m, \n\e[31m\e[31m   |\e[0m                ^\e[0m\n\e[31m   |\e\
    [0m                Not found: a\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpefjqf1b3.scala:14:24 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m            Map(a -> \e[31m1\e[0m, e -> \e[31m1\e[0m, i -> \e[31m1\e[0m, o\
    \ -> \e[31m1\e[0m, u -> \e[31m1\e[0m, y -> \e[31m1\e[0m, \n\e[31m\e[31m   |\e\
    [0m                        ^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: e\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpefjqf1b3.scala:14:32\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m            Map(a -> \e[31m1\e\
    [0m, e -> \e[31m1\e[0m, i -> \e[31m1\e[0m, o -> \e[31m1\e[0m, u -> \e[31m1\e[0m,\
    \ y -> \e[31m1\e[0m, \n\e[31m\e[31m   |\e[0m                                ^\e\
    [0m\n\e[31m   |\e[0m                                Not found: i\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpefjqf1b3.scala:14:40 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m            Map(a -> \e[31m1\e[0m, e -> \e[31m1\e[0m,\
    \ i -> \e[31m1\e[0m, o -> \e[31m1\e[0m, u -> \e[31m1\e[0m, y -> \e[31m1\e[0m,\
    \ \n\e[31m\e[31m   |\e[0m                                        ^\e[0m\n\e[31m\
    \   |\e[0m                            "
  stdout: ''
  timestamp: 1659978999
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        val newMessage\
    \ = message.map(letter => \n            if (vowels.contains(letter)) letter else\
    \ \n                alphabet(alphabet.indexOf(letter) + 2))\n        newMessage.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3xsr8z9.scala:19)\n\tat Problem.main(tmpf3xsr8z9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659978999
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val vowelMap =\
    \ new mutable.HashMap[String, String]()\n        val letterMap = new mutable.HashMap[String,\
    \ String]()\n        val messageArray = message.split(\"\")\n        val messageArrayLength\
    \ = messageArray.length\n        val messageArrayLength = messageArrayLength -\
    \ 1\n        var i = 0\n        while (i < messageArrayLength) {\n           \
    \ val letter = messageArray(i)\n            val letterIndex = letters.indexOf(letter)\n\
    \            if (letterIndex != -1) {\n                val vowel = vowels(i)\n\
    \                val vowelIndex = vowels.indexOf(vowel)\n                if (vowelIndex\
    \ != -1) {\n                    val letter2 = letters(letterIndex + 1)\n     \
    \               val vowel2 = vowels(vowelIndex + 1)\n                    val letter3\
    \ = letters(letterIndex + 2)\n                    val vowel3 = vowels(vowelIndex\
    \ + 2)\n                    val letter4 = letters(letterIndex + 3)\n         \
    \           val vowel4 = vowels(vowelIndex + 3)\n                    val letter5\
    \ = letters(letterIndex + 4)\n                    val vowel5 = vowels(vowelIndex\
    \ + 4)\n                    val letter6 = letters(letterIndex + 5)\n         \
    \           val vowel6 = vowels(vowelIndex + 5)\n                    val letter7\
    \ = letters(letterIndex + 6)\n                    val vowel7 = vowels(vowelIndex\
    \ + 6)\n                    val letter8 = letters(letterIndex + 7)\n         \
    \           val vowel8 = vowels(vowelIndex + 7)\n                    val letter9\
    \ = letters(letterIndex + 8)\n                    val vowel9 = vowels(vowelIndex\
    \ + 8)\n                    val letter10 = letters(letterIndex + 9)\n        \
    \            val vowel10 = vowels(vowelIndex + 9)\n                    val letter11\
    \ = letters(letterIndex + 10)\n                    val vowel11 = vowels(vowelIndex\
    \ + 10)\n                    val letter12 = letters(letterIndex + 11)\n      \
    \              val vowel12 = vowels(vowelIndex + 11)\n                    val\
    \ letter13 = letters(letterIndex + 12)\n                    val vowel13 = vowels(vowelIndex\
    \ + 12)\n                    val letter14 = letters(letterIndex + 13)\n      \
    \              val vowel14 = vowels(vowelIndex + 13)\n                    val\
    \ letter15 = letters(letterIndex + 14)\n                    val vowel15 = vowels(vowelIndex\
    \ + 14)\n                    val letter16 = letters(letterIndex + 15)\n      \
    \              val vowel16 = vowels(vowelIndex + 15)\n                    val\
    \ letter17 = letters(letterIndex + 16)\n                    val vowel17 = vowels(vowelIndex\
    \ + 16)\n                    val letter18 = letters(letterIndex + \n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpe3ls05iy.scala:58:56 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m                    \e[33mval\e[0m \e[36mletter18\e[0m\
    \ = letters(letterIndex + \n\e[31m\e[31m   |\e[0m                            \
    \                            ^\e[0m\n\e[31m   |\e[0m                         \
    \              expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpe3ls05iy.scala:69:0 ----------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe3ls05iy.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmessageArrayLength\e[0m = messageArrayLength - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmessageArrayLength is already defined as \e[33mvalue\e[0m \e[35mmessageArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpe3ls05iy.scala:13:27 ------------------------\e[0m\e[0m\n\
    \e[31m13 |\e[0m        \e[33mval\e[0m \e[36mvowelMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mString\e[0m, \e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                 \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                           Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe3ls05iy.scala:14:28\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mletterMap\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mString\e[0m, \e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [33m\e[33m-- Warning: /tmp/tmpe3ls05iy.scala:60:4 ----------------------------------"
  stdout: ''
  timestamp: 1659978997
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => vowels.indexOf(letter) + 2)\n        val newMessageString\
    \ = newMessageArray.toList.toString.mkString(\"\")\n        val newMessageArray2\
    \ = newMessageString.split(\"\")\n        val newMessageArray3 = newMessageArray2.map(letter\
    \ => vowels.indexOf(letter) + 1)\n        val newMessageString2 = newMessageArray3.toList.toString.mkString(\"\
    \")\n        val newMessageArray4 = newMessageString2.split(\"\")\n        val\
    \ newMessageArray5 = newMessageArray4.map(letter => vowels.indexOf(letter) + 0)\n\
    \        val newMessageString3 = newMessageArray5.toList.toString.mkString(\"\"\
    )\n        newMessageString3\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpgr_2svaw.scala:24)\n\tat Problem.main(tmpgr_2svaw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a','e','i','o','u')\n        val newMessage = message.map(letter\
    \ => \n            letter match {\n                case 'a' => alphabet(0)\n \
    \               case 'b' => alphabet(1)\n                case 'c' => alphabet(2)\n\
    \                case 'd' => alphabet(3)\n                case 'e' => alphabet(4)\n\
    \                case 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n\
    \                case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n\
    \                case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n\
    \                case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v' => alphabet(21)\n                case 'w' => alphabet(22)\n\
    \                case 'x' => alphabet(23)\n                case 'y' => alphabet(24)\n\
    \                case 'z' => alphabet(25)\n                case _ => letter\n\
    \            }\n        )\n        val newVowels = vowels.map(letter => \n   \
    \         letter match {\n                case 'a' => alphabet(0)\n          \
    \      case 'e' => alphabet(1)\n                case 'i' => alphabet(2)\n    \
    \            case 'o' => alphabet(3)\n                case 'u' => alphabet(4)\n\
    \                case _ => letter\n            }\n        )\n        val newMessageAndVowels\
    \ = newMessage ++ newVowels\n        val newAlphabet = alphabet.map(letter =>\
    \ \n            letter match {\n                case 'a' => alphabet(0)\n    \
    \            case 'b' => alphabet(1)\n                case 'c' => alphabet(2)\n\
    \                case 'd' => alphabet(3)\n                case 'e' => alphabet(4)\n\
    \                case 'f' => alphabet(5)\n                case 'g' => alphabet(6)\n\
    \                case 'h' => alphabet(7)\n                case 'i' => alphabet(8)\n\
    \                case 'j' => alphabet(9)\n                case 'k' => alphabet(10)\n\
    \                case 'l' => alphabet(11)\n                case 'm' => alphabet(12)\n\
    \                case 'n' => alphabet(13)\n                case 'o' => alphabet(14)\n\
    \                case 'p' => alphabet(15)\n                case 'q' => alphabet(16)\n\
    \                case 'r' => alphabet(17)\n                case 's' => alphabet(18)\n\
    \                case 't' => alphabet(19)\n                case 'u' => alphabet(20)\n\
    \                case 'v\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp456zbuip.scala:78:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m                \e[33mcase\e[0m \e[31m'v\e[0m\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0msymbol literal 'v is\
    \ no longer supported,\n\e[31m   |\e[0muse a string literal \"v\" or an application\
    \ Symbol(\"v\") instead,\n\e[31m   |\e[0mor enclose in braces '{v} if you want\
    \ a quoted expression.\n\e[31m   |\e[0mFor now, you can also `import language.deprecated.symbolLiterals`\
    \ to accept\n\e[31m   |\e[0mthe idiom, but this possibility might no longer be\
    \ available in the future.\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp456zbuip.scala:79:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    '=>' expected, but '}' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp456zbuip.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp456zbuip.scala:89:0 ----------------------------\e[0m\e[0m\n\e[31m89\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E051] Reference Error: /tmp/tmp456zbuip.scala:54:45 ------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e[36mnewMessageAndVowels\e[0m\
    \ = newMessage ++ newVowels\n\e[31m\e[31m   |\e[0m                           \
    \       ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m++\e[0m in \e[33mclass\e[0m \e[35mStringOps\e\
    [0m with types\n\e[31m   |\e[0m (suffix: IterableOnce[Char]): String\n\e[31m \
    \  |\e[0m [B >: Char](suffix: Iterable[B]): IndexedSeq[B]\n\e[31m   |\e[0mboth\
    \ match arguments ((newVowels : List[Char]))\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp456zbuip.scala:88:1 ---------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Un"
  stdout: ''
  timestamp: 1659979000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val newMessage =\
    \ message.map(letter => alphabet(alphabet.indexOf(letter) + 1))\n        val newVowels\
    \ = vowels.map(letter => alphabet(alphabet.indexOf(letter) + 2))\n        newMessage.zip(newVowels).map(x\
    \ => x.swap).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_s_r42e2.scala:18)\n\tat Problem.main(tmp_s_r42e2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => {\n            if (vowels.contains(letter)) {\n                val vowelIndex\
    \ = vowels.indexOf(letter)\n                val vowel2Index = vowels.indexOf(vowel,\
    \ vowelIndex + 1)\n                val vowel2Letter = vowels(vowel2Index)\n  \
    \              val letterIndex = vowels.indexOf(letter)\n                val letter2Index\
    \ = vowels.indexOf(letter, letterIndex + 1)\n                val letter2Letter\
    \ = vowels(letter2Index)\n                val newLetter = if (letter2Index < vowelIndex)\
    \ letter2Letter else letter\n                vowels(vowelIndex) = newLetter\n\
    \                vowels(vowel2Index) = newLetter\n                letter\n   \
    \         } else {\n                letter\n            }\n        }).mkString(\"\
    \")\n        newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk9r718fp.scala:16:49 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m                \e[33mval\e[0m \e[36mvowel2Index\e[0m\
    \ = vowels.indexOf(vowel, vowelIndex + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \                                               ^^^^^\e[0m\n\e[31m   |\e[0m  \
    \                                               Not found: vowel\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk9r718fp.scala:22:16 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                vowels(vowelIndex) = newLetter\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e[0m                value\
    \ update is not a member of String\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpk9r718fp.scala:23:16\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m                vowels(vowel2Index)\
    \ = newLetter\n\e[31m\e[31m   |\e[0m                ^^^^^^\e[0m\n\e[31m   |\e\
    [0m                value update is not a member of String\n3 errors found\n"
  stdout: ''
  timestamp: 1659979000
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiou\"\n\
    \        val messageArray = message.split(\"\")\n        val newMessage = messageArray.map(letter\
    \ => {\n            val index = vowels.indexOf(letter)\n            if (index\
    \ != -1) {\n                vowels(index - 1) + vowels(index)\n            } else\
    \ {\n                letter\n            }\n        }).mkString(\"\")\n      \
    \  newMessage\n    }\n    def main(args: Array[String]) = {\n    assert(encode((\"\
    TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\"\
    )));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n    assert(encode((\"\
    This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n    assert(encode((\"\
    I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\
    \n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpai17spy6.scala:24)\n\tat Problem.main(tmpai17spy6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979001
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        var result = \"\"\n     \
    \   var vowels = \"aeiou\"\n        var letters = \"abcdefghijklmnopqrstuvwxyz\"\
    \n        var vowelIndex = 0\n        var letterIndex = 0\n        var currentLetter\
    \ = \"\"\n        var currentVowel = \"\"\n        var currentVowelIndex = 0\n\
    \        var currentLetterIndex = 0\n        for(letter <- message) {\n      \
    \      currentLetter = letter\n            currentVowel = vowels(vowelIndex)\n\
    \            currentVowelIndex = letters.indexOf(currentVowel)\n            currentLetterIndex\
    \ = letters.indexOf(letter)\n            result += currentLetter\n           \
    \ result += currentVowel\n            result += letters(letterIndex)\n       \
    \     result += letters(currentLetterIndex)\n            vowelIndex += 1\n   \
    \         letterIndex += 1\n        }\n        return result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n   \
    \ assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmibpuk5d.scala:21:28\
    \ --------------------\e[0m\e[0m\n\e[31m21 |\e[0m            currentLetter = letter\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Found:    (letter : Char)\n\e[31m   |\e[0m      \
    \                      Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpmibpuk5d.scala:22:33 --------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m            currentVowel = vowels(vowelIndex)\n\e[31m\e[31m\
    \   |\e[0m                           ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Found:    Char\n\e[31m   |\e[0m                  \
    \         Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val newMessageArray\
    \ = messageArray.map(letter => vowels.indexOf(letter) match {\n            case\
    \ -1 => letter\n            case i => vowels(i + 2)\n        })\n        newMessageArray.toString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy83ejy3c.scala:20)\n\tat Problem.main(tmpy83ejy3c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('o','a','e','i','u')\n        val newMessage = message.map(c\
    \ => alphabet(alphabet.indexOf(c) + 1))\n        val newVowels = vowels.map(c\
    \ => alphabet(alphabet.indexOf(c) + 2))\n        newMessage.zip(newVowels).map(c\
    \ => c._1 + c._2).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpqxw5d6uq.scala:18)\n\tat Problem.main(tmpqxw5d6uq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        var newMessage = message\n\
    \        val vowels = Set(\"a\", \"e\", \"i\", \"o\", \"u\")\n        val vowelsCount\
    \ = vowels.toList\n        val vowelsCount2 = vowelsCount.tail\n        val vowelsCount3\
    \ = vowelsCount2.tail\n        val vowelsCount4 = vowelsCount3.tail\n        val\
    \ vowelsCount5 = vowelsCount4.tail\n        val vowelsCount6 = vowelsCount5.tail\n\
    \        val vowelsCount7 = vowelsCount6.tail\n        val vowelsCount8 = vowelsCount7.tail\n\
    \        val vowelsCount9 = vowelsCount8.tail\n        val vowelsCount10 = vowelsCount9.tail\n\
    \        val vowelsCount11 = vowelsCount10.tail\n        val vowelsCount12 = vowelsCount11.tail\n\
    \        val vowelsCount13 = vowelsCount12.tail\n        val vowelsCount14 = vowelsCount13.tail\n\
    \        val vowelsCount15 = vowelsCount14.tail\n        val vowelsCount16 = vowelsCount15.tail\n\
    \        val vowelsCount17 = vowelsCount16.tail\n        val vowelsCount18 = vowelsCount17.tail\n\
    \        val vowelsCount19 = vowelsCount18.tail\n        val vowelsCount20 = vowelsCount19.tail\n\
    \        val vowelsCount21 = vowelsCount20.tail\n        val vowelsCount22 = vowelsCount21.tail\n\
    \        val vowelsCount23 = vowelsCount22.tail\n        val vowelsCount24 = vowelsCount23.tail\n\
    \        val vowelsCount25 = vowelsCount24.tail\n        val vowelsCount26 = vowelsCount25.tail\n\
    \        val vowelsCount27 = vowelsCount26.tail\n        val vowelsCount28 = vowelsCount27.tail\n\
    \        val vowelsCount29 = vowelsCount28.tail\n        val vowelsCount30 = vowelsCount29.tail\n\
    \        val vowelsCount31 = vowelsCount30.tail\n        val vowelsCount32 = vowelsCount31.tail\n\
    \        val vowelsCount33 = vowelsCount32.tail\n        val vowelsCount34 = vowelsCount33.tail\n\
    \        val vowelsCount35 = vowelsCount34.tail\n        val vowelsCount36 = vowelsCount35.tail\n\
    \        val vowelsCount37 = vowelsCount36.tail\n        val vowelsCount38 = vowelsCount37.tail\n\
    \        val vowelsCount39 = vowelsCount\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"\
    Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\"\
    )));\n    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\"\
    )));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW\
    \ wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp13681vw8.scala:52:5\
    \ ---------------------\e[0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val alphabet = List('a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z')\n\
    \        val vowels = List('a', 'e', 'i', 'o', 'u')\n        val newMessage =\
    \ message.map(letter => \n            if (vowels.contains(letter)) letter else\
    \ alphabet(alphabet.indexOf(letter) + 2))\n        newMessage.toString()\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp02cjx9bz.scala:18)\n\tat Problem.main(tmp02cjx9bz.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979002
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val letters = \"abcdefghijklmnopqrstuvwxyz\"\n        val vowelMap =\
    \ new mutable.HashMap[Char, Char]()\n        for (i <- 0 to message.length - 1)\
    \ {\n            val c = message.charAt(i)\n            if (vowels.contains(c))\
    \ {\n                vowelMap += (c -> vowels.indexOf(c) + 2)\n            }\n\
    \        }\n        val result = new StringBuilder\n        for (i <- 0 to message.length\
    \ - 1) {\n            val c = message.charAt(i)\n            if (letters.contains(c))\
    \ {\n                val index = letters.indexOf(c)\n                val replacement\
    \ = vowelMap.getOrElse(c, c)\n                result.append(replacement)\n   \
    \         } else {\n                result.append(c)\n            }\n        }\n\
    \        return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(encode((\"TEST\")).equals((\"tgst\")));\n    assert(encode((\"Mudasir\"\
    )).equals((\"mWDCSKR\")));\n    assert(encode((\"YES\")).equals((\"ygs\")));\n\
    \    assert(encode((\"This is a message\")).equals((\"tHKS KS C MGSSCGG\")));\n\
    \    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"k dQnT kNqW wHcT\
    \ Tq wRkTg\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgwicxrdp.scala:13:27 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mvowelMap\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mChar\e[0m, \e[35mChar\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                    \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1659979001
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that takes a message, and encodes in such a \n  \
    \  // way that it swaps case of all letters, replaces all vowels in \n    // the\
    \ message with the letter that appears 2 places ahead of that \n    // vowel in\
    \ the english alphabet. \n    // Assume only letters. \n    // Examples:\n   \
    \ def encode(message : String) : String = {\n        val vowels = \"aeiouAEIOU\"\
    \n        val messageArray = message.split(\"\")\n        val encodedMessage =\
    \ messageArray.map(letter => \n            if (vowels.contains(letter)) letter\
    \ else vowels.indexOf(letter) + 2)\n        encodedMessage.toString.toLowerCase\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(encode((\"TEST\")).equals((\"\
    tgst\")));\n    assert(encode((\"Mudasir\")).equals((\"mWDCSKR\")));\n    assert(encode((\"\
    YES\")).equals((\"ygs\")));\n    assert(encode((\"This is a message\")).equals((\"\
    tHKS KS C MGSSCGG\")));\n    assert(encode((\"I DoNt KnOw WhAt tO WrItE\")).equals((\"\
    k dQnT kNqW wHcT Tq wRkTg\")));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpivlrb_j1.scala:18)\n\tat Problem.main(tmpivlrb_j1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1659979002
