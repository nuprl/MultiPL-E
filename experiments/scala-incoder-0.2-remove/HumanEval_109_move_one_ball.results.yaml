language: scala
name: HumanEval_109_move_one_ball
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else if(arr.size\
    \ == 1) false\n        else {\n            val first = arr.head\n            val\
    \ rest = arr.tail\n            val restLength = rest.length\n            val restHead\
    \ = rest(0)\n            val restTail = rest(restLength-1)\n            val restHeadIndex\
    \ = restHead.asInstanceOf[Int]\n            val restTailIndex = restTail.asInstanceOf[Int]\n\
    \            val restHeadValue = restHead.asInstanceOf[Long]\n            val\
    \ restTailValue = restTail.asInstanceOf[Long]\n            val restHeadIndex =\
    \ restHeadIndex.asInstanceOf[Int]\n            val restTailIndex = restTailIndex.asInstanceOf[Int]\n\
    \            val restHeadValue = restHeadValue.asInstanceOf[Long]\n          \
    \  val restTailValue = restTailValue.asInstanceOf[Long]\n            val restHeadIndex\
    \ = restHeadIndex.asInstanceOf[Int]\n            val restTailIndex = restTailIndex.asInstanceOf[Int]\n\
    \            val restHeadValue = restHeadValue.asInstanceOf[Long]\n          \
    \  val restTailValue = restTailValue.asInstanceOf[Long]\n            val restHeadIndex\
    \ = restHeadIndex.asInstanceOf[Int]\n            val restTailIndex = restTailIndex.asInstanceOf[Int]\n\
    \            val restHeadValue = restHeadValue.asInstanceOf[Long]\n          \
    \  val restTailValue = restTailValue.asInstanceOf[Long]\n            val restHeadIndex\
    \ = restHeadIndex.asInstanceOf[Int]\n            val restTailIndex = restTailIndex.asInstanceOf[Int]\n\
    \            val restHeadValue = restHeadValue.asInstanceOf[Long]\n          \
    \  val restTailValue = restTailValue.asInstanceOf[Long]\n            val restHeadIndex\
    \ = restHeadIndex.asInstanceOf[Int]\n            val restTailIndex = restTailIndex.asInstanceOf[Int]\n\
    \            val restHeadValue = restHeadValue.asInstanceOf[Long]\n          \
    \  val restTailValue = restTailValue.asInstanceOf[Long]\n            val restHeadIndex\
    \ = restHeadIndex.asInstanceOf[Int]\n            val restTailIndex = restTailIndex.asInstanceOf[Int]\n\
    \            val restHeadValue = restHeadValue.asInstanceOf[Long]\n          \
    \  val restTailValue = restTailValue.asInstanceOf[Long]\n            val restHeadIndex\
    \ = restHeadIndex.asInstanceOf[Int]\n            val restTailIndex = restTailIndex.as\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiivdwonq.scala:70:0 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpiivdwonq.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mrestHeadIndex\e[0m = restHeadIndex.asInstanceOf[\e[35mInt\e[0m]\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrestHeadIndex is already defined as \e[33mvalue\e[0m \e[35mrestHeadIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpiivdwonq.scala:35:16 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m            \e[33mval\e[0m \e[36mrestTailIndex\e[0m = restTailIndex.asInstanceOf[\e\
    [35mInt\e[0m]\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrestTailIndex is already defined as \e[33mvalue\e[0m \e[35mrestTailIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpiivdwonq.scala:36:16 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m            \e[33mval\e[0m \e[36mrestHeadValue\e[0m = restHeadValue.asInstanceOf[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrestHeadValue is already defined as \e[33mvalue\e[0m \e[35mrestHeadValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpiivdwonq.scala:37:16 ---------------------------\e[0m\e[0m\n\e\
    [31m37 |\e[0m            \e[33mval\e[0m \e[36mrestTailValue\e[0m = restTailValue.asInstanceOf[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrestTailValue is already defined as \e[33mvalue\e[0m \e[35mrestTailValue\e\
    [0m\n\e[31m   "
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:30:12 ----------"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:29:12 ----------"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val r = arr.last\n        val s = arr.init\n        val t = arr.tail\n\
    \        val u = arr.init\n        val v = arr.tail\n        val w = arr.init\n\
    \        val x = arr.tail\n        val y = arr.init\n        val z = arr.tail\n\
    \        val a = arr.init\n        val b = arr.tail\n        val c = arr.init\n\
    \        val d = arr.tail\n        val e = arr.init\n        val f = arr.tail\n\
    \        val g = arr.init\n        val h = arr.tail\n        val i = arr.init\n\
    \        val j = arr.tail\n        val k = arr.init\n        val l = arr.tail\n\
    \        val m = arr.init\n        val n = arr.tail\n        val o = arr.init\n\
    \        val p = arr.tail\n        val q = arr.init\n        val r = arr.tail\n\
    \        val s = arr.init\n        val t = arr.tail\n        val u = arr.init\n\
    \        val v = arr.tail\n        val w = arr.init\n        val x = arr.tail\n\
    \        val y = arr.init\n        val z = arr.tail\n        val a = arr.init\n\
    \        val b = arr.tail\n        val c = arr.init\n        val d = arr.tail\n\
    \        val e = arr.init\n        val f = arr.tail\n        val g = arr.init\n\
    \        val h = arr.tail\n        val i = arr.init\n        val j = arr.tail\n\
    \        val k = arr.init\n        val l = arr.tail\n        val m = arr.init\n\
    \        val n = arr.tail\n        val o = arr.init\n        val p = arr.tail\n\
    \        val q = arr.init\n        val r = arr.tail\n        val s = arr.init\n\
    \        val t = arr.tail\n        val u = arr.init\n        val v = arr.tail\n\
    \        val w = arr.init\n        val x = arr.tail\n        val y = arr.init\n\
    \        val z = arr.tail\n        val a = arr.init\n        val b = arr.tail\n\
    \        val c = arr.init\n        val d = arr.tail\n        val e = arr.init\n\
    \        val f = arr.tail\n        val g = arr.init\n        val h = arr.tail\n\
    \        val i = arr.init\n        val j = arr.tail\n        val k = arr.init\n\
    \        val l = arr.tail\n        val m = arr.init\n        val n = arr.tail\n\
    \        val o = arr.init\n        val p = arr.tail\n        val q = arr.init\n\
    \        val r = arr.tail\n        val s = arr.init\n        val t = arr.tail\n\
    \        val u = arr.init\n        val v = arr.tail\n        val \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpko6mu2zp.scala:107:11 --------------------------\e\
    [0m\e[0m\n\e[31m107 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpko6mu2zp.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpko6mu2zp.scala:46:12 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpko6mu2zp.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpko6mu2zp.scala:51:12 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = arr.init\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0ms is already defined\
    \ as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpko6mu2zp.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mt\e[0m = arr.tail\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e["
  stdout: ''
  timestamp: 1660009573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val result2 = new\
    \ mutable.ListBuffer[Long]()\n        val result3 = new mutable.ListBuffer[Long]()\n\
    \        val result4 = new mutable.ListBuffer[Long]()\n        val result5 = new\
    \ mutable.ListBuffer[Long]()\n        val result6 = new mutable.ListBuffer[Long]()\n\
    \        val result7 = new mutable.ListBuffer[Long]()\n        val result8 = new\
    \ mutable.ListBuffer[Long]()\n        val result9 = new mutable.ListBuffer[Long]()\n\
    \        val result10 = new mutable.ListBuffer[Long]()\n        val result11 =\
    \ new mutable.ListBuffer[Long]()\n        val result12 = new mutable.ListBuffer[Long]()\n\
    \        val result13 = new mutable.ListBuffer[Long]()\n        val result14 =\
    \ new mutable.ListBuffer[Long]()\n        val result15 = new mutable.ListBuffer[Long]()\n\
    \        val result16 = new mutable.ListBuffer[Long]()\n        val result17 =\
    \ new mutable.ListBuffer[Long]()\n        val result18 = new mutable.ListBuffer[Long]()\n\
    \        val result19 = new mutable.ListBuffer[Long]()\n        val result20 =\
    \ new mutable.ListBuffer[Long]()\n        val result21 = new mutable.ListBuffer[Long]()\n\
    \        val result22 = new mutable.ListBuffer[Long]()\n        val result23 =\
    \ new mutable.ListBuffer[Long]()\n        val result24 = new mutable.ListBuffer[Long]()\n\
    \        val result25 = new mutable.ListBuffer[Long]()\n        val result26 =\
    \ new mutable.ListBuffer[Long]()\n        val result27 = new mutable.ListBuffer[Long]()\n\
    \        val result28 = new mutable.ListBuffer[Long]()\n        val result29 =\
    \ new mutable.ListBuffer[Long]()\n        val result30 = new mutable.ListBuffer[Long]()\n\
    \        val result31 = new mutable.ListBuffer[Long]()\n        val result32 =\
    \ new mutable.ListBuffer[Long]()\n        val result33 = new mutable.ListBuffer[Long]()\n\
    \        val result34 = new mutable.ListBuffer[Long]()\n        val result35 =\
    \ new mutable.ListBuffer[Long]()\n        val result36 = new mutable.List\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt02w6sm7.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpt02w6sm7.scala:24:25 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt02w6sm7.scala:25:26\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mresult2\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpt02w6sm7.scala:26:26 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult3\e[0m = \e[33mnew\e[0m\
    \ mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m               \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt02w6sm7.scala:27:26\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mresult4\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpt02w6sm7.scala:28:26 ----"
  stdout: ''
  timestamp: 1660009574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val result = new Array[Boolean](n)\n        val arr = arr.toList\n  \
    \      val n = arr.size\n        val result = new Array[Boolean](n)\n        val\
    \ arr = arr.toList\n        val n = arr.size\n        val result = new Array[Boolean](n)\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val result = new Array[Boolean](n)\n        val arr = arr.toList\n  \
    \      val n = arr.size\n        val result = new Array[Boolean](n)\n        val\
    \ arr = arr.toList\n        val n = arr.size\n        val result = new Array[Boolean](n)\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val result = new Array[Boolean](n)\n        val arr = arr.toList\n  \
    \      val n = arr.size\n        val result = new Array[Boolean](n)\n        val\
    \ arr = arr.toList\n        val n = arr.size\n        val result = new Array[Boolean](n)\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val result = new Array[Boolean](n)\n        val arr = arr.toList\n  \
    \      val n = arr.size\n        val result = new Array[Boolean](n)\n        val\
    \ arr = arr.toList\n        val n = arr.size\n        val result = new Array[Boolean](n)\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val result = new Array[Boolean](n)\n        val arr = arr.toList\n  \
    \      val n = arr.size\n        val result = new Array[Boolean](n)\n        val\
    \ arr = arr.toList\n        val n = arr.size\n        val result = new Array[Boolean](n)\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val result = new Array[Boolean](n)\n        val arr = arr.toList\n  \
    \      val n = arr.size\n        val result = new Array[Boolean](n)\n        val\
    \ arr = arr.toList\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm8f6ncne.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm8f6ncne.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm8f6ncne.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m[\e[35mBoolean\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpm8f6ncne.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpm8f6ncne.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /t"
  stdout: ''
  timestamp: 1660009574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.to\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1gt30356.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1gt30356.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1gt30356.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1gt30356.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1gt30356.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1gt30356.scala:30:12 ---------------------------\e\
    [0m\e[0"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr.toSeq\n        val arr3 = arr.toBuffer\n        val arr4 = arr.toArray\n\
    \        val arr5 = arr.toSeq\n        val arr6 = arr.toBuffer\n        val arr7\
    \ = arr.toArray\n        val arr8 = arr.toSeq\n        val arr9 = arr.toBuffer\n\
    \        val arr10 = arr.toArray\n        val arr11 = arr.toSeq\n        val arr12\
    \ = arr.toBuffer\n        val arr13 = arr.toArray\n        val arr14 = arr.toSeq\n\
    \        val arr15 = arr.toBuffer\n        val arr16 = arr.toArray\n        val\
    \ arr17 = arr.toSeq\n        val arr18 = arr.toBuffer\n        val arr19 = arr.toArray\n\
    \        val arr20 = arr.toSeq\n        val arr21 = arr.toBuffer\n        val\
    \ arr22 = arr.toArray\n        val arr23 = arr.toSeq\n        val arr24 = arr.toBuffer\n\
    \        val arr25 = arr.toArray\n        val arr26 = arr.toSeq\n        val arr27\
    \ = arr.toBuffer\n        val arr28 = arr.toArray\n        val arr29 = arr.toSeq\n\
    \        val arr30 = arr.toBuffer\n        val arr31 = arr.toArray\n        val\
    \ arr32 = arr.toSeq\n        val arr33 = arr.toBuffer\n        val arr34 = arr.toArray\n\
    \        val arr35 = arr.toSeq\n        val arr36 = arr.toBuffer\n        val\
    \ arr37 = arr.toArray\n        val arr38 = arr.toSeq\n        val arr39 = arr.toBuffer\n\
    \        val arr40 = arr.toArray\n        val arr41 = arr.toSeq\n        val arr42\
    \ = arr.toBuffer\n        val arr43 = arr.toArray\n        val arr44 = arr.toSeq\n\
    \        val arr45 = arr.toBuffer\n        val arr46 = arr.toArray\n        val\
    \ arr47 = arr.toSeq\n        val arr48 = arr.toBuffer\n        val arr49 = arr.toArray\n\
    \        val arr50 = arr.toSeq\n        val arr51 = arr.toBuffer\n        val\
    \ arr52 = arr.toArray\n        val arr53 = arr.toSeq\n        val arr54 = arr.toBuffer\n\
    \        val arr55 = arr.toArray\n        val arr56 = arr.toSeq\n        \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4n6obddv.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp4n6obddv.scala:82:5 ---------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = true\n        while(i\
    \ < n && j < n) {\n            temp = arr(i)\n            arr(i) = arr(j)\n  \
    \          arr(j) = temp\n            i += 1\n            j += 1\n        }\n\
    \        while(i < n) {\n            arr(i) = arr(j)\n            i += 1\n   \
    \         j += 1\n        }\n        while(j < n) {\n            arr(j) = arr(k)\n\
    \            j += 1\n            k += 1\n        }\n        for(i = k; i >= 0;\
    \ i -= 1) {\n            for(j = k; j >= 0; j -= 1) {\n                for(k =\
    \ k; k >= 0; k -= 1) {\n                    if(arr(i) > arr(j) && arr(i) > arr(k)\
    \ && arr(j) > arr(k)) {\n                        arr(i) = arr(k)\n           \
    \             arr(k) = arr(j)\n                        arr(j) = arr(i)\n     \
    \               }\n                }\n            }\n        }\n        for(i\
    \ = k; i >= 0; i -= 1) {\n            for(j = k; j >= 0; j -= 1) {\n         \
    \       for(k = k; k >= 0; k -= 1) {\n                    if(arr(i) < arr(j) &&\
    \ arr(i) < arr(k) && arr(j) < arr(k)) {\n                        arr(i) = arr(k)\n\
    \                        arr(k) = arr(j)\n                        arr(j) = arr(i)\n\
    \                    }\n                }\n            }\n        }\n        for(i\
    \ = k; i >= 0; i -= 1) {\n            for(j = k; j >= 0; j -= 1) {\n         \
    \       for(k = k; k >= 0; k -= 1) {\n                    if(arr(i) == arr(j)\
    \ && arr(i) == arr(k) && arr(j) == arr(k)) {\n                        arr(i) =\
    \ arr(k)\n                        arr(k) = arr(j)\n                        arr(j)\
    \ = arr(i)\n                    }\n                }\n            }\n        }\n\
    \        for(i = k; i >= 0; i -= 1) {\n            for(j = k; j >= 0; j -= 1)\
    \ {\n                for(k = k; k >= 0; k -= 1) {\n                    if(arr(i)\
    \ == arr(j) && arr(i) == arr(k) && arr(j) == arr(k)) {\n                     \
    \   arr(i) = arr(k)\n                        arr(k) = arr(j)\n               \
    \         arr(j) = arr(i)\n                    }\n                }\n        \
    \    }\n        }\n        for(i = k; i >= 0; i -= 1) {\n            for(j = k;\
    \ j >= 0; j -= 1) {\n                \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu7cr3prm.scala:47:14 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mfor\e[0m(i = k; i >= \e[31m0\e[0m; i -=\
    \ \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m\
    \              ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpu7cr3prm.scala:47:25 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mfor\e[0m(i = k; i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 '<-' expected, but ';' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpu7cr3prm.scala:47:33 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mfor\e[0m(i = k; i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 '<-' expected, but ')' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpu7cr3prm.scala:58:14 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mfor\e[0m(i = k; i >= \e[31m0\e[0m; i -=\
    \ \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m\
    \              ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpu7cr3prm.scala:58:25 ---------------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m        \e[33mfor\e[0m(i = k; i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 '<-' expected, but ';' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpu7cr3prm.scala:58:33 ---------------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m        \e[33mfor\e[0m(i = k; i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                                 ^\e[0m\n\e[31m   |\e[0m\
    \                                 '<-' expected, but ')' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpu7cr3prm.scala:69:14 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mfor\e[0m(i = k; i >= \e[31m0\e[0m; i -=\
    \ \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m\
    \              ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tm"
  stdout: ''
  timestamp: 1660009577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val sortedArr = arr.sortBy(x => x)\n        val sortedArr2 = sortedArr.sortBy(x\
    \ => x)\n        val sortedArr3 = sortedArr2.sortBy(x => x)\n        val sortedArr4\
    \ = sortedArr3.sortBy(x => x)\n        val sortedArr5 = sortedArr4.sortBy(x =>\
    \ x)\n        val sortedArr6 = sortedArr5.sortBy(x => x)\n        val sortedArr7\
    \ = sortedArr6.sortBy(x => x)\n        val sortedArr8 = sortedArr7.sortBy(x =>\
    \ x)\n        val sortedArr9 = sortedArr8.sortBy(x => x)\n        val sortedArr10\
    \ = sortedArr9.sortBy(x => x)\n        val sortedArr11 = sortedArr10.sortBy(x\
    \ => x)\n        val sortedArr12 = sortedArr11.sortBy(x => x)\n        val sortedArr13\
    \ = sortedArr12.sortBy(x => x)\n        val sortedArr14 = sortedArr13.sortBy(x\
    \ => x)\n        val sortedArr15 = sortedArr14.sortBy(x => x)\n        val sortedArr16\
    \ = sortedArr15.sortBy(x => x)\n        val sortedArr17 = sortedArr16.sortBy(x\
    \ => x)\n        val sortedArr18 = sortedArr17.sortBy(x => x)\n        val sortedArr19\
    \ = sortedArr18.sortBy(x => x)\n        val sortedArr20 = sortedArr19.sortBy(x\
    \ => x)\n        val sortedArr21 = sortedArr20.sortBy(x => x)\n        val sortedArr22\
    \ = sortedArr21.sortBy(x => x)\n        val sortedArr23 = sortedArr22.sortBy(x\
    \ => x)\n        val sortedArr24 = sortedArr23.sortBy(x => x)\n        val sortedArr25\
    \ = sortedArr24.sortBy(x => x)\n        val sortedArr26 = sortedArr25.sortBy(x\
    \ => x)\n        val sortedArr27 = sortedArr26.sortBy(x => x)\n        val sortedArr28\
    \ = sortedArr27.sortBy(x => x)\n        val sortedArr29 = sortedArr28.sortBy(x\
    \ => x)\n        val sortedArr30 = sortedArr29.sortBy(x => x)\n        val sortedArr31\
    \ = sortedArr30.sortBy(x => x)\n        val sortedArr32 = sortedArr31.sortBy(x\
    \ => x)\n        val sortedArr33 = sortedArr32.sortBy(x => x)\n        val sortedArr34\
    \ = sortedArr33.sortBy(x => x)\n        val sorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl15paooq.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpl15paooq.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl15paooq.scala:59:5\
    \ ---------------------\e[0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        val arr = arr.toList\n        val arr1 = arr.toArray\n\
    \        val arr2 = arr1.clone\n        val arr3 = arr2.clone\n        val arr4\
    \ = arr3.clone\n        val arr5 = arr4.clone\n        val arr6 = arr5.clone\n\
    \        val arr7 = arr6.clone\n        val arr8 = arr7.clone\n        val arr9\
    \ = arr8.clone\n        val arr10 = arr9.clone\n        val arr11 = arr10.clone\n\
    \        val arr12 = arr11.clone\n        val arr13 = arr12.clone\n        val\
    \ arr14 = arr13.clone\n        val arr15 = arr14.clone\n        val arr16 = arr15.clone\n\
    \        val arr17 = arr16.clone\n        val arr18 = arr17.clone\n        val\
    \ arr19 = arr18.clone\n        val arr20 = arr19.clone\n        val arr21 = arr20.clone\n\
    \        val arr22 = arr21.clone\n        val arr23 = arr22.clone\n        val\
    \ arr24 = arr23.clone\n        val arr25 = arr24.clone\n        val arr26 = arr25.clone\n\
    \        val arr27 = arr26.clone\n        val arr28 = arr27.clone\n        val\
    \ arr29 = arr28.clone\n        val arr30 = arr29.clone\n        val arr31 = arr30.clone\n\
    \        val arr32 = arr31.clone\n        val arr33 = arr32.clone\n        val\
    \ arr34 = arr33.clone\n        val arr35 = arr34.clone\n        val arr36 = arr35.clone\n\
    \        val arr37 = arr36.clone\n        val arr38 = arr37.clone\n        val\
    \ arr39 = arr38.clone\n        val arr40 = arr39.clone\n        val arr41 = arr40.clone\n\
    \        val arr42 = arr41.clone\n        val arr43 = arr42.clone\n        val\
    \ arr44 = arr43.clone\n        val arr45 = arr44.clone\n        val arr46 = arr45.clone\n\
    \        val arr47 = arr46.clone\n        val arr48 = arr47.clone\n        val\
    \ arr49 = arr48.clone\n        val arr50 = arr49.clone\n        val arr51 = arr50.clone\n\
    \        val arr52 = arr51.clone\n        val arr53 = arr52.clone\n        val\
    \ arr54 = arr53.clone\n        val arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiauy3kos.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiauy3kos.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiauy3kos.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr1 = arr.toList\n        val arr2\
    \ = arr1.toArray\n        val arr3 = arr2.toList\n        val arr4 = arr3.toArray\n\
    \        val arr5 = arr4.toList\n        val arr6 = arr5.toArray\n        val\
    \ arr7 = arr6.toList\n        val arr8 = arr7.toArray\n        val arr9 = arr8.toList\n\
    \        val arr10 = arr9.toArray\n        val arr11 = arr10.toList\n        val\
    \ arr12 = arr11.toArray\n        val arr13 = arr12.toList\n        val arr14 =\
    \ arr13.toArray\n        val arr15 = arr14.toList\n        val arr16 = arr15.toArray\n\
    \        val arr17 = arr16.toList\n        val arr18 = arr17.toArray\n       \
    \ val arr19 = arr18.toList\n        val arr20 = arr19.toArray\n        val arr21\
    \ = arr20.toList\n        val arr22 = arr21.toArray\n        val arr23 = arr22.toList\n\
    \        val arr24 = arr23.toArray\n        val arr25 = arr24.toList\n       \
    \ val arr26 = arr25.toArray\n        val arr27 = arr26.toList\n        val arr28\
    \ = arr27.toArray\n        val arr29 = arr28.toList\n        val arr30 = arr29.toArray\n\
    \        val arr31 = arr30.toList\n        val arr32 = arr31.toArray\n       \
    \ val arr33 = arr32.toList\n        val arr34 = arr33.toArray\n        val arr35\
    \ = arr34.toList\n        val arr36 = arr35.toArray\n        val arr37 = arr36.toList\n\
    \        val arr38 = arr37.toArray\n        val arr39 = arr38.toList\n       \
    \ val arr40 = arr39.toArray\n        val arr41 = arr40.toList\n        val arr42\
    \ = arr41.toArray\n        val arr43 = arr42.toList\n        val arr44 = arr43.toArray\n\
    \        val arr45 = arr44.toList\n        val arr46 = arr45.toArray\n       \
    \ val arr47 = arr46.toList\n        val arr48 = arr47.toArray\n        val arr49\
    \ = arr48.toList\n        val arr50 = arr49.toArray\n        val arr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4pz_9ckv.scala:76:4 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4pz_9ckv.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4pz_9ckv.scala:76:5\
    \ ---------------------\e[0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val temp = new mutable.ListBuffer[Long]()\n\
    \        val temp2 = new mutable.ListBuffer[Long]()\n        val temp3 = new mutable.ListBuffer[Long]()\n\
    \        val temp4 = new mutable.ListBuffer[Long]()\n        val temp5 = new mutable.ListBuffer[Long]()\n\
    \        val temp6 = new mutable.ListBuffer[Long]()\n        val temp7 = new mutable.ListBuffer[Long]()\n\
    \        val temp8 = new mutable.ListBuffer[Long]()\n        val temp9 = new mutable.ListBuffer[Long]()\n\
    \        val temp10 = new mutable.ListBuffer[Long]()\n        val temp11 = new\
    \ mutable.ListBuffer[Long]()\n        val temp12 = new mutable.ListBuffer[Long]()\n\
    \        val temp13 = new mutable.ListBuffer[Long]()\n        val temp14 = new\
    \ mutable.ListBuffer[Long]()\n        val temp15 = new mutable.ListBuffer[Long]()\n\
    \        val temp16 = new mutable.ListBuffer[Long]()\n        val temp17 = new\
    \ mutable.ListBuffer[Long]()\n        val temp18 = new mutable.ListBuffer[Long]()\n\
    \        val temp19 = new mutable.ListBuffer[Long]()\n        val temp20 = new\
    \ mutable.ListBuffer[Long]()\n        val temp21 = new mutable.ListBuffer[Long]()\n\
    \        val temp22 = new mutable.ListBuffer[Long]()\n        val temp23 = new\
    \ mutable.ListBuffer[Long]()\n        val temp24 = new mutable.ListBuffer[Long]()\n\
    \        val temp25 = new mutable.ListBuffer[Long]()\n        val temp26 = new\
    \ mutable.ListBuffer[Long]()\n        val temp27 = new mutable.ListBuffer[Long]()\n\
    \        val temp28 = new mutable.ListBuffer[Long]()\n        val temp29 = new\
    \ mutable.ListBuffer[Long]()\n        val temp30 = new mutable.ListBuffer[Long]()\n\
    \        val temp31 = new mutable.ListBuffer[Long]()\n        val temp32 = new\
    \ mutable.ListBuffer[Long]()\n        val temp33 = new mutable.ListBuffer[Long]()\n\
    \        val temp34 = new mutable.ListBuffer[Long]()\n        val temp35 = new\
    \ mutable.ListBuffer\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4d0mp2xa.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:24:25 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:25:23\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mtemp\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4d0mp2xa.scala:26:24 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mtemp2\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mtemp3\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:28:24\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1660009574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val sorted = arr.sortBy(_)\n        val first = sorted.head\n       \
    \ val last = sorted.last\n        val result = if (first > last) false else true\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp73vprozo.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E081] Type Error: /tmp/tmp73vprozo.scala:24:32 -----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36msorted\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \  Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 =>\
    \ arr.sortBy(_$1).\n2 errors found\n"
  stdout: ''
  timestamp: 1660009569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        val left = new Array[Long](n)\n\
    \        val right = new Array[Long](n)\n        val leftCount = new Array[Int](n)\n\
    \        val rightCount = new Array[Int](n)\n        val leftCount2 = new Array[Int](n)\n\
    \        val rightCount2 = new Array[Int](n)\n        val leftCount3 = new Array[Int](n)\n\
    \        val rightCount3 = new Array[Int](n)\n        val leftCount4 = new Array[Int](n)\n\
    \        val rightCount4 = new Array[Int](n)\n        val leftCount5 = new Array[Int](n)\n\
    \        val rightCount5 = new Array[Int](n)\n        val leftCount6 = new Array[Int](n)\n\
    \        val rightCount6 = new Array[Int](n)\n        val leftCount7 = new Array[Int](n)\n\
    \        val rightCount7 = new Array[Int](n)\n        val leftCount8 = new Array[Int](n)\n\
    \        val rightCount8 = new Array[Int](n)\n        val leftCount9 = new Array[Int](n)\n\
    \        val rightCount9 = new Array[Int](n)\n        val leftCount10 = new Array[Int](n)\n\
    \        val rightCount10 = new Array[Int](n)\n        val leftCount11 = new Array[Int](n)\n\
    \        val rightCount11 = new Array[Int](n)\n        val leftCount12 = new Array[Int](n)\n\
    \        val rightCount12 = new Array[Int](n)\n        val leftCount13 = new Array[Int](n)\n\
    \        val rightCount13 = new Array[Int](n)\n        val leftCount14 = new Array[Int](n)\n\
    \        val rightCount14 = new Array[Int](n)\n        val leftCount15 = new Array[Int](n)\n\
    \        val rightCount15 = new Array[Int](n)\n        val leftCount16 = new Array[Int](n)\n\
    \        val rightCount16 = new Array[Int](n)\n        val leftCount17 = new Array[Int](n)\n\
    \        val rightCount17 = new Array[Int](n)\n        val leftCount18 = new Array[Int](n)\n\
    \        val rightCount18 = new Array[Int](n)\n        val leftCount19 = new Array[Int](n)\n\
    \        val rightCount19 = new Array[Int](n)\n        val leftCount20 = new Array[Int](n)\n\
    \        val right\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpayxchpzl.scala:67:4 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpayxchpzl.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpayxchpzl.scala:67:5\
    \ ---------------------\e[0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val temp = new mutable.ListBuffer[Long]()\n\
    \        val temp2 = new mutable.ListBuffer[Long]()\n        val temp3 = new mutable.ListBuffer[Long]()\n\
    \        val temp4 = new mutable.ListBuffer[Long]()\n        val temp5 = new mutable.ListBuffer[Long]()\n\
    \        val temp6 = new mutable.ListBuffer[Long]()\n        val temp7 = new mutable.ListBuffer[Long]()\n\
    \        val temp8 = new mutable.ListBuffer[Long]()\n        val temp9 = new mutable.ListBuffer[Long]()\n\
    \        val temp10 = new mutable.ListBuffer[Long]()\n        val temp11 = new\
    \ mutable.ListBuffer[Long]()\n        val temp12 = new mutable.ListBuffer[Long]()\n\
    \        val temp13 = new mutable.ListBuffer[Long]()\n        val temp14 = new\
    \ mutable.ListBuffer[Long]()\n        val temp15 = new mutable.ListBuffer[Long]()\n\
    \        val temp16 = new mutable.ListBuffer[Long]()\n        val temp17 = new\
    \ mutable.ListBuffer[Long]()\n        val temp18 = new mutable.ListBuffer[Long]()\n\
    \        val temp19 = new mutable.ListBuffer[Long]()\n        val temp20 = new\
    \ mutable.ListBuffer[Long]()\n        val temp21 = new mutable.ListBuffer[Long]()\n\
    \        val temp22 = new mutable.ListBuffer[Long]()\n        val temp23 = new\
    \ mutable.ListBuffer[Long]()\n        val temp24 = new mutable.ListBuffer[Long]()\n\
    \        val temp25 = new mutable.ListBuffer[Long]()\n        val temp26 = new\
    \ mutable.ListBuffer[Long]()\n        val temp27 = new mutable.ListBuffer[Long]()\n\
    \        val temp28 = new mutable.ListBuffer[Long]()\n        val temp29 = new\
    \ mutable.ListBuffer[Long]()\n        val temp30 = new mutable.ListBuffer[Long]()\n\
    \        val temp31 = new mutable.ListBuffer[Long]()\n        val temp32 = new\
    \ mutable.ListBuffer[Long]()\n        val temp33 = new mutable.ListBuffer[Long]()\n\
    \        val temp34 = new mutable.ListBuffer[Long]()\n        val temp35 = new\
    \ mutable.ListBuffer\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4d0mp2xa.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:24:25 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:25:23\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mtemp\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4d0mp2xa.scala:26:24 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mtemp2\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mtemp3\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:28:24\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1660009574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toArray\n        val n =\
    \ arr.length\n        val result = new Array[Boolean](n+1)\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var temp = 0\n        var flag\
    \ = false\n        var temp1 = new Array[Long](n)\n        var temp2 = new Array[Long](n)\n\
    \        var temp3 = new Array[Long](n)\n        var temp4 = new Array[Long](n)\n\
    \        var temp5 = new Array[Long](n)\n        var temp6 = new Array[Long](n)\n\
    \        var temp7 = new Array[Long](n)\n        var temp8 = new Array[Long](n)\n\
    \        var temp9 = new Array[Long](n)\n        var temp10 = new Array[Long](n)\n\
    \        var temp11 = new Array[Long](n)\n        var temp12 = new Array[Long](n)\n\
    \        var temp13 = new Array[Long](n)\n        var temp14 = new Array[Long](n)\n\
    \        var temp15 = new Array[Long](n)\n        var temp16 = new Array[Long](n)\n\
    \        var temp17 = new Array[Long](n)\n        var temp18 = new Array[Long](n)\n\
    \        var temp19 = new Array[Long](n)\n        var temp20 = new Array[Long](n)\n\
    \        var temp21 = new Array[Long](n)\n        var temp22 = new Array[Long](n)\n\
    \        var temp23 = new Array[Long](n)\n        var temp24 = new Array[Long](n)\n\
    \        var temp25 = new Array[Long](n)\n        var temp26 = new Array[Long](n)\n\
    \        var temp27 = new Array[Long](n)\n        var temp28 = new Array[Long](n)\n\
    \        var temp29 = new Array[Long](n)\n        var temp30 = new Array[Long](n)\n\
    \        var temp31 = new Array[Long](n)\n        var temp32 = new Array[Long](n)\n\
    \        var temp33 = new Array[Long](n)\n        var temp34 = new Array[Long](n)\n\
    \        var temp35 = new Array[Long](n)\n        var temp36 = new Array[Long](n)\n\
    \        var temp37 = new Array[Long](n)\n        var temp38 = new Array[Long](n)\n\
    \        var temp39 = new Array[Long](n)\n        var temp40 = new Array[Long](n)\n\
    \        var temp41 = new Array[Long](n)\n        var temp42 = new Array[Long](n)\n\
    \        var temp43 = new Array[Long](n)\n        var temp44 = new Array[Long](n)\n\
    \        var temp45 = new Array[Long](n)\n        var temp46 = new Array[Long](n)\n\
    \        var temp47\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprhhh4uxy.scala:77:4 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprhhh4uxy.scala:22:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprhhh4uxy.scala:77:5\
    \ ---------------------\e[0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = false\n        while(i\
    \ < n) {\n            temp = arr(i)\n            for(j <- i until n) {\n     \
    \           if(arr(j) < temp) {\n                    temp = arr(j)\n         \
    \       }\n            }\n            arr(i) = temp\n            i += 1\n    \
    \        for(j <- i until n) {\n                if(arr(j) < temp) {\n        \
    \            temp = arr(j)\n                }\n            }\n            arr(i)\
    \ = temp\n            i += 1\n            for(j <- i until n) {\n            \
    \    if(arr(j) < temp) {\n                    temp = arr(j)\n                }\n\
    \            }\n            arr(i) = temp\n            i += 1\n            for(j\
    \ <- i until n) {\n                if(arr(j) < temp) {\n                    temp\
    \ = arr(j)\n                }\n            }\n            arr(i) = temp\n    \
    \        i += 1\n            for(j <- i until n) {\n                if(arr(j)\
    \ < temp) {\n                    temp = arr(j)\n                }\n          \
    \  }\n            arr(i) = temp\n            i += 1\n            for(j <- i until\
    \ n) {\n                if(arr(j) < temp) {\n                    temp = arr(j)\n\
    \                }\n            }\n            arr(i) = temp\n            i +=\
    \ 1\n            for(j <- i until n) {\n                if(arr(j) < temp) {\n\
    \                    temp = arr(j)\n                }\n            }\n       \
    \     arr(i) = temp\n            i += 1\n            for(j <- i until n) {\n \
    \               if(arr(j) < temp) {\n                    temp = arr(j)\n     \
    \           }\n            }\n            arr(i) = temp\n            i += 1\n\
    \            for(j <- i until n) {\n                if(arr(j) < temp) {\n    \
    \                temp = arr(j)\n                }\n            }\n           \
    \ arr(i) = temp\n            i += 1\n            for(j <- i until n) {\n     \
    \           if(arr(j) < temp) {\n                    temp = arr(j)\n         \
    \       }\n            }\n            arr(i) = temp\n            i += 1\n    \
    \        for(j <- i until n) {\n                if(arr(j) < temp) {\n        \
    \            temp = arr(j)\n                }\n            }\n            arr(i)\
    \ = temp\n            i += 1\n            for(j <- i until n) {\n            \
    \    if(arr(j) < temp) {\n                    temp = arr(j)\n                }\n\
    \            }\n            arr(i) = temp\n            i += 1\n            for(j\
    \ <- i until n) {\n                if(arr(j) < temp) {\n                    temp\
    \ = arr(j)\n                }\n            }\n            \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmomzzyzp.scala:132:0 ---------------------------\e\
    [0m\e[0m\n\e[31m132 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmomzzyzp.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmomzzyzp.scala:131:1\
    \ --------------------\e[0m\e[0m\n\e[31m131 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: Boolean\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpmomzzyzp.scala:123:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m123 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val sortedArr = arr.sortBy(_)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.take\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0wla7kue.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0wla7kue.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0wla7kue.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.takeRight(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0wla7kue.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0wla7kue.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.takeRight(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msortedArr i"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.sortBy(_)\n        val arr2 = arr.toList\n        val arr3\
    \ = arr2.reverse\n        val arr4 = arr3.take(n)\n        val arr5 = arr4.sortBy(_)\n\
    \        val arr6 = arr5.toList\n        val arr7 = arr6.reverse\n        val\
    \ arr8 = arr7.take(n)\n        val arr9 = arr8.sortBy(_)\n        val arr10 =\
    \ arr9.toList\n        val arr11 = arr10.reverse\n        val arr12 = arr11.toList\n\
    \        val arr13 = arr12.reverse\n        val arr14 = arr13.toList\n       \
    \ val arr15 = arr14.reverse\n        val arr16 = arr15.toList\n        val arr17\
    \ = arr16.reverse\n        val arr18 = arr17.toList\n        val arr19 = arr18.reverse\n\
    \        val arr20 = arr19.toList\n        val arr21 = arr20.reverse\n       \
    \ val arr22 = arr21.toList\n        val arr23 = arr22.reverse\n        val arr24\
    \ = arr23.toList\n        val arr25 = arr24.reverse\n        val arr26 = arr25.toList\n\
    \        val arr27 = arr26.reverse\n        val arr28 = arr27.toList\n       \
    \ val arr29 = arr28.reverse\n        val arr30 = arr29.toList\n        val arr31\
    \ = arr30.reverse\n        val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n\
    \        val arr34 = arr33.toList\n        val arr35 = arr34.reverse\n       \
    \ val arr36 = arr35.toList\n        val arr37 = arr36.reverse\n        val arr38\
    \ = arr37.toList\n        val arr39 = arr38.reverse\n        val arr40 = arr39.toList\n\
    \        val arr41 = arr40.reverse\n        val arr42 = arr41.toList\n       \
    \ val arr43 = arr42.reverse\n        val arr44 = arr43.toList\n        val arr45\
    \ = arr44.reverse\n        val arr46 = arr45.toList\n        val arr47 = arr46.reverse\n\
    \        val arr48 = arr47.toList\n        val arr49 = arr48.reverse\n       \
    \ val arr50 = arr49.toList\n        val arr51 = arr50.reverse\n        val arr52\
    \ = arr51.toList\n        val arr53 = arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8hmhax6q.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp8hmhax6q.scala:22:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp8hmhax6q.scala:28:31\
    \ -----------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e\
    [0m \e[36marr5\e[0m = arr4.sortBy(_)\n\e[31m\e[31m   |\e[0m                  \
    \             ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m   I could not infer the type of the parameter _$2 of expanded\
    \ function:\n\e[31m   |\e[0m   _$2 => arr4.sortBy(_$2).\n\e[31m\e[31m-- [E081]\
    \ Type Error: /tmp/tmp8hmhax6q.scala:32:31 -----------------------------\e[0m\e\
    [0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr9\e[0m = arr8.sortBy(_)\n\e\
    [31m\e[31m   |\e[0m                               ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$3 of expanded function:\n\e[31m   |\e[0m   _$3 => arr8.sortBy(_$3).\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8hmhax6q.scala:77:5 ---------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val sortedArr = arr.sortBy(x => x)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzaodmce9.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzaodmce9.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzaodmce9.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.takeRight(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzaodmce9.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzaodmce9.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already de"
  stdout: ''
  timestamp: 1660009573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 =\
    \ arr2.reverse\n        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n\
    \        val arr6 = arr5.toList\n        val arr7 = arr6.reverse\n        val\
    \ arr8 = arr7.toList\n        val arr9 = arr8.toList\n        val arr10 = arr9.reverse\n\
    \        val arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val\
    \ arr13 = arr12.reverse\n        val arr14 = arr13.toList\n        val arr15 =\
    \ arr14.toList\n        val arr16 = arr15.reverse\n        val arr17 = arr16.toList\n\
    \        val arr18 = arr17.toList\n        val arr19 = arr18.reverse\n       \
    \ val arr20 = arr19.toList\n        val arr21 = arr20.reverse\n        val arr22\
    \ = arr21.toList\n        val arr23 = arr22.reverse\n        val arr24 = arr23.toList\n\
    \        val arr25 = arr24.reverse\n        val arr26 = arr25.toList\n       \
    \ val arr27 = arr26.reverse\n        val arr28 = arr27.toList\n        val arr29\
    \ = arr28.reverse\n        val arr30 = arr29.toList\n        val arr31 = arr30.reverse\n\
    \        val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n       \
    \ val arr34 = arr33.toList\n        val arr35 = arr34.reverse\n        val arr36\
    \ = arr35.toList\n        val arr37 = arr36.reverse\n        val arr38 = arr37.toList\n\
    \        val arr39 = arr38.reverse\n        val arr40 = arr39.toList\n       \
    \ val arr41 = arr40.reverse\n        val arr42 = arr41.toList\n        val arr43\
    \ = arr42.reverse\n        val arr44 = arr43.toList\n        val arr45 = arr44.reverse\n\
    \        val arr46 = arr45.toList\n        val arr47 = arr46.reverse\n       \
    \ val arr48 = arr47.toList\n        val arr49 = arr48.reverse\n        val arr50\
    \ = arr49.toList\n        val arr51 = arr50.reverse\n        val arr52 = arr51.toList\n\
    \        val arr53 = arr52.reverse\n        val arr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjoc4od3l.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjoc4od3l.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjoc4od3l.scala:78:5\
    \ ---------------------\e[0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        val arr = arr.toList\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n\
    \        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n       \
    \ var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8\
    \ = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n\
    \        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n    \
    \    var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var\
    \ temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21\
    \ = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n\
    \        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n    \
    \    var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var\
    \ temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34\
    \ = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n\
    \        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n    \
    \    var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var\
    \ temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47\
    \ = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n\
    \        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n    \
    \    var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var\
    \ temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60\
    \ = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n\
    \        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n    \
    \    var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var\
    \ temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73\
    \ = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n\
    \        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n    \
    \    var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var\
    \ temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86\
    \ = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\
    \        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n    \
    \    var temp93 = 0\n        var temp94 = 0\n        var temp95\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5283dng5.scala:124:4 ---------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5283dng5.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5283dng5.scala:124:5\
    \ --------------------\e[0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val result = new Array[Boolean](n + 1)\n        val left = new Array[Long](n\
    \ + 1)\n        val right = new Array[Long](n + 1)\n        val leftIndex = 0\n\
    \        val rightIndex = 0\n        val leftCount = 0\n        val rightCount\
    \ = 0\n        val leftMax = arr.max\n        val rightMax = arr.max\n       \
    \ val leftMin = arr.min\n        val rightMin = arr.min\n        val leftSum =\
    \ arr.sum\n        val rightSum = arr.sum\n        val leftSumOfRight = rightSum\
    \ - rightMin\n        val rightSumOfLeft = leftSum - leftMin\n        val leftSumOfRightOfLeft\
    \ = leftSumOfRight - leftMax\n        val rightSumOfLeftOfRight = rightSumOfLeft\
    \ - rightMax\n        val leftSumOfRightOfLeftOfRight = leftSumOfRightOfLeft -\
    \ leftMin\n        val rightSumOfLeftOfRightOfLeftOfRight = rightSumOfLeftOfRightOfLeft\
    \ - rightMax\n        val leftSumOfRightOfLeftOfRightOfLeftOfRight = leftSumOfRightOfLeftOfRightOfLeftOfRight\
    \ - leftMin\n        val rightSumOfLeftOfRightOfLeftOfRightOfLeftOfRight = rightSumOfLeftOfRightOfLeftOfRightOfLeftOfRight\
    \ - rightMax\n        val leftSumOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRight\
    \ = leftSumOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRight - leftMin\n        val\
    \ rightSumOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRight = rightSumOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRight\
    \ - rightMax\n        val leftSumOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRight\
    \ = leftSumOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRight - leftMin\n\
    \        val rightSumOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOfRightOfLeftOf\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbpy032b7.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbpy032b7.scala:22:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbpy032b7.scala:42:49\
    \ ------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e\
    [36mrightSumOfLeftOfRightOfLeftOfRight\e[0m = rightSumOfLeftOfRightOfLeft - rightMax\n\
    \e[31m\e[31m   |\e[0m                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Not found: rightSumOfLeftOfRightOfLeft\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbpy032b7.scala:43:55\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mleftSumOfRightOfLeftOfRightOfLeftOfRight\e[0m = leftSumOfRightOfLeftOfRightOfLeftOfRight\
    \ - leftMin\n\e[31m\e[31m   |\e[0m                                           \
    \            ^\e[0m\n\e[31m   |\e[0m     Recursive \e[33mvalue\e[0m \e[35mleftSumOfRightOfLeftOfRightOfLeftOfRight\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpbpy032b7.scala:44:62\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightSumOfLeftOfRightOfLeftOfRightOfLeftOfRight\e[0m = rightSumOfLeftOfRightOfLeftOfRightOfLeftOfRight\
    \ - rightMax\n\e[31m\e[31m   |\e[0m                                          \
    \                    ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mrightSumOfLeftOfRightOfLeftOfRightOfLeftOfRight\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation "
  stdout: ''
  timestamp: 1660009583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 =\
    \ arr2.reverse\n        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n\
    \        val arr6 = arr5.toList\n        val arr7 = arr6.reverse\n        val\
    \ arr8 = arr7.toList\n        val arr9 = arr8.toList\n        val arr10 = arr9.reverse\n\
    \        val arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val\
    \ arr13 = arr12.reverse\n        val arr14 = arr13.toList\n        val arr15 =\
    \ arr14.toList\n        val arr16 = arr15.reverse\n        val arr17 = arr16.toList\n\
    \        val arr18 = arr17.toList\n        val arr19 = arr18.reverse\n       \
    \ val arr20 = arr19.toList\n        val arr21 = arr20.toList\n        val arr22\
    \ = arr21.reverse\n        val arr23 = arr22.toList\n        val arr24 = arr23.toList\n\
    \        val arr25 = arr24.reverse\n        val arr26 = arr25.toList\n       \
    \ val arr27 = arr26.toList\n        val arr28 = arr27.reverse\n        val arr29\
    \ = arr28.toList\n        val arr30 = arr29.toList\n        val arr31 = arr30.reverse\n\
    \        val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n       \
    \ val arr34 = arr33.toList\n        val arr35 = arr34.reverse\n        val arr36\
    \ = arr35.toList\n        val arr37 = arr36.reverse\n        val arr38 = arr37.toList\n\
    \        val arr39 = arr38.reverse\n        val arr40 = arr39.toList\n       \
    \ val arr41 = arr40.reverse\n        val arr42 = arr41.toList\n        val arr43\
    \ = arr42.reverse\n        val arr44 = arr43.toList\n        val arr45 = arr44.reverse\n\
    \        val arr46 = arr45.toList\n        val arr47 = arr46.reverse\n       \
    \ val arr48 = arr47.toList\n        val arr49 = arr48.reverse\n        val arr50\
    \ = arr49.toList\n        val arr51 = arr50.reverse\n        val arr52 = arr51.toList\n\
    \        val arr53 = arr52.reverse\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmg0ji000.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpmg0ji000.scala:78:5 ---------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009585
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else if(arr.size\
    \ == 1) true\n        else {\n            val sortedArr = arr.sortBy(x => x)\n\
    \            val newArr = arr.filterNot(x => x == sortedArr(0))\n            val\
    \ newSortedArr = newArr.sortBy(x => x)\n            if(newSortedArr == sortedArr)\
    \ true\n            else false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp0nktbcjn.scala:33)\n\tat Problem.main(tmp0nktbcjn.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Boolean](n+1)\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var temp = 0\n        var flag = false\n \
    \       var temp2 = 1\n        var temp3 = 1\n        var temp4 = 1\n        var\
    \ temp5 = 1\n        var temp6 = 1\n        var temp7 = 1\n        var temp8 =\
    \ 1\n        var temp9 = 1\n        var temp10 = 1\n        var temp11 = 1\n \
    \       var temp12 = 1\n        var temp13 = 1\n        var temp14 = 1\n     \
    \   var temp15 = 1\n        var temp16 = 1\n        var temp17 = 1\n        var\
    \ temp18 = 1\n        var temp19 = 1\n        var temp20 = 1\n        var temp21\
    \ = 1\n        var temp22 = 1\n        var temp23 = 1\n        var temp24 = 1\n\
    \        var temp25 = 1\n        var temp26 = 1\n        var temp27 = 1\n    \
    \    var temp28 = 1\n        var temp29 = 1\n        var temp30 = 1\n        var\
    \ temp31 = 1\n        var temp32 = 1\n        var temp33 = 1\n        var temp34\
    \ = 1\n        var temp35 = 1\n        var temp36 = 1\n        var temp37 = 1\n\
    \        var temp38 = 1\n        var temp39 = 1\n        var temp40 = 1\n    \
    \    var temp41 = 1\n        var temp42 = 1\n        var temp43 = 1\n        var\
    \ temp44 = 1\n        var temp45 = 1\n        var temp46 = 1\n        var temp47\
    \ = 1\n        var temp48 = 1\n        var temp49 = 1\n        var temp50 = 1\n\
    \        var temp51 = 1\n        var temp52 = 1\n        var temp53 = 1\n    \
    \    var temp54 = 1\n        var temp55 = 1\n        var temp56 = 1\n        var\
    \ temp57 = 1\n        var temp58 = 1\n        var temp59 = 1\n        var temp60\
    \ = 1\n        var temp61 = 1\n        var temp62 = 1\n        var temp63 = 1\n\
    \        var temp64 = 1\n        var temp65 = 1\n        var temp66 = 1\n    \
    \    var temp67 = 1\n        var temp68 = 1\n        var temp69 = 1\n        var\
    \ temp70 = 1\n        var temp71 = 1\n        var temp72 = 1\n        var temp73\
    \ = 1\n        var temp74 = 1\n        var temp75 = 1\n        var temp76 = 1\n\
    \        var temp77 = 1\n        var temp78 = 1\n        var temp79 = 1\n    \
    \    var temp80 = 1\n        var temp81 = 1\n        var temp82 = 1\n        var\
    \ temp83 = 1\n        var temp84 = 1\n        var temp85 = 1\n        var temp86\
    \ = 1\n        var temp87 = 1\n        var temp88 = 1\n        var temp89 = 1\n\
    \        var temp90 = 1\n        var temp91 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp4z6rrqow.scala:119:20 --------------------------\e\
    [0m\e[0m\n\e[31m119 |\e[0m        \e[33mvar\e[0m \e[36mtemp91\e[0m = \n\e[31m\e\
    [31m    |\e[0m                    ^\e[0m\n\e[31m    |\e[0m                   \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m    |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp4z6rrqow.scala:120:5 --------------------\e\
    [0m\e[0m\n\e[31m120 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else {\n\
    \            val n = arr.size\n            val arr = arr.toList\n            val\
    \ first = arr(0)\n            val last = arr(n-1)\n            val mid = arr(n/2)\n\
    \            val left = new Array[Long](n-1)\n            val right = new Array[Long](n-1)\n\
    \            val leftIndex = 0\n            val rightIndex = 0\n            val\
    \ leftCount = 1\n            val rightCount = 1\n            while(leftCount <\
    \ n && rightCount < n) {\n                if(mid < first) {\n                \
    \    left.put(leftIndex, mid)\n                    leftCount += 1\n          \
    \          leftIndex += 1\n                }\n                else if(mid > last)\
    \ {\n                    right.put(rightIndex, mid)\n                    rightCount\
    \ += 1\n                    rightIndex += 1\n                }\n             \
    \   else {\n                    left.put(leftIndex, mid)\n                   \
    \ leftCount += 1\n                    leftIndex += 1\n                    right.put(rightIndex,\
    \ mid)\n                    rightCount += 1\n                    rightIndex +=\
    \ 1\n                }\n            }\n            val leftSorted = left.toList\n\
    \            val rightSorted = right.toList\n            val leftIndex = 0\n \
    \           val rightIndex = 0\n            val leftCount = 1\n            val\
    \ rightCount = 1\n            while(leftCount < n && rightCount < n) {\n     \
    \           if(leftSorted(leftIndex) < rightSorted(rightIndex)) {\n          \
    \          left.put(leftIndex, leftSorted(leftIndex))\n                    leftCount\
    \ += 1\n                    leftIndex += 1\n                }\n              \
    \  else {\n                    right.put(rightIndex, rightSorted(rightIndex))\n\
    \                    rightCount += 1\n                    rightIndex += 1\n  \
    \              }\n            }\n            val leftSorted = left.toList\n  \
    \          val rightSorted = right.toList\n            val leftIndex = 0\n   \
    \         val rightIndex = 0\n            val leftCount = 1\n            val rightCount\
    \ = 1\n            while(leftCount < n && rightCount < n) {\n                if(leftSorted(leftIndex)\
    \ < rightSorted(rightIndex)) {\n                    left.put(leftIndex, leftSorted(leftIndex))\n\
    \                    leftCount += 1\n                    leftIndex += 1\n    \
    \            }\n                else {\n                    right.put(rightIndex,\
    \ rightSorted(rightIndex))\n                    rightCount += 1\n            \
    \        rightIndex += 1\n                }\n            }\n            val leftSorted\
    \ = left.toList\n            val rightSorted = right.toList\n            val leftIndex\
    \ = 0\n            val rightIndex = 0\n            val leftCount = 1\n       \
    \     val rightCount = 1\n            while(leftCount < n && rightCount < n) {\n\
    \                if(leftSorted(leftIndex) < rightSorted(rightIndex)) {\n     \
    \               left.put(leftIndex, \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbfzjj_bs.scala:100:4 ---------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbfzjj_bs.scala:110:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m110 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmpbfzjj_bs.scala:57:16 ---------------------------\e[0m\e\
    [0m\n\e[31m57 |\e[0m            \e[33mval\e[0m \e[36mleftIndex\e[0m = \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftIndex\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbfzjj_bs.scala:58:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m58 |\e[0m            \e[33mval\e\
    [0m \e[36mrightIndex\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightIndex is already defined as \e[33mvalue\e[0m \e[35mrightIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbfzjj_bs.scala:59:16 ---------------------------\e[0m\e[0m\n\e\
    [31m59 |\e[0m            \e[33mval\e[0m \e[36mleftCount\e[0m = \e[31m1\e[0m\n\e\
    [31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbfzjj_bs.scala:60:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m60 |\e[0m            \e[33mval\e\
    [0m \e[36mrightCount\e[0m = \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightCount is already defined as \e[33mvalue\e[0m \e[35mrightCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel defin"
  stdout: ''
  timestamp: 1660009590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n\
    \        else {\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val firstIndex = arr.indexOf(first)\n            val lastIndex =\
    \ arr.indexOf(last)\n            val temp = arr(firstIndex)\n            arr(firstIndex)\
    \ = arr(lastIndex) \n            arr(lastIndex) = temp\n            moveOneBall(arr.tail)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpwkd8l89v.scala:30:12 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            arr(firstIndex) = arr(lastIndex) \n\e[31m\e\
    [31m   |\e[0m            ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpwkd8l89v.scala:31:12 ------------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m            arr(lastIndex) = temp\n\e[31m\e[31m   |\e[0m            ^^^\e[0m\n\
    \e[31m   |\e[0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val arr1 = arr.toArray\n        val arr2 = arr1.slice(1, n).reverse\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.slice(1, n).reverse\n\
    \        val arr5 = arr4.slice(1, n).reverse\n        val arr6 = arr5.slice(1,\
    \ n).reverse\n        val arr7 = arr6.slice(1, n).reverse\n        val arr8 =\
    \ arr7.slice(1, n).reverse\n        val arr9 = arr8.slice(1, n).reverse\n    \
    \    val arr10 = arr9.slice(1, n).reverse\n        val arr11 = arr10.slice(1,\
    \ n).reverse\n        val arr12 = arr11.slice(1, n).reverse\n        val arr13\
    \ = arr12.slice(1, n).reverse\n        val arr14 = arr13.slice(1, n).reverse\n\
    \        val arr15 = arr14.slice(1, n).reverse\n        val arr16 = arr15.slice(1,\
    \ n).reverse\n        val arr17 = arr16.slice(1, n).reverse\n        val arr18\
    \ = arr17.slice(1, n).reverse\n        val arr19 = arr18.slice(1, n).reverse\n\
    \        val arr20 = arr19.slice(1, n).reverse\n        val arr21 = arr20.slice(1,\
    \ n).reverse\n        val arr22 = arr21.slice(1, n).reverse\n        val arr23\
    \ = arr22.slice(1, n).reverse\n        val arr24 = arr23.slice(1, n).reverse\n\
    \        val arr25 = arr24.slice(1, n).reverse\n        val arr26 = arr25.slice(1,\
    \ n).reverse\n        val arr27 = arr26.slice(1, n).reverse\n        val arr28\
    \ = arr27.slice(1, n).reverse\n        val arr29 = arr28.slice(1, n).reverse\n\
    \        val arr30 = arr29.slice(1, n).reverse\n        val arr31 = arr30.slice(1,\
    \ n).reverse\n        val arr32 = arr31.slice(1, n).reverse\n        val arr33\
    \ = arr32.slice(1, n).reverse\n        val arr34 = arr33.slice(1, n).reverse\n\
    \        val arr35 = arr34.slice(1, n).reverse\n        val arr36 = arr35.slice(1,\
    \ n).reverse\n        val arr37 = arr36.slice(1, n).reverse\n        val arr38\
    \ = arr37.slice(1, n).reverse\n        val arr39 = arr38.slice(1, n).reverse\n\
    \        val arr40 = arr39.slice(1, n).\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsrzm8htm.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpsrzm8htm.scala:23:18 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsrzm8htm.scala:64:5 ---------------------\e[0m\e[0m\n\e[31m64\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        val temp2 = new Array[Long](n)\n        val temp3 = new Array[Long](n)\n\
    \        val temp4 = new Array[Long](n)\n        val temp5 = new Array[Long](n)\n\
    \        val temp6 = new Array[Long](n)\n        val temp7 = new Array[Long](n)\n\
    \        val temp8 = new Array[Long](n)\n        val temp9 = new Array[Long](n)\n\
    \        val temp10 = new Array[Long](n)\n        val temp11 = new Array[Long](n)\n\
    \        val temp12 = new Array[Long](n)\n        val temp13 = new Array[Long](n)\n\
    \        val temp14 = new Array[Long](n)\n        val temp15 = new Array[Long](n)\n\
    \        val temp16 = new Array[Long](n)\n        val temp17 = new Array[Long](n)\n\
    \        val temp18 = new Array[Long](n)\n        val temp19 = new Array[Long](n)\n\
    \        val temp20 = new Array[Long](n)\n        val temp21 = new Array[Long](n)\n\
    \        val temp22 = new Array[Long](n)\n        val temp23 = new Array[Long](n)\n\
    \        val temp24 = new Array[Long](n)\n        val temp25 = new Array[Long](n)\n\
    \        val temp26 = new Array[Long](n)\n        val temp27 = new Array[Long](n)\n\
    \        val temp28 = new Array[Long](n)\n        val temp29 = new Array[Long](n)\n\
    \        val temp30 = new Array[Long](n)\n        val temp31 = new Array[Long](n)\n\
    \        val temp32 = new Array[Long](n)\n        val temp33 = new Array[Long](n)\n\
    \        val temp34 = new Array[Long](n)\n        val temp35 = new Array[Long](n)\n\
    \        val temp36 = new Array[Long](n)\n        val temp37 = new Array[Long](n)\n\
    \        val temp38 = new Array[Long](n)\n        val temp39 = new Array[Long](n)\n\
    \        val temp40 = new Array[Long](n)\n        val temp41 = new Array[Long](n)\n\
    \        val temp42 = new Array[Long](n)\n        val temp43 = new Array[Long](n)\n\
    \        val temp44 = new Array[Long](n)\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpasqfrun5.scala:69:11 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpasqfrun5.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val sortedArr = arr.sortBy(x => x)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwauonjcx.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwauonjcx.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpwauonjcx.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.takeRight(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwauonjcx.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwauonjcx.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already de"
  stdout: ''
  timestamp: 1660009587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 =\
    \ arr2.reverse\n        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n\
    \        val arr6 = arr5.toList\n        val arr7 = arr6.reverse\n        val\
    \ arr8 = arr7.toList\n        val arr9 = arr8.toList\n        val arr10 = arr9.reverse\n\
    \        val arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val\
    \ arr13 = arr12.reverse\n        val arr14 = arr13.toList\n        val arr15 =\
    \ arr14.toList\n        val arr16 = arr15.reverse\n        val arr17 = arr16.toList\n\
    \        val arr18 = arr17.toList\n        val arr19 = arr18.reverse\n       \
    \ val arr20 = arr19.toList\n        val arr21 = arr20.toList\n        val arr22\
    \ = arr21.reverse\n        val arr23 = arr22.toList\n        val arr24 = arr23.toList\n\
    \        val arr25 = arr24.reverse\n        val arr26 = arr25.toList\n       \
    \ val arr27 = arr26.toList\n        val arr28 = arr27.reverse\n        val arr29\
    \ = arr28.toList\n        val arr30 = arr29.toList\n        val arr31 = arr30.reverse\n\
    \        val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n       \
    \ val arr34 = arr33.toList\n        val arr35 = arr34.reverse\n        val arr36\
    \ = arr35.toList\n        val arr37 = arr36.reverse\n        val arr38 = arr37.toList\n\
    \        val arr39 = arr38.reverse\n        val arr40 = arr39.toList\n       \
    \ val arr41 = arr40.reverse\n        val arr42 = arr41.toList\n        val arr43\
    \ = arr42.reverse\n        val arr44 = arr43.toList\n        val arr45 = arr44.reverse\n\
    \        val arr46 = arr45.toList\n        val arr47 = arr46.reverse\n       \
    \ val arr48 = arr47.toList\n        val arr49 = arr48.reverse\n        val arr50\
    \ = arr49.toList\n        val arr51 = arr50.reverse\n        val arr52 = arr51.toList\n\
    \        val arr53 = arr52.reverse\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpmg0ji000.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpmg0ji000.scala:78:5 ---------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009585
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val arr2 = arr.toArray\n        val arr3 = arr2.toList\n        val arr4\
    \ = arr3.toArray\n        val arr5 = arr4.toList\n        val arr6 = arr5.toArray\n\
    \        val arr7 = arr6.toList\n        val arr8 = arr7.toArray\n        val\
    \ arr9 = arr8.toList\n        val arr10 = arr9.toArray\n        val arr11 = arr10.toList\n\
    \        val arr12 = arr11.toArray\n        val arr13 = arr12.toList\n       \
    \ val arr14 = arr13.toArray\n        val arr15 = arr14.toList\n        val arr16\
    \ = arr15.toArray\n        val arr17 = arr16.toList\n        val arr18 = arr17.toArray\n\
    \        val arr19 = arr18.toList\n        val arr20 = arr19.toArray\n       \
    \ val arr21 = arr20.toList\n        val arr22 = arr21.toArray\n        val arr23\
    \ = arr22.toList\n        val arr24 = arr23.toArray\n        val arr25 = arr24.toList\n\
    \        val arr26 = arr25.toArray\n        val arr27 = arr26.toList\n       \
    \ val arr28 = arr27.toArray\n        val arr29 = arr28.toList\n        val arr30\
    \ = arr29.toArray\n        val arr31 = arr30.toList\n        val arr32 = arr31.toArray\n\
    \        val arr33 = arr32.toList\n        val arr34 = arr33.toArray\n       \
    \ val arr35 = arr34.toList\n        val arr36 = arr35.toArray\n        val arr37\
    \ = arr36.toList\n        val arr38 = arr37.toArray\n        val arr39 = arr38.toList\n\
    \        val arr40 = arr39.toArray\n        val arr41 = arr40.toList\n       \
    \ val arr42 = arr41.toArray\n        val arr43 = arr42.toList\n        val arr44\
    \ = arr43.toArray\n        val arr45 = arr44.toList\n        val arr46 = arr45.toArray\n\
    \        val arr47 = arr46.toList\n        val arr48 = arr47.toArray\n       \
    \ val arr49 = arr48.toList\n        val arr50 = arr49.toArray\n        val arr51\
    \ = arr50.toList\n        val arr52 = arr5\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk039vu38.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpk039vu38.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.drop(arr.length-1)\n        val arr = arr.take(arr.length-1)\n   \
    \     val arr = arr.toList\n        val arr = arr.sortBy(\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpd35sy679.scala:78:29 ---------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd35sy679.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd35sy679.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpd35sy679.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd35sy679.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.take(arr.length-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel def"
  stdout: ''
  timestamp: 1660009587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = false\n        while(i\
    \ < n && j < n) {\n            temp = arr(i)\n            arr(i) = arr(j)\n  \
    \          arr(j) = temp\n            i += 1\n            j += 1\n        }\n\
    \        while(i < n) {\n            arr(i) = arr(n - 1)\n            i += 1\n\
    \        }\n        while(j < n) {\n            arr(j) = arr(0)\n            j\
    \ += 1\n        }\n        for(i = 1 until n) {\n            for(j = 0 until n)\
    \ {\n                k = i\n                while(k >= 0 && arr(k) > arr(j)) {\n\
    \                    arr(k) = arr(k)\n                    k -= 1\n           \
    \     }\n                k = j\n                while(k >= 0 && arr(k) > arr(i))\
    \ {\n                    arr(k) = arr(k)\n                    k -= 1\n       \
    \         }\n            }\n        }\n        for(i = 1 until n) {\n        \
    \    for(j = 0 until n) {\n                k = i\n                while(k >= 0\
    \ && arr(k) > arr(j)) {\n                    arr(k) = arr(k)\n               \
    \     k -= 1\n                }\n                k = j\n                while(k\
    \ >= 0 && arr(k) > arr(i)) {\n                    arr(k) = arr(k)\n          \
    \          k -= 1\n                }\n            }\n        }\n        for(i\
    \ = 1 until n) {\n            for(j = 0 until n) {\n                k = i\n  \
    \              while(k >= 0 && arr(k) > arr(j)) {\n                    arr(k)\
    \ = arr(k)\n                    k -= 1\n                }\n                k =\
    \ j\n                while(k >= 0 && arr(k) > arr(i)) {\n                    arr(k)\
    \ = arr(k)\n                    k -= 1\n                }\n            }\n   \
    \     }\n        for(i = 1 until n) {\n            for(j = 0 until n) {\n    \
    \            k = i\n                while(k >= 0 && arr(k) > arr(j)) {\n     \
    \               arr(k) = arr(k)\n                    k -= 1\n                }\n\
    \                k = j\n                while(k >= 0 && arr(k) > arr(i)) {\n \
    \                   arr(k) = arr(k)\n                    k -= 1\n            \
    \    }\n            }\n        }\n        for(i = 1 until n) {\n            for(j\
    \ = 0 until n) {\n                k = i\n                while(k >= 0 && arr(k)\
    \ > arr(j)) {\n                    arr(k) = arr(k)\n                    k -= 1\n\
    \                }\n                k = j\n                while(k >= 0 && arr(k)\
    \ > arr(i)) {\n                    arr(k) = arr(k)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_nzmp6ba.scala:45:14 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mfor\e[0m(i = \e[31m1\e[0m until n) {\n\e\
    [31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m              ')' expected,\
    \ but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_nzmp6ba.scala:45:27\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mfor\e[0m(i\
    \ = \e[31m1\e[0m until n) {\n\e[31m\e[31m   |\e[0m                           ^\e\
    [0m\n\e[31m   |\e[0m                           '<-' expected, but '{' found\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_nzmp6ba.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_nzmp6ba.scala:58:9 -------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        }\n\e[31m\e[31m   |\e[0m         ^\e[0m\n\e[31m\
    \   |\e[0mvalue foreach is not a member of Null, but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import Option.option2Iterable\n\
    \e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m  import collection.LazyZip4.lazyZip4ToIterable\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.iterator asScala\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.map AsScalaConcurrentMap\n\
    \e[31m   |\e[0m  import collection.convert.ImplicitConversions.set asScala\n\e\
    [31m   |\e[0m\n4 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val\
    \ arr = arr.sortBy(x => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkk1j50kj.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkk1j50kj.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkk1j50kj.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpkk1j50kj.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkk1j50kj.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Nam"
  stdout: ''
  timestamp: 1660009587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr1 = arr.toList\n        val arr2 =\
    \ arr1.reverse\n        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n\
    \        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val\
    \ arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n\
    \        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n       \
    \ val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14\
    \ = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n\
    \        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n      \
    \  val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21\
    \ = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n\
    \        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n      \
    \  val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28\
    \ = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n\
    \        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n      \
    \  val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35\
    \ = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n\
    \        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n      \
    \  val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42\
    \ = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n\
    \        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n      \
    \  val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49\
    \ = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n\
    \        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n      \
    \  val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr5\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo5z31xtb.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo5z31xtb.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo5z31xtb.scala:81:5\
    \ ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = false\n        var\
    \ temp2 = 1\n        var temp3 = 0\n        var temp4 = 0\n        var temp5 =\
    \ 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n   \
    \     var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n        var\
    \ temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n        var temp15\
    \ = 0\n        var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n\
    \        var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n    \
    \    var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n        var\
    \ temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n        var temp28\
    \ = 0\n        var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n\
    \        var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n    \
    \    var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n        var\
    \ temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n        var temp41\
    \ = 0\n        var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n\
    \        var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n    \
    \    var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n        var\
    \ temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n        var temp54\
    \ = 0\n        var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n\
    \        var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n    \
    \    var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n        var\
    \ temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n        var temp67\
    \ = 0\n        var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n\
    \        var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n    \
    \    var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n        var\
    \ temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n        var temp80\
    \ = 0\n        var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n\
    \        var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n    \
    \    var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n        var\
    \ temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n        var temp93\
    \ = 0\n        var temp94 = 0\n        var temp95 = 0\n        var \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpzdtbke_c.scala:124:11 --------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzdtbke_c.scala:125:5 --------------------\e\
    [0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val s = arr.tail\n        val d = new Array[Long](n)\n        val r =\
    \ new Array[Long](n)\n        val t = new Array[Long](n)\n        val u = new\
    \ Array[Long](n)\n        val v = new Array[Long](n)\n        val w = new Array[Long](n)\n\
    \        val x = new Array[Long](n)\n        val y = new Array[Long](n)\n    \
    \    val z = new Array[Long](n)\n        val a = new Array[Long](n)\n        val\
    \ b = new Array[Long](n)\n        val c = new Array[Long](n)\n        val d =\
    \ new Array[Long](n)\n        val e = new Array[Long](n)\n        val f = new\
    \ Array[Long](n)\n        val g = new Array[Long](n)\n        val h = new Array[Long](n)\n\
    \        val i = new Array[Long](n)\n        val j = new Array[Long](n)\n    \
    \    val k = new Array[Long](n)\n        val l = new Array[Long](n)\n        val\
    \ m = new Array[Long](n)\n        val n = new Array[Long](n)\n        val o =\
    \ new Array[Long](n)\n        val p = new Array[Long](n)\n        val q = new\
    \ Array[Long](n)\n        val r = new Array[Long](n)\n        val s = new Array[Long](n)\n\
    \        val t = new Array[Long](n)\n        val u = new Array[Long](n)\n    \
    \    val v = new Array[Long](n)\n        val w = new Array[Long](n)\n        val\
    \ x = new Array[Long](n)\n        val y = new Array[Long](n)\n        val z =\
    \ new Array[Long](n)\n        val a = new Array[Long](n)\n        val b = new\
    \ Array[Long](n)\n        val c = new Array[Long](n)\n        val d = new Array[Long](n)\n\
    \        val e = new Array[Long](n)\n        val f = new Array[Long](n)\n    \
    \    val g = new Array[Long](n)\n        val h = new Array[Long](n)\n        val\
    \ i = new Array[Long](n)\n        val j = new Array[Long](n)\n        val k =\
    \ new Array[Long](n)\n        val l = new Array[Long](n)\n        val m = new\
    \ Array[Long](n)\n        val n = new Array[Long](n)\n        val o = new Array\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphgmxgu7m.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0md is already defined as \e[33mvalue\e[0m \e[35md\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphgmxgu7m.scala:46:12 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mm is already defined as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphgmxgu7m.scala:47:12 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphgmxgu7m.scala:51:12 ---------------------------\e[0m\e[0m\n\e[31m51\
    \ |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mr is already defined as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphgmxgu7m.scala:52:12 ---------------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e\
    [35mLong\e[0m](n)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0ms is already defined as \e[33mvalue\e[0m \e[35ms\e[0m\n\e[31m \
    \  |\e[0m\n\e["
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr1.reverse\n        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n\
    \        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val\
    \ arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n\
    \        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n       \
    \ val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14\
    \ = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n\
    \        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n      \
    \  val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21\
    \ = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n\
    \        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n      \
    \  val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28\
    \ = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n\
    \        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n      \
    \  val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35\
    \ = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n\
    \        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n      \
    \  val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42\
    \ = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n\
    \        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n      \
    \  val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49\
    \ = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n\
    \        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n      \
    \  val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr56\
    \ = arr55.reverse\n        val arr57 = arr56.reverse\n        val arr58\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2jh1i6fw.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp2jh1i6fw.scala:80:5 ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val result\
    \ = new Array[Boolean](n)\n        val arr = arr.toList\n        val len = arr.length\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n\
    \        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n       \
    \ var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8\
    \ = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n\
    \        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n    \
    \    var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var\
    \ temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21\
    \ = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n\
    \        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n    \
    \    var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var\
    \ temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34\
    \ = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n\
    \        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n    \
    \    var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var\
    \ temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47\
    \ = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n\
    \        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n    \
    \    var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var\
    \ temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60\
    \ = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n\
    \        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n    \
    \    var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var\
    \ temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73\
    \ = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n\
    \        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n    \
    \    var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var\
    \ temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86\
    \ = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\
    \        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n    \
    \    var temp93 = 0\n        var temp94 = 0\n        var temp95\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpk7xejam7.scala:124:4 ---------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk7xejam7.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk7xejam7.scala:124:5\
    \ --------------------\e[0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var temp = 0\n        var temp1 = 0\n        var temp2 = 0\n    \
    \    var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n        var\
    \ temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9 =\
    \ 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n\
    \        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n    \
    \    var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var\
    \ temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22\
    \ = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n\
    \        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n    \
    \    var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var\
    \ temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35\
    \ = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n\
    \        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n    \
    \    var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var\
    \ temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48\
    \ = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n\
    \        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n    \
    \    var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var\
    \ temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61\
    \ = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n\
    \        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n    \
    \    var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var\
    \ temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74\
    \ = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n\
    \        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n    \
    \    var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var\
    \ temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87\
    \ = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n\
    \        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n    \
    \    var temp94 = 0\n        var temp95 = 0\n        var temp96 = 0\n        var\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp4boj67z2.scala:124:11 --------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4boj67z2.scala:125:5 --------------------\e\
    [0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val sortedArr = arr.sortBy(x => x)\n        val leftArr\
    \ = arr.take(n)\n        val rightArr = arr.drop(n)\n        val leftArrSize =\
    \ leftArr.length\n        val rightArrSize = rightArr.length\n        if (leftArrSize\
    \ == rightArrSize) {\n            val leftArrSorted = leftArr.sortBy(x => x)\n\
    \            val rightArrSorted = rightArr.sortBy(x => x)\n            if (leftArrSorted\
    \ == rightArrSorted) {\n                val leftArrSortedSize = leftArrSorted.length\n\
    \                val rightArrSortedSize = rightArrSorted.length\n            \
    \    if (leftArrSortedSize == rightArrSortedSize) {\n                    val leftArrSortedSortedSize\
    \ = leftArrSorted.sortBy(x => x)\n                    val rightArrSortedSortedSize\
    \ = rightArrSorted.sortBy(x => x)\n                    if (leftArrSortedSortedSize\
    \ == rightArrSortedSortedSize) {\n                        val leftArrSortedSortedSortedSize\
    \ = leftArrSorted.sortBy(x => x)\n                        val rightArrSortedSortedSortedSize\
    \ = rightArrSorted.sortBy(x => x)\n                        if (leftArrSortedSortedSortedSize\
    \ == rightArrSortedSortedSortedSize) {\n                            val leftArrSortedSortedSortedSortedSize\
    \ = leftArrSorted.sortBy(x => x)\n                            val rightArrSortedSortedSortedSortedSize\
    \ = rightArrSorted.sortBy(x => x)\n                            if (leftArrSortedSortedSortedSortedSize\
    \ == rightArrSortedSortedSortedSortedSortedSize) {\n                         \
    \       val leftArrSortedSortedSortedSortedSortedSize = leftArrSorted.sortBy(x\
    \ => x)\n                                val rightArrSortedSortedSortedSortedSortedSize\
    \ = rightArrSorted.sortBy(x => x)\n                                if (leftArrSortedSortedSortedSortedSortedSize\
    \ == rightArrSortedSortedSortedSortedSortedSortedSortedSize) {\n             \
    \                       val leftArrSortedSortedSortedSortedSortedSortedSize =\
    \ leftArrSorted.sortBy(x => x)\n                                    val rightArrSortedSortedSortedSortedSortedSortedSortedSize\
    \ = rightArrSorted.sortBy(x => x)\n                                    if (leftArrSortedSortedSortedSortedSortedSortedSortedSize\
    \ == rightArrSortedSortedSortedSortedSortedSortedSortedSortedSortedSize) {\n \
    \                                       val leftArrSortedSortedSortedSortedSortedSortedSortedSortedSize\
    \ = leftArrSorted.sortBy(x => x)\n                                        val\
    \ rightArrSortedSortedSortedSortedSortedSortedSortedSortedSortedSize = rightArrSorted.sortBy(x\
    \ => x)\n                                        if (leftArrSortedSortedSortedSortedSortedSortedSortedSortedSortedSize\
    \ == rightArrSortedSortedSortedSortedSortedSortedSortedSorted\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj0rns7bh.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj0rns7bh.scala:64:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpj0rns7bh.scala:44:71 ------------------------\e[0m\e[0m\n\
    \e[31m44 |\e[0m                            \e[33mif\e[0m (leftArrSortedSortedSortedSortedSize\
    \ == rightArrSortedSortedSortedSortedSortedSize) {\n\e[31m\e[31m   |\e[0m    \
    \                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Not found: rightArrSortedSortedSortedSortedSortedSize\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj0rns7bh.scala:47:81\
    \ ------------------------\e[0m\e[0m\n\e[31m47 |\e[0m                        \
    \        \e[33mif\e[0m (leftArrSortedSortedSortedSortedSortedSize == rightArrSortedSortedSortedSortedSortedSortedSortedSize)\
    \ {\n\e[31m\e[31m   |\e[0m                                                   \
    \                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m       Not found: rightArrSortedSortedSortedSortedSortedSortedSortedSize\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj0rns7bh.scala:50:40\
    \ ------------------------\e[0m\e[0m\n\e[31m50 |\e[0m                        \
    \            \e[33mif\e[0m (leftArrSortedSortedSortedSortedSortedSortedSortedSize\
    \ == rightArrSortedSortedSortedSortedSortedSortedSortedSortedSortedSize) {\n\e\
    [31m\e[31m   |\e[0m                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Not found: leftArrSortedSortedSortedSortedSortedSortedSortedSize\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation av"
  stdout: ''
  timestamp: 1660009586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr1 = arr.toArray\n        val arr2 = arr1.clone()\n\
    \        val arr3 = arr2.clone()\n        val arr4 = arr3.clone()\n        val\
    \ arr5 = arr4.clone()\n        val arr6 = arr5.clone()\n        val arr7 = arr6.clone()\n\
    \        val arr8 = arr7.clone()\n        val arr9 = arr8.clone()\n        val\
    \ arr10 = arr9.clone()\n        val arr11 = arr10.clone()\n        val arr12 =\
    \ arr11.clone()\n        val arr13 = arr12.clone()\n        val arr14 = arr13.clone()\n\
    \        val arr15 = arr14.clone()\n        val arr16 = arr15.clone()\n      \
    \  val arr17 = arr16.clone()\n        val arr18 = arr17.clone()\n        val arr19\
    \ = arr18.clone()\n        val arr20 = arr19.clone()\n        val arr21 = arr20.clone()\n\
    \        val arr22 = arr21.clone()\n        val arr23 = arr22.clone()\n      \
    \  val arr24 = arr23.clone()\n        val arr25 = arr24.clone()\n        val arr26\
    \ = arr25.clone()\n        val arr27 = arr26.clone()\n        val arr28 = arr27.clone()\n\
    \        val arr29 = arr28.clone()\n        val arr30 = arr29.clone()\n      \
    \  val arr31 = arr30.clone()\n        val arr32 = arr31.clone()\n        val arr33\
    \ = arr32.clone()\n        val arr34 = arr33.clone()\n        val arr35 = arr34.clone()\n\
    \        val arr36 = arr35.clone()\n        val arr37 = arr36.clone()\n      \
    \  val arr38 = arr37.clone()\n        val arr39 = arr38.clone()\n        val arr40\
    \ = arr39.clone()\n        val arr41 = arr40.clone()\n        val arr42 = arr41.clone()\n\
    \        val arr43 = arr42.clone()\n        val arr44 = arr43.clone()\n      \
    \  val arr45 = arr44.clone()\n        val arr46 = arr45.clone()\n        val arr47\
    \ = arr46.clone()\n        val arr48 = arr47.clone()\n        val arr49 = arr48.clone()\n\
    \        val arr50 = arr49.clone()\n        val arr51 = arr50.clone()\n      \
    \  val arr52 = arr51.clone()\n        val arr53 = arr52.clone()\n        val arr54\
    \ = arr53.clone()\n        val arr55 = arr54.clone()\n        val arr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppb3zu6b8.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppb3zu6b8.scala:22:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppb3zu6b8.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new Array[Boolean](n+1)\n        var i = 0\n        var\
    \ j = 0\n        var k = 0\n        var temp = 0\n        while(i < n) {\n   \
    \         while(j < n) {\n                temp = 0\n                while(k <=\
    \ j) {\n                    temp = temp + arr(k)\n                    k = k +\
    \ 1\n                }\n                arr(i) = temp\n                i = i +\
    \ 1\n                j = j + 1\n            }\n            i = i + 1\n       \
    \ }\n        for(i = n - 1; i >= 0; i = i - 1) {\n            while(j >= 0) {\n\
    \                temp = 0\n                while(k <= j) {\n                 \
    \   temp = temp + arr(k)\n                    k = k + 1\n                }\n \
    \               arr(i) = temp\n                i = i - 1\n                j =\
    \ j - 1\n            }\n        }\n        for(i = n - 1; i >= 0; i = i - 1) {\n\
    \            while(j >= 0) {\n                temp = 0\n                while(k\
    \ <= j) {\n                    temp = temp + arr(k)\n                    k = k\
    \ + 1\n                }\n                arr(i) = temp\n                i = i\
    \ - 1\n                j = j - 1\n            }\n        }\n        for(i = n\
    \ - 1; i >= 0; i = i - 1) {\n            while(j >= 0) {\n                temp\
    \ = 0\n                while(k <= j) {\n                    temp = temp + arr(k)\n\
    \                    k = k + 1\n                }\n                arr(i) = temp\n\
    \                i = i - 1\n                j = j - 1\n            }\n       \
    \ }\n        for(i = n - 1; i >= 0; i = i - 1) {\n            while(j >= 0) {\n\
    \                temp = 0\n                while(k <= j) {\n                 \
    \   temp = temp + arr(k)\n                    k = k + 1\n                }\n \
    \               arr(i) = temp\n                i = i - 1\n                j =\
    \ j - 1\n            }\n        }\n        for(i = n - 1; i >= 0; i = i - 1) {\n\
    \            while(j >= 0) {\n                temp = 0\n                while(k\
    \ <= j) {\n                    temp = temp + arr(k)\n                    k = k\
    \ + 1\n                }\n                arr(i) = temp\n                i = i\
    \ - 1\n                j = j - 1\n            }\n        }\n        for(i = n\
    \ - 1; i >= 0; i = i - 1) {\n            while(j >= 0) {\n                temp\
    \ = 0\n                while(k <= j) {\n                    temp = temp + arr(k)\n\
    \                    k = k + 1\n                }\n                arr(i) = temp\n\
    \                i = i - 1\n                j = j - 1\n            }\n       \
    \ }\n        for(i = n - 1; i >= 0; i = i - 1) {\n            while(j >= 0) {\n\
    \                temp = 0\n                while(k <= j) {\n                 \
    \   temp = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvqq41312.scala:42:14 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\
    \e[31m   |\e[0m              ')' expected, but '=' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpvqq41312.scala:42:29 ---------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e[31m0\e\
    [0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                          \
    \   ^\e[0m\n\e[31m   |\e[0m                             '<-' expected, but ';'\
    \ found\n\e[31m\e[31m-- [E020] Syntax Error: /tmp/tmpvqq41312.scala:42:40 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                   \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \        \e[33myield\e[0m or \e[33mdo\e[0m expected\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpvqq41312.scala:54:14 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\
    \e[31m   |\e[0m              ')' expected, but '=' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpvqq41312.scala:54:29 ---------------------------\e[0m\e\
    [0m\n\e[31m54 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e[31m0\e\
    [0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                          \
    \   ^\e[0m\n\e[31m   |\e[0m                             '<-' expected, but ';'\
    \ found\n\e[31m\e[31m-- [E020] Syntax Error: /tmp/tmpvqq41312.scala:54:40 ---------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                   \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \        \e[33myield\e[0m or \e[33mdo\e[0m expected\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when "
  stdout: ''
  timestamp: 1660009592
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr = arr.toList\n        val arr1 =\
    \ arr.toArray\n        val arr2 = arr1.toList\n        val arr3 = arr2.toArray\n\
    \        val arr4 = arr3.toList\n        val arr5 = arr4.toArray\n        val\
    \ arr6 = arr5.toList\n        val arr7 = arr6.toArray\n        val arr8 = arr7.toList\n\
    \        val arr9 = arr8.toArray\n        val arr10 = arr9.toList\n        val\
    \ arr11 = arr10.toArray\n        val arr12 = arr11.toList\n        val arr13 =\
    \ arr12.toArray\n        val arr14 = arr13.toList\n        val arr15 = arr14.toArray\n\
    \        val arr16 = arr15.toList\n        val arr17 = arr16.toArray\n       \
    \ val arr18 = arr17.toList\n        val arr19 = arr18.toArray\n        val arr20\
    \ = arr19.toList\n        val arr21 = arr20.toArray\n        val arr22 = arr21.toList\n\
    \        val arr23 = arr22.toArray\n        val arr24 = arr23.toList\n       \
    \ val arr25 = arr24.toArray\n        val arr26 = arr25.toList\n        val arr27\
    \ = arr26.toArray\n        val arr28 = arr27.toList\n        val arr29 = arr28.toArray\n\
    \        val arr30 = arr29.toList\n        val arr31 = arr30.toArray\n       \
    \ val arr32 = arr31.toList\n        val arr33 = arr32.toArray\n        val arr34\
    \ = arr33.toList\n        val arr35 = arr34.toArray\n        val arr36 = arr35.toList\n\
    \        val arr37 = arr36.toArray\n        val arr38 = arr37.toList\n       \
    \ val arr39 = arr38.toArray\n        val arr40 = arr39.toList\n        val arr41\
    \ = arr40.toArray\n        val arr42 = arr41.toList\n        val arr43 = arr42.toArray\n\
    \        val arr44 = arr43.toList\n        val arr45 = arr44.toArray\n       \
    \ val arr46 = arr45.toList\n        val arr47 = arr46.toArray\n        val arr48\
    \ = arr47.toList\n        val arr49 = arr48.toArray\n        val arr50 = arr49\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptzrkpsk8.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptzrkpsk8.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmptzrkpsk8.scala:76:5 ---------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009590
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:30:12 ----------"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ true\n        else {\n            val arr = arr.sortBy(x => x)\n           \
    \ val first = arr(0)\n            val last = arr(n)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n            val last = arr.drop(n - 1)\n            val first = arr.take(n\
    \ - 1)\n\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpa4sepoc8.scala:92:0 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa4sepoc8.scala:28:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e\
    [0m \e[36mfirst\e[0m = arr.take(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mfirst is already defined\
    \ as \e[33mvalue\e[0m \e[35mfirst\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa4sepoc8.scala:29:16 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m \e[36mlast\e[0m = arr.drop(n\
    \ - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlast is already defined as \e[33mvalue\e[0m \e[35mlast\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa4sepoc8.scala:30:16 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m            \e[33mval\e[0m \e[36mfirst\e[0m = arr.take(n - \e[31m1\e[0m)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mfirst is already defined as \e[33mvalue\e[0m \e[35mfirst\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa4sepoc8.scala:31:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mlast\e[0m = arr.drop(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlast is already defined\
    \ as \e[33mvalue\e[0m \e[35mlast\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa4sepoc8.scala:32:16 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e[0m \e[36mfirst\e[0m = arr."
  stdout: ''
  timestamp: 1660009597
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val result\
    \ = new Array[Boolean](n)\n        val visited = new Array[Boolean](n)\n     \
    \   val visitedIndex = new Array[Int](n)\n        val visitedIndexIndex = new\
    \ Array[Int](n)\n        val visitedIndexIndexIndex = new Array[Int](n)\n    \
    \    val visitedIndexIndexIndexIndex = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndex = new\
    \ Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndex = new\
    \ Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndex =\
    \ new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo5_p_ck0.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpo5_p_ck0.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mvisitedIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mInt\e[0m](n)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvisitedIndexIndexIndexIndexIndexIndexIndexIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mvisitedIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo5_p_ck0.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mvisitedIndexIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mInt\e[0m](n)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvisitedIndexIndexIndexIndexIndexIndexIndexIndexIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mvisitedIndexIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpo5_p_ck0.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mvisitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mInt\e[0m](n)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvisitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mvisitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded m"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:30:12 ----------"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toSet\n        val n = arr.size\n\
    \        val arr = arr.toSeq\n        val arr = arr.toArray\n        val arr =\
    \ arr.toList\n        val arr = arr.toMap\n        val arr = arr.toSet\n     \
    \   val arr = arr.toSeq\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toMap\n        val arr = arr.toSet\n        val arr = arr.toSeq\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.toMap\n        val arr = arr.toSet\n        val arr = arr.toSeq\n    \
    \    val arr = arr.toArray\n        val arr = arr.toList\n        val arr = arr.toMap\n\
    \        val arr = arr.toSet\n        val arr = arr.toSeq\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.toMap\n        val arr =\
    \ arr.toSet\n        val arr = arr.toSeq\n        val arr = arr.toArray\n    \
    \    val arr = arr.toList\n        val arr = arr.toMap\n        val arr = arr.toSet\n\
    \        val arr = arr.toSeq\n        val arr = arr.toArray\n        val arr =\
    \ arr.toList\n        val arr = arr.toMap\n        val arr = arr.toSet\n     \
    \   val arr = arr.toSeq\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toMap\n        val arr = arr.toSet\n        val arr = arr.toSeq\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.toMap\n        val arr = arr.toSet\n        val arr = arr.toSeq\n    \
    \    val arr = arr.toArray\n        val arr = arr.toList\n        val arr = arr.toMap\n\
    \        val arr = arr.toSet\n        val arr = arr.toSeq\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.toMap\n        val arr =\
    \ arr.toSet\n        val arr = arr.toSeq\n        val arr = arr.toArray\n    \
    \    val arr = arr.toList\n        val arr = arr.toMap\n        val arr = arr.toSet\n\
    \        val arr = arr.toSeq\n        val arr = arr.toArray\n        val arr =\
    \ arr.toList\n        val arr = arr.toMap\n        val arr = arr.toSet\n     \
    \   val arr = arr.toSeq\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.toMap\n        val arr = arr.toSet\n        val arr = arr.toSeq\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpkxwtfvjc.scala:95:11 ---------------------------\e\
    [0m\e[0m\n\e[31m95 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpkxwtfvjc.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSeq\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkxwtfvjc.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkxwtfvjc.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkxwtfvjc.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toMap\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpkxwtfvjc.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toSet\n\e\
    [31m\e[31m   |"
  stdout: ''
  timestamp: 1660009598
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr1.clone\n        val arr3 = arr2.clone\n        val arr4 = arr3.clone\n\
    \        val arr5 = arr4.clone\n        val arr6 = arr5.clone\n        val arr7\
    \ = arr6.clone\n        val arr8 = arr7.clone\n        val arr9 = arr8.clone\n\
    \        val arr10 = arr9.clone\n        val arr11 = arr10.clone\n        val\
    \ arr12 = arr11.clone\n        val arr13 = arr12.clone\n        val arr14 = arr13.clone\n\
    \        val arr15 = arr14.clone\n        val arr16 = arr15.clone\n        val\
    \ arr17 = arr16.clone\n        val arr18 = arr17.clone\n        val arr19 = arr18.clone\n\
    \        val arr20 = arr19.clone\n        val arr21 = arr20.clone\n        val\
    \ arr22 = arr21.clone\n        val arr23 = arr22.clone\n        val arr24 = arr23.clone\n\
    \        val arr25 = arr24.clone\n        val arr26 = arr25.clone\n        val\
    \ arr27 = arr26.clone\n        val arr28 = arr27.clone\n        val arr29 = arr28.clone\n\
    \        val arr30 = arr29.clone\n        val arr31 = arr30.clone\n        val\
    \ arr32 = arr31.clone\n        val arr33 = arr32.clone\n        val arr34 = arr33.clone\n\
    \        val arr35 = arr34.clone\n        val arr36 = arr35.clone\n        val\
    \ arr37 = arr36.clone\n        val arr38 = arr37.clone\n        val arr39 = arr38.clone\n\
    \        val arr40 = arr39.clone\n        val arr41 = arr40.clone\n        val\
    \ arr42 = arr41.clone\n        val arr43 = arr42.clone\n        val arr44 = arr43.clone\n\
    \        val arr45 = arr44.clone\n        val arr46 = arr45.clone\n        val\
    \ arr47 = arr46.clone\n        val arr48 = arr47.clone\n        val arr49 = arr48.clone\n\
    \        val arr50 = arr49.clone\n        val arr51 = arr50.clone\n        val\
    \ arr52 = arr51.clone\n        val arr53 = arr52.clone\n        val arr54 = arr53.clone\n\
    \        val arr55 = arr54\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmphgufl1lu.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmphgufl1lu.scala:80:5 ---------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009597
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr = arr.toList\n        val arr1 =\
    \ arr.toArray\n        val arr2 = arr.toBuffer\n        val arr3 = arr.toSeq\n\
    \        val arr4 = arr.toStream\n        val arr5 = arr.toIterator\n        val\
    \ arr6 = arr.toSet\n        val arr7 = arr.toMap\n        val arr8 = arr.toSet\n\
    \        val arr9 = arr.toSeq\n        val arr10 = arr.toStream\n        val arr11\
    \ = arr.toIterator\n        val arr12 = arr.toMap\n        val arr13 = arr.toSet\n\
    \        val arr14 = arr.toSeq\n        val arr15 = arr.toStream\n        val\
    \ arr16 = arr.toIterator\n        val arr17 = arr.toMap\n        val arr18 = arr.toSet\n\
    \        val arr19 = arr.toSeq\n        val arr20 = arr.toStream\n        val\
    \ arr21 = arr.toIterator\n        val arr22 = arr.toMap\n        val arr23 = arr.toSet\n\
    \        val arr24 = arr.toSeq\n        val arr25 = arr.toStream\n        val\
    \ arr26 = arr.toIterator\n        val arr27 = arr.toMap\n        val arr28 = arr.toSet\n\
    \        val arr29 = arr.toSeq\n        val arr30 = arr.toStream\n        val\
    \ arr31 = arr.toIterator\n        val arr32 = arr.toMap\n        val arr33 = arr.toSet\n\
    \        val arr34 = arr.toSeq\n        val arr35 = arr.toStream\n        val\
    \ arr36 = arr.toIterator\n        val arr37 = arr.toMap\n        val arr38 = arr.toSet\n\
    \        val arr39 = arr.toSeq\n        val arr40 = arr.toStream\n        val\
    \ arr41 = arr.toIterator\n        val arr42 = arr.toMap\n        val arr43 = arr.toSet\n\
    \        val arr44 = arr.toSeq\n        val arr45 = arr.toStream\n        val\
    \ arr46 = arr.toIterator\n        val arr47 = arr.toMap\n        val arr48 = arr.toSet\n\
    \        val arr49 = arr.toSeq\n        val arr50 = arr.toStream\n        val\
    \ arr51 = arr.toIterator\n        val arr52 = arr.toMap\n        val arr53 = arr.toSet\n\
    \        val arr54 = arr.toSeq\n        val arr55 = arr.toStream\n        val\
    \ arr5\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpag0bnxc3.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpag0bnxc3.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpag0bnxc3.scala:24:18 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpag0bnxc3.scala:82:5 ---------------------\e[0m\e[0m\n\e[31m82\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val result\
    \ = new Array[Boolean](n)\n        var i = 0\n        var j = 0\n        var k\
    \ = 0\n        var temp = 0\n        var flag = false\n        var temp2 = new\
    \ Array[Long](n)\n        var temp3 = new Array[Long](n)\n        var temp4 =\
    \ new Array[Long](n)\n        var temp5 = new Array[Long](n)\n        var temp6\
    \ = new Array[Long](n)\n        var temp7 = new Array[Long](n)\n        var temp8\
    \ = new Array[Long](n)\n        var temp9 = new Array[Long](n)\n        var temp10\
    \ = new Array[Long](n)\n        var temp11 = new Array[Long](n)\n        var temp12\
    \ = new Array[Long](n)\n        var temp13 = new Array[Long](n)\n        var temp14\
    \ = new Array[Long](n)\n        var temp15 = new Array[Long](n)\n        var temp16\
    \ = new Array[Long](n)\n        var temp17 = new Array[Long](n)\n        var temp18\
    \ = new Array[Long](n)\n        var temp19 = new Array[Long](n)\n        var temp20\
    \ = new Array[Long](n)\n        var temp21 = new Array[Long](n)\n        var temp22\
    \ = new Array[Long](n)\n        var temp23 = new Array[Long](n)\n        var temp24\
    \ = new Array[Long](n)\n        var temp25 = new Array[Long](n)\n        var temp26\
    \ = new Array[Long](n)\n        var temp27 = new Array[Long](n)\n        var temp28\
    \ = new Array[Long](n)\n        var temp29 = new Array[Long](n)\n        var temp30\
    \ = new Array[Long](n)\n        var temp31 = new Array[Long](n)\n        var temp32\
    \ = new Array[Long](n)\n        var temp33 = new Array[Long](n)\n        var temp34\
    \ = new Array[Long](n)\n        var temp35 = new Array[Long](n)\n        var temp36\
    \ = new Array[Long](n)\n        var temp37 = new Array[Long](n)\n        var temp38\
    \ = new Array[Long](n)\n        var temp39 = new Array[Long](n)\n        var temp40\
    \ = new Array[Long](n)\n        var temp41 = new Array[Long](n)\n        var temp42\
    \ = new Array[Long](n)\n        var temp43 = new Array[Long](n)\n        var temp44\
    \ = new Array[Long](n)\n        var temp45 = new Array[Long](n)\n        var temp46\
    \ = new Array[Long](n)\n        var temp47 = new Array[Long](n)\n        var temp48\
    \ = new Array[Long](n)\n        var \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp824dh1mq.scala:76:11 ---------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp824dh1mq.scala:77:5 ---------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val arr1 = arr.toArray\n        val arr2 = arr1.slice(1, n).reverse\n\
    \        val arr3 = arr2.reverse\n        val arr4 = arr3.slice(1, n).reverse\n\
    \        val arr5 = arr4.slice(1, n).reverse\n        val arr6 = arr5.slice(1,\
    \ n).reverse\n        val arr7 = arr6.slice(1, n).reverse\n        val arr8 =\
    \ arr7.slice(1, n).reverse\n        val arr9 = arr8.slice(1, n).reverse\n    \
    \    val arr10 = arr9.slice(1, n).reverse\n        val arr11 = arr10.slice(1,\
    \ n).reverse\n        val arr12 = arr11.slice(1, n).reverse\n        val arr13\
    \ = arr12.slice(1, n).reverse\n        val arr14 = arr13.slice(1, n).reverse\n\
    \        val arr15 = arr14.slice(1, n).reverse\n        val arr16 = arr15.slice(1,\
    \ n).reverse\n        val arr17 = arr16.slice(1, n).reverse\n        val arr18\
    \ = arr17.slice(1, n).reverse\n        val arr19 = arr18.slice(1, n).reverse\n\
    \        val arr20 = arr19.slice(1, n).reverse\n        val arr21 = arr20.slice(1,\
    \ n).reverse\n        val arr22 = arr21.slice(1, n).reverse\n        val arr23\
    \ = arr22.slice(1, n).reverse\n        val arr24 = arr23.slice(1, n).reverse\n\
    \        val arr25 = arr24.slice(1, n).reverse\n        val arr26 = arr25.slice(1,\
    \ n).reverse\n        val arr27 = arr26.slice(1, n).reverse\n        val arr28\
    \ = arr27.slice(1, n).reverse\n        val arr29 = arr28.slice(1, n).reverse\n\
    \        val arr30 = arr29.slice(1, n).reverse\n        val arr31 = arr30.slice(1,\
    \ n).reverse\n        val arr32 = arr31.slice(1, n).reverse\n        val arr33\
    \ = arr32.slice(1, n).reverse\n        val arr34 = arr33.slice(1, n).reverse\n\
    \        val arr35 = arr34.slice(1, n).reverse\n        val arr36 = arr35.slice(1,\
    \ n).reverse\n        val arr37 = arr36.slice(1, n).reverse\n        val arr38\
    \ = arr37.slice(1, n).reverse\n        val arr39 = arr38.slice(1, n).reverse\n\
    \        val arr40 = arr39.slice(1, n).\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsrzm8htm.scala:64:4 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpsrzm8htm.scala:23:18 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpsrzm8htm.scala:64:5 ---------------------\e[0m\e[0m\n\e[31m64\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009587
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val sorted = arr.sortBy(x => x)\n        val result = sorted.reverse.tail.forall(x\
    \ => x != sorted(0))\n        result \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpt2cvagxd.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009595
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val arr2 = arr.toArray\n        val arr3 = arr2.toList\n        val arr4\
    \ = arr3.toArray\n        val arr5 = arr4.toList\n        val arr6 = arr5.toArray\n\
    \        val arr7 = arr6.toList\n        val arr8 = arr7.toArray\n        val\
    \ arr9 = arr8.toList\n        val arr10 = arr9.toArray\n        val arr11 = arr10.toList\n\
    \        val arr12 = arr11.toArray\n        val arr13 = arr12.toList\n       \
    \ val arr14 = arr13.toArray\n        val arr15 = arr14.toList\n        val arr16\
    \ = arr15.toArray\n        val arr17 = arr16.toList\n        val arr18 = arr17.toArray\n\
    \        val arr19 = arr18.toList\n        val arr20 = arr19.toArray\n       \
    \ val arr21 = arr20.toList\n        val arr22 = arr21.toArray\n        val arr23\
    \ = arr22.toList\n        val arr24 = arr23.toArray\n        val arr25 = arr24.toList\n\
    \        val arr26 = arr25.toArray\n        val arr27 = arr26.toList\n       \
    \ val arr28 = arr27.toArray\n        val arr29 = arr28.toList\n        val arr30\
    \ = arr29.toArray\n        val arr31 = arr30.toList\n        val arr32 = arr31.toArray\n\
    \        val arr33 = arr32.toList\n        val arr34 = arr33.toArray\n       \
    \ val arr35 = arr34.toList\n        val arr36 = arr35.toArray\n        val arr37\
    \ = arr36.toList\n        val arr38 = arr37.toArray\n        val arr39 = arr38.toList\n\
    \        val arr40 = arr39.toArray\n        val arr41 = arr40.toList\n       \
    \ val arr42 = arr41.toArray\n        val arr43 = arr42.toList\n        val arr44\
    \ = arr43.toArray\n        val arr45 = arr44.toList\n        val arr46 = arr45.toArray\n\
    \        val arr47 = arr46.toList\n        val arr48 = arr47.toArray\n       \
    \ val arr49 = arr48.toList\n        val arr50 = arr49.toArray\n        val arr51\
    \ = arr50.toList\n        val arr52 = arr5\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpk039vu38.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpk039vu38.scala:75:5 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        val temp2 = new Array[Long](n)\n        val temp3 = new Array[Long](n)\n\
    \        val temp4 = new Array[Long](n)\n        val temp5 = new Array[Long](n)\n\
    \        val temp6 = new Array[Long](n)\n        val temp7 = new Array[Long](n)\n\
    \        val temp8 = new Array[Long](n)\n        val temp9 = new Array[Long](n)\n\
    \        val temp10 = new Array[Long](n)\n        val temp11 = new Array[Long](n)\n\
    \        val temp12 = new Array[Long](n)\n        val temp13 = new Array[Long](n)\n\
    \        val temp14 = new Array[Long](n)\n        val temp15 = new Array[Long](n)\n\
    \        val temp16 = new Array[Long](n)\n        val temp17 = new Array[Long](n)\n\
    \        val temp18 = new Array[Long](n)\n        val temp19 = new Array[Long](n)\n\
    \        val temp20 = new Array[Long](n)\n        val temp21 = new Array[Long](n)\n\
    \        val temp22 = new Array[Long](n)\n        val temp23 = new Array[Long](n)\n\
    \        val temp24 = new Array[Long](n)\n        val temp25 = new Array[Long](n)\n\
    \        val temp26 = new Array[Long](n)\n        val temp27 = new Array[Long](n)\n\
    \        val temp28 = new Array[Long](n)\n        val temp29 = new Array[Long](n)\n\
    \        val temp30 = new Array[Long](n)\n        val temp31 = new Array[Long](n)\n\
    \        val temp32 = new Array[Long](n)\n        val temp33 = new Array[Long](n)\n\
    \        val temp34 = new Array[Long](n)\n        val temp35 = new Array[Long](n)\n\
    \        val temp36 = new Array[Long](n)\n        val temp37 = new Array[Long](n)\n\
    \        val temp38 = new Array[Long](n)\n        val temp39 = new Array[Long](n)\n\
    \        val temp40 = new Array[Long](n)\n        val temp41 = new Array[Long](n)\n\
    \        val temp42 = new Array[Long](n)\n        val temp43 = new Array[Long](n)\n\
    \        val temp44 = new Array[Long](n)\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp_6vjcmjo.scala:69:11 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_6vjcmjo.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = true\n        var\
    \ temp1 = new Array[Long](n)\n        var temp2 = new Array[Long](n)\n       \
    \ var temp3 = new Array[Long](n)\n        var temp4 = new Array[Long](n)\n   \
    \     var temp5 = new Array[Long](n)\n        var temp6 = new Array[Long](n)\n\
    \        var temp7 = new Array[Long](n)\n        var temp8 = new Array[Long](n)\n\
    \        var temp9 = new Array[Long](n)\n        var temp10 = new Array[Long](n)\n\
    \        var temp11 = new Array[Long](n)\n        var temp12 = new Array[Long](n)\n\
    \        var temp13 = new Array[Long](n)\n        var temp14 = new Array[Long](n)\n\
    \        var temp15 = new Array[Long](n)\n        var temp16 = new Array[Long](n)\n\
    \        var temp17 = new Array[Long](n)\n        var temp18 = new Array[Long](n)\n\
    \        var temp19 = new Array[Long](n)\n        var temp20 = new Array[Long](n)\n\
    \        var temp21 = new Array[Long](n)\n        var temp22 = new Array[Long](n)\n\
    \        var temp23 = new Array[Long](n)\n        var temp24 = new Array[Long](n)\n\
    \        var temp25 = new Array[Long](n)\n        var temp26 = new Array[Long](n)\n\
    \        var temp27 = new Array[Long](n)\n        var temp28 = new Array[Long](n)\n\
    \        var temp29 = new Array[Long](n)\n        var temp30 = new Array[Long](n)\n\
    \        var temp31 = new Array[Long](n)\n        var temp32 = new Array[Long](n)\n\
    \        var temp33 = new Array[Long](n)\n        var temp34 = new Array[Long](n)\n\
    \        var temp35 = new Array[Long](n)\n        var temp36 = new Array[Long](n)\n\
    \        var temp37 = new Array[Long](n)\n        var temp38 = new Array[Long](n)\n\
    \        var temp39 = new Array[Long](n)\n        var temp40 = new Array[Long](n)\n\
    \        var temp41 = new Array[Long](n)\n        var temp42 = new Array[Long](n)\n\
    \        var temp43 = new Array[Long](n)\n        var temp44 = new Array[Long](n)\n\
    \        var temp45 = new Array[Long](n)\n        var temp46 = new Array[Long](n)\n\
    \        var temp47 = new Array\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmplf0jktly.scala:76:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m        \e[33mvar\e[0m \e[36mtemp47\e[0m = \e[33mnew\e\
    [0m \e[35mArray\e[0m\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmissing argument for parameter _length of \e[33mconstructor\e[0m\
    \ \e[35mArray\e[0m in \e[33mclass\e[0m \e[35mArray\e[0m: (_length: Int): Array[T]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplf0jktly.scala:77:5 ---------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009599
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else if(arr.size\
    \ == 1) false\n        else {\n            val sortedArr = arr.sortBy(x => x)\n\
    \            val leftArr = arr.take(arr.size - 1)\n            val rightArr =\
    \ arr.drop(arr.size - 1)\n            val leftSortedArr = sortedArr.take(sortedArr.size\
    \ - 1)\n            val rightSortedArr = sortedArr.drop(sortedArr.size - 1)\n\
    \            val leftArr = leftArr.sortBy(x => x)\n            val rightArr =\
    \ rightArr.sortBy(x => x)\n            val leftSortedArr = leftSortedArr.sortBy(x\
    \ => x)\n            val rightSortedArr = rightSortedArr.sortBy(x => x)\n    \
    \        val leftArr = leftArr.take(leftArr.size - 1)\n            val rightArr\
    \ = rightArr.take(rightArr.size - 1)\n            val leftSortedArr = leftSortedArr.take(leftSortedArr.size\
    \ - 1)\n            val rightSortedArr = rightSortedArr.take(rightSortedArr.size\
    \ - 1)\n            val leftArr = leftArr.take(leftArr.size - 1)\n           \
    \ val rightArr = rightArr.take(rightArr.size - 1)\n            val leftSortedArr\
    \ = leftSortedArr.take(leftSortedArr.size - 1)\n            val rightSortedArr\
    \ = rightSortedArr.take(rightSortedArr.size - 1)\n            val leftArr = leftArr.take(leftArr.size\
    \ - 1)\n            val rightArr = rightArr.take(rightArr.size - 1)\n        \
    \    val leftSortedArr = leftSortedArr.take(leftSortedArr.size - 1)\n        \
    \    val rightSortedArr = rightSortedArr.take(rightSortedArr.size - 1)\n     \
    \       val leftArr = leftArr.take(leftArr.size - 1)\n            val rightArr\
    \ = rightArr.take(rightArr.size - 1)\n            val leftSortedArr = leftSortedArr.take(leftSortedArr.size\
    \ - 1)\n            val rightSortedArr = rightSortedArr.take(rightSortedArr.size\
    \ - 1)\n            val leftArr = leftArr.take(leftArr.size - 1)\n           \
    \ val rightArr = rightArr.take(rightArr.size - 1)\n            val leftSortedArr\
    \ = leftSortedArr.take(leftSortedArr.size - 1)\n            val rightSortedArr\
    \ = rightSortedArr.take(rightSortedArr.size - 1)\n            val leftArr = leftArr.take(leftArr.size\
    \ - 1)\n            \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmjzwp_ax.scala:66:0 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmjzwp_ax.scala:30:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e\
    [0m \e[36mleftArr\e[0m = leftArr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftArr\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmjzwp_ax.scala:31:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mrightArr\e[0m = rightArr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightArr\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmjzwp_ax.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mleftSortedArr\e[0m = leftSortedArr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mleftSortedArr is already defined as \e[33mvalue\e[0m \e[35mleftSortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmjzwp_ax.scala:33:16 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m            \e[33mval\e[0m \e[36mrightSortedArr\e[0m = rightSortedArr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightSortedArr is already defined as \e[33mvalue\e[0m \e[35mrightSortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of"
  stdout: ''
  timestamp: 1660009601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var temp = 0\n        var flag = true\n        while(i < n) {\n \
    \           temp = arr(i)\n            for(j <- 0 until i) {\n               \
    \ if(arr(j) > temp) {\n                    arr(j) = arr(j)-temp\n            \
    \        arr(i) = arr(i)-temp\n                    temp = arr(i)\n           \
    \     }\n            }\n            arr(i) = temp\n            if(i == n-1) {\n\
    \                arr(0) = 0\n                flag = false\n            }\n   \
    \         i += 1\n        }\n        flag\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptlzo8hhs.scala:30:22\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            temp = arr(i)\n\e\
    [31m\e[31m   |\e[0m                   ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \        Found:    Long\n\e[31m   |\e[0m                   Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptlzo8hhs.scala:33:20 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                    arr(j) = arr(j)-temp\n\e[31m\e[31m\
    \   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmptlzo8hhs.scala:34:20 ------------------------\e[0m\e[0m\n\
    \e[31m34 |\e[0m                    arr(i) = arr(i)-temp\n\e[31m\e[31m   |\e[0m\
    \                    ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of\
    \ List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmptlzo8hhs.scala:35:30 --------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m                    temp = arr(i)\n\e[31m\e[31m   |\e[0m             \
    \              ^^^^^^\e[0m\n\e[31m   |\e[0m                           Found: \
    \   Long\n\e[31m   |\e[0m                           Required: Int\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptlzo8hhs.scala:38:12 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m            arr(i) = temp\n\e[31m\e[31m   |\e[0m    \
    \        ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmptlzo8hhs.scala:40:16\
    \ ------------------------\e[0m\e[0m\n\e[31m40 |\e[0m                arr(\e[31m0\e\
    [0m) = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                ^^^\e[0m\n\e[31m   |\e\
    [0m  value update is not a member of List[Long] - did you mean arr.updated?\n\
    6 errors found\n"
  stdout: ''
  timestamp: 1660009601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        while(i < n) {\n           \
    \ while(j < n) {\n                temp = 0\n                while(k <= j) {\n\
    \                    temp = temp + arr(k)\n                    k = k + 1\n   \
    \             }\n                temp = m\n                arr(i) = temp\n   \
    \             i = i + 1\n                j = j + 1\n            }\n        }\n\
    \        for(i = n - 1; i >= 0; i = i - 1) {\n            arr(i) = arr(i) + 1\n\
    \        }\n        for(i = n - 1; i >= 0; i = i - 1) {\n            if(arr(i)\
    \ > arr(i + 1)) {\n                arr(i) = arr(i) - 1\n            }\n      \
    \  }\n        for(i = n - 1; i >= 0; i = i - 1) {\n            if(arr(i) < arr(i\
    \ + 1)) {\n                arr(i) = arr(i) + 1\n            }\n        }\n   \
    \     for(i = n - 1; i >= 0; i = i - 1) {\n            if(arr(i) == arr(i + 1))\
    \ {\n                arr(i) = arr(i) - 1\n            }\n        }\n        for(i\
    \ = n - 1; i >= 0; i = i - 1) {\n            if(arr(i) == arr(i + 1)) {\n    \
    \            arr(i) = arr(i) + 1\n            }\n        }\n        for(i = n\
    \ - 1; i >= 0; i = i - 1) {\n            if(arr(i) == arr(i + 1)) {\n        \
    \        arr(i) = arr(i) - 1\n            }\n        }\n        for(i = n - 1;\
    \ i >= 0; i = i - 1) {\n            if(arr(i) == arr(i + 1)) {\n             \
    \   arr(i) = arr(i) + 1\n            }\n        }\n        for(i = n - 1; i >=\
    \ 0; i = i - 1) {\n            if(arr(i) == arr(i + 1)) {\n                arr(i)\
    \ = arr(i) - 1\n            }\n        }\n        for(i = n - 1; i >= 0; i = i\
    \ - 1) {\n            if(arr(i) == arr(i + 1)) {\n                arr(i) = arr(i)\
    \ + 1\n            }\n        }\n        for(i = n - 1; i >= 0; i = i - 1) {\n\
    \            if(arr(i) == arr(i + 1)) {\n                arr(i) = arr(i) - 1\n\
    \            }\n        }\n        for(i = n - 1; i >= 0; i = i - 1) {\n     \
    \       if(arr(i) == arr(i + 1)) {\n                arr(i) = arr(i) + 1\n    \
    \        }\n        }\n        for(i = n - 1; i >= 0; i = i - 1) {\n         \
    \   if(arr(i) == arr(i + 1)) {\n                arr(i) = arr(i) - 1\n        \
    \    }\n        }\n        for(i = n - 1; i >= 0; i = i - 1) {\n            if(arr(i)\
    \ == arr(i + 1)\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj0jpzmb_.scala:42:14 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\
    \e[31m   |\e[0m              ')' expected, but '=' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpj0jpzmb_.scala:42:29 ---------------------------\e[0m\e\
    [0m\n\e[31m42 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e[31m0\e\
    [0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                          \
    \   ^\e[0m\n\e[31m   |\e[0m                             '<-' expected, but ';'\
    \ found\n\e[31m\e[31m-- [E020] Syntax Error: /tmp/tmpj0jpzmb_.scala:42:40 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                   \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \        \e[33myield\e[0m or \e[33mdo\e[0m expected\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpj0jpzmb_.scala:45:14 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\
    \e[31m   |\e[0m              ')' expected, but '=' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpj0jpzmb_.scala:45:29 ---------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e[31m0\e\
    [0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                          \
    \   ^\e[0m\n\e[31m   |\e[0m                             '<-' expected, but ';'\
    \ found\n\e[31m\e[31m-- [E020] Syntax Error: /tmp/tmpj0jpzmb_.scala:45:40 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i = i - \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                   \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \        \e[33myield\e[0m or \e[33mdo\e[0m expected\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when "
  stdout: ''
  timestamp: 1660009609
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else {\n\
    \            val arr1 = arr.toList\n            val arr2 = arr1.reverse\n    \
    \        val arr3 = arr2.reverse\n            val arr4 = arr3.reverse\n      \
    \      val arr5 = arr4.reverse\n            val arr6 = arr5.reverse\n        \
    \    val arr7 = arr6.reverse\n            val arr8 = arr7.reverse\n          \
    \  val arr9 = arr8.reverse\n            val arr10 = arr9.reverse\n           \
    \ val arr11 = arr10.reverse\n            val arr12 = arr11.reverse\n         \
    \   val arr13 = arr12.reverse\n            val arr14 = arr13.reverse\n       \
    \     val arr15 = arr14.reverse\n            val arr16 = arr15.reverse\n     \
    \       val arr17 = arr16.reverse\n            val arr18 = arr17.reverse\n   \
    \         val arr19 = arr18.reverse\n            val arr20 = arr19.reverse\n \
    \           val arr21 = arr20.reverse\n            val arr22 = arr21.reverse\n\
    \            val arr23 = arr22.reverse\n            val arr24 = arr23.reverse\n\
    \            val arr25 = arr24.reverse\n            val arr26 = arr25.reverse\n\
    \            val arr27 = arr26.reverse\n            val arr28 = arr27.reverse\n\
    \            val arr29 = arr28.reverse\n            val arr30 = arr29.reverse\n\
    \            val arr31 = arr30.reverse\n            val arr32 = arr31.reverse\n\
    \            val arr33 = arr32.reverse\n            val arr34 = arr33.reverse\n\
    \            val arr35 = arr34.reverse\n            val arr36 = arr35.reverse\n\
    \            val arr37 = arr36.reverse\n            val arr38 = arr37.reverse\n\
    \            val arr39 = arr38.reverse\n            val arr40 = arr39.reverse\n\
    \            val arr41 = arr40.reverse\n            val arr42 = arr41.reverse\n\
    \            val arr43 = arr42.reverse\n            val arr44 = arr43.reverse\n\
    \            val arr45 = arr44.reverse\n            val arr46 = arr45.reverse\n\
    \            val arr47 = arr46.reverse\n            val arr48 = arr47.reverse\n\
    \            val arr49 = arr48.reverse\n            val arr50 = arr49.reverse\n\
    \            val arr51 = arr50.reverse\n            val arr52 = arr51.reverse\n\
    \            val arr53 = arr52.reverse\n            val arr54 = arr53.reverse\n\
    \            val arr55 = arr54.reverse\n            val arr56 = arr55.reverse\n\
    \            val arr57 = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5675u4r3.scala:80:23 ---------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m            \e[33mval\e[0m \e[36marr57\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp5675u4r3.scala:91:0 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5675u4r3.scala:90:1\
    \ ---------------------\e[0m\e[0m\n\e[31m90 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp5675u4r3.scala:82:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m82 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfy7wyy5u.scala:95:17 ---------------------------\e\
    [0m\e[0m\n\e[31m95 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfy7wyy5u.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e\
    [0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpfy7wyy5u.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfy7wyy5u.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfy7wyy5u.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfy7wyy5u.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33m"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        val temp2 = new Array[Long](n)\n        val temp3 = new Array[Long](n)\n\
    \        val temp4 = new Array[Long](n)\n        val temp5 = new Array[Long](n)\n\
    \        val temp6 = new Array[Long](n)\n        val temp7 = new Array[Long](n)\n\
    \        val temp8 = new Array[Long](n)\n        val temp9 = new Array[Long](n)\n\
    \        val temp10 = new Array[Long](n)\n        val temp11 = new Array[Long](n)\n\
    \        val temp12 = new Array[Long](n)\n        val temp13 = new Array[Long](n)\n\
    \        val temp14 = new Array[Long](n)\n        val temp15 = new Array[Long](n)\n\
    \        val temp16 = new Array[Long](n)\n        val temp17 = new Array[Long](n)\n\
    \        val temp18 = new Array[Long](n)\n        val temp19 = new Array[Long](n)\n\
    \        val temp20 = new Array[Long](n)\n        val temp21 = new Array[Long](n)\n\
    \        val temp22 = new Array[Long](n)\n        val temp23 = new Array[Long](n)\n\
    \        val temp24 = new Array[Long](n)\n        val temp25 = new Array[Long](n)\n\
    \        val temp26 = new Array[Long](n)\n        val temp27 = new Array[Long](n)\n\
    \        val temp28 = new Array[Long](n)\n        val temp29 = new Array[Long](n)\n\
    \        val temp30 = new Array[Long](n)\n        val temp31 = new Array[Long](n)\n\
    \        val temp32 = new Array[Long](n)\n        val temp33 = new Array[Long](n)\n\
    \        val temp34 = new Array[Long](n)\n        val temp35 = new Array[Long](n)\n\
    \        val temp36 = new Array[Long](n)\n        val temp37 = new Array[Long](n)\n\
    \        val temp38 = new Array[Long](n)\n        val temp39 = new Array[Long](n)\n\
    \        val temp40 = new Array[Long](n)\n        val temp41 = new Array[Long](n)\n\
    \        val temp42 = new Array[Long](n)\n        val temp43 = new Array[Long](n)\n\
    \        val temp44 = new Array[Long](n)\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpasqfrun5.scala:69:11 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpasqfrun5.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009586
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n\
    \        else {\n            val sortedArr = arr.sort\n            val first =\
    \ sortedArr.head\n            val last = sortedArr.last\n            val newArr\
    \ = arr.filter(_ != first)\n            val newArr2 = newArr.filter(_ != last)\n\
    \            if (newArr2.size != n) false\n            else {\n              \
    \  val newArr3 = newArr2.filter(_ != first)\n                val newArr4 = newArr3.filter(_\
    \ != last)\n                if (newArr4.size != n) false\n                else\
    \ {\n                    val newArr5 = newArr4.filter(_ != first)\n          \
    \          val newArr6 = newArr5.filter(_ != last)\n                    if (newArr6.size\
    \ != n) false\n                    else {\n                        val newArr7\
    \ = newArr6.filter(_ != first)\n                        val newArr8 = newArr7.filter(_\
    \ != last)\n                        if (newArr8.size != n) false\n           \
    \             else {\n                            val newArr9 = newArr8.filter(_\
    \ != first)\n                            val newArr10 = newArr9.filter(_ != last)\n\
    \                            if (newArr10.size != n) false\n                 \
    \           else {\n                                val newArr11 = newArr10.filter(_\
    \ != first)\n                                val newArr12 = newArr11.filter(_\
    \ != last)\n                                if (newArr12.size != n) false\n  \
    \                              else {\n                                    val\
    \ newArr13 = newArr12.filter(_ != first)\n                                   \
    \ val newArr14 = newArr13.filter(_ != last)\n                                \
    \    if (newArr14.size != n) false\n                                    else {\n\
    \                                        val newArr15 = newArr14.filter(_ != first)\n\
    \                                        val newArr16 = newArr15.filter(_ != last)\n\
    \                                        if (newArr16.size != n) false\n     \
    \                                   else {\n                                 \
    \           val newArr17 = newArr16.filter(_ != first)\n                     \
    \                       val newArr18 = newArr17.filter(_ != last)\n          \
    \                                  if (newArr18.size != n) false\n           \
    \                                 else {\n                                   \
    \             val newArr19 = newArr18.filter(_ != first)\n                   \
    \                             val newArr20 = newArr19.filter(_ != last)\n    \
    \                                            if (newArr20.size != n) false\n \
    \                                               else {\n                     \
    \                               val newArr21 = newArr20.filter(_ != first)\n \
    \                                                   val newArr22 = newArr21.filter(_\
    \ != last)\n                                                    if (newArr22.size\
    \ != n) false\n                                                    else {\n  \
    \                                                      val newArr23 = newArr22.filter(_\
    \ != first)\n                                                        val newArr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfyxqbhd6.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfyxqbhd6.scala:84:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpfyxqbhd6.scala:25:32 ------------------------\e[0m\e[0m\n\
    \e[31m25 |\e[0m            \e[33mval\e[0m \e[36msortedArr\e[0m = arr.sort\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \     value sort is not a member of List[Long] - did you mean arr.sortBy?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfyxqbhd6.scala:83:1 ---------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpfyxqbhd6.scala:75:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m75 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009603
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else {\n\
    \            val arr1 = arr.toList\n            val arr2 = arr1.reverse\n    \
    \        val arr3 = arr2.reverse\n            val arr4 = arr3.reverse\n      \
    \      val arr5 = arr4.reverse\n            val arr6 = arr5.reverse\n        \
    \    val arr7 = arr6.reverse\n            val arr8 = arr7.reverse\n          \
    \  val arr9 = arr8.reverse\n            val arr10 = arr9.reverse\n           \
    \ val arr11 = arr10.reverse\n            val arr12 = arr11.reverse\n         \
    \   val arr13 = arr12.reverse\n            val arr14 = arr13.reverse\n       \
    \     val arr15 = arr14.reverse\n            val arr16 = arr15.reverse\n     \
    \       val arr17 = arr16.reverse\n            val arr18 = arr17.reverse\n   \
    \         val arr19 = arr18.reverse\n            val arr20 = arr19.reverse\n \
    \           val arr21 = arr20.reverse\n            val arr22 = arr21.reverse\n\
    \            val arr23 = arr22.reverse\n            val arr24 = arr23.reverse\n\
    \            val arr25 = arr24.reverse\n            val arr26 = arr25.reverse\n\
    \            val arr27 = arr26.reverse\n            val arr28 = arr27.reverse\n\
    \            val arr29 = arr28.reverse\n            val arr30 = arr29.reverse\n\
    \            val arr31 = arr30.reverse\n            val arr32 = arr31.reverse\n\
    \            val arr33 = arr32.reverse\n            val arr34 = arr33.reverse\n\
    \            val arr35 = arr34.reverse\n            val arr36 = arr35.reverse\n\
    \            val arr37 = arr36.reverse\n            val arr38 = arr37.reverse\n\
    \            val arr39 = arr38.reverse\n            val arr40 = arr39.reverse\n\
    \            val arr41 = arr40.reverse\n            val arr42 = arr41.reverse\n\
    \            val arr43 = arr42.reverse\n            val arr44 = arr43.reverse\n\
    \            val arr45 = arr44.reverse\n            val arr46 = arr45.reverse\n\
    \            val arr47 = arr46.reverse\n            val arr48 = arr47.reverse\n\
    \            val arr49 = arr48.reverse\n            val arr50 = arr49.reverse\n\
    \            val arr51 = arr50.reverse\n            val arr52 = arr51.reverse\n\
    \            val arr53 = arr52.reverse\n            val arr54 = arr53.reverse\n\
    \            val arr55 = arr54.reverse\n            val arr56 = arr55.reverse\n\
    \            val arr57 = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp5675u4r3.scala:80:23 ---------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m            \e[33mval\e[0m \e[36marr57\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp5675u4r3.scala:91:0 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5675u4r3.scala:90:1\
    \ ---------------------\e[0m\e[0m\n\e[31m90 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp5675u4r3.scala:82:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m82 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ true\n        else {\n            val m = arr.head\n            val r = arr.tail\n\
    \            val r1 = r.tail\n            val r2 = r.tail\n            val r3\
    \ = r.tail\n            val r4 = r.tail\n            val r5 = r.tail\n       \
    \     val r6 = r.tail\n            val r7 = r.tail\n            val r8 = r.tail\n\
    \            val r9 = r.tail\n            val r10 = r.tail\n            val r11\
    \ = r.tail\n            val r12 = r.tail\n            val r13 = r.tail\n     \
    \       val r14 = r.tail\n            val r15 = r.tail\n            val r16 =\
    \ r.tail\n            val r17 = r.tail\n            val r18 = r.tail\n       \
    \     val r19 = r.tail\n            val r20 = r.tail\n            val r21 = r.tail\n\
    \            val r22 = r.tail\n            val r23 = r.tail\n            val r24\
    \ = r.tail\n            val r25 = r.tail\n            val r26 = r.tail\n     \
    \       val r27 = r.tail\n            val r28 = r.tail\n            val r29 =\
    \ r.tail\n            val r30 = r.tail\n            val r31 = r.tail\n       \
    \     val r32 = r.tail\n            val r33 = r.tail\n            val r34 = r.tail\n\
    \            val r35 = r.tail\n            val r36 = r.tail\n            val r37\
    \ = r.tail\n            val r38 = r.tail\n            val r39 = r.tail\n     \
    \       val r40 = r.tail\n            val r41 = r.tail\n            val r42 =\
    \ r.tail\n            val r43 = r.tail\n            val r44 = r.tail\n       \
    \     val r45 = r.tail\n            val r46 = r.tail\n            val r47 = r.tail\n\
    \            val r48 = r.tail\n            val r49 = r.tail\n            val r50\
    \ = r.tail\n            val r51 = r.tail\n            val r52 = r.tail\n     \
    \       val r53 = r.tail\n            val r54 = r.tail\n            val r55 =\
    \ r.tail\n            val r56 = r.tail\n            val r57 = r.tail\n       \
    \     val r58 = r.tail\n            val r59 = r.tail\n            val r60 = r.tail\n\
    \            val r61 = r.tail\n            val r62 = r.tail\n            val r63\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8senzyzy.scala:89:21 ---------------------------\e\
    [0m\e[0m\n\e[31m89 |\e[0m            \e[33mval\e[0m \e[36mr63\e[0m = \n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmp8senzyzy.scala:100:0 ---------------------------\e\
    [0m\e[0m\n\e[31m100 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8senzyzy.scala:99:1\
    \ ---------------------\e[0m\e[0m\n\e[31m99 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp8senzyzy.scala:91:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m91 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009602
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr1 = arr.toList\n        val arr2 =\
    \ arr1.reverse\n        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n\
    \        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val\
    \ arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n\
    \        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n       \
    \ val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14\
    \ = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n\
    \        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n      \
    \  val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21\
    \ = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n\
    \        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n      \
    \  val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28\
    \ = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n\
    \        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n      \
    \  val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35\
    \ = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n\
    \        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n      \
    \  val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42\
    \ = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n\
    \        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n      \
    \  val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49\
    \ = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n\
    \        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n      \
    \  val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr5\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_s6qa8fa.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp_s6qa8fa.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_s6qa8fa.scala:81:5\
    \ ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.sortBy(_)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(_)\n        val len\
    \ = arr.length\n        val arr = arr.sortBy(_)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(_)\n        val len = arr.length\n        val arr\
    \ = arr.sortBy(_)\n        val len = arr.length\n        val arr = arr.\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp50v5n596.scala:91:4 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp50v5n596.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp50v5n596.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp50v5n596.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp50v5n596.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp50v5n596.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(_)\n\e[31m\e[31m  \
    \ |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined\
    \ as "
  stdout: ''
  timestamp: 1660009601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3\
    \ = 0\n        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n \
    \       var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var\
    \ temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13\
    \ = 0\n        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n\
    \        var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n    \
    \    var temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var\
    \ temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26\
    \ = 0\n        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n\
    \        var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n    \
    \    var temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var\
    \ temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39\
    \ = 0\n        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n\
    \        var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n    \
    \    var temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var\
    \ temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52\
    \ = 0\n        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n\
    \        var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n    \
    \    var temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var\
    \ temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65\
    \ = 0\n        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n\
    \        var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n    \
    \    var temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var\
    \ temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78\
    \ = 0\n        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n\
    \        var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n    \
    \    var temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var\
    \ temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91\
    \ = 0\n        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n\
    \        var temp95 = 0\n        var temp96 = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr7cl9d82.scala:125:5\
    \ --------------------\e[0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr1 = arr.toArray\n        val arr2 = arr.toBuffer\n\
    \        val arr3 = arr.toSeq\n        val arr4 = arr.toSet\n        val arr5\
    \ = arr.toMap\n        val arr6 = arr.toIterator\n        val arr7 = arr.toStream\n\
    \        val arr8 = arr.toIterable\n        val arr9 = arr.toArray\n        val\
    \ arr10 = arr.toArray\n        val arr11 = arr.toArray\n        val arr12 = arr.toArray\n\
    \        val arr13 = arr.toArray\n        val arr14 = arr.toArray\n        val\
    \ arr15 = arr.toArray\n        val arr16 = arr.toArray\n        val arr17 = arr.toArray\n\
    \        val arr18 = arr.toArray\n        val arr19 = arr.toArray\n        val\
    \ arr20 = arr.toArray\n        val arr21 = arr.toArray\n        val arr22 = arr.toArray\n\
    \        val arr23 = arr.toArray\n        val arr24 = arr.toArray\n        val\
    \ arr25 = arr.toArray\n        val arr26 = arr.toArray\n        val arr27 = arr.toArray\n\
    \        val arr28 = arr.toArray\n        val arr29 = arr.toArray\n        val\
    \ arr30 = arr.toArray\n        val arr31 = arr.toArray\n        val arr32 = arr.toArray\n\
    \        val arr33 = arr.toArray\n        val arr34 = arr.toArray\n        val\
    \ arr35 = arr.toArray\n        val arr36 = arr.toArray\n        val arr37 = arr.toArray\n\
    \        val arr38 = arr.toArray\n        val arr39 = arr.toArray\n        val\
    \ arr40 = arr.toArray\n        val arr41 = arr.toArray\n        val arr42 = arr.toArray\n\
    \        val arr43 = arr.toArray\n        val arr44 = arr.toArray\n        val\
    \ arr45 = arr.toArray\n        val arr46 = arr.toArray\n        val arr47 = arr.toArray\n\
    \        val arr48 = arr.toArray\n        val arr49 = arr.toArray\n        val\
    \ arr50 = arr.toArray\n        val arr51 = arr.toArray\n        val arr52 = arr.toArray\n\
    \        val arr53 = arr.toArray\n        val arr54 = arr.toArray\n        val\
    \ arr55 = arr.toArray\n        val arr56 = arr.toArray\n        val arr57 = arr.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpose0odvo.scala:22:18 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpose0odvo.scala:81:5 ---------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009601
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val first = arr(0)\n        val last = arr(n)\n       \
    \ val mid = first + last\n        val mid2 = mid / 2\n        val mid3 = mid -\
    \ mid2\n        val mid4 = mid3 / 2\n        val mid5 = mid3 - mid4\n        val\
    \ mid6 = mid5 / 2\n        val mid7 = mid5 - mid6\n        val mid8 = mid7 / 2\n\
    \        val mid9 = mid7 - mid8\n        val mid10 = mid9 / 2\n        val mid11\
    \ = mid9 - mid10\n        val mid12 = mid11 / 2\n        val mid13 = mid11 - mid12\n\
    \        val mid14 = mid13 / 2\n        val mid15 = mid13 - mid14\n        val\
    \ mid16 = mid15 / 2\n        val mid17 = mid15 - mid16\n        val mid18 = mid17\
    \ / 2\n        val mid19 = mid17 - mid18\n        val mid20 = mid19 / 2\n    \
    \    val mid21 = mid19 - mid20\n        val mid22 = mid21 / 2\n        val mid23\
    \ = mid21 - mid22\n        val mid24 = mid23 / 2\n        val mid25 = mid23 -\
    \ mid24\n        val mid26 = mid25 / 2\n        val mid27 = mid25 - mid26\n  \
    \      val mid28 = mid27 / 2\n        val mid29 = mid27 - mid28\n        val mid30\
    \ = mid29 / 2\n        val mid31 = mid29 - mid30\n        val mid32 = mid31 /\
    \ 2\n        val mid33 = mid31 - mid32\n        val mid34 = mid33 / 2\n      \
    \  val mid35 = mid33 - mid34\n        val mid36 = mid35 / 2\n        val mid37\
    \ = mid35 - mid36\n        val mid38 = mid37 / 2\n        val mid39 = mid37 -\
    \ mid38\n        val mid40 = mid39 / 2\n        val mid41 = mid39 - mid40\n  \
    \      val mid42 = mid41 / 2\n        val mid43 = mid41 - mid42\n        val mid44\
    \ = mid43 / 2\n        val mid45 = mid43 - mid44\n        val mid46 = mid45 /\
    \ 2\n        val mid47 = mid45 - mid46\n        val mid48 = mid47 / 2\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6uki6utd.scala:74:5\
    \ ---------------------\e[0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009603
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n\
    \        else {\n            val first = arr(0)\n            val last = arr(n-1)\n\
    \            val mid = first + last/2\n            val newArr = arr.filter(_ !=\
    \ mid)\n            val newArr2 = newArr.filter(_ > mid)\n            val newArr3\
    \ = newArr2.filter(_ < mid)\n            if (newArr3.isEmpty) moveOneBall(newArr2)\n\
    \            else moveOneBall(newArr3)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpemu1p8ps.scala:38)\n\tat Problem.main(tmpemu1p8ps.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660009605
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val r = new Array[Long](n + 1)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = false\n        while(i\
    \ < n) {\n            if(i == n) {\n                temp = m\n               \
    \ for(j <- 0 until n) {\n                    r(i) = arr(j)\n                 \
    \   i += 1\n                }\n                for(j <- 0 until n) {\n       \
    \             arr(j) = temp\n                    j += 1\n                }\n \
    \               flag = true\n                break\n            }\n          \
    \  temp = arr(i)\n            for(j <- 0 until n) {\n                r(i) = arr(j)\n\
    \                i += 1\n            }\n            for(j <- 0 until n) {\n  \
    \              arr(j) = temp\n                j += 1\n            }\n        \
    \    i += 1\n        }\n        if(flag) {\n            for(j <- 0 until n) {\n\
    \                arr(j) = r(k + 1)\n                k += 1\n            }\n  \
    \          for(j <- 0 until n) {\n                r(j) = arr(j)\n            \
    \    j += 1\n            }\n            for(j <- 0 until n) {\n              \
    \  arr(j) = r(k + 1)\n                k += 1\n            }\n            return\
    \ true\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdjcku5a8.scala:32:23\
    \ --------------------\e[0m\e[0m\n\e[31m32 |\e[0m                temp = m\n\e\
    [31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m            \
    \           Found:    (m : Long)\n\e[31m   |\e[0m                       Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdjcku5a8.scala:38:20\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    arr(j)\
    \ = temp\n\e[31m\e[31m   |\e[0m                    ^^^\e[0m\n\e[31m   |\e[0m \
    \ value update is not a member of List[Long] - did you mean arr.updated?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpdjcku5a8.scala:39:22 ------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m                    j += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^\e[0m\n\e[31m   |\e[0m                    value\
    \ += is not a member of Int - did you mean j.!=?\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpdjcku5a8.scala:42:16 ------------------------\e[0m\e[0m\n\e[31m42\
    \ |\e[0m                break\n\e[31m\e[31m   |\e[0m                ^^^^^\e[0m\n\
    \e[31m   |\e[0m                Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpdjcku5a8.scala:44:22 --------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m            temp = arr(i)\n\e[31m\e[31m   |\e[0m    \
    \               ^^^^^^\e[0m\n\e[31m   |\e[0m                   Found:    Long\n\
    \e[31m   |\e[0m                   Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdjcku5a8.scala:50:16 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                arr(j) = temp\n\e[31m\e[31m   |\e[0m\
    \                ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpdjcku5a8.scala:51:18\
    \ ------------------------\e[0m\e[0m\n\e[31m51 |\e[0m                j += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660009607
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr = arr.drop(1)\n        val arr =\
    \ arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr\
    \ = arr.drop(1)\n        val arr = arr.drop(1)\n        val arr = arr.drop(1)\n\
    \        val arr = arr.drop(1)\n        val arr = arr.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp83wa4tv8.scala:96:4 ----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp83wa4tv8.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp83wa4tv8.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp83wa4tv8.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.drop(\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp83wa4tv8.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp83wa4tv8.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e["
  stdout: ''
  timestamp: 1660009609
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val sortedArr = arr.sortBy(-_)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedAr\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgd7qupkv.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgd7qupkv.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgd7qupkv.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.take(n-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgd7qupkv.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.drop(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgd7qupkv.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.take(n-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgd7qupkv.scala:29:12 ---------------------------\e["
  stdout: ''
  timestamp: 1660009611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val m = arr.head\n        val s = arr.tail\n        val\
    \ d = new Array[Long](n + 1)\n        val r = new Array[Long](n + 1)\n       \
    \ val t = new Array[Long](n + 1)\n        val u = new Array[Long](n + 1)\n   \
    \     val v = new Array[Long](n + 1)\n        val w = new Array[Long](n + 1)\n\
    \        val x = new Array[Long](n + 1)\n        val y = new Array[Long](n + 1)\n\
    \        val z = new Array[Long](n + 1)\n        val a = new Array[Long](n + 1)\n\
    \        val b = new Array[Long](n + 1)\n        val c = new Array[Long](n + 1)\n\
    \        val d = new Array[Long](n + 1)\n        val e = new Array[Long](n + 1)\n\
    \        val f = new Array[Long](n + 1)\n        val g = new Array[Long](n + 1)\n\
    \        val h = new Array[Long](n + 1)\n        val i = new Array[Long](n + 1)\n\
    \        val j = new Array[Long](n + 1)\n        val k = new Array[Long](n + 1)\n\
    \        val l = new Array[Long](n + 1)\n        val m = new Array[Long](n + 1)\n\
    \        val n = new Array[Long](n + 1)\n        val o = new Array[Long](n + 1)\n\
    \        val p = new Array[Long](n + 1)\n        val q = new Array[Long](n + 1)\n\
    \        val r = new Array[Long](n + 1)\n        val s = new Array[Long](n + 1)\n\
    \        val t = new Array[Long](n + 1)\n        val u = new Array[Long](n + 1)\n\
    \        val v = new Array[Long](n + 1)\n        val w = new Array[Long](n + 1)\n\
    \        val x = new Array[Long](n + 1)\n        val y = new Array[Long](n + 1)\n\
    \        val z = new Array[Long](n + 1)\n        val a = new Array[Long](n + 1)\n\
    \        val b = new Array[Long](n + 1)\n        val c = new Array[Long](n + 1)\n\
    \        val d = new Array[Long](n + 1)\n        val e = new Array[Long](n + 1)\n\
    \        val f = new Array[Long](n + 1)\n        val g = new Array[Long](n + 1)\n\
    \        val h = new Array[Long](n + 1)\n        val i = new Array[Long](n + 1)\n\
    \        val j = new Array\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphn15nkie.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36md\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0md is already defined\
    \ as \e[33mvalue\e[0m \e[35md\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphn15nkie.scala:47:12 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mm\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvalue\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphn15nkie.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphn15nkie.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mval\e[0m \e[36mr\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mr is already defined\
    \ as \e[33mvalue\e[0m \e[35mr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphn15nkie.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \e[36ms\e[0m = \e[33mnew\e[0m\
    \ \e[35mArray\e[0m[\e[35mLong\e[0m](n + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009610
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else if(arr.head\
    \ == arr.last) false\n        else {\n            val newArr = arr.tail.tail\n\
    \            val newArr2 = newArr.tail\n            val newArr3 = newArr2.tail\n\
    \            val newArr4 = newArr3.tail\n            val newArr5 = newArr4.tail\n\
    \            val newArr6 = newArr5.tail\n            val newArr7 = newArr6.tail\n\
    \            val newArr8 = newArr7.tail\n            val newArr9 = newArr8.tail\n\
    \            val newArr10 = newArr9.tail\n            val newArr11 = newArr10.tail\n\
    \            val newArr12 = newArr11.tail\n            val newArr13 = newArr12.tail\n\
    \            val newArr14 = newArr13.tail\n            val newArr15 = newArr14.tail\n\
    \            val newArr16 = newArr15.tail\n            val newArr17 = newArr16.tail\n\
    \            val newArr18 = newArr17.tail\n            val newArr19 = newArr18.tail\n\
    \            val newArr20 = newArr19.tail\n            val newArr21 = newArr20.tail\n\
    \            val newArr22 = newArr21.tail\n            val newArr23 = newArr22.tail\n\
    \            val newArr24 = newArr23.tail\n            val newArr25 = newArr24.tail\n\
    \            val newArr26 = newArr25.tail\n            val newArr27 = newArr26.tail\n\
    \            val newArr28 = newArr27.tail\n            val newArr29 = newArr28.tail\n\
    \            val newArr30 = newArr29.tail\n            val newArr31 = newArr30.tail\n\
    \            val newArr32 = newArr31.tail\n            val newArr33 = newArr32.tail\n\
    \            val newArr34 = newArr33.tail\n            val newArr35 = newArr34.tail\n\
    \            val newArr36 = newArr35.tail\n            val newArr37 = newArr36.tail\n\
    \            val newArr38 = newArr37.tail\n            val newArr39 = newArr38.tail\n\
    \            val newArr40 = newArr39.tail\n            val newArr41 = newArr40.tail\n\
    \            val newArr42 = newArr41.tail\n            val newArr43 = newArr42.tail\n\
    \            val newArr44 = newArr43.tail\n            val newArr45 = newArr44.tail\n\
    \            val newArr46 = newArr45.tail\n            val newArr47 = newArr46.tail\n\
    \            val newArr48 = newArr47.tail\n            \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcmsk1ing.scala:84:0 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcmsk1ing.scala:83:1\
    \ ---------------------\e[0m\e[0m\n\e[31m83 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpcmsk1ing.scala:75:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m75 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val startIndex = len - 1\n        val endIndex = startIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzhg1jojj.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mstartIndex\e[0m = startIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstartIndex is already defined as \e[33mvalue\e[0m \e[35mstartIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzhg1jojj.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mendIndex\e[0m = endIndex - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mendIndex is already defined as \e[33mvalue\e[0m \e[35mendIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzhg1jojj.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mstartValue\e[0m = arr(startIndex)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstartValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mstartValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzhg1jojj.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mendValue\e[0m = arr(endIndex)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mendValue is already defined as \e[33mvalue\e[0m \e[35mendValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzhg1jojj.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mstartIndex\e[0m = startIndex - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mstartIndex is already defined as \e[33mvalue\e[0m \e[35mstartIndex\e\
    [0m\n\e[31"
  stdout: ''
  timestamp: 1660009612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprkjx1l37.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprkjx1l37.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprkjx1l37.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmprkjx1l37.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmprkjx1l37.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprkjx1l37.scala:30:12\
    \ ----"
  stdout: ''
  timestamp: 1660009612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val n = arr.length\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n   \
    \     val arr = arr.toList\n        val arr = arr.toList\n        val arr = arr.toList\n\
    \        val arr = arr.toList\n        val arr = arr.toList\n        val arr =\
    \ arr.toList\n        val arr = arr.toList\n        val arr = \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpfy7wyy5u.scala:95:17 ---------------------------\e\
    [0m\e[0m\n\e[31m95 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfy7wyy5u.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.length\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e\
    [0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpfy7wyy5u.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfy7wyy5u.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfy7wyy5u.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfy7wyy5u.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33m"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else {\n\
    \            val n = arr.size\n            val arr = arr.toList\n            val\
    \ first = arr(0)\n            val last = arr(n)\n            val newArr = arr.toArray\n\
    \            val newArr2 = newArr.toList\n            val newArr3 = newArr2.reverse\n\
    \            val newArr4 = newArr3.toArray\n            val newArr5 = newArr4.reverse\n\
    \            val newArr6 = newArr5.reverse\n            val newArr7 = newArr6.reverse\n\
    \            val newArr8 = newArr7.reverse\n            val newArr9 = newArr8.reverse\n\
    \            val newArr10 = newArr9.reverse\n            val newArr11 = newArr10.reverse\n\
    \            val newArr12 = newArr11.reverse\n            val newArr13 = newArr12.reverse\n\
    \            val newArr14 = newArr13.reverse\n            val newArr15 = newArr14.reverse\n\
    \            val newArr16 = newArr15.reverse\n            val newArr17 = newArr16.reverse\n\
    \            val newArr18 = newArr17.reverse\n            val newArr19 = newArr18.reverse\n\
    \            val newArr20 = newArr19.reverse\n            val newArr21 = newArr20.reverse\n\
    \            val newArr22 = newArr21.reverse\n            val newArr23 = newArr22.reverse\n\
    \            val newArr24 = newArr23.reverse\n            val newArr25 = newArr24.reverse\n\
    \            val newArr26 = newArr25.reverse\n            val newArr27 = newArr26.reverse\n\
    \            val newArr28 = newArr27.reverse\n            val newArr29 = newArr28.reverse\n\
    \            val newArr30 = newArr29.reverse\n            val newArr31 = newArr30.reverse\n\
    \            val newArr32 = newArr31.reverse\n            val newArr33 = newArr32.reverse\n\
    \            val newArr34 = newArr33.reverse\n            val newArr35 = newArr34.reverse\n\
    \            val newArr36 = newArr35.reverse\n            val newArr37 = newArr36.reverse\n\
    \            val newArr38 = newArr37.reverse\n            val newArr39 = newArr38.reverse\n\
    \            val newArr40 = newArr39.reverse\n            val newArr41 = newArr40.reverse\n\
    \            val newArr42 = newArr41.reverse\n            val newArr43 = newArr42.reverse\n\
    \            val newArr44 = newArr43.reverse\n            val newArr45 = newArr44.reverse\n\
    \            val newArr46 = newArr45.reverse\n            val newArr47 = newArr46.reverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnkkm4mgm.scala:85:0 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnkkm4mgm.scala:25:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                      ^\e\
    [0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnkkm4mgm.scala:84:1\
    \ ---------------------\e[0m\e[0m\n\e[31m84 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpnkkm4mgm.scala:76:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m76 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Boolean](n + 1)\n        result(0) = true\n  \
    \      result(1) = false\n        val max = (n - 1).toLong\n        val min =\
    \ 0\n        val maxIndex = 0\n        val minIndex = 0\n        var i = 0\n \
    \       var j = 0\n        var k = 0\n        var temp = 0\n        var temp2\
    \ = 0\n        var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n \
    \       var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var\
    \ temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12\
    \ = 0\n        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n\
    \        var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n    \
    \    var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var\
    \ temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25\
    \ = 0\n        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n\
    \        var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n    \
    \    var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var\
    \ temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38\
    \ = 0\n        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n\
    \        var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n    \
    \    var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var\
    \ temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51\
    \ = 0\n        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n\
    \        var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n    \
    \    var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var\
    \ temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64\
    \ = 0\n        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n\
    \        var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n    \
    \    var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var\
    \ temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77\
    \ = 0\n        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n\
    \        var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n    \
    \    var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var\
    \ temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps4is88i8.scala:124:5\
    \ --------------------\e[0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val result = new mutable.ListBuffer[Long]()\n        var\
    \ i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n        var\
    \ temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n        var temp5 =\
    \ 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n   \
    \     var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n        var\
    \ temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n        var temp15\
    \ = 0\n        var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n\
    \        var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n    \
    \    var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n        var\
    \ temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n        var temp28\
    \ = 0\n        var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n\
    \        var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n    \
    \    var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n        var\
    \ temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n        var temp41\
    \ = 0\n        var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n\
    \        var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n    \
    \    var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n        var\
    \ temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n        var temp54\
    \ = 0\n        var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n\
    \        var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n    \
    \    var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n        var\
    \ temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n        var temp67\
    \ = 0\n        var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n\
    \        var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n    \
    \    var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n        var\
    \ temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n        var temp80\
    \ = 0\n        var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n\
    \        var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n    \
    \    var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n        var\
    \ temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n        var temp93\
    \ = 0\n        var temp94 = 0\n        var temp95 = 0\n        var \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpqim84qbo.scala:123:11 --------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqim84qbo.scala:22:18 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqim84qbo.scala:24:25 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqim84qbo.scala:124:5\
    \ --------------------\e[0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660009612
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        val temp2 = new Array[Long](n)\n        val temp3 = new Array[Long](n)\n\
    \        val temp4 = new Array[Long](n)\n        val temp5 = new Array[Long](n)\n\
    \        val temp6 = new Array[Long](n)\n        val temp7 = new Array[Long](n)\n\
    \        val temp8 = new Array[Long](n)\n        val temp9 = new Array[Long](n)\n\
    \        val temp10 = new Array[Long](n)\n        val temp11 = new Array[Long](n)\n\
    \        val temp12 = new Array[Long](n)\n        val temp13 = new Array[Long](n)\n\
    \        val temp14 = new Array[Long](n)\n        val temp15 = new Array[Long](n)\n\
    \        val temp16 = new Array[Long](n)\n        val temp17 = new Array[Long](n)\n\
    \        val temp18 = new Array[Long](n)\n        val temp19 = new Array[Long](n)\n\
    \        val temp20 = new Array[Long](n)\n        val temp21 = new Array[Long](n)\n\
    \        val temp22 = new Array[Long](n)\n        val temp23 = new Array[Long](n)\n\
    \        val temp24 = new Array[Long](n)\n        val temp25 = new Array[Long](n)\n\
    \        val temp26 = new Array[Long](n)\n        val temp27 = new Array[Long](n)\n\
    \        val temp28 = new Array[Long](n)\n        val temp29 = new Array[Long](n)\n\
    \        val temp30 = new Array[Long](n)\n        val temp31 = new Array[Long](n)\n\
    \        val temp32 = new Array[Long](n)\n        val temp33 = new Array[Long](n)\n\
    \        val temp34 = new Array[Long](n)\n        val temp35 = new Array[Long](n)\n\
    \        val temp36 = new Array[Long](n)\n        val temp37 = new Array[Long](n)\n\
    \        val temp38 = new Array[Long](n)\n        val temp39 = new Array[Long](n)\n\
    \        val temp40 = new Array[Long](n)\n        val temp41 = new Array[Long](n)\n\
    \        val temp42 = new Array[Long](n)\n        val temp43 = new Array[Long](n)\n\
    \        val temp44 = new Array[Long](n)\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4dyajsuy.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp4dyajsuy.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Boolean](n + 1)\n        result(0) = true\n  \
    \      result(1) = false\n        val temp = new Array[Long](n)\n        var i\
    \ = 0\n        while (i < n) {\n            temp(i) = arr(i)\n            i +=\
    \ 1\n        }\n        var j = 0\n        while (j < n) {\n            val temp\
    \ = temp(j)\n            val temp1 = temp(j + 1)\n            if (temp1 < temp)\
    \ {\n                val temp = temp1\n                temp(j + 1) = temp(j)\n\
    \                temp(j) = temp1\n            }\n            j += 1\n        }\n\
    \        var k = 0\n        while (k <= n) {\n            if (result(k)) {\n \
    \               val temp = temp(k)\n                temp(k) = temp(n - 1)\n  \
    \              temp(n - 1) = temp\n            }\n            k += 1\n       \
    \ }\n        result(n - 1)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong)))\
    \ == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong, 10l.toLong,\
    \ 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfb25226u.scala:35:23 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36mtemp\e[0m = temp(j)\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             Recursive \e[33mvalue\e[0m \e[35mtemp\e[0m needs type\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpfb25226u.scala:47:27 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m                \e[33mval\e[0m \e[36mtemp\e[0m = temp(k)\n\
    \e[31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m      \
    \                     Recursive \e[33mvalue\e[0m \e[35mtemp\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009611
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        var i = 0\n        var j = 0\n        var k = 0\n        var temp1 =\
    \ 0\n        var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n   \
    \     var temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var\
    \ temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11\
    \ = 0\n        var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n\
    \        var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n    \
    \    var temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var\
    \ temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24\
    \ = 0\n        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n\
    \        var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n    \
    \    var temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var\
    \ temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37\
    \ = 0\n        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n\
    \        var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n    \
    \    var temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var\
    \ temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50\
    \ = 0\n        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n\
    \        var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n    \
    \    var temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var\
    \ temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63\
    \ = 0\n        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n\
    \        var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n    \
    \    var temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var\
    \ temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76\
    \ = 0\n        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n\
    \        var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n    \
    \    var temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var\
    \ temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89\
    \ = 0\n        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n\
    \        var temp93 = 0\n        var temp94\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw34qpex9.scala:123:4 ---------------------------\e\
    [0m\e[0m\n\e[31m123 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpw34qpex9.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw34qpex9.scala:123:5\
    \ --------------------\e[0m\e[0m\n\e[31m123 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr2 = arr.tail\n        val arr3 = arr2.reverse\n        val arr4\
    \ = arr3.foldLeft(0)((acc, x) => acc + (x * x))\n        val arr5 = arr4.foldLeft(0)((acc,\
    \ x) => acc + (x * x))\n        val arr6 = arr5.foldLeft(0)((acc, x) => acc +\
    \ (x * x))\n        val arr7 = arr6.foldLeft(0)((acc, x) => acc + (x * x))\n \
    \       val arr8 = arr7.foldLeft(0)((acc, x) => acc + (x * x))\n        val arr9\
    \ = arr8.foldLeft(0)((acc, x) => acc + (x * x))\n        val arr10 = arr9.foldLeft(0)((acc,\
    \ x) => acc + (x * x))\n        val arr11 = arr10.foldLeft(0)((acc, x) => acc\
    \ + (x * x))\n        val arr12 = arr11.foldLeft(0)((acc, x) => acc + (x * x))\n\
    \        val arr13 = arr12.foldLeft(0)((acc, x) => acc + (x * x))\n        val\
    \ arr14 = arr13.foldLeft(0)((acc, x) => acc + (x * x))\n        val arr15 = arr14.foldLeft(0)((acc,\
    \ x) => acc + (x * x))\n        val arr16 = arr15.foldLeft(0)((acc, x) => acc\
    \ + (x * x))\n        val arr17 = arr16.foldLeft(0)((acc, x) => acc + (x * x))\n\
    \        val arr18 = arr17.foldLeft(0)((acc, x) => acc + (x * x))\n        val\
    \ arr19 = arr18.foldLeft(0)((acc, x) => acc + (x * x))\n        val arr20 = arr19.foldLeft(0)((acc,\
    \ x) => acc + (x * x))\n        val arr21 = arr20.foldLeft(0)((acc, x) => acc\
    \ + (x * x))\n        val arr22 = arr21.foldLeft(0)((acc, x) => acc + (x * x))\n\
    \        val arr23 = arr22.foldLeft(0)((acc, x) => acc + (x * x))\n        val\
    \ arr24 = arr23.foldLeft(0)((acc, x) => acc + (x * x))\n        val arr25 = arr24.foldLeft(0)((acc,\
    \ x) => acc + (x * x))\n        val arr26 = arr25.foldLeft(0)((acc, x) => acc\
    \ + (x * x))\n        val arr27 = arr26.foldLeft(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpx_pgpby8.scala:49:35 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m \e[36marr27\e[0m = arr26.foldLeft(\n\
    \e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m   |\e[0m\
    \                                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx_pgpby8.scala:26:48\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr4\e\
    [0m = arr3.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) => acc + (x *\
    \ x))\n\e[31m\e[31m   |\e[0m                                                ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                Found:   \
    \ Long\n\e[31m   |\e[0m                                                Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpx_pgpby8.scala:27:24\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36marr5\e[0m = arr4.foldLeft(\e[31m0\e[0m)((\e[36macc\e[0m, \e[36mx\e[0m) =>\
    \ acc + (x * x))\n\e[31m\e[31m   |\e[0m                   ^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                   value foldLeft is not a member of Int\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpx_pgpby8.scala:50:5 ---------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val result = new Array[Boolean](n)\n        var i = 0\n        var j\
    \ = 0\n        var k = 0\n        var temp = 0\n        var temp2 = 0\n      \
    \  var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n        var temp6\
    \ = 0\n        var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n \
    \       var temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n     \
    \   var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n        var\
    \ temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n        var temp19\
    \ = 0\n        var temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n\
    \        var temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n    \
    \    var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n        var\
    \ temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n        var temp32\
    \ = 0\n        var temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n\
    \        var temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n    \
    \    var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n        var\
    \ temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n        var temp45\
    \ = 0\n        var temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n\
    \        var temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n    \
    \    var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n        var\
    \ temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n        var temp58\
    \ = 0\n        var temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n\
    \        var temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n    \
    \    var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n        var\
    \ temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n        var temp71\
    \ = 0\n        var temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n\
    \        var temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n    \
    \    var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n        var\
    \ temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n        var temp84\
    \ = 0\n        var temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n\
    \        var temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n    \
    \    var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n        var\
    \ temp94 = 0\n        var temp95 = 0\n        var temp96 = 0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpaxttpprb.scala:22:18 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpaxttpprb.scala:124:5 --------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        val temp2 = new Array[Long](n)\n        val temp3 = new Array[Long](n)\n\
    \        val temp4 = new Array[Long](n)\n        val temp5 = new Array[Long](n)\n\
    \        val temp6 = new Array[Long](n)\n        val temp7 = new Array[Long](n)\n\
    \        val temp8 = new Array[Long](n)\n        val temp9 = new Array[Long](n)\n\
    \        val temp10 = new Array[Long](n)\n        val temp11 = new Array[Long](n)\n\
    \        val temp12 = new Array[Long](n)\n        val temp13 = new Array[Long](n)\n\
    \        val temp14 = new Array[Long](n)\n        val temp15 = new Array[Long](n)\n\
    \        val temp16 = new Array[Long](n)\n        val temp17 = new Array[Long](n)\n\
    \        val temp18 = new Array[Long](n)\n        val temp19 = new Array[Long](n)\n\
    \        val temp20 = new Array[Long](n)\n        val temp21 = new Array[Long](n)\n\
    \        val temp22 = new Array[Long](n)\n        val temp23 = new Array[Long](n)\n\
    \        val temp24 = new Array[Long](n)\n        val temp25 = new Array[Long](n)\n\
    \        val temp26 = new Array[Long](n)\n        val temp27 = new Array[Long](n)\n\
    \        val temp28 = new Array[Long](n)\n        val temp29 = new Array[Long](n)\n\
    \        val temp30 = new Array[Long](n)\n        val temp31 = new Array[Long](n)\n\
    \        val temp32 = new Array[Long](n)\n        val temp33 = new Array[Long](n)\n\
    \        val temp34 = new Array[Long](n)\n        val temp35 = new Array[Long](n)\n\
    \        val temp36 = new Array[Long](n)\n        val temp37 = new Array[Long](n)\n\
    \        val temp38 = new Array[Long](n)\n        val temp39 = new Array[Long](n)\n\
    \        val temp40 = new Array[Long](n)\n        val temp41 = new Array[Long](n)\n\
    \        val temp42 = new Array[Long](n)\n        val temp43 = new Array[Long](n)\n\
    \        val temp44 = new Array[Long](n)\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprlmm57xf.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmprlmm57xf.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        val arr = arr.toList\n     \
    \   var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n  \
    \      var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n        var\
    \ temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8 =\
    \ 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n \
    \       var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n     \
    \   var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var\
    \ temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21\
    \ = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n\
    \        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n    \
    \    var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var\
    \ temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34\
    \ = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n\
    \        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n    \
    \    var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var\
    \ temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47\
    \ = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n\
    \        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n    \
    \    var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var\
    \ temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60\
    \ = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n\
    \        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n    \
    \    var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var\
    \ temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73\
    \ = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n\
    \        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n    \
    \    var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var\
    \ temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86\
    \ = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\
    \        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n    \
    \    var temp93 = 0\n        var temp94 = 0\n        var temp95\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqjn1051z.scala:124:4 ---------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqjn1051z.scala:25:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqjn1051z.scala:124:5\
    \ --------------------\e[0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val m = arr.head\n        val arr = arr.tail\n        val\
    \ arr1 = arr.toList\n        val arr2 = arr1.reverse\n        val arr3 = arr2.toList\n\
    \        val arr4 = arr3.reverse\n        val arr5 = arr4.toList\n        val\
    \ arr6 = arr5.toList\n        val arr7 = arr6.reverse\n        val arr8 = arr7.toList\n\
    \        val arr9 = arr8.reverse\n        val arr10 = arr9.toList\n        val\
    \ arr11 = arr10.reverse\n        val arr12 = arr11.toList\n        val arr13 =\
    \ arr12.reverse\n        val arr14 = arr13.toList\n        val arr15 = arr14.reverse\n\
    \        val arr16 = arr15.toList\n        val arr17 = arr16.reverse\n       \
    \ val arr18 = arr17.toList\n        val arr19 = arr18.reverse\n        val arr20\
    \ = arr19.toList\n        val arr21 = arr20.reverse\n        val arr22 = arr21.toList\n\
    \        val arr23 = arr22.reverse\n        val arr24 = arr23.toList\n       \
    \ val arr25 = arr24.reverse\n        val arr26 = arr25.toList\n        val arr27\
    \ = arr26.reverse\n        val arr28 = arr27.toList\n        val arr29 = arr28.reverse\n\
    \        val arr30 = arr29.toList\n        val arr31 = arr30.reverse\n       \
    \ val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n        val arr34\
    \ = arr33.toList\n        val arr35 = arr34.reverse\n        val arr36 = arr35.toList\n\
    \        val arr37 = arr36.reverse\n        val arr38 = arr37.toList\n       \
    \ val arr39 = arr38.reverse\n        val arr40 = arr39.toList\n        val arr41\
    \ = arr40.reverse\n        val arr42 = arr41.toList\n        val arr43 = arr42.reverse\n\
    \        val arr44 = arr43.toList\n        val arr45 = arr44.reverse\n       \
    \ val arr46 = arr45.toList\n        val arr47 = arr46.reverse\n        val arr48\
    \ = arr47.toList\n        val arr49 = arr48.reverse\n        val arr50 = arr49.toList\n\
    \        val arr51 = arr50.reverse\n        val arr52 = arr51.toList\n       \
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqz9jlja5.scala:25:18 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpqz9jlja5.scala:79:5 ---------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr = arr.toList\n        val arr1 =\
    \ arr.toArray\n        val arr2 = arr.toBuffer\n        val arr3 = arr.toSeq\n\
    \        val arr4 = arr.toSet\n        val arr5 = arr.toMap\n        val arr6\
    \ = arr.toSeq.toArray\n        val arr7 = arr.toSeq.toList\n        val arr8 =\
    \ arr.toSeq.toSet\n        val arr9 = arr.toSeq.toMap\n        val arr10 = arr.toSeq.toSeq.toArray\n\
    \        val arr11 = arr.toSeq.toSeq.toList\n        val arr12 = arr.toSeq.toSeq.toSet\n\
    \        val arr13 = arr.toSeq.toSeq.toMap\n        val arr14 = arr.toSeq.toSeq.toSeq.toArray\n\
    \        val arr15 = arr.toSeq.toSeq.toSeq.toList\n        val arr16 = arr.toSeq.toSeq.toSeq.toSet\n\
    \        val arr17 = arr.toSeq.toSeq.toSeq.toMap\n        val arr18 = arr.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val arr19 = arr.toSeq.toSeq.toSeq.toSeq.toList\n        val arr20 = arr.toSeq.toSeq.toSeq.toSeq.toSet\n\
    \        val arr21 = arr.toSeq.toSeq.toSeq.toSeq.toMap\n        val arr22 = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n\
    \        val arr23 = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toList\n        val arr24\
    \ = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toSet\n        val arr25 = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toMap\n\
    \        val arr26 = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n       \
    \ val arr27 = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toList\n        val arr28\
    \ = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSet\n        val arr29 = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toMap\n\
    \        val arr30 = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toArray\n \
    \       val arr31 = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toList\n   \
    \     val arr32 = arr.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSeq.toSet\n      \
    \  \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyx3u52u7.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyx3u52u7.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpyx3u52u7.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660009615
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ true\n        else {\n            val first = arr(0)\n            val last =\
    \ arr(n - 1)\n            val mid = first + last\n            val mid2 = mid /\
    \ 2\n            val mid3 = mid / 3\n            val mid4 = mid / 4\n        \
    \    val mid5 = mid / 5\n            val mid6 = mid / 6\n            val mid7\
    \ = mid / 7\n            val mid8 = mid / 8\n            val mid9 = mid / 9\n\
    \            val mid10 = mid / 10\n            val mid11 = mid / 11\n        \
    \    val mid12 = mid / 12\n            val mid13 = mid / 13\n            val mid14\
    \ = mid / 14\n            val mid15 = mid / 15\n            val mid16 = mid /\
    \ 16\n            val mid17 = mid / 17\n            val mid18 = mid / 18\n   \
    \         val mid19 = mid / 19\n            val mid20 = mid / 20\n           \
    \ val mid21 = mid / 21\n            val mid22 = mid / 22\n            val mid23\
    \ = mid / 23\n            val mid24 = mid / 24\n            val mid25 = mid /\
    \ 25\n            val mid26 = mid / 26\n            val mid27 = mid / 27\n   \
    \         val mid28 = mid / 28\n            val mid29 = mid / 29\n           \
    \ val mid30 = mid / 30\n            val mid31 = mid / 31\n            val mid32\
    \ = mid / 32\n            val mid33 = mid / 33\n            val mid34 = mid /\
    \ 34\n            val mid35 = mid / 35\n            val mid36 = mid / 36\n   \
    \         val mid37 = mid / 37\n            val mid38 = mid / 38\n           \
    \ val mid39 = mid / 39\n            val mid40 = mid / 40\n            val mid41\
    \ = mid / 41\n            val mid42 = mid / 42\n            val mid43 = mid /\
    \ 43\n            val mid44 = mid / 44\n            val mid45 = mid / 45\n   \
    \         val mid46 = mid / 46\n            val mid47 = mid / 47\n           \
    \ val mid48 = mid / 48\n            val mid49 = mid / 49\n            val mid50\
    \ = mid / 50\n            val mid51 = mid / 51\n            val mid52 = mid /\
    \ 52\n            val mid53 = mid / 53\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsx46qg2a.scala:91:0 ----------------------------\e\
    [0m\e[0m\n\e[31m91 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsx46qg2a.scala:90:1\
    \ ---------------------\e[0m\e[0m\n\e[31m90 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpsx46qg2a.scala:82:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m82 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009617
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val n = arr.length\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = false\n        while(i\
    \ < n) {\n            temp = arr(i)\n            while(j < n) {\n            \
    \    if(arr(j) < temp) {\n                    temp = arr(j)\n                \
    \    k = j\n                }\n                j += 1\n            }\n       \
    \     result(i) = temp\n            i += 1\n            while(j < n) {\n     \
    \           arr(k) = arr(j)\n                k += 1\n                j += 1\n\
    \            }\n            while(j < n) {\n                arr(k) = arr(j)\n\
    \                k += 1\n                j += 1\n            }\n        }\n  \
    \      for(i<-n;i<n;i++) {\n            if(result(i) == arr(i)) {\n          \
    \      flag = true\n            }\n        }\n        if(flag) {\n           \
    \ return true\n        } else {\n            return false\n        }\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpc6m7sm4v.scala:52:20 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mfor\e[0m(i<-n;i<n;i++) {\n\e[31m\e[31m\
    \   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m                    '<-'\
    \ expected, but ';' found\n\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpc6m7sm4v.scala:52:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m52 |\e[0m        \e[33mfor\e[0m(i<-n;i<n;i++)\
    \ {\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m    \
    \                    pattern expected\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpc6m7sm4v.scala:22:18 ---------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var count = 0\n        var flag\
    \ = false\n        while(i < n) {\n            temp = arr(i)\n            while(j\
    \ < n) {\n                if(arr(j) < temp) {\n                    arr(j) = arr(j+1)\n\
    \                    arr(j+1) = temp\n                    temp = arr(j)\n    \
    \                j++\n                }\n                else {\n            \
    \        j++\n                }\n            }\n            result(i) = temp\n\
    \            i += 1\n        }\n        for(i<n; i< n+1) {\n            for(j\
    \ <i; j<n+1) {\n                if(result(i) > result(j)) {\n                \
    \    temp = result(i)\n                    result(i) = result(j)\n           \
    \         result(j) = temp\n                }\n            }\n        }\n    \
    \    for(i<n; i< n+1) {\n            if(result(i) == 0) {\n                flag\
    \ = true\n            }\n        }\n        if(flag) {\n            return true\n\
    \        }\n        else {\n            return false\n        }\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpi8wq1x8v.scala:38:23 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpi8wq1x8v.scala:41:23 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m                    j++\n\e[31m\e[31m   |\e[0m                       ^\e\
    [0m\n\e[31m   |\e[0m                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi8wq1x8v.scala:47:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mfor\e[0m(i<n;\
    \ i< n+\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e\
    [0m               ')' expected, but ';' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpi8wq1x8v.scala:47:23 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mfor\e[0m(i<n; i< n+\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                       ^\e[0m\n\e[31m   |\e[0m                       '<-' expected,\
    \ but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi8wq1x8v.scala:56:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m56 |\e[0m        \e[33mfor\e[0m(i<n;\
    \ i< n+\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\e[31m   |\e\
    [0m               ')' expected, but ';' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpi8wq1x8v.scala:56:23 ---------------------------\e[0m\e[0m\n\e[31m56\
    \ |\e[0m        \e[33mfor\e[0m(i<n; i< n+\e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m\
    \                       ^\e[0m\n\e[31m   |\e[0m                       '<-' expected,\
    \ but ')' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpi8wq1x8v.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e"
  stdout: ''
  timestamp: 1660009614
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toArray\n        val len = arr.length\n        val arr =\
    \ arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n \
    \       val len = arr.length\n        val arr = arr.toArray\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toArray\n        val len = arr.length\n        val arr =\
    \ arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n \
    \       val len = arr.length\n        val arr = arr.toArray\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toArray\n        val len = arr.length\n        val arr =\
    \ arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n \
    \       val len = arr.length\n        val arr = arr.toArray\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toArray\n        val len = arr.length\n        val arr =\
    \ arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n \
    \       val len = arr.length\n        val arr = arr.toArray\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toArray\n        val len = arr.length\n        val arr =\
    \ arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n \
    \       val len = arr.length\n        val arr = arr.toArray\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toArray\n        val len = arr.length\n        val arr =\
    \ arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n \
    \       val len = arr.length\n        val arr = arr.toArray\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toArray\n        val len = arr.length\n        val arr =\
    \ arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n \
    \       val len = arr.length\n        val arr = arr.toArray\n        val len =\
    \ arr.length\n        val arr = arr.toArray\n        val len = arr.length\n  \
    \      val arr = arr.toArray\n        val len = arr.length\n        val arr =\
    \ arr.toArray\n        val len = arr.length\n        val arr = arr.to\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbmzionn5.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbmzionn5.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbmzionn5.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbmzionn5.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbmzionn5.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbmzionn5.scala:29:12\
    \ ----"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n\
    \        else {\n            val left = 0\n            val right = n - 1\n   \
    \         val mid = left + (right - left) / 2\n            val leftVal = arr(mid)\n\
    \            val rightVal = arr(mid)\n            val leftVal2 = arr(mid)\n  \
    \          val rightVal2 = arr(mid)\n            val leftVal3 = arr(mid)\n   \
    \         val rightVal3 = arr(mid)\n            val leftVal4 = arr(mid)\n    \
    \        val rightVal4 = arr(mid)\n            val leftVal5 = arr(mid)\n     \
    \       val rightVal5 = arr(mid)\n            val leftVal6 = arr(mid)\n      \
    \      val rightVal6 = arr(mid)\n            val leftVal7 = arr(mid)\n       \
    \     val rightVal7 = arr(mid)\n            val leftVal8 = arr(mid)\n        \
    \    val rightVal8 = arr(mid)\n            val leftVal9 = arr(mid)\n         \
    \   val rightVal9 = arr(mid)\n            val leftVal10 = arr(mid)\n         \
    \   val rightVal10 = arr(mid)\n            val leftVal11 = arr(mid)\n        \
    \    val rightVal11 = arr(mid)\n            val leftVal12 = arr(mid)\n       \
    \     val rightVal12 = arr(mid)\n            val leftVal13 = arr(mid)\n      \
    \      val rightVal13 = arr(mid)\n            val leftVal14 = arr(mid)\n     \
    \       val rightVal14 = arr(mid)\n            val leftVal15 = arr(mid)\n    \
    \        val rightVal15 = arr(mid)\n            val leftVal16 = arr(mid)\n   \
    \         val rightVal16 = arr(mid)\n            val leftVal17 = arr(mid)\n  \
    \          val rightVal17 = arr(mid)\n            val leftVal18 = arr(mid)\n \
    \           val rightVal18 = arr(mid)\n            val leftVal19 = arr(mid)\n\
    \            val rightVal19 = arr(mid)\n            val leftVal20 = arr(mid)\n\
    \            val rightVal20 = arr(mid)\n            val leftVal21 = arr(mid)\n\
    \            val rightVal21 = arr(mid)\n            val leftVal22 = arr(mid)\n\
    \            val rightVal22 = arr(mid)\n            val leftVal23 = arr(mid)\n\
    \            val rightVal23 = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp6miiuy05.scala:73:28 ---------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m            \e[33mval\e[0m \e[36mrightVal23\e[0m = \n\
    \e[31m\e[31m   |\e[0m                            ^\e[0m\n\e[31m   |\e[0m     \
    \                       expression expected but \e[31m'}'\e[0m found\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6miiuy05.scala:84:0 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6miiuy05.scala:83:1\
    \ ---------------------\e[0m\e[0m\n\e[31m83 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp6miiuy05.scala:75:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m75 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val s = arr.tail\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ x + 1)\n        val arr = arr.map(x => x - 1)\n        val arr = arr.map(x =>\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpgnce8_fc.scala:74:30 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.map(\e[36mx\e\
    [0m => \n\e[31m\e[31m   |\e[0m                              ^\e[0m\n\e[31m   |\e\
    [0m                              expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpgnce8_fc.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpgnce8_fc.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.map(\e[36mx\e\
    [0m => x - \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgnce8_fc.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.map(\e[36mx\e[0m => x + \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgnce8_fc.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.map(\e[36mx\e[0m => x - \e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded method"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr1 = arr.tail\n        val arr2 = arr1.tail\n        val arr3 =\
    \ arr2.tail\n        val arr4 = arr3.tail\n        val arr5 = arr4.tail\n    \
    \    val arr6 = arr5.tail\n        val arr7 = arr6.tail\n        val arr8 = arr7.tail\n\
    \        val arr9 = arr8.tail\n        val arr10 = arr9.tail\n        val arr11\
    \ = arr10.tail\n        val arr12 = arr11.tail\n        val arr13 = arr12.tail\n\
    \        val arr14 = arr13.tail\n        val arr15 = arr14.tail\n        val arr16\
    \ = arr15.tail\n        val arr17 = arr16.tail\n        val arr18 = arr17.tail\n\
    \        val arr19 = arr18.tail\n        val arr20 = arr19.tail\n        val arr21\
    \ = arr20.tail\n        val arr22 = arr21.tail\n        val arr23 = arr22.tail\n\
    \        val arr24 = arr23.tail\n        val arr25 = arr24.tail\n        val arr26\
    \ = arr25.tail\n        val arr27 = arr26.tail\n        val arr28 = arr27.tail\n\
    \        val arr29 = arr28.tail\n        val arr30 = arr29.tail\n        val arr31\
    \ = arr30.tail\n        val arr32 = arr31.tail\n        val arr33 = arr32.tail\n\
    \        val arr34 = arr33.tail\n        val arr35 = arr34.tail\n        val arr36\
    \ = arr35.tail\n        val arr37 = arr36.tail\n        val arr38 = arr37.tail\n\
    \        val arr39 = arr38.tail\n        val arr40 = arr39.tail\n        val arr41\
    \ = arr40.tail\n        val arr42 = arr41.tail\n        val arr43 = arr42.tail\n\
    \        val arr44 = arr43.tail\n        val arr45 = arr44.tail\n        val arr46\
    \ = arr45.tail\n        val arr47 = arr46.tail\n        val arr48 = arr47.tail\n\
    \        val arr49 = arr48.tail\n        val arr50 = arr49.tail\n        val arr51\
    \ = arr50.tail\n        val arr52 = arr51.tail\n        val arr53 = arr52.tail\n\
    \        val arr54 = arr53.tail\n        val arr55 = arr54.tail\n        val arr56\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1i6h3do7.scala:79:19 ---------------------------\e\
    [0m\e[0m\n\e[31m79 |\e[0m        \e[33mval\e[0m \e[36marr56\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1i6h3do7.scala:80:5 ---------------------\e[0m\e[0m\n\e[31m80\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toArray\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toArray\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toArray\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n\
    \        val arr = arr.toArray\n        val arr = arr.toList\n        val arr\
    \ = arr.sortBy(-_)\n        val arr = arr.toArray\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(-_)\n        val arr = arr.toArray\n        val\
    \ arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(-_)\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.sortBy(-\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpom314or8.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpom314or8.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpom314or8.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpom314or8.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpom314or8.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpom314or8.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(-_)\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue"
  stdout: ''
  timestamp: 1660009623
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else {\n\
    \            val n = arr.length\n            val arr = arr.toList\n          \
    \  val arr1 = arr.toArray\n            val arr2 = arr1.reverse\n            val\
    \ arr3 = arr2.reverse\n            val arr4 = arr3.reverse\n            val arr5\
    \ = arr4.reverse\n            val arr6 = arr5.reverse\n            val arr7 =\
    \ arr6.reverse\n            val arr8 = arr7.reverse\n            val arr9 = arr8.reverse\n\
    \            val arr10 = arr9.reverse\n            val arr11 = arr10.reverse\n\
    \            val arr12 = arr11.reverse\n            val arr13 = arr12.reverse\n\
    \            val arr14 = arr13.reverse\n            val arr15 = arr14.reverse\n\
    \            val arr16 = arr15.reverse\n            val arr17 = arr16.reverse\n\
    \            val arr18 = arr17.reverse\n            val arr19 = arr18.reverse\n\
    \            val arr20 = arr19.reverse\n            val arr21 = arr20.reverse\n\
    \            val arr22 = arr21.reverse\n            val arr23 = arr22.reverse\n\
    \            val arr24 = arr23.reverse\n            val arr25 = arr24.reverse\n\
    \            val arr26 = arr25.reverse\n            val arr27 = arr26.reverse\n\
    \            val arr28 = arr27.reverse\n            val arr29 = arr28.reverse\n\
    \            val arr30 = arr29.reverse\n            val arr31 = arr30.reverse\n\
    \            val arr32 = arr31.reverse\n            val arr33 = arr32.reverse\n\
    \            val arr34 = arr33.reverse\n            val arr35 = arr34.reverse\n\
    \            val arr36 = arr35.reverse\n            val arr37 = arr36.reverse\n\
    \            val arr38 = arr37.reverse\n            val arr39 = arr38.reverse\n\
    \            val arr40 = arr39.reverse\n            val arr41 = arr40.reverse\n\
    \            val arr42 = arr41.reverse\n            val arr43 = arr42.reverse\n\
    \            val arr44 = arr43.reverse\n            val arr45 = arr44.reverse\n\
    \            val arr46 = arr45.reverse\n            val arr47 = arr46.reverse\n\
    \            val arr48 = arr47.reverse\n            val arr49 = arr48.reverse\n\
    \            val arr50 = arr49.reverse\n            val arr51 = arr50.reverse\n\
    \            val arr52 = arr51.reverse\n            val arr53 = arr52.reverse\n\
    \            val arr54 = arr53.reverse\n            val arr55 = arr54.reverse\n\
    \            \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7xnifgfb.scala:92:0 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7xnifgfb.scala:25:22\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e\
    [0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                      ^\e\
    [0m\n\e[31m   |\e[0m                      Recursive \e[33mvalue\e[0m \e[35marr\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7xnifgfb.scala:91:1\
    \ ---------------------\e[0m\e[0m\n\e[31m91 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp7xnifgfb.scala:83:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m83 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else {\n\
    \            val first = arr.head\n            val rest = arr.tail\n         \
    \   val newArr = rest.map(x => x + 1)\n            val newFirst = first + 1\n\
    \            val newRest = rest - newFirst\n            val newRest2 = newRest.map(x\
    \ => x + 1)\n            val newRest3 = newRest2.map(x => x + 1)\n           \
    \ val newRest4 = newRest3.map(x => x + 1)\n            val newRest5 = newRest4.map(x\
    \ => x + 1)\n            val newRest6 = newRest5.map(x => x + 1)\n           \
    \ val newRest7 = newRest6.map(x => x + 1)\n            val newRest8 = newRest7.map(x\
    \ => x + 1)\n            val newRest9 = newRest8.map(x => x + 1)\n           \
    \ val newRest10 = newRest9.map(x => x + 1)\n            val newRest11 = newRest10.map(x\
    \ => x + 1)\n            val newRest12 = newRest11.map(x => x + 1)\n         \
    \   val newRest13 = newRest12.map(x => x + 1)\n            val newRest14 = newRest13.map(x\
    \ => x + 1)\n            val newRest15 = newRest14.map(x => x + 1)\n         \
    \   val newRest16 = newRest15.map(x => x + 1)\n            val newRest17 = newRest16.map(x\
    \ => x + 1)\n            val newRest18 = newRest17.map(x => x + 1)\n         \
    \   val newRest19 = newRest18.map(x => x + 1)\n            val newRest20 = newRest19.map(x\
    \ => x + 1)\n            val newRest21 = newRest20.map(x => x + 1)\n         \
    \   val newRest22 = newRest21.map(x => x + 1)\n            val newRest23 = newRest22.map(x\
    \ => x + 1)\n            val newRest24 = newRest23.map(x => x + 1)\n         \
    \   val newRest25 = newRest24.map(x => x + 1)\n            val newRest26 = newRest25.map(x\
    \ => x + 1)\n            val newRest27 = newRest26.map(x => x + 1)\n         \
    \   val newRest28 = newRest27.map(x => x + 1)\n            val newRest29 = newRest28.map(x\
    \ => x + 1)\n            val newRest30 = newRest29.map(x => x + 1)\n         \
    \   val newRest31 = newRest30.map(x => x + 1)\n            val newRest32 = newRest31.map(x\
    \ => x + 1)\n            val newRest33 = newRest32.map(x => x + 1)\n         \
    \   val newRest34 = newRest33.map(x => \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp8_qi82zf.scala:61:46 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m            \e[33mval\e[0m \e[36mnewRest34\e[0m = newRest33.map(\e\
    [36mx\e[0m => \n\e[31m\e[31m   |\e[0m                                        \
    \      ^\e[0m\n\e[31m   |\e[0m                                       expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmp8_qi82zf.scala:72:0 ----------------------------\e[0m\e[0m\n\e[31m72\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8_qi82zf.scala:28:31 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mnewRest\e[0m = rest\
    \ - newFirst\n\e[31m\e[31m   |\e[0m                          ^^^^^^\e[0m\n\e[31m\
    \   |\e[0mvalue - is not a member of List[Long], but could be made available as\
    \ an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import math.Fractional.Implicits.infixFractionalOps\n\e[31m   |\e[0m  import\
    \ math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e[0m  import math.Numeric.Implicits.infixNumericOps\n\
    \e[31m   |\e[0m\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8_qi82zf.scala:71:1\
    \ ---------------------\e[0m\e[0m\n\e[31m71 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp8_qi82zf.scala:63:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m63 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val result = new Array[Boolean](n + 1)\n        val visited = new Array[Boolean](n\
    \ + 1)\n        val visitedIndex = new Array[Int](n + 1)\n        val visitedIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndex = new Array[Int](n\
    \ + 1)\n        val visitedIndexIndexIndexIndex = new Array[Int](n + 1)\n    \
    \    val visitedIndexIndexIndexIndexIndex = new Array[Int](n + 1)\n        val\
    \ visitedIndexIndexIndexIndexIndexIndex = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int](n + 1)\n        val visitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ = new Array[Int]\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfrrklsnh.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mvisitedIndexIndexIndexIndexIndexIndexIndex\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mInt\e[0m](n + \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvisitedIndexIndexIndexIndexIndexIndexIndex is already defined\
    \ as \e[33mvalue\e[0m \e[35mvisitedIndexIndexIndexIndexIndexIndexIndex\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpfrrklsnh.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mvisitedIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mInt\e[0m](n + \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvisitedIndexIndexIndexIndexIndexIndexIndexIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mvisitedIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfrrklsnh.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mvisitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m = \e[33mnew\e[0m \e[35mArray\e[0m[\e[35mInt\e[0m](n + \e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvisitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mvisitedIndexIndexIndexIndexIndexIndexIndexIndexIndexIndexIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfrrklsnh.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e"
  stdout: ''
  timestamp: 1660009624
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else if(arr.size\
    \ == 1) false\n        else {\n            val first = arr.head\n            val\
    \ last = arr.last\n            val newArr = arr.drop(1).dropRight(1)\n       \
    \     val newLast = last\n            val newFirst = first\n            val newLastIndex\
    \ = newArr.size - 1\n            val newFirstIndex = newArr.size - 2\n       \
    \     val newLastValue = newArr(newLastIndex)\n            val newFirstValue =\
    \ newArr(newFirstIndex)\n            val newLastIndex = newArr.size - 1\n    \
    \        val newFirstIndex = newArr.size - 2\n            val newLastValue = newArr(newLastIndex)\n\
    \            val newFirstValue = newArr(newFirstIndex)\n            val newLastIndex\
    \ = newArr.size - 1\n            val newFirstIndex = newArr.size - 2\n       \
    \     val newLastValue = newArr(newLastIndex)\n            val newFirstValue =\
    \ newArr(newFirstIndex)\n            val newLastIndex = newArr.size - 1\n    \
    \        val newFirstIndex = newArr.size - 2\n            val newLastValue = newArr(newLastIndex)\n\
    \            val newFirstValue = newArr(newFirstIndex)\n            val newLastIndex\
    \ = newArr.size - 1\n            val newFirstIndex = newArr.size - 2\n       \
    \     val newLastValue = newArr(newLastIndex)\n            val newFirstValue =\
    \ newArr(newFirstIndex)\n            val newLastIndex = newArr.size - 1\n    \
    \        val newFirstIndex = newArr.size - 2\n            val newLastValue = newArr(newLastIndex)\n\
    \            val newFirstValue = newArr(newFirstIndex)\n            val newLastIndex\
    \ = newArr.size - 1\n            val newFirstIndex = newArr.size - 2\n       \
    \     val newLastValue = newArr(newLastIndex)\n            val newFirstValue =\
    \ newArr(newFirstIndex)\n            val newLastIndex = newArr.size - 1\n    \
    \        val newFirstIndex = newArr.size - 2\n            val newLastValue = newArr(newLastIndex)\n\
    \            val newFirstValue = newArr(newFirstIndex)\n            val newLastIndex\
    \ = newArr.size - 1\n            val newFirstIndex = newArr.size - 2\n       \
    \     val newLastValue = newArr(newLastIndex)\n            val newFirstValue =\
    \ newArr(newFirstIndex)\n            val newLastIndex = newArr.size - 1\n    \
    \        val newFirstIndex = newArr.size - 2\n            val newLastValue = newArr(newLastIndex)\n\
    \            val newFirstValue = newArr(newFirstIndex)\n            val newLastIndex\
    \ = newArr.size - 1\n            val newFirstIndex = newAr\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdqqy5evt.scala:82:0 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdqqy5evt.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mnewLastIndex\e[0m = newArr.size - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewLastIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewLastIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdqqy5evt.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mnewFirstIndex\e[0m = newArr.size - \e[31m2\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewFirstIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewFirstIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdqqy5evt.scala:36:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m            \e[33mval\e\
    [0m \e[36mnewLastValue\e[0m = newArr(newLastIndex)\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewLastValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewLastValue\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdqqy5evt.scala:37:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m            \e[33mval\e\
    [0m \e[36mnewFirstValue\e[0m = newArr(newFirstIndex)\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewFirstValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mnewFirstValue\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming"
  stdout: ''
  timestamp: 1660009625
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var flag = false\n        while(i\
    \ < n && j < n) {\n            temp = arr(i)\n            arr(i) = arr(j)\n  \
    \          arr(j) = temp\n            i += 1\n            j += 1\n           \
    \ k += 1\n        }\n        for(i = k; i > 0; i -= 1) {\n            temp = arr(i)\n\
    \            arr(i) = arr(i - 1)\n            arr(i - 1) = temp\n        }\n \
    \       for(i = k; i > 0; i -= 1) {\n            temp = arr(i)\n            arr(i)\
    \ = arr(i - 1)\n            arr(i - 1) = temp\n        }\n        for(i = k; i\
    \ > 0; i -= 1) {\n            temp = arr(i)\n            arr(i) = arr(i - 1)\n\
    \            arr(i - 1) = temp\n        }\n        for(i = k; i > 0; i -= 1) {\n\
    \            temp = arr(i)\n            arr(i) = arr(i - 1)\n            arr(i\
    \ - 1) = temp\n        }\n        for(i = k; i > 0; i -= 1) {\n            temp\
    \ = arr(i)\n            arr(i) = arr(i - 1)\n            arr(i - 1) = temp\n \
    \       }\n        for(i = k; i > 0; i -= 1) {\n            temp = arr(i)\n  \
    \          arr(i) = arr(i - 1)\n            arr(i - 1) = temp\n        }\n   \
    \     for(i = k; i > 0; i -= 1) {\n            temp = arr(i)\n            arr(i)\
    \ = arr(i - 1)\n            arr(i - 1) = temp\n        }\n        for(i = k; i\
    \ > 0; i -= 1) {\n            temp = arr(i)\n            arr(i) = arr(i - 1)\n\
    \            arr(i - 1) = temp\n        }\n        for(i = k; i > 0; i -= 1) {\n\
    \            temp = arr(i)\n            arr(i) = arr(i - 1)\n            arr(i\
    \ - 1) = temp\n        }\n        for(i = k; i > 0; i -= 1) {\n            temp\
    \ = arr(i)\n            arr(i) = arr(i - 1)\n            arr(i - 1) = temp\n \
    \       }\n        for(i = k; i > 0; i -= 1) {\n            temp = arr(i)\n  \
    \          arr(i) = arr(i - 1)\n            arr(i - 1) = temp\n        }\n   \
    \     for(i = k; i > 0; i -= 1) {\n            temp = arr(i)\n            arr(i)\
    \ = arr(i - 1)\n            arr(i - 1) = temp\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpc7uugl.scala:38:14 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mfor\e[0m(i = k; i > \e[31m0\e[0m; i -=\
    \ \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m\
    \              ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpnpc7uugl.scala:38:24 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mfor\e[0m(i = k; i > \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               '<-' expected, but ';' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpnpc7uugl.scala:38:32 ---------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mfor\e[0m(i = k; i > \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               '<-' expected, but ')' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpnpc7uugl.scala:43:14 ---------------------------\e[0m\e\
    [0m\n\e[31m43 |\e[0m        \e[33mfor\e[0m(i = k; i > \e[31m0\e[0m; i -= \e[31m1\e\
    [0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e[0m           \
    \   ')' expected, but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpc7uugl.scala:43:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mfor\e[0m(i\
    \ = k; i > \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m         \
    \               ^\e[0m\n\e[31m   |\e[0m                        '<-' expected,\
    \ but ';' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpc7uugl.scala:43:32\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mfor\e[0m(i\
    \ = k; i > \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m         \
    \                       ^\e[0m\n\e[31m   |\e[0m                              \
    \  '<-' expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpc7uugl.scala:48:14\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mfor\e[0m(i\
    \ = k; i > \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m         \
    \     ^\e[0m\n\e[31m   |\e[0m              ')' expected, but '=' found\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmpnpc7uugl.scala"
  stdout: ''
  timestamp: 1660009630
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val len = arr.length\n        if (len ==\
    \ 0) return true\n        val mid = len / 2\n        val leftArr = arr.take(mid)\n\
    \        val rightArr = arr.drop(mid)\n        val leftSorted = leftArr.sorted\n\
    \        val rightSorted = rightArr.sorted\n        val leftSorted = leftSorted.reverse\n\
    \        val rightSorted = rightSorted.reverse\n        val leftSortedLength =\
    \ leftSorted.length\n        val rightSortedLength = rightSorted.length\n    \
    \    val leftSortedLength = leftSortedLength - 1 // To remove the last element\n\
    \        val rightSortedLength = rightSortedLength - 1 // To remove the last element\n\
    \        if (leftSortedLength == rightSortedLength) {\n            val leftSortedSet\
    \ = leftSorted.toSet\n            val rightSortedSet = rightSorted.toSet\n   \
    \         if (leftSortedSet == rightSortedSet) {\n                return true\n\
    \            }\n        }\n        return false\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpa833rpc4.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mleftSorted\e[0m = leftSorted.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mleftSorted is already defined as \e[33mvalue\e[0m \e[35mleftSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa833rpc4.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mrightSorted\e[0m = rightSorted.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mrightSorted is already defined as \e[33mvalue\e[0m \e[35mrightSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpa833rpc4.scala:33:12 ---------------------------\e[0m\e[0m\n\e\
    [31m33 |\e[0m        \e[33mval\e[0m \e[36mleftSortedLength\e[0m = leftSortedLength\
    \ - \e[31m1\e[0m \e[34m// To remove the last element\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftSortedLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftSortedLength\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpa833rpc4.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mrightSortedLength\e[0m = rightSortedLength\
    \ - \e[31m1\e[0m \e[34m// To remove the last element\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mrightSortedLength\
    \ is already defined as \e[33mvalue\e[0m \e[35mrightSortedLength\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var temp = 0\n        var count = 0\n\
    \        while(i < n) {\n            temp = arr(i)\n            while(j < n) {\n\
    \                if(arr(j) < temp) {\n                    temp = arr(j)\n    \
    \                k = j\n                }\n                j += 1\n          \
    \  }\n            arr(k) = temp\n            i += 1\n            k += 1\n    \
    \        count += 1\n        }\n        if(count == 0) {\n            return true\n\
    \        }\n        while(j < n) {\n            arr(k) = arr(j)\n            k\
    \ += 1\n            j += 1\n        }\n        while(i < n) {\n            arr(k)\
    \ = arr(i)\n            k += 1\n            i += 1\n        }\n        while(j\
    \ < n) {\n            arr(k) = arr(j)\n            k += 1\n            j += 1\n\
    \        }\n        while(i < n) {\n            arr(k) = arr(i)\n            k\
    \ += 1\n            i += 1\n        }\n        while(j < n) {\n            arr(k)\
    \ = arr(j)\n            k += 1\n            j += 1\n        }\n        while(i\
    \ < n) {\n            arr(k) = arr(i)\n            k += 1\n            i += 1\n\
    \        }\n        while(j < n) {\n            arr(k) = arr(j)\n            k\
    \ += 1\n            j += 1\n        }\n        while(i < n) {\n            arr(k)\
    \ = arr(i)\n            k += 1\n            i += 1\n        }\n        while(j\
    \ < n) {\n            arr(k) = arr(j)\n            k += 1\n            j += 1\n\
    \        }\n        while(i < n) {\n            arr(k) = arr(i)\n            k\
    \ += 1\n            i += 1\n        }\n        while(j < n) {\n            arr(k)\
    \ = arr(j)\n            k += 1\n            j += 1\n        }\n        while(i\
    \ < n) {\n            arr(k) = arr(i)\n            k += 1\n            i += 1\n\
    \        }\n        while(j < n) {\n            arr(k) = arr(j)\n            k\
    \ += 1\n            j += 1\n        }\n        while(i < n) {\n            arr(k)\
    \ = arr(i)\n            k += 1\n            i += 1\n        }\n        while(j\
    \ < n) {\n            arr(k) = arr(j)\n            k += 1\n            j += 1\n\
    \        }\n        while(i < n) {\n            arr(k) = arr(i)\n            k\
    \ += 1\n            i += 1\n        }\n        while(j < n) {\n            arr(k)\
    \ = arr(j)\n            k += 1\n            j += 1\n        }\n        while(i\
    \ < n) {\n            arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpff9j0a2p.scala:144:0 ---------------------------\e\
    [0m\e[0m\n\e[31m144 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpff9j0a2p.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpff9j0a2p.scala:24:25\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpff9j0a2p.scala:143:1 --------------------\e[0m\e[0m\n\e[31m143\
    \ |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e[0m\n\e[31m    |\e[0m Found:    Unit\n\e\
    [31m    |\e[0m Required: Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpff9j0a2p.scala:135:4\
    \ ---------------------------------------\e[0m\e[0m\n\e[33m135 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m    |\e[0m    ^\e[0m\n\e[33m    |\e[0m    Line is indented too far\
    \ to the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1660009626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        while(i < n) {\n           \
    \ temp = arr(i)\n            for(j <- 0 until i) {\n                if(arr(j)\
    \ > temp) {\n                    arr(j) = arr(j)\n                } else {\n \
    \                   arr(j) = temp\n                }\n            }\n        \
    \    result(i) = arr(i)\n            i += 1\n        }\n        for(k <- 0 until\
    \ i) {\n            arr(k) = result(k) \n        }\n        arr.toList.sortWith(_\
    \ < _)\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6x_8xi_b.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660009622
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val r = new Array[Long](n)\n        val temp = new Array[Long](n)\n \
    \       val temp2 = new Array[Long](n)\n        val temp3 = new Array[Long](n)\n\
    \        val temp4 = new Array[Long](n)\n        val temp5 = new Array[Long](n)\n\
    \        val temp6 = new Array[Long](n)\n        val temp7 = new Array[Long](n)\n\
    \        val temp8 = new Array[Long](n)\n        val temp9 = new Array[Long](n)\n\
    \        val temp10 = new Array[Long](n)\n        val temp11 = new Array[Long](n)\n\
    \        val temp12 = new Array[Long](n)\n        val temp13 = new Array[Long](n)\n\
    \        val temp14 = new Array[Long](n)\n        val temp15 = new Array[Long](n)\n\
    \        val temp16 = new Array[Long](n)\n        val temp17 = new Array[Long](n)\n\
    \        val temp18 = new Array[Long](n)\n        val temp19 = new Array[Long](n)\n\
    \        val temp20 = new Array[Long](n)\n        val temp21 = new Array[Long](n)\n\
    \        val temp22 = new Array[Long](n)\n        val temp23 = new Array[Long](n)\n\
    \        val temp24 = new Array[Long](n)\n        val temp25 = new Array[Long](n)\n\
    \        val temp26 = new Array[Long](n)\n        val temp27 = new Array[Long](n)\n\
    \        val temp28 = new Array[Long](n)\n        val temp29 = new Array[Long](n)\n\
    \        val temp30 = new Array[Long](n)\n        val temp31 = new Array[Long](n)\n\
    \        val temp32 = new Array[Long](n)\n        val temp33 = new Array[Long](n)\n\
    \        val temp34 = new Array[Long](n)\n        val temp35 = new Array[Long](n)\n\
    \        val temp36 = new Array[Long](n)\n        val temp37 = new Array[Long](n)\n\
    \        val temp38 = new Array[Long](n)\n        val temp39 = new Array[Long](n)\n\
    \        val temp40 = new Array[Long](n)\n        val temp41 = new Array[Long](n)\n\
    \        val temp42 = new Array[Long](n)\n        val temp43 = new Array[Long](n)\n\
    \        val temp44 = new Array[Long](n)\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpl6jn18qp.scala:69:11 ---------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl6jn18qp.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ true\n        else {\n            val sortedArr = arr.sortBy(x => x)\n     \
    \       val sortedArr = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x\
    \ => x)\n            val sortedArr = arr.sortBy(x => x)\n            val sortedArr\
    \ = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x => x)\n     \
    \       val sortedArr = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x\
    \ => x)\n            val sortedArr = arr.sortBy(x => x)\n            val sortedArr\
    \ = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x => x)\n     \
    \       val sortedArr = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x\
    \ => x)\n            val sortedArr = arr.sortBy(x => x)\n            val sortedArr\
    \ = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x => x)\n     \
    \       val sortedArr = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x\
    \ => x)\n            val sortedArr = arr.sortBy(x => x)\n            val sortedArr\
    \ = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x => x)\n     \
    \       val sortedArr = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x\
    \ => x)\n            val sortedArr = arr.sortBy(x => x)\n            val sortedArr\
    \ = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x => x)\n     \
    \       val sortedArr = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x\
    \ => x)\n            val sortedArr = arr.sortBy(x => x)\n            val sortedArr\
    \ = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x => x)\n     \
    \       val sortedArr = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x\
    \ => x)\n            val sortedArr = arr.sortBy(x => x)\n            val sortedArr\
    \ = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x => x)\n     \
    \       val sortedArr = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x\
    \ => x)\n            val sortedArr = arr.sortBy(x => x)\n            val sortedArr\
    \ = arr.sortBy(x => x)\n            val sortedArr = arr.sortBy(x => x)\n     \
    \       val sortedArr = arr.sort\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7uv908s8.scala:77:0 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7uv908s8.scala:26:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7uv908s8.scala:27:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7uv908s8.scala:28:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7uv908s8.scala:29:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7uv908s8.scala:30:16"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3\
    \ = 0\n        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n \
    \       var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var\
    \ temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13\
    \ = 0\n        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n\
    \        var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n    \
    \    var temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var\
    \ temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26\
    \ = 0\n        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n\
    \        var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n    \
    \    var temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var\
    \ temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39\
    \ = 0\n        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n\
    \        var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n    \
    \    var temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var\
    \ temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52\
    \ = 0\n        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n\
    \        var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n    \
    \    var temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var\
    \ temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65\
    \ = 0\n        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n\
    \        var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n    \
    \    var temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var\
    \ temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78\
    \ = 0\n        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n\
    \        var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n    \
    \    var temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var\
    \ temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91\
    \ = 0\n        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n\
    \        var temp95 = 0\n        var temp96 = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr7cl9d82.scala:125:5\
    \ --------------------\e[0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val result = new Array[Boolean](n)\n        val left = new Array[Long](n)\n\
    \        val right = new Array[Long](n)\n        val leftIndex = 0\n        val\
    \ rightIndex = 0\n        val leftCount = 0\n        val rightCount = 0\n    \
    \    val leftMax = arr.head\n        val rightMax = arr.last\n        val leftMin\
    \ = arr.head\n        val rightMin = arr.last\n        val leftMaxIndex = arr.indexOf(0)\n\
    \        val rightMaxIndex = arr.lastIndexOf(0)\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.lastIndexOf(0)\n        val leftMaxCount = arr.count(x\
    \ => x == leftMax)\n        val rightMaxCount = arr.count(x => x == rightMax)\n\
    \        val leftMinCount = arr.count(x => x == leftMin)\n        val rightMinCount\
    \ = arr.count(x => x == rightMin)\n        val leftMaxIndex = arr.indexOf(0)\n\
    \        val rightMaxIndex = arr.lastIndexOf(0)\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.lastIndexOf(0)\n        val leftMaxCount = arr.count(x\
    \ => x == leftMax)\n        val rightMaxCount = arr.count(x => x == rightMax)\n\
    \        val leftMinCount = arr.count(x => x == leftMin)\n        val rightMinCount\
    \ = arr.count(x => x == rightMin)\n        val leftMaxIndex = arr.indexOf(0)\n\
    \        val rightMaxIndex = arr.lastIndexOf(0)\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.lastIndexOf(0)\n        val leftMaxCount = arr.count(x\
    \ => x == leftMax)\n        val rightMaxCount = arr.count(x => x == rightMax)\n\
    \        val leftMinCount = arr.count(x => x == leftMin)\n        val rightMinCount\
    \ = arr.count(x => x == rightMin)\n        val leftMaxIndex = arr.indexOf(0)\n\
    \        val rightMaxIndex = arr.lastIndexOf(0)\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.lastIndexOf(0)\n        val leftMaxCount = arr.count(x\
    \ => x == leftMax)\n        val rightMaxCount = arr.count(x => x == rightMax)\n\
    \        val leftMinCount = arr.count(x => x == leftMin)\n        val rightMinCount\
    \ = arr.count(x => x == rightMin)\n        val leftMaxIndex = arr.indexOf(0)\n\
    \        val rightMaxIndex = arr.lastIndexOf(0)\n        val leftMinIndex = arr.indexOf(0)\n\
    \        val rightMinIndex = arr.lastIndexOf(0)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqiqgmsem.scala:43:12 ---------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mleftMaxIndex\e[0m = arr.indexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMaxIndex is already defined as \e[33mvalue\e[0m \e[35mleftMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqiqgmsem.scala:44:12 ---------------------------\e[0m\e[0m\n\e\
    [31m44 |\e[0m        \e[33mval\e[0m \e[36mrightMaxIndex\e[0m = arr.lastIndexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightMaxIndex is already defined as \e[33mvalue\e[0m \e[35mrightMaxIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqiqgmsem.scala:45:12 ---------------------------\e[0m\e[0m\n\e\
    [31m45 |\e[0m        \e[33mval\e[0m \e[36mleftMinIndex\e[0m = arr.indexOf(\e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mleftMinIndex is already defined as \e[33mvalue\e[0m \e[35mleftMinIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqiqgmsem.scala:46:12 ---------------------------\e[0m\e[0m\n\e\
    [31m46 |\e[0m        \e[33mval\e[0m \e[36mrightMinIndex\e[0m = arr.lastIndexOf(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightMinIndex is already defined as \e[33mvalue\e[0m \e[35mrightMinIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqiqgmsem.scala:47:12 ---------------------------\e[0m\e[0m\n\e\
    [31m47 |\e[0m        \e[33mval\e[0m \e[36mleftMaxCount\e[0m = arr.count(\e[36mx\e\
    [0m => x == leftMax)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009626
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val visited = new\
    \ mutable.HashSet[Long]()\n        val visitedCount = new mutable.HashMap[Long,\
    \ Int]()\n        val visitedCountMap = new mutable.HashMap[Long, Int]()\n   \
    \     visited.add(0)\n        visitedCount.update(0, arr.size)\n        visitedCountMap.update(0,0)\n\
    \        val maxCount = visitedCount.max\n        val maxCountKey = visitedCount.maxKey\n\
    \        val maxCountValue = visitedCount.maxValue\n        val maxCountKeyValue\
    \ = visitedCountMap.maxKeyValue\n        val maxCountKeyValueValue = visitedCountMap.maxValue\n\
    \        val maxCountKeyValueValueValue = visitedCountMap.maxValueValue\n    \
    \    val maxCountKeyValueValueValueValue = visitedCountMap.maxValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValue = visitedCountMap.maxValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValue = visitedCountMap.maxValueValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValueValue = visitedCountMap.maxValueValueValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValueValueValue = visitedCountMap.maxValueValueValueValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValueValueValue = visitedCountMap.maxValueValueValueValueValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValueValueValue = visitedCountMap.maxValueValueValueValueValueValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValueValueValueValue = visitedCountMap.maxValueValueValueValueValueValueValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValueValueValueValueValue = visitedCountMap.maxValueValueValueValueValueValueValueValueValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValueValueValueValueValueValue\
    \ = visitedCountMap.maxValueValueValueValueValueValueValueValueValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValueValueValueValueValueValueValue\
    \ = visitedCountMap.maxValueValueValueValueValueValueValueValueValueValueValueValueValue\n\
    \        val maxCountKeyValueValueValueValueValueValueValueValueValueValueValueValue\
    \ = visitedCountMap.maxValueValueValueValueValueValueValueValueValueValueValueValueValueValue\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpc0hg9qwl.scala:42:12 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mmaxCountKeyValueValueValueValueValueValueValueValue\e\
    [0m = visitedCountMap.maxValueValueValueValueValueValueValueValue\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountKeyValueValueValueValueValueValueValueValue is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxCountKeyValueValueValueValueValueValueValueValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc0hg9qwl.scala:43:12 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mmaxCountKeyValueValueValueValueValueValueValueValue\e\
    [0m = visitedCountMap.maxValueValueValueValueValueValueValueValueValue\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountKeyValueValueValueValueValueValueValueValue is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxCountKeyValueValueValueValueValueValueValueValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpc0hg9qwl.scala:48:12 ---------------------------\e[0m\e[0m\n\e\
    [31m48 |\e[0m        \e[33mval\e[0m \e[36mmaxCountKeyValueValueValueValueValueValueValueValueValueValueValueValue\e\
    [0m = visitedCountMap.maxValueValueValueValueValueValueValueValueValueValueValueValueValueValue\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxCountKeyValueValueValueValueValueValueValueValueValueValueValueValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxCountKeyValueValueValueValueValueV"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var temp1 = 0\n        var temp2\
    \ = 0\n        var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n \
    \       var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var\
    \ temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12\
    \ = 0\n        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n\
    \        var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n    \
    \    var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var\
    \ temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25\
    \ = 0\n        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n\
    \        var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n    \
    \    var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var\
    \ temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38\
    \ = 0\n        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n\
    \        var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n    \
    \    var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var\
    \ temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51\
    \ = 0\n        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n\
    \        var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n    \
    \    var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var\
    \ temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64\
    \ = 0\n        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n\
    \        var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n    \
    \    var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var\
    \ temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77\
    \ = 0\n        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n\
    \        var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n    \
    \    var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var\
    \ temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90\
    \ = 0\n        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n\
    \        var temp94 = 0\n        var temp95 = 0\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpjhitcu8d.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpjhitcu8d.scala:124:5 --------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        while(i < n) {\n           \
    \ temp = arr(i)\n            while(j < (n - i)) {\n                arr(j) = arr(j\
    \ + 1)\n                j += 1\n            }\n            arr(j) = temp\n   \
    \         i += 1\n            j += 1\n        }\n        for(i = n - 1; i >= 0;\
    \ i -= 1) {\n            k = i\n            while(k >= 0 && arr(k) > arr(k + 1))\
    \ {\n                arr(k) = arr(k + 1)\n                k -= 1\n           \
    \ }\n        }\n        for(i = n - 1; i >= 0; i -= 1) {\n            k = i\n\
    \            while(k >= 0 && arr(k) < arr(k + 1)) {\n                arr(k) =\
    \ arr(k + 1)\n                k -= 1\n            }\n        }\n        for(i\
    \ = n - 1; i >= 0; i -= 1) {\n            k = i\n            while(k >= 0 && arr(k)\
    \ == arr(k + 1)) {\n                arr(k) = arr(k + 1)\n                k -=\
    \ 1\n            }\n        }\n        for(i = n - 1; i >= 0; i -= 1) {\n    \
    \        k = i\n            while(k >= 0 && arr(k) > arr(k + 1)) {\n         \
    \       arr(k) = arr(k + 1)\n                k -= 1\n            }\n        }\n\
    \        for(i = n - 1; i >= 0; i -= 1) {\n            k = i\n            while(k\
    \ >= 0 && arr(k) < arr(k + 1)) {\n                arr(k) = arr(k + 1)\n      \
    \          k -= 1\n            }\n        }\n        for(i = n - 1; i >= 0; i\
    \ -= 1) {\n            k = i\n            while(k >= 0 && arr(k) == arr(k + 1))\
    \ {\n                arr(k) = arr(k + 1)\n                k -= 1\n           \
    \ }\n        }\n        for(i = n - 1; i >= 0; i -= 1) {\n            k = i\n\
    \            while(k >= 0 && arr(k) > arr(k + 1)) {\n                arr(k) =\
    \ arr(k + 1)\n                k -= 1\n            }\n        }\n        for(i\
    \ = n - 1; i >= 0; i -= 1) {\n            k = i\n            while(k >= 0 && arr(k)\
    \ < arr(k + 1)) {\n                arr(k) = arr(k + 1)\n                k -= 1\n\
    \            }\n        }\n        for(i = n - 1; i >= 0; i -= 1) {\n        \
    \    k = i\n            while(k >= 0 && arr(k) == arr(k + 1)) {\n            \
    \    arr(k) = arr(k + 1)\n                k -= 1\n            }\n        }\n \
    \       \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4oz7f3f9.scala:39:14 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e\
    [31m   |\e[0m              ')' expected, but '=' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp4oz7f3f9.scala:39:29 ---------------------------\e[0m\e\
    [0m\n\e[31m39 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e[31m0\e\
    [0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                             ^\e\
    [0m\n\e[31m   |\e[0m                             '<-' expected, but ';' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4oz7f3f9.scala:39:37 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                      \
    \               ^\e[0m\n\e[31m   |\e[0m                                     '<-'\
    \ expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4oz7f3f9.scala:46:14\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mfor\e[0m(i\
    \ = n - \e[31m1\e[0m; i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m  \
    \ |\e[0m              ^\e[0m\n\e[31m   |\e[0m              ')' expected, but '='\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4oz7f3f9.scala:46:29 ---------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e\
    [31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m   |\e[0m                      \
    \       ^\e[0m\n\e[31m   |\e[0m                             '<-' expected, but\
    \ ';' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4oz7f3f9.scala:46:37\
    \ ---------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mfor\e[0m(i\
    \ = n - \e[31m1\e[0m; i >= \e[31m0\e[0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m  \
    \ |\e[0m                                     ^\e[0m\n\e[31m   |\e[0m         \
    \                            '<-' expected, but ')' found\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmp4oz7f3f9.scala:53:14 ---------------------------\e[0m\e\
    [0m\n\e[31m53 |\e[0m        \e[33mfor\e[0m(i = n - \e[31m1\e[0m; i >= \e[31m0\e\
    [0m; i -= \e[31m1\e[0m) {\n\e[31m\e[31m "
  stdout: ''
  timestamp: 1660009632
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr1 = arr.toList\n        val arr2 =\
    \ arr1.reverse\n        val arr3 = arr2.toList\n        val arr4 = arr3.reverse\n\
    \        val arr5 = arr4.toList\n        val arr6 = arr5.toList\n        val arr7\
    \ = arr6.reverse\n        val arr8 = arr7.toList\n        val arr9 = arr8.reverse\n\
    \        val arr10 = arr9.toList\n        val arr11 = arr10.reverse\n        val\
    \ arr12 = arr11.toList\n        val arr13 = arr12.reverse\n        val arr14 =\
    \ arr13.toList\n        val arr15 = arr14.reverse\n        val arr16 = arr15.toList\n\
    \        val arr17 = arr16.reverse\n        val arr18 = arr17.toList\n       \
    \ val arr19 = arr18.reverse\n        val arr20 = arr19.toList\n        val arr21\
    \ = arr20.reverse\n        val arr22 = arr21.toList\n        val arr23 = arr22.reverse\n\
    \        val arr24 = arr23.toList\n        val arr25 = arr24.reverse\n       \
    \ val arr26 = arr25.toList\n        val arr27 = arr26.reverse\n        val arr28\
    \ = arr27.toList\n        val arr29 = arr28.reverse\n        val arr30 = arr29.toList\n\
    \        val arr31 = arr30.reverse\n        val arr32 = arr31.toList\n       \
    \ val arr33 = arr32.reverse\n        val arr34 = arr33.toList\n        val arr35\
    \ = arr34.reverse\n        val arr36 = arr35.toList\n        val arr37 = arr36.reverse\n\
    \        val arr38 = arr37.toList\n        val arr39 = arr38.reverse\n       \
    \ val arr40 = arr39.toList\n        val arr41 = arr40.reverse\n        val arr42\
    \ = arr41.toList\n        val arr43 = arr42.reverse\n        val arr44 = arr43.toList\n\
    \        val arr45 = arr44.reverse\n        val arr46 = arr45.toList\n       \
    \ val arr47 = arr46.reverse\n        val arr48 = arr47.toList\n        val arr49\
    \ = arr48.reverse\n        val arr50 = arr49.toList\n        val arr51 = arr50.reverse\n\
    \        val arr52 = arr51.toList\n        val arr53 = arr5\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmplcq7xdbn.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmplcq7xdbn.scala:78:5 ---------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val arr1 = arr.toArray\n        val arr2 = arr1.clone\n        val arr3\
    \ = arr2.clone\n        val arr4 = arr3.clone\n        val arr5 = arr4.clone\n\
    \        val arr6 = arr5.clone\n        val arr7 = arr6.clone\n        val arr8\
    \ = arr7.clone\n        val arr9 = arr8.clone\n        val arr10 = arr9.clone\n\
    \        val arr11 = arr10.clone\n        val arr12 = arr11.clone\n        val\
    \ arr13 = arr12.clone\n        val arr14 = arr13.clone\n        val arr15 = arr14.clone\n\
    \        val arr16 = arr15.clone\n        val arr17 = arr16.clone\n        val\
    \ arr18 = arr17.clone\n        val arr19 = arr18.clone\n        val arr20 = arr19.clone\n\
    \        val arr21 = arr20.clone\n        val arr22 = arr21.clone\n        val\
    \ arr23 = arr22.clone\n        val arr24 = arr23.clone\n        val arr25 = arr24.clone\n\
    \        val arr26 = arr25.clone\n        val arr27 = arr26.clone\n        val\
    \ arr28 = arr27.clone\n        val arr29 = arr28.clone\n        val arr30 = arr29.clone\n\
    \        val arr31 = arr30.clone\n        val arr32 = arr31.clone\n        val\
    \ arr33 = arr32.clone\n        val arr34 = arr33.clone\n        val arr35 = arr34.clone\n\
    \        val arr36 = arr35.clone\n        val arr37 = arr36.clone\n        val\
    \ arr38 = arr37.clone\n        val arr39 = arr38.clone\n        val arr40 = arr39.clone\n\
    \        val arr41 = arr40.clone\n        val arr42 = arr41.clone\n        val\
    \ arr43 = arr42.clone\n        val arr44 = arr43.clone\n        val arr45 = arr44.clone\n\
    \        val arr46 = arr45.clone\n        val arr47 = arr46.clone\n        val\
    \ arr48 = arr47.clone\n        val arr49 = arr48.clone\n        val arr50 = arr49.clone\n\
    \        val arr51 = arr50.clone\n        val arr52 = arr51.clone\n        val\
    \ arr53 = arr52.clone\n        val arr54 = arr53.clone\n        val arr55 = arr54.clone\n\
    \        val arr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpplgpo9ax.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpplgpo9ax.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpplgpo9ax.scala:80:5\
    \ ---------------------\e[0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009627
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val result\
    \ = new Array[Boolean](n + 1)\n        var i = 0\n        var j = 0\n        var\
    \ k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n\
    \        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n       \
    \ var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10\
    \ = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n\
    \        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n    \
    \    var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var\
    \ temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23\
    \ = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n\
    \        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n    \
    \    var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var\
    \ temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36\
    \ = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n\
    \        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n    \
    \    var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var\
    \ temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49\
    \ = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n\
    \        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n    \
    \    var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var\
    \ temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62\
    \ = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n\
    \        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n    \
    \    var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var\
    \ temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75\
    \ = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n\
    \        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n    \
    \    var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var\
    \ temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88\
    \ = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n\
    \        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    \
    \    var temp95 = 0\n        var temp96 = 0\n        var temp97 = 0\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwnr5dak4.scala:125:5\
    \ --------------------\e[0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009628
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val arr1 = arr.toArray\n        val arr2 = arr1.reverse\n        val\
    \ arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n        val arr5 = arr4.reverse\n\
    \        val arr6 = arr5.reverse\n        val arr7 = arr6.reverse\n        val\
    \ arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n        val arr10 = arr9.reverse\n\
    \        val arr11 = arr10.reverse\n        val arr12 = arr11.reverse\n      \
    \  val arr13 = arr12.reverse\n        val arr14 = arr13.reverse\n        val arr15\
    \ = arr14.reverse\n        val arr16 = arr15.reverse\n        val arr17 = arr16.reverse\n\
    \        val arr18 = arr17.reverse\n        val arr19 = arr18.reverse\n      \
    \  val arr20 = arr19.reverse\n        val arr21 = arr20.reverse\n        val arr22\
    \ = arr21.reverse\n        val arr23 = arr22.reverse\n        val arr24 = arr23.reverse\n\
    \        val arr25 = arr24.reverse\n        val arr26 = arr25.reverse\n      \
    \  val arr27 = arr26.reverse\n        val arr28 = arr27.reverse\n        val arr29\
    \ = arr28.reverse\n        val arr30 = arr29.reverse\n        val arr31 = arr30.reverse\n\
    \        val arr32 = arr31.reverse\n        val arr33 = arr32.reverse\n      \
    \  val arr34 = arr33.reverse\n        val arr35 = arr34.reverse\n        val arr36\
    \ = arr35.reverse\n        val arr37 = arr36.reverse\n        val arr38 = arr37.reverse\n\
    \        val arr39 = arr38.reverse\n        val arr40 = arr39.reverse\n      \
    \  val arr41 = arr40.reverse\n        val arr42 = arr41.reverse\n        val arr43\
    \ = arr42.reverse\n        val arr44 = arr43.reverse\n        val arr45 = arr44.reverse\n\
    \        val arr46 = arr45.reverse\n        val arr47 = arr46.reverse\n      \
    \  val arr48 = arr47.reverse\n        val arr49 = arr48.reverse\n        val arr50\
    \ = arr49.reverse\n        val arr51 = arr50.reverse\n        val arr52 = arr51.reverse\n\
    \        val arr53 = arr52.reverse\n        val arr54 = arr53.reverse\n      \
    \  val arr55 = arr54.reverse\n        val arr56 = arr55.reverse\n\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu39tnyk6.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpu39tnyk6.scala:81:5 ---------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009631
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr1 = arr.toList\n        val arr2 =\
    \ arr1.reverse\n        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n\
    \        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val\
    \ arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n\
    \        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n       \
    \ val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14\
    \ = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n\
    \        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n      \
    \  val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21\
    \ = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n\
    \        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n      \
    \  val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28\
    \ = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n\
    \        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n      \
    \  val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35\
    \ = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n\
    \        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n      \
    \  val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42\
    \ = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n\
    \        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n      \
    \  val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49\
    \ = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n\
    \        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n      \
    \  val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr5\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo5z31xtb.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo5z31xtb.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo5z31xtb.scala:81:5\
    \ ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Boolean](n)\n        val arr = arr.tail\n    \
    \    val arr2 = arr.toList\n        val arr3 = arr2.reverse\n        val arr4\
    \ = arr3.toArray\n        val arr5 = arr4.toList\n        val arr6 = arr5.toArray\n\
    \        val arr7 = arr6.reverse\n        val arr8 = arr7.toList\n        val\
    \ arr9 = arr8.toArray\n        val arr10 = arr9.reverse\n        val arr11 = arr10.toList\n\
    \        val arr12 = arr11.toArray\n        val arr13 = arr12.reverse\n      \
    \  val arr14 = arr13.toList\n        val arr15 = arr14.toArray\n        val arr16\
    \ = arr15.reverse\n        val arr17 = arr16.toList\n        val arr18 = arr17.toArray\n\
    \        val arr19 = arr18.reverse\n        val arr20 = arr19.toList\n       \
    \ val arr21 = arr20.toArray\n        val arr22 = arr21.reverse\n        val arr23\
    \ = arr22.toList\n        val arr24 = arr23.toArray\n        val arr25 = arr24.reverse\n\
    \        val arr26 = arr25.toList\n        val arr27 = arr26.toArray\n       \
    \ val arr28 = arr27.reverse\n        val arr29 = arr28.toList\n        val arr30\
    \ = arr29.toArray\n        val arr31 = arr30.reverse\n        val arr32 = arr31.toList\n\
    \        val arr33 = arr32.toArray\n        val arr34 = arr33.reverse\n      \
    \  val arr35 = arr34.toList\n        val arr36 = arr35.toArray\n        val arr37\
    \ = arr36.reverse\n        val arr38 = arr37.toList\n        val arr39 = arr38.toArray\n\
    \        val arr40 = arr39.reverse\n        val arr41 = arr40.toList\n       \
    \ val arr42 = arr41.toArray\n        val arr43 = arr42.reverse\n        val arr44\
    \ = arr43.toList\n        val arr45 = arr44.toArray\n        val arr46 = arr45.reverse\n\
    \        val arr47 = arr46.toList\n        val arr48 = arr47.toArray\n       \
    \ val arr49 = arr48.reverse\n        val arr50 = arr49.toList\n        val arr51\
    \ = arr50.toArray\n        val arr52 = arr51.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplzjlgp8m.scala:77:4 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmplzjlgp8m.scala:25:18 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m\
    \                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmplzjlgp8m.scala:77:5 ---------------------\e[0m\e[0m\n\e[31m77\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009634
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ {\n            return true\n        }\n        val left = 0\n        val right\
    \ = n - 1\n        val mid = left + (right - left) / 2\n        val temp = arr(mid)\n\
    \        arr(mid) = arr(right)\n        arr(right) = temp\n        moveOneBall(arr.drop(1))\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp31hglvcj.scala:30:8 -------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        arr(mid) = arr(right)\n\e[31m\e[31m   |\e[0m\
    \        ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member of List[Long]\
    \ - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp31hglvcj.scala:31:8\
    \ -------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        arr(right) = temp\n\
    \e[31m\e[31m   |\e[0m        ^^^\e[0m\n\e[31m   |\e[0m  value update is not a\
    \ member of List[Long] - did you mean arr.updated?\n2 errors found\n"
  stdout: ''
  timestamp: 1660009637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n\
    \        else {\n            val sortedArr = arr.sortWith(_ < _)\n           \
    \ val sortedArr = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n\
    \            val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = sortedArr.take(n)\n   \
    \         val sortedArr = sortedArr.sortWith(_ < _)\n            val sortedArr\
    \ = sortedArr.drop(n - 1)\n            val sortedArr = \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvn6dgqwv.scala:63:27 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m            \e[33mval\e[0m \e[36msortedArr\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvn6dgqwv.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvn6dgqwv.scala:26:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = sortedArr.drop(n - \e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvn6dgqwv.scala:27:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = sortedArr.take(n)\n\e[31m\e[31m   |\e[0m          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr is already\
    \ defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvn6dgqwv.scala:28:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e\
    [0m \e[36msortedArr\e[0m = sortedArr.sortWith(_ < _)\n\e[31m\e[31m   |\e[0m  \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvn6dgqwv.scala:29:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e"
  stdout: ''
  timestamp: 1660009637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val len = arr.length\n        if(len ==\
    \ 0) return true\n        val first = arr(0)\n        val last = arr(len-1)\n\
    \        val mid = len/2\n        val left = new Array[Long](mid)\n        val\
    \ right = new Array[Long](mid)\n        for(i <- 0 until mid) left(i) = arr(i)\n\
    \        for(i <- mid until len) right(i) = arr(i)\n        val leftLen = left.length\n\
    \        val rightLen = right.length\n        val leftMax = left.max\n       \
    \ val rightMax = right.max\n        val leftMin = left.min\n        val rightMin\
    \ = right.min\n        val leftSum = left.sum\n        val rightSum = right.sum\n\
    \        val leftProduct = left.product\n        val rightProduct = right.product\n\
    \        val leftDiff = left.diff\n        val rightDiff = right.diff\n      \
    \  val leftSumOfDiff = left.sumOfDiff\n        val rightSumOfDiff = right.sumOfDiff\n\
    \        val leftProductOfDiff = left.productOfDiff\n        val rightProductOfDiff\
    \ = right.productOfDiff\n        val leftDiffOfDiff = left.diffOfDiff\n      \
    \  val rightDiffOfDiff = right.diffOfDiff\n        val leftSumOfDiffOfDiff = left.sumOfDiffOfDiff\n\
    \        val rightSumOfDiffOfDiff = right.sumOfDiffOfDiff\n        val leftProductOfDiffOfDiff\
    \ = left.productOfDiffOfDiff\n        val rightProductOfDiffOfDiff = right.productOfDiffOfDiff\n\
    \        val leftDiffOfDiffOfDiff = left.diffOfDiffOfDiff\n        val rightDiffOfDiffOfDiff\
    \ = right.diffOfDiffOfDiff\n        val leftSumOfDiffOfDiffOfDiff = left.sumOfDiffOfDiffOfDiff\n\
    \        val rightSumOfDiffOfDiffOfDiff = right.sumOfDiffOfDiffOfDiff\n      \
    \  val leftProductOfDiffOfDiffOfDiff = left.productOfDiffOfDiffOfDiff\n      \
    \  val rightProductOfDiffOfDiffOfDiff = right.productOfDiffOfDiffOfDiff\n    \
    \    val leftDiffOfDiffOfDiffOfDiff = left.diffOfDiffOfDiffOfDiff\n        val\
    \ rightDiffOfDiffOfDiffOfDiff = right.diffOfDiffOfDiffOfDiff\n        val leftSumOfDiffOfDiffOfDiffOfDiff\
    \ = left.sumOfDiffOfDiffOfDiffOfDiff\n        val rightSumOfDiffOfDiffOfDiffOfDiff\
    \ = right.sumOfDiffOfDiff\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzdj2r8nr.scala:43:33 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m \e[36mleftSumOfDiff\e[0m = left.sumOfDiff\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                          value sumOfDiff is not a member of Array[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzdj2r8nr.scala:44:35 ------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mrightSumOfDiff\e[0m = right.sumOfDiff\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          value sumOfDiff is not a member of Array[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzdj2r8nr.scala:45:37 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mleftProductOfDiff\e[0m =\
    \ left.productOfDiff\n\e[31m\e[31m   |\e[0m                                ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                      value productOfDiff is not a member\
    \ of Array[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzdj2r8nr.scala:46:39\
    \ ------------------------\e[0m\e[0m\n\e[31m46 |\e[0m        \e[33mval\e[0m \e\
    [36mrightProductOfDiff\e[0m = right.productOfDiff\n\e[31m\e[31m   |\e[0m     \
    \                            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \               value productOfDiff is not a member of Array[Long]\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpzdj2r8nr.scala:47:34 ------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m        \e[33mval\e[0m \e[36mleftDiffOfDiff\e[0m = left.diffOfDiff\n\
    \e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         value diffOfDiff is not a member of Array[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzdj2r8nr.scala:48:36 ------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m \e[36mrightDiffOfDiff\e[0m = right.diffOfDiff\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                         value diffOfDiff is not a member of Array[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzdj2r8n"
  stdout: ''
  timestamp: 1660009639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val temp = new mutable.ListBuffer[Long]()\n\
    \        val temp2 = new mutable.ListBuffer[Long]()\n        val temp3 = new mutable.ListBuffer[Long]()\n\
    \        val temp4 = new mutable.ListBuffer[Long]()\n        val temp5 = new mutable.ListBuffer[Long]()\n\
    \        val temp6 = new mutable.ListBuffer[Long]()\n        val temp7 = new mutable.ListBuffer[Long]()\n\
    \        val temp8 = new mutable.ListBuffer[Long]()\n        val temp9 = new mutable.ListBuffer[Long]()\n\
    \        val temp10 = new mutable.ListBuffer[Long]()\n        val temp11 = new\
    \ mutable.ListBuffer[Long]()\n        val temp12 = new mutable.ListBuffer[Long]()\n\
    \        val temp13 = new mutable.ListBuffer[Long]()\n        val temp14 = new\
    \ mutable.ListBuffer[Long]()\n        val temp15 = new mutable.ListBuffer[Long]()\n\
    \        val temp16 = new mutable.ListBuffer[Long]()\n        val temp17 = new\
    \ mutable.ListBuffer[Long]()\n        val temp18 = new mutable.ListBuffer[Long]()\n\
    \        val temp19 = new mutable.ListBuffer[Long]()\n        val temp20 = new\
    \ mutable.ListBuffer[Long]()\n        val temp21 = new mutable.ListBuffer[Long]()\n\
    \        val temp22 = new mutable.ListBuffer[Long]()\n        val temp23 = new\
    \ mutable.ListBuffer[Long]()\n        val temp24 = new mutable.ListBuffer[Long]()\n\
    \        val temp25 = new mutable.ListBuffer[Long]()\n        val temp26 = new\
    \ mutable.ListBuffer[Long]()\n        val temp27 = new mutable.ListBuffer[Long]()\n\
    \        val temp28 = new mutable.ListBuffer[Long]()\n        val temp29 = new\
    \ mutable.ListBuffer[Long]()\n        val temp30 = new mutable.ListBuffer[Long]()\n\
    \        val temp31 = new mutable.ListBuffer[Long]()\n        val temp32 = new\
    \ mutable.ListBuffer[Long]()\n        val temp33 = new mutable.ListBuffer[Long]()\n\
    \        val temp34 = new mutable.ListBuffer[Long]()\n        val temp35 = new\
    \ mutable.ListBuffer\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4d0mp2xa.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:24:25 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:25:23\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mtemp\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4d0mp2xa.scala:26:24 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mtemp2\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mtemp3\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:28:24\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1660009574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val lastElement\
    \ = arr(n-1)\n        val firstElement = arr(0)\n        val lastElementIndex\
    \ = arr.lastIndexOf(lastElement)\n        val firstElementIndex = arr.indexOf(firstElement)\n\
    \        val firstElementIndexInLastElement = firstElementIndex + lastElementIndex\n\
    \        val lastElementIndexInFirstElement = lastElementIndex - firstElementIndex\n\
    \        val lastElementIndexInFirstElementInLastElement = lastElementIndexInFirstElement\
    \ + firstElementIndexInLastElement\n        val lastElementIndexInFirstElementInLastElementInLastElement\
    \ = lastElementIndexInFirstElementInLastElement + firstElementIndexInLastElementInLastElement\n\
    \        val lastElementIndexInFirstElementInLastElementInLastElementInLastElement\
    \ = lastElementIndexInFirstElementInLastElementInLastElement + firstElementIndexInLastElementInLastElementInLastElementInLastElement\n\
    \        val lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElement\
    \ = lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElement\
    \ + firstElementIndexInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\n\
    \        val lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElementInLastElement\
    \ = lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElementInLastElement\
    \ + firstElementIndexInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\n\
    \        val lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\
    \ = lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\
    \ + firstElementIndexInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\n\
    \        val lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\
    \ = lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\
    \ + firstElementIndexInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpauzzeuxu.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpauzzeuxu.scala:24:25 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpauzzeuxu.scala:34:97\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElement\e\
    [0m = lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElement\
    \ + firstElementIndexInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                         ^\e[0m\n\e[31m   |\e[0mRecursive \e\
    [33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElement\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpauzzeuxu.scala:35:110 --------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mlastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElementInLastElement\e\
    [0m = lastElementIndexInFirstElementInLastElementInLastElementInLastElementInLastElementInLastElement\
    \ + firstElementIndexInLastElementInLastElementInLastElementInLastElementInLastElementInLastElementInLastElement\n\
    \e[31m\e[31m   |\e[0m                          "
  stdout: ''
  timestamp: 1660009637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val arr1 = arr.toArray\n        val arr2 = arr.toBuffer\n        val\
    \ arr3 = arr.toSeq\n        val arr4 = arr.toSet\n        val arr5 = arr.toMap\n\
    \        val arr6 = arr.toIterator\n        val arr7 = arr.toArray\n        val\
    \ arr8 = arr.toList\n        val arr9 = arr.toArray\n        val arr10 = arr.toBuffer\n\
    \        val arr11 = arr.toSeq\n        val arr12 = arr.toSet\n        val arr13\
    \ = arr.toMap\n        val arr14 = arr.toIterator\n        val arr15 = arr.toArray\n\
    \        val arr16 = arr.toList\n        val arr17 = arr.toArray\n        val\
    \ arr18 = arr.toBuffer\n        val arr19 = arr.toSeq\n        val arr20 = arr.toSet\n\
    \        val arr21 = arr.toMap\n        val arr22 = arr.toIterator\n        val\
    \ arr23 = arr.toArray\n        val arr24 = arr.toList\n        val arr25 = arr.toArray\n\
    \        val arr26 = arr.toBuffer\n        val arr27 = arr.toSeq\n        val\
    \ arr28 = arr.toSet\n        val arr29 = arr.toMap\n        val arr30 = arr.toIterator\n\
    \        val arr31 = arr.toArray\n        val arr32 = arr.toList\n        val\
    \ arr33 = arr.toArray\n        val arr34 = arr.toBuffer\n        val arr35 = arr.toSeq\n\
    \        val arr36 = arr.toSet\n        val arr37 = arr.toMap\n        val arr38\
    \ = arr.toIterator\n        val arr39 = arr.toArray\n        val arr40 = arr.toList\n\
    \        val arr41 = arr.toArray\n        val arr42 = arr.toBuffer\n        val\
    \ arr43 = arr.toSeq\n        val arr44 = arr.toSet\n        val arr45 = arr.toMap\n\
    \        val arr46 = arr.toIterator\n        val arr47 = arr.toArray\n       \
    \ val arr48 = arr.toList\n        val arr49 = arr.toArray\n        val arr50 =\
    \ arr.toBuffer\n        val arr51 = arr.toSeq\n        val arr52 = arr.toSet\n\
    \        val arr53 = arr.toMap\n        val arr54 = arr.toIterator\n        val\
    \ arr55 = arr.toArray\n        val arr56 = arr.toList\n        val arr57 = arr.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5a2itajf.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp5a2itajf.scala:81:5 ---------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n\
    \        else {\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val mid = first + last/2\n            val left = arr.filter(_ < mid)\n\
    \            val right = arr.filter(_ > mid)\n            val leftSorted = left.sortWith(_\
    \ < _)\n            val rightSorted = right.sortWith(_ > _)\n            val leftSortedSize\
    \ = leftSorted.size\n            val rightSortedSize = rightSorted.size\n    \
    \        if (leftSortedSize == rightSortedSize) {\n                val leftSortedList\
    \ = leftSorted.toList\n                val rightSortedList = rightSorted.toList\n\
    \                val leftSortedListSize = leftSortedList.size\n              \
    \  val rightSortedListSize = rightSortedList.size\n                if (leftSortedListSize\
    \ == rightSortedListSize) {\n                    val leftSortedListIterator =\
    \ leftSortedList.iterator\n                    val rightSortedListIterator = rightSortedList.iterator\n\
    \                    val leftSortedListIteratorSize = leftSortedListIterator.size\n\
    \                    val rightSortedListIteratorSize = rightSortedListIterator.size\n\
    \                    if (leftSortedListIteratorSize == rightSortedListIteratorSize)\
    \ {\n                        val leftSortedListIteratorIterator = leftSortedListIterator.iterator\n\
    \                        val rightSortedListIteratorIterator = rightSortedListIterator.iterator\n\
    \                        val leftSortedListIteratorIteratorSize = leftSortedListIteratorIterator.size\n\
    \                        val rightSortedListIteratorIteratorSize = rightSortedListIteratorIterator.size\n\
    \                        if (leftSortedListIteratorIteratorSize == rightSortedListIteratorIteratorSize)\
    \ {\n                            val leftSortedListIteratorIteratorIterator =\
    \ leftSortedListIteratorIterator.iterator\n                            val rightSortedListIteratorIteratorIterator\
    \ = rightSortedListIteratorIterator.iterator\n                            val\
    \ leftSortedListIteratorIteratorIteratorSize = leftSortedListIteratorIteratorIterator.size\n\
    \                            val rightSortedListIteratorIteratorIteratorSize =\
    \ rightSortedListIteratorIteratorIterator.size\n                            if\
    \ (leftSortedListIteratorIteratorIteratorSize == rightSortedListIteratorIteratorIteratorSize)\
    \ {\n                                val leftSortedListIteratorIteratorIteratorIterator\
    \ = leftSortedListIteratorIteratorIterator.iterator\n                        \
    \        val rightSortedListIteratorIteratorIteratorIterator = rightSortedListIteratorIteratorIterator.iterator\n\
    \                                val leftSortedListIteratorIteratorIteratorIteratorSize\
    \ = leftSortedListIteratorIteratorIteratorIterator.size\n                    \
    \            val rightSortedListIteratorIteratorIteratorIteratorSize = rightSortedListIteratorIteratorIteratorIterator.size\n\
    \                                if (leftSortedListIteratorIteratorIteratorIteratorSize\
    \ == rightSortedListIteratorIteratorIteratorIteratorSize) {\n                \
    \                    val leftSortedListIteratorIteratorIteratorIteratorIterator\
    \ = leftSortedList\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmphjiekqox.scala:71:0 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphjiekqox.scala:34:12\
    \ --------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mif\e[0m (leftSortedSize\
    \ == rightSortedSize) {\n\e[31m\e[31m   |\e[0m            ^\e[0m\n\e[31m   |\e\
    [0m            Found:    Unit\n\e[31m   |\e[0m            Required: Boolean\n\e\
    [31m   |\e[0m            Maybe you are missing an else part for the conditional?\n\
    \e[31m35 |\e[0m                \e[33mval\e[0m \e[36mleftSortedList\e[0m = leftSorted.toList\n\
    \e[31m36 |\e[0m                \e[33mval\e[0m \e[36mrightSortedList\e[0m = rightSorted.toList\n\
    \e[31m37 |\e[0m                \e[33mval\e[0m \e[36mleftSortedListSize\e[0m =\
    \ leftSortedList.size\n\e[31m38 |\e[0m                \e[33mval\e[0m \e[36mrightSortedListSize\e\
    [0m = rightSortedList.size\n\e[31m39 |\e[0m                \e[33mif\e[0m (leftSortedListSize\
    \ == rightSortedListSize) {\n\e[31m40 |\e[0m                    \e[33mval\e[0m\
    \ \e[36mleftSortedListIterator\e[0m = leftSortedList.iterator\n\e[31m41 |\e[0m\
    \                    \e[33mval\e[0m \e[36mrightSortedListIterator\e[0m = rightSortedList.iterator\n\
    \e[31m42 |\e[0m                    \e[33mval\e[0m \e[36mleftSortedListIteratorSize\e\
    [0m = leftSortedListIterator.size\n\e[31m43 |\e[0m                    \e[33mval\e\
    [0m \e[36mrightSortedListIteratorSize\e[0m = rightSortedListIterator.size\n\e\
    [31m44 |\e[0m                    \e[33mif\e[0m (leftSortedListIteratorSize ==\
    \ rightSortedListIteratorSize) {\n\e[31m45 |\e[0m                        \e[33mval\e\
    [0m \e[36mleftSortedListIteratorIterator\e[0m = leftSortedListIterator.iterator\n\
    \e[31m46 |\e[0m                        \e[33mval\e[0m \e[36mrightSortedListIteratorIterator\e\
    [0m = rightSortedListIterator.iterator\n\e[31m47 |\e[0m                      \
    \  \e[33mval\e[0m \e[36mleftSortedListIteratorIteratorSize\e[0m = leftSortedListIteratorIterator.size\n\
    \e[31m48 |\e[0m                        \e[33mval\e[0m \e[36mrightSortedListIteratorIteratorSize\e\
    [0m = rightSortedListIteratorIter"
  stdout: ''
  timestamp: 1660009633
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr = arr.toList\n        val sortedArr = arr.sortBy(x\
    \ => x)\n        val sortedArr = sortedArr.drop(1).reverse\n        val sortedArr\
    \ = sortedArr.take(n).reverse\n        val sortedArr = sortedArr.toList\n    \
    \    val sortedArr = sortedArr.drop(1).reverse\n        val sortedArr = sortedArr.take(n).reverse\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.drop(1).reverse\n\
    \        val sortedArr = sortedArr.take(n).reverse\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.drop(1).reverse\n        val sortedArr = sortedArr.take(n).reverse\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.drop(1).reverse\n\
    \        val sortedArr = sortedArr.take(n).reverse\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.drop(1).reverse\n        val sortedArr = sortedArr.take(n).reverse\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.drop(1).reverse\n\
    \        val sortedArr = sortedArr.take(n).reverse\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.drop(1).reverse\n        val sortedArr = sortedArr.take(n).reverse\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.drop(1).reverse\n\
    \        val sortedArr = sortedArr.take(n).reverse\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.drop(1).reverse\n        val sortedArr = sortedArr.take(n).reverse\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.drop(1).reverse\n\
    \        val sortedArr = sortedArr.take(n).reverse\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.drop(1).reverse\n        val sortedArr = sortedArr.take(n).reverse\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.drop(1).reverse\n\
    \        val sortedArr = sortedArr.take(n).reverse\n        val sortedArr = sortedArr.toList\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5z99woik.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.drop(\e\
    [31m1\e[0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5z99woik.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.take(n).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5z99woik.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp5z99woik.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.drop(\e[31m1\e\
    [0m).reverse\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5z99woik.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.take(n).reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n"
  stdout: ''
  timestamp: 1660009637
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val l = arr.head\n        val r = arr.last\n        val mid = arr.size\
    \ / 2\n        val left = new Array[Long](n)\n        val right = new Array[Long](n)\n\
    \        val temp = new Array[Long](n)\n        val temp2 = new Array[Long](n)\n\
    \        val temp3 = new Array[Long](n)\n        val temp4 = new Array[Long](n)\n\
    \        val temp5 = new Array[Long](n)\n        val temp6 = new Array[Long](n)\n\
    \        val temp7 = new Array[Long](n)\n        val temp8 = new Array[Long](n)\n\
    \        val temp9 = new Array[Long](n)\n        val temp10 = new Array[Long](n)\n\
    \        val temp11 = new Array[Long](n)\n        val temp12 = new Array[Long](n)\n\
    \        val temp13 = new Array[Long](n)\n        val temp14 = new Array[Long](n)\n\
    \        val temp15 = new Array[Long](n)\n        val temp16 = new Array[Long](n)\n\
    \        val temp17 = new Array[Long](n)\n        val temp18 = new Array[Long](n)\n\
    \        val temp19 = new Array[Long](n)\n        val temp20 = new Array[Long](n)\n\
    \        val temp21 = new Array[Long](n)\n        val temp22 = new Array[Long](n)\n\
    \        val temp23 = new Array[Long](n)\n        val temp24 = new Array[Long](n)\n\
    \        val temp25 = new Array[Long](n)\n        val temp26 = new Array[Long](n)\n\
    \        val temp27 = new Array[Long](n)\n        val temp28 = new Array[Long](n)\n\
    \        val temp29 = new Array[Long](n)\n        val temp30 = new Array[Long](n)\n\
    \        val temp31 = new Array[Long](n)\n        val temp32 = new Array[Long](n)\n\
    \        val temp33 = new Array[Long](n)\n        val temp34 = new Array[Long](n)\n\
    \        val temp35 = new Array[Long](n)\n        val temp36 = new Array[Long](n)\n\
    \        val temp37 = new Array[Long](n)\n        val temp38 = new Array[Long](n)\n\
    \        val temp39 = new Array[Long](n)\n        val temp40 = new Array[Long](n)\n\
    \        val temp41 = new Array[Long](n)\n        val temp42 = new \n    }\n \
    \   def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5rluy77t.scala:71:4 ----------------------------\e\
    [0m\e[0m\n\e[31m71 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp5rluy77t.scala:23:18 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp5rluy77t.scala:71:5 ---------------------\e[0m\e[0m\n\e[31m71\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val first = arr(0)\n        val last = arr(n-1)\n     \
    \   val mid = first + last/2\n        val left = new mutable.ListBuffer[Long]()\n\
    \        val right = new mutable.ListBuffer[Long]()\n        val leftCount = new\
    \ mutable.ListBuffer[Long]()\n        val rightCount = new mutable.ListBuffer[Long]()\n\
    \        val leftCount2 = new mutable.ListBuffer[Long]()\n        val rightCount2\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount3 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount3 = new mutable.ListBuffer[Long]()\n        val leftCount4\
    \ = new mutable.ListBuffer[Long]()\n        val rightCount4 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount5 = new mutable.ListBuffer[Long]()\n        val rightCount5\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount6 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount6 = new mutable.ListBuffer[Long]()\n        val leftCount7\
    \ = new mutable.ListBuffer[Long]()\n        val rightCount7 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount8 = new mutable.ListBuffer[Long]()\n        val rightCount8\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount9 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount9 = new mutable.ListBuffer[Long]()\n        val leftCount10\
    \ = new mutable.ListBuffer[Long]()\n        val rightCount10 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount11 = new mutable.ListBuffer[Long]()\n        val rightCount11\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount12 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount12 = new mutable.ListBuffer[Long]()\n        val leftCount13\
    \ = new mutable.ListBuffer[Long]()\n        val rightCount13 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount14 = new mutable.ListBuffer[Long]()\n        val rightCount14\
    \ = new mutable.ListBuffer[Long]()\n        val leftCount15 = new mutable.ListBuffer[Long]()\n\
    \        val rightCount15 = new mutable.ListBuffer[Long]()\n        val leftCount\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp27ot3t_l.scala:60:4 ----------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp27ot3t_l.scala:27:23\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mleft\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp27ot3t_l.scala:28:24 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mright\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp27ot3t_l.scala:29:28 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mleftCount\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                            Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp27ot3t_l.scala:30:29\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e\
    [36mrightCount\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp27ot3t_l.scala:31:29 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mleftCount2\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          "
  stdout: ''
  timestamp: 1660009639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var temp = 0\n        var temp2 = 0\n        var temp3 = 0\n    \
    \    var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n        var\
    \ temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10\
    \ = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n\
    \        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n    \
    \    var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var\
    \ temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23\
    \ = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n\
    \        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n    \
    \    var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var\
    \ temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36\
    \ = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n\
    \        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n    \
    \    var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var\
    \ temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49\
    \ = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n\
    \        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n    \
    \    var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var\
    \ temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62\
    \ = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n\
    \        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n    \
    \    var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var\
    \ temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75\
    \ = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n\
    \        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n    \
    \    var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var\
    \ temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88\
    \ = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n\
    \        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n    \
    \    var temp95 = 0\n        var temp96 = 0\n        var temp97 = 0\n        var\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpao83e1ar.scala:124:11 --------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m        \e[33mvar\e[0m \n\e[31m\e[31m    |\e[0m    \
    \       ^\e[0m\n\e[31m    |\e[0m           pattern expected\n\e[31m    |\e[0m\n\
    \e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpao83e1ar.scala:125:5 --------------------\e\
    [0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val result = new mutable.ListBuffer[Long]()\n        var\
    \ index = 0\n        var temp = 0\n        var count = 0\n        while(index\
    \ < len){\n            temp = arr(index)\n            while(temp > 0){\n     \
    \           temp -= 1\n                index += 1\n            }\n           \
    \ result += temp\n            index += 1\n        }\n        val result = result.toList\n\
    \        val len = result.length\n        val result = new mutable.ListBuffer[Long]()\n\
    \        var index = 0\n        var temp = 0\n        var count = 0\n        while(index\
    \ < len){\n            temp = arr(index)\n            while(temp > 0){\n     \
    \           temp -= 1\n                index += 1\n            }\n           \
    \ result += temp\n            index += 1\n        }\n        val result = result.toList\n\
    \        val len = result.length\n        if(len == 0){\n            return true\n\
    \        }\n        val result = new mutable.ListBuffer[Long]()\n        var index\
    \ = 0\n        var temp = 0\n        var count = 0\n        while(index < len){\n\
    \            temp = arr(index)\n            while(temp > 0){\n               \
    \ temp -= 1\n                index += 1\n            }\n            result +=\
    \ temp\n            index += 1\n        }\n        val result = result.toList\n\
    \        val len = result.length\n        if(len == 0){\n            return true\n\
    \        }\n        val result = new mutable.ListBuffer[Long]()\n        var index\
    \ = 0\n        var temp = 0\n        var count = 0\n        while(index < len){\n\
    \            temp = arr(index)\n            while(temp > 0){\n               \
    \ temp -= 1\n                index += 1\n            }\n            result +=\
    \ temp\n            index += 1\n        }\n        val result = result.toList\n\
    \        val len = result.length\n        if(len == 0){\n            return true\n\
    \        }\n        val result = new mutable.ListBuffer[Long]()\n        var index\
    \ = 0\n        var temp = 0\n        var count = 0\n        while(index < len){\n\
    \            temp = arr(index)\n            while(temp > 0){\n               \
    \ temp -= 1\n                index += 1\n            }\n            result +=\
    \ temp\n            index += 1\n        }\n        val result = result.toList\n\
    \        val len = result.length\n        if(len == 0){\n            return true\n\
    \        }\n        val result = new mutable.ListBuffer[Long]()\n        var index\
    \ = 0\n        var temp = 0\n        var count = 0\n        while(index < len){\n\
    \            temp = arr(index)\n            while(temp > 0){\n               \
    \ temp -= 1\n                index += 1\n            }\n            result +=\
    \ temp\n            index += 1\n        }\n        val result = result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu47i3ada.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = result.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mresult\
    \ is already defined as \e[33mvalue\e[0m \e[35mresult\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu47i3ada.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = result.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpu47i3ada.scala:39:12 ---------------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu47i3ada.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mvar\e[0m \e[36mindex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mindex is already defined\
    \ as \e[33mvariable\e[0m \e[35mindex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu47i3ada.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mvar\e[0m \e[36mtemp\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mtemp is already\
    \ defined as \e[33mvariable\e[0m \e[35mtemp\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of "
  stdout: ''
  timestamp: 1660009640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else {\n\
    \            val sortedArr = arr.sortBy(x => x)\n            val lastElement =\
    \ sortedArr.last\n            val firstElement = sortedArr.head\n            val\
    \ newArr = arr.filterNot(x => x == lastElement)\n            val newArr = newArr.concat(sortedArr.filterNot(x\
    \ => x == firstElement))\n            val newArr = newArr.filterNot(x => x ==\
    \ firstElement)\n            val newArr = newArr.filterNot(x => x == lastElement)\n\
    \            val newArr = newArr.filterNot(x => x == lastElement)\n          \
    \  val newArr = newArr.filterNot(x => x == lastElement)\n            val newArr\
    \ = newArr.filterNot(x => x == lastElement)\n            val newArr = newArr.filterNot(x\
    \ => x == lastElement)\n            val newArr = newArr.filterNot(x => x == lastElement)\n\
    \            val newArr = newArr.filterNot(x => x == lastElement)\n          \
    \  val newArr = newArr.filterNot(x => x == lastElement)\n            val newArr\
    \ = newArr.filterNot(x => x == lastElement)\n            val newArr = newArr.filterNot(x\
    \ => x == lastElement)\n            val newArr = newArr.filterNot(x => x == lastElement)\n\
    \            val newArr = newArr.filterNot(x => x == lastElement)\n          \
    \  val newArr = newArr.filterNot(x => x == lastElement)\n            val newArr\
    \ = newArr.filterNot(x => x == lastElement)\n            val newArr = newArr.filterNot(x\
    \ => x == lastElement)\n            val newArr = newArr.filterNot(x => x == lastElement)\n\
    \            val newArr = newArr.filterNot(x => x == lastElement)\n          \
    \  val newArr = newArr.filterNot(x => x == lastElement)\n            val newArr\
    \ = newArr.filterNot(x => x == lastElement)\n            val newArr = newArr.filterNot(x\
    \ => x == lastElement)\n            val newArr = newArr.filterNot(x => x == lastElement)\n\
    \            val newArr = newArr.filterNot(x => x == lastElement)\n          \
    \  val newArr = newArr.filterNot(x => x == lastElement)\n            val \n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpe40jucu6.scala:53:15 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe40jucu6.scala:64:0 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe40jucu6.scala:28:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e\
    [0m \e[36mnewArr\e[0m = newArr.concat(sortedArr.filterNot(\e[36mx\e[0m => x ==\
    \ firstElement))\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArr is already defined as \e[33mvalue\e[0m \e[35mnewArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpe40jucu6.scala:29:16 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m            \e[33mval\e[0m \e[36mnewArr\e[0m = newArr.filterNot(\e\
    [36mx\e[0m => x == firstElement)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArr is already defined as \e[33mvalue\e[0m \e[35mnewArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpe40jucu6.scala:30:16 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m            \e[33mval\e[0m \e[36mnewArr\e[0m = newArr.filterNot(\e\
    [36mx\e[0m => x == lastElement)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArr is already defined as \e[33mvalue\e[0m \e[35mnewArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpe40jucu6.scala:31:16 -----------"
  stdout: ''
  timestamp: 1660009640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val lastElement\
    \ = arr.last\n        val lastElementIndex = arr.lastIndexOf(lastElement)\n  \
    \      val lastElementIndex = lastElementIndex + 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = lastElementIndex - 1\n        val lastElementIndex = lastElementIndex - 1\n\
    \        val lastElementIndex = lastElementIndex - 1\n        val lastElementIndex\
    \ = last\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcoxfar4w.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlastElementIndex\e[0m =\
    \ lastElementIndex + \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlastElementIndex is already defined as \e[33mvalue\e[0m \e\
    [35mlastElementIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcoxfar4w.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlastElementIndex\e[0m =\
    \ lastElementIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlastElementIndex is already defined as \e[33mvalue\e[0m \e\
    [35mlastElementIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcoxfar4w.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlastElementIndex\e[0m =\
    \ lastElementIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlastElementIndex is already defined as \e[33mvalue\e[0m \e\
    [35mlastElementIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcoxfar4w.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlastElementIndex\e[0m =\
    \ lastElementIndex - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlastElementIndex is already defined as \e[33mvalue\e[0m \e\
    [35mlastElementIndex\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpcoxfar4w.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mlastEl"
  stdout: ''
  timestamp: 1660009639
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n        val arr\
    \ = arr.toArray\n        val len = arr.length\n        val arr = arr.toArray\n\
    \        val len = arr.length\n        val arr = arr.toArray\n        val len\
    \ = arr.length\n        val arr = arr.toArray\n        val len = arr.length\n\
    \        val arr = arr.toArray\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpabh_xzbh.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpabh_xzbh.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpabh_xzbh.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpabh_xzbh.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpabh_xzbh.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is\
    \ already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpabh_xzbh.scala:30:12\
    \ ----"
  stdout: ''
  timestamp: 1660009640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val len = arr.length\n        if(len ==\
    \ 0)\n            return true\n        val maxVal = arr(len-1)\n        val minVal\
    \ = arr(0)\n        val maxIndex = len-1\n        val minIndex = 0\n        val\
    \ maxCount = 1\n        val minCount = 1\n        val maxCount2 = 1\n        val\
    \ minCount2 = 1\n        val maxCount3 = 1\n        val minCount3 = 1\n      \
    \  val maxCount4 = 1\n        val minCount4 = 1\n        val maxCount5 = 1\n \
    \       val minCount5 = 1\n        val maxCount6 = 1\n        val minCount6 =\
    \ 1\n        val maxCount7 = 1\n        val minCount7 = 1\n        val maxCount8\
    \ = 1\n        val minCount8 = 1\n        val maxCount9 = 1\n        val minCount9\
    \ = 1\n        val maxCount10 = 1\n        val minCount10 = 1\n        val maxCount11\
    \ = 1\n        val minCount11 = 1\n        val maxCount12 = 1\n        val minCount12\
    \ = 1\n        val maxCount13 = 1\n        val minCount13 = 1\n        val maxCount14\
    \ = 1\n        val minCount14 = 1\n        val maxCount15 = 1\n        val minCount15\
    \ = 1\n        val maxCount16 = 1\n        val minCount16 = 1\n        val maxCount17\
    \ = 1\n        val minCount17 = 1\n        val maxCount18 = 1\n        val minCount18\
    \ = 1\n        val maxCount19 = 1\n        val minCount19 = 1\n        val maxCount20\
    \ = 1\n        val minCount20 = 1\n        val maxCount21 = 1\n        val minCount21\
    \ = 1\n        val maxCount22 = 1\n        val minCount22 = 1\n        val maxCount23\
    \ = 1\n        val minCount23 = 1\n        val maxCount24 = 1\n        val minCount24\
    \ = 1\n        val maxCount25 = 1\n        val minCount25 = 1\n        val maxCount26\
    \ = 1\n        val minCount26 = 1\n        val maxCount27 = 1\n        val minCount27\
    \ = 1\n        val maxCount28 = 1\n        val minCount28 = 1\n        val maxCount29\
    \ = 1\n        val minCount29 = 1\n        val maxCount30 = 1\n        val minCount30\
    \ = 1\n        val maxCount31 = 1\n        val minCount31 = 1\n        val maxCount32\
    \ = 1\n        val minCount32 = 1\n        val maxCount33 = 1\n        val minCount33\
    \ = 1\n        val max\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpko9fkdn6.scala:96:4 ----------------------------\e\
    [0m\e[0m\n\e[31m96 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpko9fkdn6.scala:96:5 ---------------------\e[0m\e[0m\n\e[31m96 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660009640
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        var i = 0\n        var j = 0\n        var k =\
    \ 0\n        var temp = 0\n        var count = 0\n        var flag = false\n \
    \       var temp2 = new Array[Long](n)\n        while(i < n) {\n            while(j\
    \ < n) {\n                if(arr(i) > arr(j)) {\n                    temp2 = arr\n\
    \                    temp2(k) = arr(j)\n                    temp2(j) = arr(i)\n\
    \                    arr(k) = temp2(0)\n                    arr(j) = temp2(1)\n\
    \                    arr(i) = temp2(0)\n                    flag = true\n    \
    \            }\n                j++\n            }\n            i++\n        \
    \    j = 0\n            k++\n        }\n        if(flag) {\n            count\
    \ = 0\n            while(i < n) {\n                while(j < n) {\n          \
    \          if(arr(i) > arr(j)) {\n                        temp2 = arr\n      \
    \                  temp2(k) = arr(j)\n                        temp2(j) = arr(i)\n\
    \                        arr(k) = temp2(0)\n                        arr(j) = temp2(1)\n\
    \                        arr(i) = temp2(0)\n                        flag = true\n\
    \                    }\n                    j++\n                }\n         \
    \       i++\n                j = 0\n                k++\n                count++\n\
    \            }\n            if(flag && count == n) {\n                i = 0\n\
    \                j = 0\n                k = 0\n                while(i < n) {\n\
    \                    while(j < n) {\n                        if(arr(i) > arr(j))\
    \ {\n                            temp2 = arr\n                            temp2(k)\
    \ = arr(j)\n                            temp2(j) = arr(i)\n                  \
    \          arr(k) = temp2(0)\n                            arr(j) = temp2(1)\n\
    \                            arr(i) = temp2(0)\n                            flag\
    \ = true\n                        }\n                        j++\n           \
    \         }\n                    i++\n                    j = 0\n            \
    \        k++\n                }\n                if(flag) {\n                \
    \    i = 0\n                    j = 0\n                    k = 0\n           \
    \         while(i < n) {\n                        while(j < n) {\n           \
    \                 if(arr(i) > arr(j)) {\n                                temp2\
    \ = arr\n                                temp2(k) = arr(j)\n                 \
    \               temp2(j) = arr(i)\n                                arr(k) = temp2(0)\n\
    \                                arr(j) = temp2(1)\n                         \
    \       arr(i) = temp2(0)\n                                flag = true\n     \
    \                       }\n                            j++\n                 \
    \       }\n                        i++\n                        j = 0\n      \
    \                  k++\n                    }\n                }\n           \
    \ }\n        }\n        if(flag) {\n            i = 0\n            j = 0\n   \
    \         k = 0\n            while(i < n) {\n                while(j < n) {\n\
    \                    if(arr(i) > arr(j)) {\n                        temp2 = arr\n\
    \                        temp2(k) = arr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp09vdrh8a.scala:42:19 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                j++\n\e[31m\e[31m   |\e[0m          \
    \         ^\e[0m\n\e[31m   |\e[0m                   expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmp09vdrh8a.scala:45:14\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m45 |\e[0m       \
    \     j = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m              ^\e[0m\n\e[31m   |\e\
    [0m              end of statement expected but '=' found\n\e[31m\e[31m-- [E018]\
    \ Syntax Error: /tmp/tmp09vdrh8a.scala:46:15 ---------------------------\e[0m\e\
    [0m\n\e[31m46 |\e[0m            k++\n\e[31m\e[31m   |\e[0m               ^\e[0m\n\
    \e[31m   |\e[0m               expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp09vdrh8a.scala:61:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m61 |\e[0m                    j++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- Error: /tmp/tmp09vdrh8a.scala:64:18 -----------------------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m                j = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  end of statement\
    \ expected but '=' found\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp09vdrh8a.scala:66:23\
    \ ---------------------------\e[0m\e[0m\n\e[31m66 |\e[0m                count++\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E018] Syntax Error: /tmp/tmp09vdrh8a.scala:83:27 ---------------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m                        j++\n\e[31m\e[31m   |\e[0m  \
    \                        "
  stdout: ''
  timestamp: 1660009645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val sortedArr = arr.sortBy(x => x)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedArr = sortedArr.drop(1)\n\
    \        val sortedArr = sortedArr.take(n-1)\n        val sortedAr\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp27m_tp51.scala:68:4 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp27m_tp51.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp27m_tp51.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.take(n-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp27m_tp51.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.drop(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp27m_tp51.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.take(n-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp27m_tp51.scala:29:12 ---------------------------\e["
  stdout: ''
  timestamp: 1660009641
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val result = new mutable.ListBuffer[Long]()\n        val\
    \ len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi0tivmoc.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi0tivmoc.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi0tivmoc.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi0tivmoc.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi0tivmoc.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpi0tivmoc.scala:30:12 ----------"
  stdout: ''
  timestamp: 1660009642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n\
    \        else {\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val mid = first + last/2\n            val left = new Array[Long](n-1)\n\
    \            val right = new Array[Long](n-1)\n            val temp = new Array[Long](n-1)\n\
    \            val temp2 = new Array[Long](n-1)\n            val temp3 = new Array[Long](n-1)\n\
    \            val temp4 = new Array[Long](n-1)\n            val temp5 = new Array[Long](n-1)\n\
    \            val temp6 = new Array[Long](n-1)\n            val temp7 = new Array[Long](n-1)\n\
    \            val temp8 = new Array[Long](n-1)\n            val temp9 = new Array[Long](n-1)\n\
    \            val temp10 = new Array[Long](n-1)\n            val temp11 = new Array[Long](n-1)\n\
    \            val temp12 = new Array[Long](n-1)\n            val temp13 = new Array[Long](n-1)\n\
    \            val temp14 = new Array[Long](n-1)\n            val temp15 = new Array[Long](n-1)\n\
    \            val temp16 = new Array[Long](n-1)\n            val temp17 = new Array[Long](n-1)\n\
    \            val temp18 = new Array[Long](n-1)\n            val temp19 = new Array[Long](n-1)\n\
    \            val temp20 = new Array[Long](n-1)\n            val temp21 = new Array[Long](n-1)\n\
    \            val temp22 = new Array[Long](n-1)\n            val temp23 = new Array[Long](n-1)\n\
    \            val temp24 = new Array[Long](n-1)\n            val temp25 = new Array[Long](n-1)\n\
    \            val temp26 = new Array[Long](n-1)\n            val temp27 = new Array[Long](n-1)\n\
    \            val temp28 = new Array[Long](n-1)\n            val temp29 = new Array[Long](n-1)\n\
    \            val temp30 = new Array[Long](n-1)\n            val temp31 = new Array[Long](n-1)\n\
    \            val temp32 = new Array[Long](n-1)\n            val temp33 = new Array[Long](n-1)\n\
    \            val temp34 = new Array[Long](n-1)\n            val temp35 = new Array[Long](n-1)\n\
    \            val temp36 = new Array[Long](n-1)\n            val temp37 = new Array[Long](n-1)\n\
    \            val temp38 = new Array[Long](n-1)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7pom8q25.scala:78:0 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7pom8q25.scala:77:1\
    \ ---------------------\e[0m\e[0m\n\e[31m77 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: Boolean\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmp7pom8q25.scala:69:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m69 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n2 errors found\n"
  stdout: ''
  timestamp: 1660009642
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n       \
    \ val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr\
    \ = arr.toArray\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toArray\n        val arr = arr.toList\n       \
    \ val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toArray\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toArray\n        val arr = arr.toList\n       \
    \ val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toArray\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toArray\n        val arr = arr.toList\n       \
    \ val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toArray\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toArray\n        val arr = arr.toList\n       \
    \ val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n\
    \        val arr = arr.toList\n        val arr = arr.sortBy(x => x)\n        val\
    \ arr = arr.toArray\n        val arr = arr.toList\n        val arr = arr.sortBy(x\
    \ => x)\n        val arr = arr.toArray\n        val arr = arr.toList\n       \
    \ val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n        val arr\
    \ = arr.toList\n        val arr = arr.sortBy(x => x)\n        val arr = arr.toArray\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpmwiauhkt.scala:86:11 ---------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpmwiauhkt.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmwiauhkt.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpmwiauhkt.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmwiauhkt.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e\
    [36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmwiauhkt.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m      "
  stdout: ''
  timestamp: 1660009644
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toList\n    \
    \    val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length-1)\n\
    \        val arr = arr.take(arr.length-1)\n        val arr = arr.toArray\n   \
    \     val arr = arr.sortBy(x => x)\n        val arr = arr.drop(arr.length\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoy7ur4sw.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoy7ur4sw.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already defined as\
    \ \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpoy7ur4sw.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(arr.length-\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoy7ur4sw.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.take(arr.length-\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoy7ur4sw.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoy7ur4sw.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[3"
  stdout: ''
  timestamp: 1660009645
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n\
    \        else {\n            val m = arr.head\n            val r = arr.tail\n\
    \            val newArr = new mutable.ArrayBuffer[Long]()\n            val newArr2\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr3 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr4 = new mutable.ArrayBuffer[Long]()\n            val newArr5\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr6 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr7 = new mutable.ArrayBuffer[Long]()\n            val newArr8\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr9 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr10 = new mutable.ArrayBuffer[Long]()\n            val newArr11\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr12 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr13 = new mutable.ArrayBuffer[Long]()\n            val newArr14\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr15 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr16 = new mutable.ArrayBuffer[Long]()\n            val newArr17\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr18 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr19 = new mutable.ArrayBuffer[Long]()\n            val newArr20\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr21 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr22 = new mutable.ArrayBuffer[Long]()\n            val newArr23\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr24 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr25 = new mutable.ArrayBuffer[Long]()\n            val newArr26\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr27 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr28 = new mutable.ArrayBuffer[Long]()\n            val newArr29\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr30 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr31 = new mutable.ArrayBuffer[Long]()\n            val newArr32\
    \ = new mutable.ArrayBuffer[Long]()\n            val newArr33 = new mutable.ArrayBuffer[Long]()\n\
    \            val newArr34 = new mutable.ArrayBuffer[Long]()\n            val newArr35\
    \ = new mutable.ArrayBuffer\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr0nrb32g.scala:72:0 ----------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr0nrb32g.scala:27:29\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m\
    \ \e[36mnewArr\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpr0nrb32g.scala:28:30 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            \e[33mval\e[0m \e[36mnewArr2\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr0nrb32g.scala:29:30\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m            \e[33mval\e[0m\
    \ \e[36mnewArr3\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpr0nrb32g.scala:30:30 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mnewArr4\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr0nrb32g.scala:31:30\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e[0m\
    \ \e[36mnewArr5\e[0m = \e[33mnew\e[0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\
    \e[3"
  stdout: ''
  timestamp: 1660009646
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val result = new mutable.ListBuffer[Long]()\n        val\
    \ temp = new mutable.ListBuffer[Long]()\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        while(i < len){\n            val temp = arr(i)\n \
    \           arr(i) = arr(j)\n            arr(j) = temp\n            i += 1\n \
    \           j += 1\n            k += 1\n        }\n        for(i <- 0 until len){\n\
    \            val temp = arr(i)\n            arr(i) = arr(k)\n            arr(k)\
    \ = temp\n            k += 1\n        }\n        for(i <- 0 until len){\n    \
    \        val temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) =\
    \ temp\n            j += 1\n        }\n        for(i <- 0 until len){\n      \
    \      val temp = arr(i)\n            arr(i) = arr(k)\n            arr(k) = temp\n\
    \            k += 1\n        }\n        for(i <- 0 until len){\n            val\
    \ temp = arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n    \
    \        j += 1\n        }\n        for(i <- 0 until len){\n            val temp\
    \ = arr(i)\n            arr(i) = arr(k)\n            arr(k) = temp\n         \
    \   k += 1\n        }\n        for(i <- 0 until len){\n            val temp =\
    \ arr(i)\n            arr(i) = arr(j)\n            arr(j) = temp\n           \
    \ j += 1\n        }\n        for(i <- 0 until len){\n            val temp = arr(i)\n\
    \            arr(i) = arr(k)\n            arr(k) = temp\n            k += 1\n\
    \        }\n        for(i <- 0 until len){\n            val temp = arr(i)\n  \
    \          arr(i) = arr(j)\n            arr(j) = temp\n            j += 1\n  \
    \      }\n        for(i <- 0 until len){\n            val temp = arr(i)\n    \
    \        arr(i) = arr(k)\n            arr(k) = temp\n            k += 1\n    \
    \    }\n        for(i <- 0 until len){\n            val temp = arr(i)\n      \
    \      arr(i) = arr(j)\n            arr(j) = temp\n            j += 1\n      \
    \  }\n        for(i <- 0 until len){\n            val temp = arr(i)\n        \
    \    arr(i) = arr(k)\n            arr(k) = temp\n            k += 1\n        }\n\
    \        for(i <- 0 until len){\n            val temp = arr(i)\n            arr(i)\
    \ = arr(j)\n            arr(\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpbdge20xf.scala:106:16 --------------------------\e\
    [0m\e[0m\n\e[31m106 |\e[0m            arr(\n\e[31m\e[31m    |\e[0m           \
    \     ^\e[0m\n\e[31m    |\e[0m                expression expected but \e[31m'}'\e\
    [0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbdge20xf.scala:117:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m117 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpbdge20xf.scala:22:18 ---------------------------\e[0m\e\
    [0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpbdge20xf.scala:24:25 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbdge20xf.scala:25:23\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mtemp\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpbdge20xf.scala:116:1 --------------------\e[0m\e[0m\n\e[31m116\
    \ |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e[0m\n\e[31m    |\e[0m Found:    Unit\n\e\
    [31m    |\e[0m Required: Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpbdge20xf.scala:108:4\
    \ -------------------------"
  stdout: ''
  timestamp: 1660009648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb4ui6lw.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb4ui6lw.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb4ui6lw.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb4ui6lw.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb4ui6lw.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbb4ui6lw.scala:31:12 ----------"
  stdout: ''
  timestamp: 1660009648
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = arr.sortBy(x => x)\n        val len = arr.length\n        val\
    \ arr = arr.sortBy(x => x)\n        val len = arr.length\n        val arr = arr.sortBy(x\
    \ => x)\n        val len = arr.length\n        val arr = arr.sortBy(x => x)\n\
    \        val len = arr.length\n        val arr = arr.sortBy(x => x)\n        val\
    \ len = arr.length\n        val arr = arr.sortBy(x => x)\n        val len = arr.length\n\
    \        val arr = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpykd5i6fn.scala:86:17 ---------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = \n\e[31m\e[31m\
    \   |\e[0m                 ^\e[0m\n\e[31m   |\e[0m                 expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpykd5i6fn.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpykd5i6fn.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpykd5i6fn.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.sortBy(\e[36mx\e[0m => x)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpykd5i6fn.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mlen\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mlen is already defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpykd5i6fn.scala:28:12 ----"
  stdout: ''
  timestamp: 1660009650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = (len - 1)\n        val min =\
    \ 0\n        val max1 = (len - 1)\n        val max2 = (len - 1)\n        val max3\
    \ = (len - 1)\n        val max4 = (len - 1)\n        val max5 = (len - 1)\n  \
    \      val max6 = (len - 1)\n        val max7 = (len - 1)\n        val max8 =\
    \ (len - 1)\n        val max9 = (len - 1)\n        val max10 = (len - 1)\n   \
    \     val max11 = (len - 1)\n        val max12 = (len - 1)\n        val max13\
    \ = (len - 1)\n        val max14 = (len - 1)\n        val max15 = (len - 1)\n\
    \        val max16 = (len - 1)\n        val max17 = (len - 1)\n        val max18\
    \ = (len - 1)\n        val max19 = (len - 1)\n        val max20 = (len - 1)\n\
    \        val max21 = (len - 1)\n        val max22 = (len - 1)\n        val max23\
    \ = (len - 1)\n        val max24 = (len - 1)\n        val max25 = (len - 1)\n\
    \        val max26 = (len - 1)\n        val max27 = (len - 1)\n        val max28\
    \ = (len - 1)\n        val max29 = (len - 1)\n        val max30 = (len - 1)\n\
    \        val max31 = (len - 1)\n        val max32 = (len - 1)\n        val max33\
    \ = (len - 1)\n        val max34 = (len - 1)\n        val max35 = (len - 1)\n\
    \        val max36 = (len - 1)\n        val max37 = (len - 1)\n        val max38\
    \ = (len - 1)\n        val max39 = (len - 1)\n        val max40 = (len - 1)\n\
    \        val max41 = (len - 1)\n        val max42 = (len - 1)\n        val max43\
    \ = (len - 1)\n        val max44 = (len - 1)\n        val max45 = (len - 1)\n\
    \        val max46 = (len - 1)\n        val max47 = (len - 1)\n        val max48\
    \ = (len - 1)\n        val max49 = (len - 1)\n        val max50 = (len - 1)\n\
    \        val max51 = (len - 1)\n        val max52 = (len - 1)\n        val max53\
    \ = (len - 1)\n        val max54 = (len - 1)\n        val max55 = (len - 1)\n\
    \        val max56 = (len - 1)\n        val max57 = (len - 1)\n        val max58\
    \ = (len - 1)\n        val max59 = (len - 1)\n        val max60 = (len\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9b0dqkd9.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp9b0dqkd9.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9b0dqkd9.scala:87:5\
    \ ---------------------\e[0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val sortedArr = arr.sortBy(x => x)\n        val sortedArr = sortedArr.toArray\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.take(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.sortBy(x\
    \ => x)\n        val sortedArr = sortedArr.toArray\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.sortBy(x => x)\n        val sortedArr = sortedArr.toArray\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.take(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.sortBy(x\
    \ => x)\n        val sortedArr = sortedArr.toArray\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.sortBy(x => x)\n        val sortedArr = sortedArr.toArray\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.take(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.sortBy(x\
    \ => x)\n        val sortedArr = sortedArr.toArray\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.sortBy(x => x)\n        val sortedArr = sortedArr.toArray\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.take(n)\n\
    \        val sortedArr = sortedArr.toList\n        val sortedArr = sortedArr.sortBy(x\
    \ => x)\n        val sortedArr = sortedArr.toArray\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.take(n)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.sortBy(x => x)\n        val sortedArr = sortedArr.toArray\n\
    \        val sortedAr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuwsgp3t0.scala:67:4 ----------------------------\e\
    [0m\e[0m\n\e[31m67 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuwsgp3t0.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuwsgp3t0.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e\
    [31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpuwsgp3t0.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.take(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuwsgp3t0.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuwsgp3t0.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |"
  stdout: ''
  timestamp: 1660009650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) return\
    \ true\n        val first = arr(0)\n        val last = arr(n - 1)\n        val\
    \ mid = first + last\n        val left = new Array[Long](n)\n        val right\
    \ = new Array[Long](n)\n        val leftIndex = 0\n        val rightIndex = 0\n\
    \        for (i <- 0 until n) {\n            if (i == 0) {\n                leftIndex\
    \ = 0\n                rightIndex = 0\n                left(0) = mid\n       \
    \         right(0) = mid\n            } else if (i == n - 1) {\n             \
    \   leftIndex = 0\n                rightIndex = n - 1\n                left(n\
    \ - 1) = mid\n                right(n - 1) = mid\n            } else {\n     \
    \           leftIndex = i - 1\n                rightIndex = i\n              \
    \  left(i) = mid\n                right(i) = mid\n            }\n            val\
    \ leftVal = arr(leftIndex)\n            val rightVal = arr(rightIndex)\n     \
    \       if (leftVal > rightVal) {\n                right(rightIndex) = leftVal\n\
    \                rightIndex += 1\n            } else {\n                left(leftIndex)\
    \ = rightVal\n                leftIndex += 1\n            }\n        }\n     \
    \   val leftSorted = left.sorted\n        val rightSorted = right.sorted\n   \
    \     if (leftSorted == rightSorted) {\n            return true\n        } else\
    \ {\n            return false\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E052] Type Error: /tmp/tmpyj1tp159.scala:33:26 -----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                leftIndex = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val leftIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpyj1tp159.scala:34:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                rightIndex\
    \ = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                Reassignment to val rightIndex\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpyj1tp159.scala:38:26 -----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                leftIndex = \e[31m0\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val leftIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpyj1tp159.scala:39:27\
    \ -----------------------------\e[0m\e[0m\n\e[31m39 |\e[0m                rightIndex\
    \ = n - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val rightIndex\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpyj1tp159.scala:43:26 -----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                leftIndex = i - \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \       Reassignment to val leftIndex\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpyj1tp159.scala:44:27 -----------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m                rightIndex = i\n\e[31m\e[31m   |\e[0m    \
    \            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val rightIndex\n\e[31m   |\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val start = 0\n        val end = len - 1\n        val mid\
    \ = len / 2\n        val flag = true\n        val arr2 = arr.toArray\n       \
    \ val arr3 = new Array[Long](len)\n        val arr4 = new Array[Long](len)\n \
    \       val arr5 = new Array[Long](len)\n        val arr6 = new Array[Long](len)\n\
    \        val arr7 = new Array[Long](len)\n        val arr8 = new Array[Long](len)\n\
    \        val arr9 = new Array[Long](len)\n        val arr10 = new Array[Long](len)\n\
    \        val arr11 = new Array[Long](len)\n        val arr12 = new Array[Long](len)\n\
    \        val arr13 = new Array[Long](len)\n        val arr14 = new Array[Long](len)\n\
    \        val arr15 = new Array[Long](len)\n        val arr16 = new Array[Long](len)\n\
    \        val arr17 = new Array[Long](len)\n        val arr18 = new Array[Long](len)\n\
    \        val arr19 = new Array[Long](len)\n        val arr20 = new Array[Long](len)\n\
    \        val arr21 = new Array[Long](len)\n        val arr22 = new Array[Long](len)\n\
    \        val arr23 = new Array[Long](len)\n        val arr24 = new Array[Long](len)\n\
    \        val arr25 = new Array[Long](len)\n        val arr26 = new Array[Long](len)\n\
    \        val arr27 = new Array[Long](len)\n        val arr28 = new Array[Long](len)\n\
    \        val arr29 = new Array[Long](len)\n        val arr30 = new Array[Long](len)\n\
    \        val arr31 = new Array[Long](len)\n        val arr32 = new Array[Long](len)\n\
    \        val arr33 = new Array[Long](len)\n        val arr34 = new Array[Long](len)\n\
    \        val arr35 = new Array[Long](len)\n        val arr36 = new Array[Long](len)\n\
    \        val arr37 = new Array[Long](len)\n        val arr38 = new Array[Long](len)\n\
    \        val arr39 = new Array[Long](len)\n        val arr40 = new Array[Long](len)\n\
    \        val arr41 = new Array[Long](len)\n        val arr42 = new Array[Long](len)\n\
    \        val arr43 = new Array[Long](len)\n        val arr44 = new Array[Long](len)\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp7q82qw3r.scala:22:18 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp7q82qw3r.scala:72:5 ---------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009650
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:30:12 ----------"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val s = arr.tail\n        val arr = arr.toList\n        val arr1 = arr.toArray\n\
    \        val arr2 = arr.toBuffer\n        val arr3 = arr.toSeq\n        val arr4\
    \ = arr.toSet\n        val arr5 = arr.toMap\n        val arr6 = arr.toIterator\n\
    \        val arr7 = arr.toIterable\n        val arr8 = arr.toStream\n        val\
    \ arr9 = arr.toTraversable\n        val arr10 = arr.toIndexedSeq\n        val\
    \ arr11 = arr.toIndexedSeq\n        val arr12 = arr.toIndexedSeq\n        val\
    \ arr13 = arr.toIndexedSeq\n        val arr14 = arr.toIndexedSeq\n        val\
    \ arr15 = arr.toIndexedSeq\n        val arr16 = arr.toIndexedSeq\n        val\
    \ arr17 = arr.toIndexedSeq\n        val arr18 = arr.toIndexedSeq\n        val\
    \ arr19 = arr.toIndexedSeq\n        val arr20 = arr.toIndexedSeq\n        val\
    \ arr21 = arr.toIndexedSeq\n        val arr22 = arr.toIndexedSeq\n        val\
    \ arr23 = arr.toIndexedSeq\n        val arr24 = arr.toIndexedSeq\n        val\
    \ arr25 = arr.toIndexedSeq\n        val arr26 = arr.toIndexedSeq\n        val\
    \ arr27 = arr.toIndexedSeq\n        val arr28 = arr.toIndexedSeq\n        val\
    \ arr29 = arr.toIndexedSeq\n        val arr30 = arr.toIndexedSeq\n        val\
    \ arr31 = arr.toIndexedSeq\n        val arr32 = arr.toIndexedSeq\n        val\
    \ arr33 = arr.toIndexedSeq\n        val arr34 = arr.toIndexedSeq\n        val\
    \ arr35 = arr.toIndexedSeq\n        val arr36 = arr.toIndexedSeq\n        val\
    \ arr37 = arr.toIndexedSeq\n        val arr38 = arr.toIndexedSeq\n        val\
    \ arr39 = arr.toIndexedSeq\n        val arr40 = arr.toIndexedSeq\n        val\
    \ arr41 = arr.toIndexedSeq\n        val arr42 = arr.toIndexedSeq\n        val\
    \ arr43 = arr.toIndexedSeq\n        val arr44 = arr.toIndexedSeq\n        val\
    \ arr45 = arr.toIndexedSeq\n        val arr46 = arr.toIndexedSeq\n        val\
    \ arr47 = arr.toIndexedSeq\n        val arr48 = arr.toIndexedSeq\n        val\
    \ arr49 = arr.toIndexedSeq\n        val arr50 = arr.toIndexedSeq\n        val\
    \ arr51 = arr.\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpffwcpzdm.scala:77:4 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpffwcpzdm.scala:25:18 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpffwcpzdm.scala:77:5 ---------------------\e[0m\e[0m\n\e[31m77\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009652
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val startIndex = len - 1 \n        val endIndex = startIndex\
    \ - 1\n        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n        val endValue = arr(endIndex)\n\
    \        val startIndex = startIndex - 1\n        val endIndex = endIndex - 1\n\
    \        val startValue = arr(startIndex)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xsdxbtr.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mstartIndex\e[0m = startIndex\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstartIndex is already defined as \e[33mvalue\e[0m \e[35mstartIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1xsdxbtr.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mendIndex\e[0m = endIndex - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mendIndex is already defined as \e[33mvalue\e[0m \e[35mendIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1xsdxbtr.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mstartValue\e[0m = arr(startIndex)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstartValue\
    \ is already defined as \e[33mvalue\e[0m \e[35mstartValue\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xsdxbtr.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mendValue\e[0m = arr(endIndex)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mendValue is already defined as \e[33mvalue\e[0m \e[35mendValue\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1xsdxbtr.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mstartIndex\e[0m = startIndex - \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mstartIndex is already defined as \e[33mvalue\e[0m \e[35mstartIndex\e\
    [0m\n\e[31"
  stdout: ''
  timestamp: 1660009651
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        if (n == 0) true\n\
    \        else {\n            val first = arr(0)\n            val last = arr(n)\n\
    \            val mid = first + (last - first) / 2\n            val midVal = arr(mid)\n\
    \            val newArr = arr.filter(_ != midVal)\n            val newArr = newArr.filter(_\
    \ > midVal)\n            if (newArr.isEmpty) true\n            else {\n      \
    \          val newArr = newArr.filter(_ < midVal)\n                if (newArr.isEmpty)\
    \ true\n                else {\n                    val newArr = newArr.filter(_\
    \ >= midVal)\n                    if (newArr.isEmpty) true\n                 \
    \   else {\n                        val newArr = newArr.filter(_ <= midVal)\n\
    \                        if (newArr.isEmpty) true\n                        else\
    \ {\n                            val newArr = newArr.filter(_ >= midVal)\n   \
    \                         if (newArr.isEmpty) true\n                         \
    \   else {\n                                val newArr = newArr.filter(_ <= midVal)\n\
    \                                if (newArr.isEmpty) true\n                  \
    \              else {\n                                    val newArr = newArr.filter(_\
    \ >= midVal)\n                                    if (newArr.isEmpty) true\n \
    \                                   else {\n                                 \
    \       val newArr = newArr.filter(_ <= midVal)\n                            \
    \            if (newArr.isEmpty) true\n                                      \
    \  else {\n                                            val newArr = newArr.filter(_\
    \ >= midVal)\n                                            if (newArr.isEmpty)\
    \ true\n                                            else {\n                 \
    \                               val newArr = newArr.filter(_ <= midVal)\n    \
    \                                            if (newArr.isEmpty) true\n      \
    \                                          else {\n                          \
    \                          val newArr = newArr.filter(_ >= midVal)\n         \
    \                                           if (newArr.isEmpty) true\n       \
    \                                             else {\n                       \
    \                                 val newArr = newArr.filter(_ <= midVal)\n  \
    \                                                      if (newArr.isEmpty) true\n\
    \                                                        else {\n            \
    \                                                val newArr = newArr.filter(_\
    \ >= midVal)\n                                                            if (newArr.isEmpty)\
    \ true\n                                                            else {\n \
    \                                                               val newArr = newArr.filter(_\
    \ <= midVal)\n                                                               \
    \ if (newArr.isEmpty) true\n                                                 \
    \               else {\n                                                     \
    \               val newArr = newArr.filter(_ >= midVal)\n                    \
    \                                                if (newArr.isEmpty) true\n  \
    \                                                                  else {\n  \
    \                                                                      val newArr\
    \ = newArr.filter(_ <= midVal)\n                                             \
    \                           if (newArr.isEmpty) true\n                       \
    \                                                 else {\n                   \
    \                                                         val newArr = newArr.filter(_\
    \ >= midVal)\n                                                               \
    \             if (newAr\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5ingtkqo.scala:80:4 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5ingtkqo.scala:90:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m90 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5ingtkqo.scala:30:16 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m            \e[33mval\e[0m \e[36mnewArr\e[0m = newArr.filter(_ >\
    \ midVal)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mnewArr is already defined as \e[33mvalue\e[0m \e[35mnewArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp5ingtkqo.scala:28:29 --------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m            \e[33mval\e[0m \e[36mmidVal\e[0m = arr(mid)\n\e[31m\e\
    [31m   |\e[0m                             ^^^\e[0m\n\e[31m   |\e[0m          \
    \                   Found:    (mid : Long)\n\e[31m   |\e[0m                  \
    \           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp5ingtkqo.scala:33:29 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m                \e[33mval\e[0m \e[36mnewArr\e[0m = newArr.filter(_ < midVal)\n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         Recursive \e[33mvalue\e[0m \e[35mnewArr\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5ingtkqo.scala:36:33\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                    \e\
    [33mval\e[0m \e[36mnewArr\e[0m = newArr.filter(_ >= midVal)\n\e[31m\e[31m   |\e\
    [0m                                 ^\e[0m\n\e[31m   |\e[0m                  \
    \               Recursive \e[33mvalue\e[0m \e[35mnewArr\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explan"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \        val len = arr.length\n        val len = arr.length\n        val len =\
    \ arr.length\n        val len = arr.length\n        val len = arr.length\n   \
    \     val len = arr.length\n        val len = arr.length\n        val len = arr.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpify529fr.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpify529fr.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpify529fr.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpify529fr.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpify529fr.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpify529fr.scala:31:12 ----------"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr1 = arr.toList\n        val arr2 =\
    \ arr1.reverse\n        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n\
    \        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val\
    \ arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n\
    \        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n       \
    \ val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14\
    \ = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n\
    \        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n      \
    \  val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21\
    \ = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n\
    \        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n      \
    \  val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28\
    \ = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n\
    \        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n      \
    \  val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35\
    \ = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n\
    \        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n      \
    \  val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42\
    \ = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n\
    \        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n      \
    \  val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49\
    \ = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n\
    \        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n      \
    \  val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr5\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo5z31xtb.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo5z31xtb.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo5z31xtb.scala:81:5\
    \ ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009588
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var j = 0\n        var k = 0\n\
    \        var temp = 0\n        var count = 0\n        var flag = false\n     \
    \   for(i <- 0 until n){\n            for(j <- 0 until n){\n                if(i\
    \ == j){\n                    result(i) = arr(i)\n                }\n        \
    \        else{\n                    if(arr(i) > arr(j)){\n                   \
    \     temp = arr(i)\n                        arr(i) = arr(j)\n               \
    \         arr(j) = temp\n                    }\n                }\n          \
    \  }\n        }\n        for(i <- 0 until n){\n            for(j <- 0 until n){\n\
    \                if(arr(i) == arr(j)){\n                    if(arr(i) > arr(j)){\n\
    \                        temp = arr(i)\n                        arr(i) = arr(j)\n\
    \                        arr(j) = temp\n                    }\n              \
    \  }\n            }\n        }\n        for(i <- 0 until n){\n            for(j\
    \ <- 0 until n){\n                if(arr(i) == arr(j)){\n                    if(arr(i)\
    \ > arr(j)){\n                        temp = arr(i)\n                        arr(i)\
    \ = arr(j)\n                        arr(j) = temp\n                    }\n   \
    \             }\n            }\n        }\n        for(i <- 0 until n){\n    \
    \        for(j <- 0 until n){\n                if(arr(i) == arr(j)){\n       \
    \             if(arr(i) > arr(j)){\n                        temp = arr(i)\n  \
    \                      arr(i) = arr(j)\n                        arr(j) = temp\n\
    \                    }\n                }\n            }\n        }\n        for(i\
    \ <- 0 until n){\n            for(j <- 0 until n){\n                if(arr(i)\
    \ == arr(j)){\n                    if(arr(i) > arr(j)){\n                    \
    \    temp = arr(i)\n                        arr(i) = arr(j)\n                \
    \        arr(j) = temp\n                    }\n                }\n           \
    \ }\n        }\n        for(i <- 0 until n){\n            for(j <- 0 until n){\n\
    \                if(arr(i) == arr(j)){\n                    if(arr(i) > arr(j)){\n\
    \                        temp = arr(i)\n                        arr(i) = arr(j)\n\
    \                        arr(j) = temp\n                    }\n              \
    \  }\n            }\n        }\n        for(i <- 0 until n){\n            for(j\
    \ <- 0 until n){\n                if(arr(i) == arr(j)){\n                    if(arr(i)\
    \ > arr(j)){\n                        temp = arr(i)\n                        arr(i)\
    \ = arr(j)\n                        arr(j) = temp\n                    }\n   \
    \             }\n            }\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpouds55pj.scala:37:34\
    \ --------------------\e[0m\e[0m\n\e[31m37 |\e[0m                        temp\
    \ = arr(i)\n\e[31m\e[31m   |\e[0m                               ^^^^^^\e[0m\n\e\
    [31m   |\e[0m                               Found:    Long\n\e[31m   |\e[0m  \
    \                             Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpouds55pj.scala:38:24 ------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m                        arr(i) = arr(j)\n\e[31m\e[31m\
    \   |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpouds55pj.scala:39:24 ------------------------\e[0m\e[0m\n\
    \e[31m39 |\e[0m                        arr(j) = temp\n\e[31m\e[31m   |\e[0m  \
    \                      ^^^\e[0m\n\e[31m   |\e[0m  value update is not a member\
    \ of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpouds55pj.scala:48:34 --------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m                        temp = arr(i)\n\e[31m\e[31m   |\e[0m         \
    \                      ^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \     Found:    Long\n\e[31m   |\e[0m                               Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpouds55pj.scala:49:24\
    \ ------------------------\e[0m\e[0m\n\e[31m49 |\e[0m                        arr(i)\
    \ = arr(j)\n\e[31m\e[31m   |\e[0m                        ^^^\e[0m\n\e[31m   |\e\
    [0m  value update is not a member of List[Long] - did you mean arr.updated?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpouds55pj.scala:50:24 ------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                        arr(j) = temp\n\e[31m\e[31m \
    \  |\e[0m                        ^^^\e[0m\n\e[31m   |\e[0m  value update is not\
    \ a member of List[Long] - did you mean arr.updated?\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpouds55pj.scala:59:34 "
  stdout: ''
  timestamp: 1660009656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        val arr = arr.toList\n     \
    \   val arr1 = arr.tail\n        val arr2 = arr.init\n        val arr3 = arr.drop(1)\n\
    \        val arr4 = arr.take(1)\n        val arr5 = arr.dropRight(1)\n       \
    \ val arr6 = arr.takeRight(1)\n        val arr7 = arr.dropWhile(x => x < m)\n\
    \        val arr8 = arr.takeWhile(x => x < m)\n        val arr9 = arr.dropWhile(x\
    \ => x < m).reverse\n        val arr10 = arr.takeWhile(x => x < m).reverse\n \
    \       val arr11 = arr.drop(1).reverse\n        val arr12 = arr.take(1).reverse\n\
    \        val arr13 = arr.dropRight(1).reverse\n        val arr14 = arr.takeRight(1).reverse\n\
    \        val arr15 = arr.dropWhile(x => x < m).reverse\n        val arr16 = arr.takeWhile(x\
    \ => x < m).reverse\n        val arr17 = arr.drop(1).reverse.take(1).reverse\n\
    \        val arr18 = arr.take(1).reverse.take(1).reverse\n        val arr19 =\
    \ arr.dropRight(1).reverse.take(1).reverse\n        val arr20 = arr.takeRight(1).reverse.take(1).reverse\n\
    \        val arr21 = arr.dropWhile(x => x < m).reverse.take(1).reverse\n     \
    \   val arr22 = arr.takeWhile(x => x < m).reverse.take(1).reverse\n        val\
    \ arr23 = arr.drop(1).reverse.take(1).reverse.take(1).reverse\n        val arr24\
    \ = arr.take(1).reverse.take(1).reverse.take(1).reverse\n        val arr25 = arr.dropRight(1).reverse.take(1).reverse.take(1).reverse\n\
    \        val arr26 = arr.takeRight(1).reverse.take(1).reverse.take(1).reverse\n\
    \        val arr27 = arr.dropWhile(x => x < m).reverse.take(1).reverse.take(1).reverse\n\
    \        val arr28 = arr.takeWhile(x => x < m).reverse.take(1).reverse.take(1).reverse\n\
    \        val arr29 = arr.drop(1).reverse.take(1).reverse.take(1).reverse.take(1).reverse\n\
    \        val arr30 = arr.take(1).reverse.take(1).reverse.take(1).reverse.take(1).reverse\n\
    \        val arr31 = \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpqpfkr0ld.scala:56:19 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m        \e[33mval\e[0m \e[36marr31\e[0m = \n\e[31m\e\
    [31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m                   expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpqpfkr0ld.scala:25:18 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqpfkr0ld.scala:57:5 ---------------------\e[0m\e[0m\n\e[31m57\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr2 = arr.toList\n        val arr3 =\
    \ arr2.reverse\n        val arr4 = arr3.toList\n        val arr5 = arr4.toList\n\
    \        val arr6 = arr5.toList\n        val arr7 = arr6.reverse\n        val\
    \ arr8 = arr7.toList\n        val arr9 = arr8.toList\n        val arr10 = arr9.reverse\n\
    \        val arr11 = arr10.toList\n        val arr12 = arr11.toList\n        val\
    \ arr13 = arr12.reverse\n        val arr14 = arr13.toList\n        val arr15 =\
    \ arr14.toList\n        val arr16 = arr15.reverse\n        val arr17 = arr16.toList\n\
    \        val arr18 = arr17.toList\n        val arr19 = arr18.reverse\n       \
    \ val arr20 = arr19.toList\n        val arr21 = arr20.toList\n        val arr22\
    \ = arr21.reverse\n        val arr23 = arr22.toList\n        val arr24 = arr23.toList\n\
    \        val arr25 = arr24.reverse\n        val arr26 = arr25.toList\n       \
    \ val arr27 = arr26.toList\n        val arr28 = arr27.reverse\n        val arr29\
    \ = arr28.toList\n        val arr30 = arr29.toList\n        val arr31 = arr30.reverse\n\
    \        val arr32 = arr31.toList\n        val arr33 = arr32.reverse\n       \
    \ val arr34 = arr33.toList\n        val arr35 = arr34.reverse\n        val arr36\
    \ = arr35.toList\n        val arr37 = arr36.reverse\n        val arr38 = arr37.toList\n\
    \        val arr39 = arr38.reverse\n        val arr40 = arr39.toList\n       \
    \ val arr41 = arr40.reverse\n        val arr42 = arr41.toList\n        val arr43\
    \ = arr42.reverse\n        val arr44 = arr43.toList\n        val arr45 = arr44.reverse\n\
    \        val arr46 = arr45.toList\n        val arr47 = arr46.reverse\n       \
    \ val arr48 = arr47.toList\n        val arr49 = arr48.reverse\n        val arr50\
    \ = arr49.toList\n        val arr51 = arr50.reverse\n        val arr52 = arr51.toList\n\
    \        val arr53 = arr52.reverse\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpu8d4eujj.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpu8d4eujj.scala:78:5 ---------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009653
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        val len = arr.length\n     \
    \   val arr2 = arr.toArray\n        val arr3 = arr2.toList\n        val arr4 =\
    \ arr3.toArray\n        var i = 0\n        var j = 0\n        var k = 0\n    \
    \    var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n    \
    \    var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n    \
    \    var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n    \
    \    var x = 0\n        var y = 0\n        var z = 0\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n    \
    \    var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n    \
    \    var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n    \
    \    var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n    \
    \    var z = 0\n        var i = 0\n        var j = 0\n        var k = 0\n    \
    \    var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n    \
    \    var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n    \
    \    var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n    \
    \    var x = 0\n        var y = 0\n        var z = 0\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n    \
    \    var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n    \
    \    var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n    \
    \    var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n    \
    \    var z = 0\n        var i = 0\n        var j = 0\n        var k = 0\n    \
    \    var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n    \
    \    var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n    \
    \    var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n    \
    \    var x = 0\n        var y = 0\n        var z = 0\n        var i = 0\n    \
    \    var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n    \
    \    var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n    \
    \    var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n    \
    \    var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n    \
    \    var z = 0\n        var i = 0\n        var j = 0\n        var k = 0\n    \
    \    var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n    \
    \    var p = 0\n        var q = 0\n        var r\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmproocjdan.scala:147:4 ---------------------------\e\
    [0m\e[0m\n\e[31m147 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmproocjdan.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mn\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmproocjdan.scala:47:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m47 |\e[0m        \e[33mvar\e[0m\
    \ \e[36mi\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mi is already defined as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmproocjdan.scala:48:12 ---------------------------\e[0m\e[0m\n\e[31m48\
    \ |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined as \e[33mvariable\e\
    [0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmproocjdan.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvariable\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmproocjdan.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mvar\e[0m \e[36ml\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvariable\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be de"
  stdout: ''
  timestamp: 1660009654
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        val temp2 = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var count = 0\n        var flag = false\n        while(i\
    \ < n) {\n            val temp = arr(i)\n            val temp2 = arr(j)\n    \
    \        val temp3 = arr(k)\n            arr(i) = temp3\n            arr(j) =\
    \ temp2\n            arr(k) = temp\n            i += 1\n            j += 1\n \
    \           k += 1\n            count += 1\n        }\n        for(i<-0 until\
    \ count) {\n            val temp = arr(i)\n            val temp2 = arr(j)\n  \
    \          val temp3 = arr(k)\n            arr(i) = temp3\n            arr(j)\
    \ = temp2\n            arr(k) = temp\n            i += 1\n            j += 1\n\
    \            k += 1\n        }\n        for(i<-0 until count) {\n            val\
    \ temp = arr(i)\n            val temp2 = arr(j)\n            val temp3 = arr(k)\n\
    \            arr(i) = temp3\n            arr(j) = temp2\n            arr(k) =\
    \ temp\n            i += 1\n            j += 1\n            k += 1\n        }\n\
    \        for(i<-0 until count) {\n            val temp = arr(i)\n            val\
    \ temp2 = arr(j)\n            val temp3 = arr(k)\n            arr(i) = temp3\n\
    \            arr(j) = temp2\n            arr(k) = temp\n            i += 1\n \
    \           j += 1\n            k += 1\n        }\n        for(i<-0 until count)\
    \ {\n            val temp = arr(i)\n            val temp2 = arr(j)\n         \
    \   val temp3 = arr(k)\n            arr(i) = temp3\n            arr(j) = temp2\n\
    \            arr(k) = temp\n            i += 1\n            j += 1\n         \
    \   k += 1\n        }\n        for(i<-0 until count) {\n            val temp =\
    \ arr(i)\n            val temp2 = arr(j)\n            val temp3 = arr(k)\n   \
    \         arr(i) = temp3\n            arr(j) = temp2\n            arr(k) = temp\n\
    \            i += 1\n            j += 1\n            k += 1\n        }\n     \
    \   for(i<-0 until count) {\n            val temp = arr(i)\n            val temp2\
    \ = arr(j)\n            val temp3 = arr(k)\n            arr(i) = temp3\n     \
    \       arr(j) = temp2\n            arr(\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpnkoydw7r.scala:105:16 --------------------------\e\
    [0m\e[0m\n\e[31m105 |\e[0m            arr(\n\e[31m\e[31m    |\e[0m           \
    \     ^\e[0m\n\e[31m    |\e[0m                expression expected but \e[31m'}'\e\
    [0m found\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnkoydw7r.scala:116:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m116 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmpnkoydw7r.scala:23:18 ---------------------------\e[0m\e\
    [0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e\
    [31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive\
    \ \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpnkoydw7r.scala:51:14 ------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m            i += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean i.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnkoydw7r.scala:62:14\
    \ ------------------------\e[0m\e[0m\n\e[31m62 |\e[0m            i += \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean i.!=?\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpnkoydw7r.scala:73:14 ------------------------\e[0m\e[0m\n\e[31m73\
    \ |\e[0m            i += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^\e\
    [0m\n\e[31m   |\e[0m            value += is not a member of Int - did you mean\
    \ i.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnkoydw7r.scala:84:14 ------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m            i += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of\
    \ Int - did you mean i.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpnkoydw7r.scala:95:14\
    \ ------------------------\e[0m\e[0m\n\e[31m95 |\e[0m            i += \e[31m1\e"
  stdout: ''
  timestamp: 1660009656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Boolean](n + 1)\n        result(0) = true\n  \
    \      result(1) = false\n        val max = (1 << n) - 1\n        val min = 0\n\
    \        var i = 0\n        while (i < n) {\n            val cur = arr(i)\n  \
    \          val cur2 = cur >> 1\n            if (cur2 > max) {\n              \
    \  val cur3 = cur >> 2\n                if (cur3 > max) {\n                  \
    \  val cur4 = cur >> 3\n                    if (cur4 > max) {\n              \
    \          val cur5 = cur >> 4\n                        if (cur5 > max) {\n  \
    \                          val cur6 = cur >> 5\n                            if\
    \ (cur6 > max) {\n                                val cur7 = cur >> 6\n      \
    \                          if (cur7 > max) {\n                               \
    \     val cur8 = cur >> 7\n                                    if (cur8 > max)\
    \ {\n                                        val cur9 = cur >> 8\n           \
    \                             if (cur9 > max) {\n                            \
    \                val cur10 = cur >> 9\n                                      \
    \      if (cur10 > max) {\n                                                val\
    \ cur11 = cur >> 10\n                                                if (cur11\
    \ > max) {\n                                                    val cur12 = cur\
    \ >> 11\n                                                    if (cur12 > max)\
    \ {\n                                                        val cur13 = cur >>\
    \ 12\n                                                        if (cur13 > max)\
    \ {\n                                                            val cur14 = cur\
    \ >> 13\n                                                            if (cur14\
    \ > max) {\n                                                                val\
    \ cur15 = cur >> 14\n                                                        \
    \        if (cur15 > max) {\n                                                \
    \                    val cur16 = cur >> 15\n                                 \
    \                                   if (cur16 > max) {\n                     \
    \                                                   val cur17 = cur >> 16\n  \
    \                                                                      if (cur17\
    \ > max) {\n                                                                 \
    \           val cur18 = cur >> 17\n                                          \
    \                                  if (cur18 > max) {\n                      \
    \                                                          val cur19 = cur >>\
    \ 18\n                                                                       \
    \         if (cur19 > max) {\n                                               \
    \                                     val cur20 = cur >> 19\n                \
    \                                                                    if (cur20\
    \ > max) {\n                                                                 \
    \                       val cur21 = cur >> 20\n                              \
    \                                                          if (cur21 > max) {\n\
    \                                                                            \
    \                val cur22 = cur >> 21\n                                     \
    \                                                       if (cur22 > max) {\n \
    \                                                                            \
    \                   val cur23 = cur >> 22\n                                  \
    \                                                              if (cur23 > max)\
    \ {\n                                                                        \
    \                            val cur24 = cur >> 23\n                         \
    \                                                                           if\
    \ (cur24 > max) {\n                                                          \
    \                                              val cur25 = cur >> 24\n       \
    \                                                                            \
    \                     if (cur25 > max) {\n                                   \
    \                                                                         val\
    \ cur26 = cur >> 25\n                                                        \
    \                                                    if (cur26 > max) {\n    \
    \                                                            \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3d9lo72t.scala:93:0 ----------------------------\e\
    [0m\e[0m\n\e[31m93 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3d9lo72t.scala:30:8\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mwhile\e[0m (i\
    \ < n) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found: \
    \   Unit\n\e[31m   |\e[0m        Required: Boolean\n\e[31m31 |\e[0m          \
    \  \e[33mval\e[0m \e[36mcur\e[0m = arr(i)\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mcur2\e[0m = cur >> \e[31m1\e[0m\n\e[31m33 |\e[0m            \e[33mif\e\
    [0m (cur2 > max) {\n\e[31m34 |\e[0m                \e[33mval\e[0m \e[36mcur3\e\
    [0m = cur >> \e[31m2\e[0m\n\e[31m35 |\e[0m                \e[33mif\e[0m (cur3\
    \ > max) {\n\e[31m36 |\e[0m                    \e[33mval\e[0m \e[36mcur4\e[0m\
    \ = cur >> \e[31m3\e[0m\n\e[31m37 |\e[0m                    \e[33mif\e[0m (cur4\
    \ > max) {\n\e[31m38 |\e[0m                        \e[33mval\e[0m \e[36mcur5\e\
    [0m = cur >> \e[31m4\e[0m\n\e[31m39 |\e[0m                        \e[33mif\e[0m\
    \ (cur5 > max) {\n\e[31m40 |\e[0m                            \e[33mval\e[0m \e\
    [36mcur6\e[0m = cur >> \e[31m5\e[0m\n\e[31m41 |\e[0m                         \
    \   \e[33mif\e[0m (cur6 > max) {\n\e[31m42 |\e[0m                            \
    \    \e[33mval\e[0m \e[36mcur7\e[0m = cur >> \e[31m6\e[0m\n\e[31m43 |\e[0m   \
    \                             \e[33mif\e[0m (cur7 > max) {\n\e[31m44 |\e[0m  \
    \                                  \e[33mval\e[0m \e[36mcur8\e[0m = cur >> \e\
    [31m7\e[0m\n\e[31m45 |\e[0m                                    \e[33mif\e[0m (cur8\
    \ > max) {\n\e[31m46 |\e[0m                                        \e[33mval\e\
    [0m \e[36mcur9\e[0m = cur >> \e[31m8\e[0m\n\e[31m47 |\e[0m                   \
    \                     \e[33mif\e[0m (cur9 > max) {\n\e[31m48 |\e[0m          \
    \                                  \e[33mval\e[0m \e[36mcur10\e[0m = cur >> \e\
    [31m9\e[0m\n\e[31m49 |\e[0m                                            \e[33mif\e\
    [0m (cur10 > max) {\n\e[31m50 |\e[0m                                         \
    \       \e[33mval\e[0m \e[36mcur11\e[0m = cur >> \e[31m10\e[0m\n\e[31m51 |\e[0m\
    \                             "
  stdout: ''
  timestamp: 1660009655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val arr = arr.toList\n        val len = arr.length\n  \
    \      val max = (len - 1) * 2\n        val maxIndex = max - 1\n        val maxVal\
    \ = arr(maxIndex)\n        val minVal = arr(0)\n        val minIndex = min - 1\n\
    \        val minVal = arr(minIndex)\n        val maxVal = arr(maxIndex)\n    \
    \    val maxVal = arr(maxIndex)\n        val minVal = arr(0)\n        val minIndex\
    \ = min - 1\n        val minVal = arr(minIndex)\n        val maxVal = arr(maxIndex)\n\
    \        val maxVal = arr(maxIndex)\n        val minVal = arr(0)\n        val\
    \ minIndex = min - 1\n        val minVal = arr(minIndex)\n        val maxVal =\
    \ arr(maxIndex)\n        val maxVal = arr(maxIndex)\n        val minVal = arr(0)\n\
    \        val minIndex = min - 1\n        val minVal = arr(minIndex)\n        val\
    \ maxVal = arr(maxIndex)\n        val maxVal = arr(maxIndex)\n        val minVal\
    \ = arr(0)\n        val minIndex = min - 1\n        val minVal = arr(minIndex)\n\
    \        val maxVal = arr(maxIndex)\n        val maxVal = arr(maxIndex)\n    \
    \    val minVal = arr(0)\n        val minIndex = min - 1\n        val minVal =\
    \ arr(minIndex)\n        val maxVal = arr(maxIndex)\n        val maxVal = arr(maxIndex)\n\
    \        val minVal = arr(0)\n        val minIndex = min - 1\n        val minVal\
    \ = arr(minIndex)\n        val maxVal = arr(maxIndex)\n        val maxVal = arr(maxIndex)\n\
    \        val minVal = arr(0)\n        val minIndex = min - 1\n        val minVal\
    \ = arr(minIndex)\n        val maxVal = arr(maxIndex)\n        val maxVal = arr(maxIndex)\n\
    \        val minVal = arr(0)\n        val minIndex = min - 1\n        val minVal\
    \ = arr(minIndex)\n        val maxVal = arr(maxIndex)\n        val maxVal = arr(maxIndex)\n\
    \        val minVal = arr(0)\n        val minIndex = min - 1\n        val minVal\
    \ = arr(minIndex)\n        val maxVal = arr(maxIndex)\n        val maxVal = arr(maxIndex)\n\
    \        val minVal = arr(0)\n        val minIndex = min - 1\n        val minVal\
    \ = arr(min\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpy9pnm9pm.scala:82:4 ----------------------------\e\
    [0m\e[0m\n\e[31m82 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy9pnm9pm.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminVal\e[0m = arr(minIndex)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mminVal is already defined as \e[33mvalue\e[0m \e[35mminVal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy9pnm9pm.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mmaxVal\e[0m = arr(maxIndex)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmaxVal is\
    \ already defined as \e[33mvalue\e[0m \e[35mmaxVal\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy9pnm9pm.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxVal\e[0m = arr(maxIndex)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxVal is already defined as \e[33mvalue\e[0m \e[35mmaxVal\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpy9pnm9pm.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mminVal\e[0m = arr(\e[31m0\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mminVal is\
    \ already defined as \e[33mvalue\e[0m \e[35mminVal\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpy9pnm9pm.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mminIndex\e[0m = min - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toArray\n\
    \        val n = arr.length\n        val result = new Array[Boolean](n)\n    \
    \    var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n \
    \       var temp2 = 0\n        var temp3 = 0\n        var temp4 = 0\n        var\
    \ temp5 = 0\n        var temp6 = 0\n        var temp7 = 0\n        var temp8 =\
    \ 0\n        var temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n \
    \       var temp12 = 0\n        var temp13 = 0\n        var temp14 = 0\n     \
    \   var temp15 = 0\n        var temp16 = 0\n        var temp17 = 0\n        var\
    \ temp18 = 0\n        var temp19 = 0\n        var temp20 = 0\n        var temp21\
    \ = 0\n        var temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n\
    \        var temp25 = 0\n        var temp26 = 0\n        var temp27 = 0\n    \
    \    var temp28 = 0\n        var temp29 = 0\n        var temp30 = 0\n        var\
    \ temp31 = 0\n        var temp32 = 0\n        var temp33 = 0\n        var temp34\
    \ = 0\n        var temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n\
    \        var temp38 = 0\n        var temp39 = 0\n        var temp40 = 0\n    \
    \    var temp41 = 0\n        var temp42 = 0\n        var temp43 = 0\n        var\
    \ temp44 = 0\n        var temp45 = 0\n        var temp46 = 0\n        var temp47\
    \ = 0\n        var temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n\
    \        var temp51 = 0\n        var temp52 = 0\n        var temp53 = 0\n    \
    \    var temp54 = 0\n        var temp55 = 0\n        var temp56 = 0\n        var\
    \ temp57 = 0\n        var temp58 = 0\n        var temp59 = 0\n        var temp60\
    \ = 0\n        var temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n\
    \        var temp64 = 0\n        var temp65 = 0\n        var temp66 = 0\n    \
    \    var temp67 = 0\n        var temp68 = 0\n        var temp69 = 0\n        var\
    \ temp70 = 0\n        var temp71 = 0\n        var temp72 = 0\n        var temp73\
    \ = 0\n        var temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n\
    \        var temp77 = 0\n        var temp78 = 0\n        var temp79 = 0\n    \
    \    var temp80 = 0\n        var temp81 = 0\n        var temp82 = 0\n        var\
    \ temp83 = 0\n        var temp84 = 0\n        var temp85 = 0\n        var temp86\
    \ = 0\n        var temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n\
    \        var temp90 = 0\n        var temp91 = 0\n        var temp92 = 0\n    \
    \    var temp93 = 0\n        var temp94 = 0\n        var temp95\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwdmq1ji2.scala:124:4 ---------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwdmq1ji2.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mn\e[0m = arr.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mn is already defined as \e[33mvalue\e[0m \e[35mn\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpwdmq1ji2.scala:23:18 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toArray\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpwdmq1ji2.scala:124:5 --------------------\e[0m\e[0m\n\e[31m124\
    \ |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m    |\e[0m     Found:\
    \    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m    |\e[0m\n\e[31m  \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660009655
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var temp1 = 0\n        var temp2\
    \ = 0\n        var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n \
    \       var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var\
    \ temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12\
    \ = 0\n        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n\
    \        var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n    \
    \    var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var\
    \ temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25\
    \ = 0\n        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n\
    \        var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n    \
    \    var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var\
    \ temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38\
    \ = 0\n        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n\
    \        var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n    \
    \    var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var\
    \ temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51\
    \ = 0\n        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n\
    \        var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n    \
    \    var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var\
    \ temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64\
    \ = 0\n        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n\
    \        var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n    \
    \    var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var\
    \ temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77\
    \ = 0\n        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n\
    \        var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n    \
    \    var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var\
    \ temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90\
    \ = 0\n        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n\
    \        var temp94 = 0\n        var temp95 = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9zt7224c.scala:125:5\
    \ --------------------\e[0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009656
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val max = (len-1)\n        val min = 0\n\
    \        val max1 = (len-1)\n        val max2 = (len-1)\n        val max3 = (len-1)\n\
    \        val max4 = (len-1)\n        val max5 = (len-1)\n        val max6 = (len-1)\n\
    \        val max7 = (len-1)\n        val max8 = (len-1)\n        val max9 = (len-1)\n\
    \        val max10 = (len-1)\n        val max11 = (len-1)\n        val max12 =\
    \ (len-1)\n        val max13 = (len-1)\n        val max14 = (len-1)\n        val\
    \ max15 = (len-1)\n        val max16 = (len-1)\n        val max17 = (len-1)\n\
    \        val max18 = (len-1)\n        val max19 = (len-1)\n        val max20 =\
    \ (len-1)\n        val max21 = (len-1)\n        val max22 = (len-1)\n        val\
    \ max23 = (len-1)\n        val max24 = (len-1)\n        val max25 = (len-1)\n\
    \        val max26 = (len-1)\n        val max27 = (len-1)\n        val max28 =\
    \ (len-1)\n        val max29 = (len-1)\n        val max30 = (len-1)\n        val\
    \ max31 = (len-1)\n        val max32 = (len-1)\n        val max33 = (len-1)\n\
    \        val max34 = (len-1)\n        val max35 = (len-1)\n        val max36 =\
    \ (len-1)\n        val max37 = (len-1)\n        val max38 = (len-1)\n        val\
    \ max39 = (len-1)\n        val max40 = (len-1)\n        val max41 = (len-1)\n\
    \        val max42 = (len-1)\n        val max43 = (len-1)\n        val max44 =\
    \ (len-1)\n        val max45 = (len-1)\n        val max46 = (len-1)\n        val\
    \ max47 = (len-1)\n        val max48 = (len-1)\n        val max49 = (len-1)\n\
    \        val max50 = (len-1)\n        val max51 = (len-1)\n        val max52 =\
    \ (len-1)\n        val max53 = (len-1)\n        val max54 = (len-1)\n        val\
    \ max55 = (len-1)\n        val max56 = (len-1)\n        val max57 = (len-1)\n\
    \        val max58 = (len-1)\n        val max59 = (len-1)\n        val max60 =\
    \ (len\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyns9drsl.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyns9drsl.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyns9drsl.scala:87:5\
    \ ---------------------\e[0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009658
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr.toBuffer\n        val arr3 = arr.toSeq\n        val arr4 = arr.toSet\n\
    \        val arr5 = arr.toSeq.sortBy(_)\n        val arr6 = arr.toSeq.sortBy(_).reverse\n\
    \        val arr7 = arr.toSeq.sortBy(_).reverse.drop(1)\n        val arr8 = arr.toSeq.sortBy(_).reverse.drop(2)\n\
    \        val arr9 = arr.toSeq.sortBy(_).reverse.drop(3)\n        val arr10 = arr.toSeq.sortBy(_).reverse.drop(4)\n\
    \        val arr11 = arr.toSeq.sortBy(_).reverse.drop(5)\n        val arr12 =\
    \ arr.toSeq.sortBy(_).reverse.drop(6)\n        val arr13 = arr.toSeq.sortBy(_).reverse.drop(7)\n\
    \        val arr14 = arr.toSeq.sortBy(_).reverse.drop(8)\n        val arr15 =\
    \ arr.toSeq.sortBy(_).reverse.drop(9)\n        val arr16 = arr.toSeq.sortBy(_).reverse.drop(10)\n\
    \        val arr17 = arr.toSeq.sortBy(_).reverse.drop(11)\n        val arr18 =\
    \ arr.toSeq.sortBy(_).reverse.drop(12)\n        val arr19 = arr.toSeq.sortBy(_).reverse.drop(13)\n\
    \        val arr20 = arr.toSeq.sortBy(_).reverse.drop(14)\n        val arr21 =\
    \ arr.toSeq.sortBy(_).reverse.drop(15)\n        val arr22 = arr.toSeq.sortBy(_).reverse.drop(16)\n\
    \        val arr23 = arr.toSeq.sortBy(_).reverse.drop(17)\n        val arr24 =\
    \ arr.toSeq.sortBy(_).reverse.drop(18)\n        val arr25 = arr.toSeq.sortBy(_).reverse.drop(19)\n\
    \        val arr26 = arr.toSeq.sortBy(_).reverse.drop(20)\n        val arr27 =\
    \ arr.toSeq.sortBy(_).reverse.drop(21)\n        val arr28 = arr.toSeq.sortBy(_).reverse.drop(22)\n\
    \        val arr29 = arr.toSeq.sortBy(_).reverse.drop(23)\n        val arr30 =\
    \ arr.\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp85f2ewf4.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp85f2ewf4.scala:23:18 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e\
    [0m                  ^\e[0m\n\e[31m   |\e[0m                  Recursive \e[33mvalue\e\
    [0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E081] Type Error:\
    \ /tmp/tmp85f2ewf4.scala:29:36 -----------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36marr5\e[0m = arr.toSeq.sortBy(_)\n\e[31m\e\
    [31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$1 of expanded function:\n\e[31m   |\e[0m   _$1 => arr.toSeq.sortBy(_$1).\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmp85f2ewf4.scala:30:36 -----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36marr6\e[0m = arr.toSeq.sortBy(_).reverse\n\
    \e[31m\e[31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e\
    [0m   Missing parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer\
    \ the type of the parameter _$2 of expanded function:\n\e[31m   |\e[0m   _$2 =>\
    \ arr.toSeq.sortBy(_$2).reverse.\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmp85f2ewf4.scala:31:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e\
    [0m \e[36marr7\e[0m = arr.toSeq.sortBy(_).reverse.drop(\e[31m1\e[0m)\n\e[31m\e\
    [31m   |\e[0m                                    ^\e[0m\n\e[31m   |\e[0m   Missing\
    \ parameter type\n\e[31m   |\e[0m\n\e[31m   |\e[0m   I could not infer the type\
    \ of the parameter _$3 of expanded function:\n\e[31m   |\e[0m   _$3 => arr.toSeq.sortBy(_$3).reverse.drop(1).\n\
    \e[31m\e[31m-- [E081] Type Error: /tmp/tmp85f2ewf4.scala:32:36 -----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36marr8\e[0m = arr.toSeq.sortBy(_).reverse.dr"
  stdout: ''
  timestamp: 1660009660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr1 = arr.toArray\n        val arr2\
    \ = arr.toBuffer\n        val arr3 = arr.toSeq\n        val arr4 = arr.toSet\n\
    \        val arr5 = arr.toMap\n        val arr6 = arr.toSeq.sortBy(_)\n      \
    \  val arr7 = arr.toSeq.sortWith(_ < _)\n        val arr8 = arr.toSeq.sortBy(_\
    \ > _)\n        val arr9 = arr.toSeq.sortWith(_ > _)\n        val arr10 = arr.toSeq.sortBy(_\
    \ < _)\n        val arr11 = arr.toSeq.sortWith(_ < _)\n        val arr12 = arr.toSeq.sortBy(_\
    \ > _)\n        val arr13 = arr.toSeq.sortWith(_ > _)\n        val arr14 = arr.toSeq.sortBy(_\
    \ < _)\n        val arr15 = arr.toSeq.sortWith(_ < _)\n        val arr16 = arr.toSeq.sortBy(_\
    \ > _)\n        val arr17 = arr.toSeq.sortWith(_ > _)\n        val arr18 = arr.toSeq.sortBy(_\
    \ < _)\n        val arr19 = arr.toSeq.sortWith(_ < _)\n        val arr20 = arr.toSeq.sortBy(_\
    \ > _)\n        val arr21 = arr.toSeq.sortWith(_ > _)\n        val arr22 = arr.toSeq.sortBy(_\
    \ < _)\n        val arr23 = arr.toSeq.sortWith(_ < _)\n        val arr24 = arr.toSeq.sortBy(_\
    \ > _)\n        val arr25 = arr.toSeq.sortWith(_ > _)\n        val arr26 = arr.toSeq.sortBy(_\
    \ < _)\n        val arr27 = arr.toSeq.sortWith(_ < _)\n        val arr28 = arr.toSeq.sortBy(_\
    \ > _)\n        val arr29 = arr.toSeq.sortWith(_ > _)\n        val arr30 = arr.toSeq.sortBy(_\
    \ < _)\n        val arr31 = arr.toSeq.sortWith(_ < _)\n        val arr32 = arr.toSeq.sortBy(_\
    \ > _)\n        val arr33 = arr.toSeq.sortWith(_ > _)\n        val arr34 = arr.toSeq.sortBy(_\
    \ < _\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf3hdo7ff.scala:59:4 ----------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf3hdo7ff.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E081] Type Error: /tmp/tmpf3hdo7ff.scala:30:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e\
    [0m \e[36marr6\e[0m = arr.toSeq.sortBy(_)\n\e[31m\e[31m   |\e[0m             \
    \                       ^\e[0m\n\e[31m   |\e[0m   Missing parameter type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m   I could not infer the type of the parameter _$1\
    \ of expanded function:\n\e[31m   |\e[0m   _$1 => arr.toSeq.sortBy(_$1).\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpf3hdo7ff.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660009660
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val sortedArr = arr.sortBy(x => x)\n        val sortedArr = sortedArr.toList\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.takeRight(n)\n\
    \        val sortedArr = sortedArr.dropRight(1)\n        val sortedArr = sortedArr.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2oqrg1yd.scala:66:4 ----------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2oqrg1yd.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2oqrg1yd.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2oqrg1yd.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.takeRight(n)\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr is already\
    \ defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2oqrg1yd.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0msortedArr\
    \ is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2oqrg1yd.scala:29:12\
    \ ------"
  stdout: ''
  timestamp: 1660009661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        if(len == 0) return true\n        val first = arr(0)\n \
    \       val last = arr[len-1]\n        val mid = len/2\n        val left = arr.take(mid)\n\
    \        val right = arr.drop(mid)\n        val leftSorted = left.sorted\n   \
    \     val rightSorted = right.sorted\n        val leftSorted = left.sorted\n \
    \       val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.sorted\n\
    \        val rightSorted = right.sorted\n        val leftSorted = left.\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqaa1osan.scala:87:4 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqaa1osan.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mleftSorted\e[0m = left.sorted\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftSorted\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftSorted\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqaa1osan.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightSorted\e[0m = right.sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightSorted is already defined as \e[33mvalue\e[0m \e[35mrightSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqaa1osan.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mleftSorted\e[0m = left.sorted\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mleftSorted\
    \ is already defined as \e[33mvalue\e[0m \e[35mleftSorted\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqaa1osan.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mrightSorted\e[0m = right.sorted\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightSorted is already defined as \e[33mvalue\e[0m \e[35mrightSorted\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqaa1osan.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e["
  stdout: ''
  timestamp: 1660009661
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val len = arr.length\n        if (len ==\
    \ 0) return true\n        val first = arr(0)\n        val last = arr[len-1]\n\
    \        val mid = len/2\n        val left = new Array[Long](mid)\n        val\
    \ right = new Array[Long](mid)\n        val leftIndex = 0\n        val rightIndex\
    \ = 0\n        val leftCount = 0\n        val rightCount = 0\n        val leftMax\
    \ = mid-1\n        val rightMax = mid-1\n        val leftMin = 0\n        val\
    \ rightMin = 0\n        val leftMaxCount = 0\n        val rightMaxCount = 0\n\
    \        val leftMinCount = 0\n        val rightMinCount = 0\n        val leftMaxCountMin\
    \ = 0\n        val rightMaxCountMin = 0\n        val leftMinCountMin = 0\n   \
    \     val rightMinCountMin = 0\n        val leftMaxCountMax = 0\n        val rightMaxCountMax\
    \ = 0\n        val leftMinCountMax = 0\n        val rightMinCountMax = 0\n   \
    \     val leftMaxCountMinMax = 0\n        val rightMaxCountMinMax = 0\n      \
    \  val leftMinCountMinMax = 0\n        val rightMinCountMinMax = 0\n        val\
    \ leftMaxCountMaxMin = 0\n        val rightMaxCountMaxMin = 0\n        val leftMinCountMaxMin\
    \ = 0\n        val rightMinCountMaxMin = 0\n        val leftMaxCountMinMaxMax\
    \ = 0\n        val rightMaxCountMinMaxMax = 0\n        val leftMinCountMinMaxMax\
    \ = 0\n        val rightMinCountMinMaxMax = 0\n        val leftMaxCountMaxMinMax\
    \ = 0\n        val rightMaxCountMinMaxMax = 0\n        val leftMinCountMinMaxMax\
    \ = 0\n        val rightMinCountMinMaxMax = 0\n        val leftMaxCountMinMaxMin\
    \ = 0\n        val rightMaxCountMinMaxMin = 0\n        val leftMinCountMinMaxMin\
    \ = 0\n        val rightMinCountMinMaxMin = 0\n        val leftMaxCountMinMaxMaxMin\
    \ = 0\n        val rightMaxCountMinMaxMaxMin = 0\n        val leftMinCountMinMaxMaxMin\
    \ = 0\n        val rightMinCountMinMaxMaxMin = 0\n        val leftMaxCountMinMaxMinMax\
    \ = 0\n        val rightMaxCountMinMaxMinMax = 0\n        val leftMinCountMinMaxMinMax\
    \ = 0\n        val rightMinCountMinMaxMinMax = 0\n        val leftMaxCountMinMaxMinMax\
    \ = 0\n        val rightMaxCountMinMaxMinMax = 0\n        val leftMinCountMinMaxMinMax\
    \ = 0\n\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xgv98j0.scala:62:12 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mrightMaxCountMinMaxMax\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightMaxCountMinMaxMax is already defined as \e[33mvalue\e\
    [0m \e[35mrightMaxCountMinMaxMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xgv98j0.scala:63:12 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mleftMinCountMinMaxMax\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMinCountMinMaxMax is already defined as \e[33mvalue\e\
    [0m \e[35mleftMinCountMinMaxMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xgv98j0.scala:64:12 ---------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m        \e[33mval\e[0m \e[36mrightMinCountMinMaxMax\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mrightMinCountMinMaxMax is already defined as \e[33mvalue\e\
    [0m \e[35mrightMinCountMinMaxMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xgv98j0.scala:77:12 ---------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m        \e[33mval\e[0m \e[36mleftMaxCountMinMaxMinMax\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftMaxCountMinMaxMinMax is already defined as \e[33mvalue\e\
    [0m \e[35mleftMaxCountMinMaxMinMax\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1xgv98j0.scala:78:12 ---------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m        \e[33mval\e[0m \e[36mrightMaxCountMinMaxMinMax\e\
    [0m = \e[31m0\e[0m\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1660009662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else {\n\
    \            val sortedArr = arr.sortWith(_ < _)\n            val movedArr = arr.filter(_\
    \ != sortedArr.last)\n            val movedArr2 = movedArr.filter(_ != sortedArr.last)\n\
    \            val movedArr3 = movedArr2.filter(_ != sortedArr.last)\n         \
    \   val movedArr4 = movedArr3.filter(_ != sortedArr.last)\n            val movedArr5\
    \ = movedArr4.filter(_ != sortedArr.last)\n            val movedArr6 = movedArr5.filter(_\
    \ != sortedArr.last)\n            val movedArr7 = movedArr6.filter(_ != sortedArr.last)\n\
    \            val movedArr8 = movedArr7.filter(_ != sortedArr.last)\n         \
    \   val movedArr9 = movedArr8.filter(_ != sortedArr.last)\n            val movedArr10\
    \ = movedArr9.filter(_ != sortedArr.last)\n            val movedArr11 = movedArr10.filter(_\
    \ != sortedArr.last)\n            val movedArr12 = movedArr11.filter(_ != sortedArr.last)\n\
    \            val movedArr13 = movedArr12.filter(_ != sortedArr.last)\n       \
    \     val movedArr14 = movedArr13.filter(_ != sortedArr.last)\n            val\
    \ movedArr15 = movedArr14.filter(_ != sortedArr.last)\n            val movedArr16\
    \ = movedArr15.filter(_ != sortedArr.last)\n            val movedArr17 = movedArr16.filter(_\
    \ != sortedArr.last)\n            val movedArr18 = movedArr17.filter(_ != sortedArr.last)\n\
    \            val movedArr19 = movedArr18.filter(_ != sortedArr.last)\n       \
    \     val movedArr20 = movedArr19.filter(_ != sortedArr.last)\n            val\
    \ movedArr21 = movedArr20.filter(_ != sortedArr.last)\n            val movedArr22\
    \ = movedArr21.filter(_ != sortedArr.last)\n            val movedArr23 = movedArr22.filter(_\
    \ != sortedArr.last)\n            val movedArr24 = movedArr23.filter(_ != sortedArr.last)\n\
    \            val movedArr25 = movedArr24.filter(_ != sortedArr.last)\n       \
    \     val movedArr26\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprcfw09wg.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprcfw09wg.scala:61:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmprcfw09wg.scala:60:1 ---------------------\e[0m\e[0m\n\
    \e[31m60 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:    Unit\n\
    \e[31m   |\e[0m Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmprcfw09wg.scala:52:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m52 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n3 errors found\n"
  stdout: ''
  timestamp: 1660009662
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new Array[Boolean](n+1)\n        result(0) = true\n    \
    \    result(1) = false\n        val left = 0\n        val right = n-1\n      \
    \  while(left < right) {\n            val mid = (left + right) / 2\n         \
    \   val midVal = arr(mid)\n            val midValPrev = arr(mid-1)\n         \
    \   val midValNext = arr(mid+1)\n            if(midValPrev > midVal) {\n     \
    \           val temp = midVal\n                midVal = midValPrev\n         \
    \       midValPrev = temp\n            }\n            if(midValNext < midVal)\
    \ {\n                val temp = midVal\n                midVal = midValNext\n\
    \                midValNext = temp\n            }\n            if(midVal == midValPrev\
    \ && midVal == midValNext) {\n                val temp = midVal\n            \
    \    midVal = midValNext\n                midValNext = temp\n            }\n \
    \           if(midVal == midValPrev) {\n                val temp = midVal\n  \
    \              midVal = midValPrev\n                midValPrev = temp\n      \
    \          val temp = midVal\n                midVal = midValNext\n          \
    \      midValNext = temp\n                val temp = midVal\n                midVal\
    \ = midValPrev\n                midValPrev = temp\n            }\n           \
    \ if(midVal == midValNext) {\n                val temp = midVal\n            \
    \    midVal = midValPrev\n                midValPrev = temp\n                val\
    \ temp = midVal\n                midVal = midValNext\n                midValNext\
    \ = temp\n                val temp = midVal\n                midVal = midValPrev\n\
    \                midValPrev = temp\n            }\n            if(midValPrev >\
    \ midValNext) {\n                val temp = midVal\n                midVal = midValPrev\n\
    \                midValPrev = temp\n                val temp = midVal\n      \
    \          midVal = midValNext\n                midValNext = temp\n          \
    \      val temp = midVal\n                midVal = midValPrev\n              \
    \  midValPrev = temp\n            }\n            if(midValNext < midValPrev) {\n\
    \                val temp = midVal\n                midVal = midValNext\n    \
    \            midValNext = temp\n                val temp = midVal\n          \
    \      midVal = midValPrev\n                midValPrev = temp\n            }\n\
    \            if(midValPrev > midValNext) {\n                val temp = midVal\n\
    \                midVal = midValPrev\n                midValPrev = temp\n    \
    \            val temp = midVal\n                midVal = mid\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf18qn6uw.scala:106:0 ---------------------------\e\
    [0m\e[0m\n\e[31m106 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpf18qn6uw.scala:23:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpf18qn6uw.scala:36:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m                midVal\
    \ = midValPrev\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val midVal\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpf18qn6uw.scala:37:27 -----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m                midValPrev = temp\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val midValPrev\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpf18qn6uw.scala:41:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m41 |\e[0m                midVal\
    \ = midValNext\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                Reassignment to val midVal\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E052] Type Error: /tmp/tmpf18qn6uw.scala:42:27 -----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                midValNext = temp\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val midValNext\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpf18qn6uw.scala:46:23\
    \ -----------------------------\e[0m\e[0m"
  stdout: ''
  timestamp: 1660009659
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val sorted = arr.sortBy(_)\n        val sortedList = sorted.toList\n\
    \        val sortedListLength = sortedList.length\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        val sortedListLength = sortedListLength - 1\n        val sortedListLength\
    \ = sortedListLength - 1\n        val sortedListLength = sortedListLength - 1\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2crxwr0j.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36msortedListLength\e[0m =\
    \ sortedListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedListLength is already defined as \e[33mvalue\e[0m \e\
    [35msortedListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2crxwr0j.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36msortedListLength\e[0m =\
    \ sortedListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedListLength is already defined as \e[33mvalue\e[0m \e\
    [35msortedListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2crxwr0j.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36msortedListLength\e[0m =\
    \ sortedListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedListLength is already defined as \e[33mvalue\e[0m \e\
    [35msortedListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2crxwr0j.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36msortedListLength\e[0m =\
    \ sortedListLength - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0msortedListLength is already defined as \e[33mvalue\e[0m \e\
    [35msortedListLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2crxwr0j.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36msorted"
  stdout: ''
  timestamp: 1660009663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new Array[Long](n)\n        val temp = new Array[Long](n)\n\
    \        val temp2 = new Array[Long](n)\n        val temp3 = new Array[Long](n)\n\
    \        val temp4 = new Array[Long](n)\n        val temp5 = new Array[Long](n)\n\
    \        val temp6 = new Array[Long](n)\n        val temp7 = new Array[Long](n)\n\
    \        val temp8 = new Array[Long](n)\n        val temp9 = new Array[Long](n)\n\
    \        val temp10 = new Array[Long](n)\n        val temp11 = new Array[Long](n)\n\
    \        val temp12 = new Array[Long](n)\n        val temp13 = new Array[Long](n)\n\
    \        val temp14 = new Array[Long](n)\n        val temp15 = new Array[Long](n)\n\
    \        val temp16 = new Array[Long](n)\n        val temp17 = new Array[Long](n)\n\
    \        val temp18 = new Array[Long](n)\n        val temp19 = new Array[Long](n)\n\
    \        val temp20 = new Array[Long](n)\n        val temp21 = new Array[Long](n)\n\
    \        val temp22 = new Array[Long](n)\n        val temp23 = new Array[Long](n)\n\
    \        val temp24 = new Array[Long](n)\n        val temp25 = new Array[Long](n)\n\
    \        val temp26 = new Array[Long](n)\n        val temp27 = new Array[Long](n)\n\
    \        val temp28 = new Array[Long](n)\n        val temp29 = new Array[Long](n)\n\
    \        val temp30 = new Array[Long](n)\n        val temp31 = new Array[Long](n)\n\
    \        val temp32 = new Array[Long](n)\n        val temp33 = new Array[Long](n)\n\
    \        val temp34 = new Array[Long](n)\n        val temp35 = new Array[Long](n)\n\
    \        val temp36 = new Array[Long](n)\n        val temp37 = new Array[Long](n)\n\
    \        val temp38 = new Array[Long](n)\n        val temp39 = new Array[Long](n)\n\
    \        val temp40 = new Array[Long](n)\n        val temp41 = new Array[Long](n)\n\
    \        val temp42 = new Array[Long](n)\n        val temp43 = new Array[Long](n)\n\
    \        val temp44 = new Array[Long](n)\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprlmm57xf.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmprlmm57xf.scala:70:5 ---------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009613
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        val arr = arr.toList\n     \
    \   var i = 0\n        var j = 0\n        var k = 0\n        var temp = 0\n  \
    \      var temp1 = 0\n        var temp2 = 0\n        var temp3 = 0\n        var\
    \ temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n        var temp7 =\
    \ 0\n        var temp8 = 0\n        var temp9 = 0\n        var temp10 = 0\n  \
    \      var temp11 = 0\n        var temp12 = 0\n        var temp13 = 0\n      \
    \  var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n        var\
    \ temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n        var temp20\
    \ = 0\n        var temp21 = 0\n        var temp22 = 0\n        var temp23 = 0\n\
    \        var temp24 = 0\n        var temp25 = 0\n        var temp26 = 0\n    \
    \    var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n        var\
    \ temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n        var temp33\
    \ = 0\n        var temp34 = 0\n        var temp35 = 0\n        var temp36 = 0\n\
    \        var temp37 = 0\n        var temp38 = 0\n        var temp39 = 0\n    \
    \    var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n        var\
    \ temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n        var temp46\
    \ = 0\n        var temp47 = 0\n        var temp48 = 0\n        var temp49 = 0\n\
    \        var temp50 = 0\n        var temp51 = 0\n        var temp52 = 0\n    \
    \    var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n        var\
    \ temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n        var temp59\
    \ = 0\n        var temp60 = 0\n        var temp61 = 0\n        var temp62 = 0\n\
    \        var temp63 = 0\n        var temp64 = 0\n        var temp65 = 0\n    \
    \    var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n        var\
    \ temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n        var temp72\
    \ = 0\n        var temp73 = 0\n        var temp74 = 0\n        var temp75 = 0\n\
    \        var temp76 = 0\n        var temp77 = 0\n        var temp78 = 0\n    \
    \    var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n        var\
    \ temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n        var temp85\
    \ = 0\n        var temp86 = 0\n        var temp87 = 0\n        var temp88 = 0\n\
    \        var temp89 = 0\n        var temp90 = 0\n        var temp91 = 0\n    \
    \    var temp92 = 0\n        var temp93 = 0\n        var temp94\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgi54va9w.scala:124:4 ---------------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgi54va9w.scala:25:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.toList\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\
    \e[31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgi54va9w.scala:124:5\
    \ --------------------\e[0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \     val arr = arr.toList\n        val len = arr.length\n        val arr = arr.toList\n\
    \        val len = arr.length\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr = arr.toList\n        val len = arr.length\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7oztvctn.scala:30:12 ----------"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val temp = new mutable.ListBuffer[Long]()\n\
    \        val temp2 = new mutable.ListBuffer[Long]()\n        val temp3 = new mutable.ListBuffer[Long]()\n\
    \        val temp4 = new mutable.ListBuffer[Long]()\n        val temp5 = new mutable.ListBuffer[Long]()\n\
    \        val temp6 = new mutable.ListBuffer[Long]()\n        val temp7 = new mutable.ListBuffer[Long]()\n\
    \        val temp8 = new mutable.ListBuffer[Long]()\n        val temp9 = new mutable.ListBuffer[Long]()\n\
    \        val temp10 = new mutable.ListBuffer[Long]()\n        val temp11 = new\
    \ mutable.ListBuffer[Long]()\n        val temp12 = new mutable.ListBuffer[Long]()\n\
    \        val temp13 = new mutable.ListBuffer[Long]()\n        val temp14 = new\
    \ mutable.ListBuffer[Long]()\n        val temp15 = new mutable.ListBuffer[Long]()\n\
    \        val temp16 = new mutable.ListBuffer[Long]()\n        val temp17 = new\
    \ mutable.ListBuffer[Long]()\n        val temp18 = new mutable.ListBuffer[Long]()\n\
    \        val temp19 = new mutable.ListBuffer[Long]()\n        val temp20 = new\
    \ mutable.ListBuffer[Long]()\n        val temp21 = new mutable.ListBuffer[Long]()\n\
    \        val temp22 = new mutable.ListBuffer[Long]()\n        val temp23 = new\
    \ mutable.ListBuffer[Long]()\n        val temp24 = new mutable.ListBuffer[Long]()\n\
    \        val temp25 = new mutable.ListBuffer[Long]()\n        val temp26 = new\
    \ mutable.ListBuffer[Long]()\n        val temp27 = new mutable.ListBuffer[Long]()\n\
    \        val temp28 = new mutable.ListBuffer[Long]()\n        val temp29 = new\
    \ mutable.ListBuffer[Long]()\n        val temp30 = new mutable.ListBuffer[Long]()\n\
    \        val temp31 = new mutable.ListBuffer[Long]()\n        val temp32 = new\
    \ mutable.ListBuffer[Long]()\n        val temp33 = new mutable.ListBuffer[Long]()\n\
    \        val temp34 = new mutable.ListBuffer[Long]()\n        val temp35 = new\
    \ mutable.ListBuffer\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp4d0mp2xa.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:24:25 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:25:23\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mtemp\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp4d0mp2xa.scala:26:24 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mtemp2\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:27:24 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mtemp3\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4d0mp2xa.scala:28:24\
    \ ------------------------\e"
  stdout: ''
  timestamp: 1660009574
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        if(arr.isEmpty) true\n        else if(arr.head.isEmpty)\
    \ false\n        else {\n            val newArr = arr.tail.tail\n            val\
    \ newHead = arr.head\n            val newTail = arr.tail.head\n            val\
    \ newHeadIndex = newHead.index\n            val newTailIndex = newTail.index\n\
    \            val newHeadValue = newHead.value\n            val newTailValue =\
    \ newTail.value\n            val newHeadIndex = newHead.index\n            val\
    \ newTailIndex = newTail.index\n            val newHeadValue = newHead.value\n\
    \            val newTailValue = newTail.value\n            val newHeadIndex =\
    \ newHead.index\n            val newTailIndex = newTail.index\n            val\
    \ newHeadValue = newHead.value\n            val newTailValue = newTail.value\n\
    \            val newHeadIndex = newHead.index\n            val newTailIndex =\
    \ newTail.index\n            val newHeadValue = newHead.value\n            val\
    \ newTailValue = newTail.value\n            val newHeadIndex = newHead.index\n\
    \            val newTailIndex = newTail.index\n            val newHeadValue =\
    \ newHead.value\n            val newTailValue = newTail.value\n            val\
    \ newHeadIndex = newHead.index\n            val newTailIndex = newTail.index\n\
    \            val newHeadValue = newHead.value\n            val newTailValue =\
    \ newTail.value\n            val newHeadIndex = newHead.index\n            val\
    \ newTailIndex = newTail.index\n            val newHeadValue = newHead.value\n\
    \            val newTailValue = newTail.value\n            val newHeadIndex =\
    \ newHead.index\n            val newTailIndex = newTail.index\n            val\
    \ newHeadValue = newHead.value\n            val newTailValue = newTail.value\n\
    \            val newHeadIndex = newHead.index\n            val newTailIndex =\
    \ newTail.index\n            val newHeadValue = newHead.value\n            val\
    \ newTailValue = newTail.value\n            val newHeadIndex = newHead.index\n\
    \            val newTailIndex = newTail.index\n            val newHeadValue =\
    \ newHead.value\n            val newTailValue = newTail.value\n            val\
    \ newHeadIndex = newHead.index\n            val newTailIndex = newTail.index\n\
    \            val newHeadValue = newHead.value\n            val newTailValue =\
    \ newTail.value\n            val newHeadIndex = newHead.index\n            val\
    \ newTailIndex = newTail.index\n            val newHeadValue = newHead.value\n\
    \            val newTailValue = newTail.value\n            val newHeadIndex =\
    \ newHead.index\n            \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpleylcukt.scala:88:0 ----------------------------\e\
    [0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpleylcukt.scala:23:25\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33melse\e[0m \e\
    [33mif\e[0m(arr.head.isEmpty) \e[31mfalse\e[0m\n\e[31m\e[31m   |\e[0m        \
    \        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                value isEmpty is\
    \ not a member of Long\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpleylcukt.scala:32:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            \e[33mval\e\
    [0m \e[36mnewHeadIndex\e[0m = newHead.index\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewHeadIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mnewHeadIndex\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpleylcukt.scala:33:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            \e[33mval\e\
    [0m \e[36mnewTailIndex\e[0m = newTail.index\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewTailIndex is already\
    \ defined as \e[33mvalue\e[0m \e[35mnewTailIndex\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpleylcukt.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36mnewHeadValue\e[0m = newHead.value\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mnewHeadValue is already\
    \ defined as \e[33mvalue\e[0m \e[35mnewHeadValue\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpleylcukt.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36mnewTailValue\e[0m = newTail.value\n\e[31m\e[31m   |\e[0m           \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660009665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \        val arr = arr.toList\n        val len = arr.length\n        val arr =\
    \ arr.toList\n        val len = arr.length\n        val arr = arr.toList\n   \
    \     val len = arr.length\n        val arr = arr.toList\n        val len = arr.length\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mlen\e[0m = arr.length\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mlen is already\
    \ defined as \e[33mvalue\e[0m \e[35mlen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp57l430w8.scala:29:12 ----------"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val result = new Array[Long](n)\n        var i = 0\n        var j = 0\n\
    \        var k = 0\n        var temp = 0\n        var temp2 = 0\n        var temp3\
    \ = 0\n        var temp4 = 0\n        var temp5 = 0\n        var temp6 = 0\n \
    \       var temp7 = 0\n        var temp8 = 0\n        var temp9 = 0\n        var\
    \ temp10 = 0\n        var temp11 = 0\n        var temp12 = 0\n        var temp13\
    \ = 0\n        var temp14 = 0\n        var temp15 = 0\n        var temp16 = 0\n\
    \        var temp17 = 0\n        var temp18 = 0\n        var temp19 = 0\n    \
    \    var temp20 = 0\n        var temp21 = 0\n        var temp22 = 0\n        var\
    \ temp23 = 0\n        var temp24 = 0\n        var temp25 = 0\n        var temp26\
    \ = 0\n        var temp27 = 0\n        var temp28 = 0\n        var temp29 = 0\n\
    \        var temp30 = 0\n        var temp31 = 0\n        var temp32 = 0\n    \
    \    var temp33 = 0\n        var temp34 = 0\n        var temp35 = 0\n        var\
    \ temp36 = 0\n        var temp37 = 0\n        var temp38 = 0\n        var temp39\
    \ = 0\n        var temp40 = 0\n        var temp41 = 0\n        var temp42 = 0\n\
    \        var temp43 = 0\n        var temp44 = 0\n        var temp45 = 0\n    \
    \    var temp46 = 0\n        var temp47 = 0\n        var temp48 = 0\n        var\
    \ temp49 = 0\n        var temp50 = 0\n        var temp51 = 0\n        var temp52\
    \ = 0\n        var temp53 = 0\n        var temp54 = 0\n        var temp55 = 0\n\
    \        var temp56 = 0\n        var temp57 = 0\n        var temp58 = 0\n    \
    \    var temp59 = 0\n        var temp60 = 0\n        var temp61 = 0\n        var\
    \ temp62 = 0\n        var temp63 = 0\n        var temp64 = 0\n        var temp65\
    \ = 0\n        var temp66 = 0\n        var temp67 = 0\n        var temp68 = 0\n\
    \        var temp69 = 0\n        var temp70 = 0\n        var temp71 = 0\n    \
    \    var temp72 = 0\n        var temp73 = 0\n        var temp74 = 0\n        var\
    \ temp75 = 0\n        var temp76 = 0\n        var temp77 = 0\n        var temp78\
    \ = 0\n        var temp79 = 0\n        var temp80 = 0\n        var temp81 = 0\n\
    \        var temp82 = 0\n        var temp83 = 0\n        var temp84 = 0\n    \
    \    var temp85 = 0\n        var temp86 = 0\n        var temp87 = 0\n        var\
    \ temp88 = 0\n        var temp89 = 0\n        var temp90 = 0\n        var temp91\
    \ = 0\n        var temp92 = 0\n        var temp93 = 0\n        var temp94 = 0\n\
    \        var temp95 = 0\n        var temp96 = 0\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpr7cl9d82.scala:125:5\
    \ --------------------\e[0m\e[0m\n\e[31m125 |\e[0m    }\n\e[31m\e[31m    |\e[0m\
    \     ^\e[0m\n\e[31m    |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required:\
    \ Boolean\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660009600
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val newArr = new Array[Long](n)\n       \
    \ val newArr2 = new Array[Long](n)\n        val newArr3 = new Array[Long](n)\n\
    \        val newArr4 = new Array[Long](n)\n        val newArr5 = new Array[Long](n)\n\
    \        val newArr6 = new Array[Long](n)\n        val newArr7 = new Array[Long](n)\n\
    \        val newArr8 = new Array[Long](n)\n        val newArr9 = new Array[Long](n)\n\
    \        val newArr10 = new Array[Long](n)\n        val newArr11 = new Array[Long](n)\n\
    \        val newArr12 = new Array[Long](n)\n        val newArr13 = new Array[Long](n)\n\
    \        val newArr14 = new Array[Long](n)\n        val newArr15 = new Array[Long](n)\n\
    \        val newArr16 = new Array[Long](n)\n        val newArr17 = new Array[Long](n)\n\
    \        val newArr18 = new Array[Long](n)\n        val newArr19 = new Array[Long](n)\n\
    \        val newArr20 = new Array[Long](n)\n        val newArr21 = new Array[Long](n)\n\
    \        val newArr22 = new Array[Long](n)\n        val newArr23 = new Array[Long](n)\n\
    \        val newArr24 = new Array[Long](n)\n        val newArr25 = new Array[Long](n)\n\
    \        val newArr26 = new Array[Long](n)\n        val newArr27 = new Array[Long](n)\n\
    \        val newArr28 = new Array[Long](n)\n        val newArr29 = new Array[Long](n)\n\
    \        val newArr30 = new Array[Long](n)\n        val newArr31 = new Array[Long](n)\n\
    \        val newArr32 = new Array[Long](n)\n        val newArr33 = new Array[Long](n)\n\
    \        val newArr34 = new Array[Long](n)\n        val newArr35 = new Array[Long](n)\n\
    \        val newArr36 = new Array[Long](n)\n        val newArr37 = new Array[Long](n)\n\
    \        val newArr38 = new Array[Long](n)\n        val newArr39 = new Array[Long](n)\n\
    \        val newArr40 = new Array[Long](n)\n        val newArf41 = new Array[Long](n)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmprd26qd_a.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.tail\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmprd26qd_a.scala:66:5 ---------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val left = new mutable.ListBuffer[Long]()\n\
    \        val right = new mutable.ListBuffer[Long]()\n        val temp = new mutable.ListBuffer[Long]()\n\
    \        val leftCount = new mutable.ListBuffer[Long]()\n        val rightCount\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount = new mutable.ListBuffer[Long]()\n\
    \        val leftCount2 = new mutable.ListBuffer[Long]()\n        val rightCount2\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount2 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount3 = new mutable.ListBuffer[Long]()\n        val rightCount3\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount3 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount4 = new mutable.ListBuffer[Long]()\n        val rightCount4\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount4 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount5 = new mutable.ListBuffer[Long]()\n        val rightCount5\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount5 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount6 = new mutable.ListBuffer[Long]()\n        val rightCount6\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount6 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount7 = new mutable.ListBuffer[Long]()\n        val rightCount7\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount7 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount8 = new mutable.ListBuffer[Long]()\n        val rightCount8\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount8 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount9 = new mutable.ListBuffer[Long]()\n        val rightCount9\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount9 = new mutable.ListBuffer[Long]()\n\
    \        val leftCount10 = new mutable.ListBuffer[Long]()\n        val rightCount10\
    \ = new mutable.ListBuffer[Long]()\n        val tempCount10 = new mutable.ListBuffer[Long]()\n\
    \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpa5p5dnk0.scala:23:18 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpa5p5dnk0.scala:24:25 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa5p5dnk0.scala:25:23\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mleft\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpa5p5dnk0.scala:26:24 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mright\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpa5p5dnk0.scala:27:23 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mtemp\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa5p5dnk0.scala:28:28\
    \ ------------------------\e[0m"
  stdout: ''
  timestamp: 1660009663
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        if (n == 0)\
    \ return true\n        val m = arr.head\n        val arr = arr.tail\n        val\
    \ arr = arr.drop(1)\n        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.take(n-1)\n        val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.take(n-1)\n        val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.take(n-1)\n        val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n       \
    \ val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n        val arr\
    \ = arr.take(n-1)\n        val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n\
    \        val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n       \
    \ val arr = arr.dropRight(1)\n        val arr = arr.take(n-1)\n        val arr\
    \ = arr.dropRight(1)\n        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n\
    \        val arr = arr.take(n-1)\n        val arr = arr.dropRight(1)\n       \
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprzq4edng.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.drop(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprzq4edng.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.take(n-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprzq4edng.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprzq4edng.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.take(n-\e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0marr is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmprzq4edng.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.dropRight(\e[31m1\e[0m)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr\
    \ is already defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel de"
  stdout: ''
  timestamp: 1660009664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val start = 0\n        val end = len - 1\n        val mid\
    \ = len / 2\n        val flag = true\n        val arr1 = arr.toArray\n       \
    \ val arr2 = arr.toArray\n        val arr3 = arr.toArray\n        val arr4 = arr.toArray\n\
    \        val arr5 = arr.toArray\n        val arr6 = arr.toArray\n        val arr7\
    \ = arr.toArray\n        val arr8 = arr.toArray\n        val arr9 = arr.toArray\n\
    \        val arr10 = arr.toArray\n        val arr11 = arr.toArray\n        val\
    \ arr12 = arr.toArray\n        val arr13 = arr.toArray\n        val arr14 = arr.toArray\n\
    \        val arr15 = arr.toArray\n        val arr16 = arr.toArray\n        val\
    \ arr17 = arr.toArray\n        val arr18 = arr.toArray\n        val arr19 = arr.toArray\n\
    \        val arr20 = arr.toArray\n        val arr21 = arr.toArray\n        val\
    \ arr22 = arr.toArray\n        val arr23 = arr.toArray\n        val arr24 = arr.toArray\n\
    \        val arr25 = arr.toArray\n        val arr26 = arr.toArray\n        val\
    \ arr27 = arr.toArray\n        val arr28 = arr.toArray\n        val arr29 = arr.toArray\n\
    \        val arr30 = arr.toArray\n        val arr31 = arr.toArray\n        val\
    \ arr32 = arr.toArray\n        val arr33 = arr.toArray\n        val arr34 = arr.toArray\n\
    \        val arr35 = arr.toArray\n        val arr36 = arr.toArray\n        val\
    \ arr37 = arr.toArray\n        val arr38 = arr.toArray\n        val arr39 = arr.toArray\n\
    \        val arr40 = arr.toArray\n        val arr41 = arr.toArray\n        val\
    \ arr42 = arr.toArray\n        val arr43 = arr.toArray\n        val arr44 = arr.toArray\n\
    \        val arr45 = arr.toArray\n        val arr46 = arr.toArray\n        val\
    \ arr47 = arr.toArray\n        val arr48 = arr.toArray\n        val arr49 = arr.toArray\n\
    \        val arr50 = arr.toArray\n        val arr51 = arr.toArray\n        val\
    \ arr52 = arr.toArray\n        val arr53 = arr.toArray\n        val arr54 = arr.toArray\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpx7oxoqdf.scala:22:18 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpx7oxoqdf.scala:83:5 ---------------------\e\
    [0m\e[0m\n\e[31m83 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val arr = arr.toList\n        val len =\
    \ arr.length\n        val arr1 = arr.toArray\n        val arr2 = arr.toBuffer\n\
    \        val arr3 = arr.toSeq\n        val arr4 = arr.toSet\n        val arr5\
    \ = arr.toMap\n        val arr6 = arr.toIterator\n        val arr7 = arr.toArray\n\
    \        val arr8 = arr.toList\n        val arr9 = arr.toArray\n        val arr10\
    \ = arr.toBuffer\n        val arr11 = arr.toSeq\n        val arr12 = arr.toSet\n\
    \        val arr13 = arr.toMap\n        val arr14 = arr.toIterator\n        val\
    \ arr15 = arr.toArray\n        val arr16 = arr.toList\n        val arr17 = arr.toArray\n\
    \        val arr18 = arr.toBuffer\n        val arr19 = arr.toSeq\n        val\
    \ arr20 = arr.toSet\n        val arr21 = arr.toMap\n        val arr22 = arr.toIterator\n\
    \        val arr23 = arr.toArray\n        val arr24 = arr.toList\n        val\
    \ arr25 = arr.toArray\n        val arr26 = arr.toBuffer\n        val arr27 = arr.toSeq\n\
    \        val arr28 = arr.toSet\n        val arr29 = arr.toMap\n        val arr30\
    \ = arr.toIterator\n        val arr31 = arr.toArray\n        val arr32 = arr.toList\n\
    \        val arr33 = arr.toArray\n        val arr34 = arr.toBuffer\n        val\
    \ arr35 = arr.toSeq\n        val arr36 = arr.toSet\n        val arr37 = arr.toMap\n\
    \        val arr38 = arr.toIterator\n        val arr39 = arr.toArray\n       \
    \ val arr40 = arr.toList\n        val arr41 = arr.toArray\n        val arr42 =\
    \ arr.toBuffer\n        val arr43 = arr.toSeq\n        val arr44 = arr.toSet\n\
    \        val arr45 = arr.toMap\n        val arr46 = arr.toIterator\n        val\
    \ arr47 = arr.toArray\n        val arr48 = arr.toList\n        val arr49 = arr.toArray\n\
    \        val arr50 = arr.toBuffer\n        val arr51 = arr.toSeq\n        val\
    \ arr52 = arr.toSet\n        val arr53 = arr.toMap\n        val arr54 = arr.toIterator\n\
    \        val arr55 = arr.toArray\n        val arr56 = arr.toList\n        val\
    \ arr57 = arr.to\n    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgs6yfuc5.scala:22:18 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgs6yfuc5.scala:81:5 ---------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n        val arr = arr.toList\n\
    \        val n = arr.size\n        val arr = arr.toList\n        val n = arr.size\n\
    \        val arr = arr.toList\n        val n = arr.size\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0marr is already\
    \ defined as \e[33mvalue\e[0m \e[35marr\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mn\e[0m = arr.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mn is already defined\
    \ as \e[33mvalue\e[0m \e[35mn\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmps6g09cc3.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e"
  stdout: ''
  timestamp: 1660009575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.length\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val sortedArr = arr.sort\n        val sortedArr\
    \ = sortedArr.toList\n        val sortedArr = sortedArr.dropRight(1)\n       \
    \ val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedArr.takeRight(n)\n        val sortedArr = sortedArr.dropRight(1)\n\
    \        val sortedArr = sortedAr\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(moveOneBall((List[Long](3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong,\
    \ 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong, 5l.toLong,\
    \ 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpu_f_gg0i.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpu_f_gg0i.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu_f_gg0i.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.takeRight(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpu_f_gg0i.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.dropRight(\e[31m1\e\
    [0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0msortedArr is already defined as \e[33mvalue\e[0m \e[35msortedArr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu_f_gg0i.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36msortedArr\e[0m = sortedArr.takeRight(n)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0msortedArr i"
  stdout: ''
  timestamp: 1660009664
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val result =\
    \ new Array[Boolean](n)\n        val arr = arr.toList\n        var i = 0\n   \
    \     var j = 0\n        var k = 0\n        var temp = 0\n        var temp2 =\
    \ 0\n        var temp3 = 0\n        var temp4 = 0\n        var temp5 = 0\n   \
    \     var temp6 = 0\n        var temp7 = 0\n        var temp8 = 0\n        var\
    \ temp9 = 0\n        var temp10 = 0\n        var temp11 = 0\n        var temp12\
    \ = 0\n        var temp13 = 0\n        var temp14 = 0\n        var temp15 = 0\n\
    \        var temp16 = 0\n        var temp17 = 0\n        var temp18 = 0\n    \
    \    var temp19 = 0\n        var temp20 = 0\n        var temp21 = 0\n        var\
    \ temp22 = 0\n        var temp23 = 0\n        var temp24 = 0\n        var temp25\
    \ = 0\n        var temp26 = 0\n        var temp27 = 0\n        var temp28 = 0\n\
    \        var temp29 = 0\n        var temp30 = 0\n        var temp31 = 0\n    \
    \    var temp32 = 0\n        var temp33 = 0\n        var temp34 = 0\n        var\
    \ temp35 = 0\n        var temp36 = 0\n        var temp37 = 0\n        var temp38\
    \ = 0\n        var temp39 = 0\n        var temp40 = 0\n        var temp41 = 0\n\
    \        var temp42 = 0\n        var temp43 = 0\n        var temp44 = 0\n    \
    \    var temp45 = 0\n        var temp46 = 0\n        var temp47 = 0\n        var\
    \ temp48 = 0\n        var temp49 = 0\n        var temp50 = 0\n        var temp51\
    \ = 0\n        var temp52 = 0\n        var temp53 = 0\n        var temp54 = 0\n\
    \        var temp55 = 0\n        var temp56 = 0\n        var temp57 = 0\n    \
    \    var temp58 = 0\n        var temp59 = 0\n        var temp60 = 0\n        var\
    \ temp61 = 0\n        var temp62 = 0\n        var temp63 = 0\n        var temp64\
    \ = 0\n        var temp65 = 0\n        var temp66 = 0\n        var temp67 = 0\n\
    \        var temp68 = 0\n        var temp69 = 0\n        var temp70 = 0\n    \
    \    var temp71 = 0\n        var temp72 = 0\n        var temp73 = 0\n        var\
    \ temp74 = 0\n        var temp75 = 0\n        var temp76 = 0\n        var temp77\
    \ = 0\n        var temp78 = 0\n        var temp79 = 0\n        var temp80 = 0\n\
    \        var temp81 = 0\n        var temp82 = 0\n        var temp83 = 0\n    \
    \    var temp84 = 0\n        var temp85 = 0\n        var temp86 = 0\n        var\
    \ temp87 = 0\n        var temp88 = 0\n        var temp89 = 0\n        var temp90\
    \ = 0\n        var temp91 = 0\n        var temp92 = 0\n        var temp93 = 0\n\
    \        var temp94 = 0\n        var temp95 = 0\n        var temp96 = 0\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgcy0yus5.scala:24:18 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36marr\e[0m = arr.toList\n\e\
    [31m\e[31m   |\e[0m                  ^\e[0m\n\e[31m   |\e[0m                 \
    \ Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs type\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpgcy0yus5.scala:124:5 --------------------\e\
    [0m\e[0m\n\e[31m124 |\e[0m    }\n\e[31m\e[31m    |\e[0m     ^\e[0m\n\e[31m   \
    \ |\e[0m     Found:    Unit\n\e[31m    |\e[0m     Required: Boolean\n\e[31m  \
    \  |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660009665
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n\
    \    // numbers in the array will be randomly ordered. Your task is to determine\
    \ if\n    // it is possible to get an array sorted in non-decreasing order by\
    \ performing \n    // the following operation on the given array:\n    // You\
    \ are allowed to perform right shift operation any number of times.\n    // One\
    \ right shift operation means shifting all elements of the array by one\n    //\
    \ position in the right direction. The last element of the array will be moved\
    \ to\n    // the starting position in the array i.e. 0th index. \n    // If it\
    \ is possible to obtain the sorted array by performing the above operation\n \
    \   // then return True else return False.\n    // If the given array is empty\
    \ then return True.\n    // Note: The given list is guaranteed to have unique\
    \ elements.\n    // For Example:\n    // Explanation: By performin 2 right shift\
    \ operations, non-decreasing order can\n    // be achieved for the given array.\n\
    \    // Explanation:It is not possible to get non-decreasing order for the given\n\
    \    // array by performing any number of right shift operations.\n    def moveOneBall(arr\
    \ : List[Long]) : Boolean = {\n        val n = arr.size\n        val m = arr.head\n\
    \        val arr = arr.tail\n        val arr1 = arr.toList\n        val arr2 =\
    \ arr1.reverse\n        val arr3 = arr2.reverse\n        val arr4 = arr3.reverse\n\
    \        val arr5 = arr4.reverse\n        val arr6 = arr5.reverse\n        val\
    \ arr7 = arr6.reverse\n        val arr8 = arr7.reverse\n        val arr9 = arr8.reverse\n\
    \        val arr10 = arr9.reverse\n        val arr11 = arr10.reverse\n       \
    \ val arr12 = arr11.reverse\n        val arr13 = arr12.reverse\n        val arr14\
    \ = arr13.reverse\n        val arr15 = arr14.reverse\n        val arr16 = arr15.reverse\n\
    \        val arr17 = arr16.reverse\n        val arr18 = arr17.reverse\n      \
    \  val arr19 = arr18.reverse\n        val arr20 = arr19.reverse\n        val arr21\
    \ = arr20.reverse\n        val arr22 = arr21.reverse\n        val arr23 = arr22.reverse\n\
    \        val arr24 = arr23.reverse\n        val arr25 = arr24.reverse\n      \
    \  val arr26 = arr25.reverse\n        val arr27 = arr26.reverse\n        val arr28\
    \ = arr27.reverse\n        val arr29 = arr28.reverse\n        val arr30 = arr29.reverse\n\
    \        val arr31 = arr30.reverse\n        val arr32 = arr31.reverse\n      \
    \  val arr33 = arr32.reverse\n        val arr34 = arr33.reverse\n        val arr35\
    \ = arr34.reverse\n        val arr36 = arr35.reverse\n        val arr37 = arr36.reverse\n\
    \        val arr38 = arr37.reverse\n        val arr39 = arr38.reverse\n      \
    \  val arr40 = arr39.reverse\n        val arr41 = arr40.reverse\n        val arr42\
    \ = arr41.reverse\n        val arr43 = arr42.reverse\n        val arr44 = arr43.reverse\n\
    \        val arr45 = arr44.reverse\n        val arr46 = arr45.reverse\n      \
    \  val arr47 = arr46.reverse\n        val arr48 = arr47.reverse\n        val arr49\
    \ = arr48.reverse\n        val arr50 = arr49.reverse\n        val arr51 = arr50.reverse\n\
    \        val arr52 = arr51.reverse\n        val arr53 = arr52.reverse\n      \
    \  val arr54 = arr53.reverse\n        val arr55 = arr54.reverse\n        val arr5\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 10l.toLong, 1l.toLong, 2l.toLong))) == (true));\n    assert(moveOneBall((List[Long](4l.toLong,\
    \ 3l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long](3l.toLong,\
    \ 5l.toLong, 4l.toLong, 1l.toLong, 2l.toLong))) == (false));\n    assert(moveOneBall((List[Long]()))\
    \ == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpo5z31xtb.scala:81:4 ----------------------------\e\
    [0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpo5z31xtb.scala:24:18\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36marr\e[0m = arr.tail\n\e[31m\e[31m   |\e[0m                  ^\e[0m\n\e\
    [31m   |\e[0m                  Recursive \e[33mvalue\e[0m \e[35marr\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo5z31xtb.scala:81:5\
    \ ---------------------\e[0m\e[0m\n\e[31m81 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660009588
