language: scala
name: HumanEval_152_compare
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSortedByScore\
    \ = guessesWithScores.sortBy(_._2)\n        val guessesWithScoresSortedByGuess\
    \ = guessesWithScoresSortedByScore.map(x => (x._1, x._2))\n        val guessesWithScoresSortedByGuessWithCorrect\
    \ = guessesWithScoresSortedByGuess.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrect\
    \ = guessesWithScoresSortedByGuess.filter(_._1 == 1)\n        val guessesWithScoresSortedByGuessWithCorrectAndIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrect ++ guessesWithScoresSortedByGuessWithIncorrect\n\
    \        val guessesWithScoresSortedByGuessWithCorrectAndCorrect = guessesWithScoresSortedByGuessWithCorrect\
    \ ++ guessesWithScoresSortedByGuessWithCorrect\n        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndCorrect\
    \ = guessesWithScoresSortedByGuessWithCorrectAndIncorrect ++ guessesWithScoresSortedByGuessWithCorrectAndCorrect\n\
    \        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect\n\
    \        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndCorrect\
    \ ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\
    \ ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAnd\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsrh_lg7y.scala:23:147 --------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect\e\
    [0m = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mguessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrh_lg7y.scala:24:92\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrect\e\
    [0m = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndCorrect\
    \ ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndCorrect\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsrh_lg7y.scala:25:104\
    \ -----------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\e\
    [0m = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\
    \ ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660013717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n\
    \        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeysSet = gameScoreKeys.toSet\n        val guessScoreKeysSet\
    \ = guessScoreKeys.toSet\n        val gameScoreValuesSet = gameScoreValues.toSet\n\
    \        val guessScoreValuesSet = guessScoreValues.toSet\n        val gameScoreKeysSetSet\
    \ = gameScoreKeysSet.toSet\n        val guessScoreKeysSetSet = guessScoreKeysSet.toSet\n\
    \        val gameScoreValuesSetSet = gameScoreValuesSet.toSet\n        val guessScoreValuesSetSet\
    \ = guessScoreValuesSet.toSet\n        val gameScoreKeysSetSetSet = gameScoreKeysSetSet.toSet\n\
    \        val guessScoreKeysSetSetSet = guessScoreKeysSetSet.toSet\n        val\
    \ gameScoreValuesSetSetSet = gameScoreValuesSetSet.toSet\n        val guessScoreValuesSetSetSet\
    \ = guessScoreValuesSetSet.toSet\n        val gameScoreKeysSetSetSetSet = gameScoreKeysSetSetSet.toSet\n\
    \        val guessScoreKeysSetSetSetSet = guessScoreKeysSetSetSet.toSet\n    \
    \    val gameScoreValuesSetSetSetSet = gameScoreValuesSetSet.toSet\n        val\
    \ guessScoreValuesSetSetSet = guessScoreValuesSetSet.toSet\n        val gameScoreKeysSetSetSetSetSet\
    \ = gameScoreKeysSetSetSet.toSet\n        val guessScoreKeysSetSetSetSet = guessScoreKeysSetSetSet.toSet\n\
    \        val gameScoreValuesSetSetSetSet = gameScoreValuesSetSet.toSet\n     \
    \   val guessScoreValuesSetSetSet = guessScoreValuesSetSet.toSet\n        val\
    \ gameScoreKeysSetSetSetSetSet = gameScoreKeysSetSetSet.toSet\n        val guessScoreKeysSetSetSetSet\
    \ = guessScoreKeysSetSetSet.toSet\n        val gameScoreValuesSetSetSetSet\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp78tn52y7.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp78tn52y7.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessScoreValuesSetSetSet\e[0m = guessScoreValuesSetSet.toSet\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValuesSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreValuesSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp78tn52y7.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeysSetSetSetSet\e\
    [0m = guessScoreKeysSetSetSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeysSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreKeysSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp78tn52y7.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValuesSetSetSetSet\e\
    [0m = gameScoreValuesSetSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreValuesSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreValuesSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp78tn52y7.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValuesSetSetSet\e\
    [0m = guessScoreValuesSetSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0"
  stdout: ''
  timestamp: 1660013719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesCorrect\
    \ = guessesScores.filter(_._1 == gameScores.keys)\n        val guessesWrong =\
    \ guessesScores.filter(_._1 != gameScores.keys)\n        val guessesDiff = guessesWrong.map\
    \ { case (score, index) => Math.abs(score - gameScores.get(score)) }\n       \
    \ guessesCorrect.map { case (score, index) => 0 }\n        ++ guessesDiff\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpdk96swc9.scala:15:50 -----------------------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mguessesCorrect\e[0m = guessesScores.filter(_._1\
    \ == gameScores.keys)\n\e[31m\e[31m   |\e[0m                                 \
    \                 ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types\
    \ Long and Iterable[Long] cannot be compared with == or !=\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpdk96swc9.scala:16:48 -----------------------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesWrong\e[0m = guessesScores.filter(_._1\
    \ != gameScores.keys)\n\e[31m\e[31m   |\e[0m                                 \
    \               ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mValues of types Long\
    \ and Iterable[Long] cannot be compared with == or !=\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpdk96swc9.scala:17:83 -----------------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        \e[33mval\e[0m \e[36mguessesDiff\e[0m = guessesWrong.map\
    \ { \e[33mcase\e[0m (score, index) => Math.abs(score - gameScores.get(score))\
    \ }\n\e[31m\e[31m   |\e[0m                                                   \
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m\
    \   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m\
    \ (x: Byte): Long\n\e[31m   |\e[0mmatch arguments (Option[Int])\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpdk96swc9.scala:18:8 ---------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        guessesCorrect.map { \e[33mcase\e[0m (score,\
    \ index) => \e[31m0\e[0m }\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e\
    [0m        Found:    scala.collection.immutable.Iterable[Int]\n\e[31m   |\e[0m\
    \        Required: List[Long]\n\e[31m19 |\e[0m        ++ guessesDiff\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameLen = game.size\n        val guessLen = guess.size\n\
    \        val result = new Array[Long](guessLen)\n        var i = 0\n        while\
    \ (i < guessLen) {\n            val gameScore = game(i)\n            val guessScore\
    \ = guess(i)\n            val diff = Math.abs(guessScore - gameScore)\n      \
    \      result(i) = diff\n            i += 1\n        }\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7z89l6r0.scala:24:8\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcompare\e\
    [0m(\e[36mgame\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mguess\e[0m : \e\
    [35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^\e[0m\n\e[31m   |\e[0m                                               \
    \     Found:    Unit\n\e[31m   |\e[0m                                        \
    \            Required: List[Long]\n\e[31m13 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m14 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreCount = gameScores.count\n        val\
    \ guessScoreCount = guessScores.count\n        val gameScoreSum = gameScores.sum\n\
    \        val guessScoreSum = guessScores.sum\n        val gameScoreDiff = gameScoreSum\
    \ - guessScoreSum\n        val guessScoreDiff = guessScoreSum - gameScoreSum\n\
    \        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n   \
    \     val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n   \
    \     val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n      \
    \  val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n      \
    \  val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val\
    \ guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val\
    \ gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent\
    \ = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent =\
    \ gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff\
    \ / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff /\
    \ gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount\
    \ * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n\
    \        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n\
    \        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n   \
    \     val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n   \
    \     val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n      \
    \  val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n      \
    \  val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val\
    \ guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val\
    \ gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent\
    \ = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiff\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5g7mregq.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5g7mregq.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreDiffPercent\e[0m = gameScoreDiff / gameScoreCount * \e[31m100\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreDiffPercent is already defined as \e[33mvalue\e[0m\
    \ \e[35mgameScoreDiffPercent\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp5g7mregq.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreDiffPercent\e\
    [0m = guessScoreDiff / guessScoreCount * \e[31m100\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreDiffPercent is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreDiffPercent\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp5g7mregq.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreDiffPercent\e[0m\
    \ = gameScoreDiff / gameScoreCount * \e[31m100\e[0m\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgameScoreDiffPercent is already defined as \e[33mvalue\e[0m \e[35mgameScoreDiffPercent\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp5g7mregq.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mguessScoreDiffPercent\e[0m = guessScoreDiff\
    \ / guessScoreCount * \e[31m100\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map{ case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfye81tef.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfye81tef.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfye81tef.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScoreList is already defined as \e[33mvalue\e[0m \e[35mguessScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfye81tef.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSet\e[0m = gameScores.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0"
  stdout: ''
  timestamp: 1660013718
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesCorrect = guessesScores.zip(gameScores).map\
    \ { case (guess, gameScore) => if (guess == gameScore) 0 else Math.abs(guess -\
    \ gameScore) }\n        guessesCorrect.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013718
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val gameDiff = gameScore - guessScore\n        val\
    \ gameDiffs = gameScores.zip(guessScores).map { case (gameScore, guessScore) =>\n\
    \            if (gameScore == guessScore) 0 else Math.abs(gameDiff - guessScore)\n\
    \        }\n        gameDiffs.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpg04k4mem.scala:24)\n\tat Problem.main(tmpg04k4mem.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // your code here\n        val gameScores = game.zipWithIndex.map{case\
    \ (score, index) => score}\n        val guessScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n    \
    \    val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n\
    \        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach{case\
    \ (score, index) => gameScoreList += score}\n        guessScoreMap.foreach{case\
    \ (score, index) => guessScoreList += score}\n        val gameScores = gameScoreList.toList\n\
    \        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new\
    \ mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n\
    \        gameScoreMap.foreach{case (score, index) => gameScoreList += score}\n\
    \        guessScoreMap.foreach{case (score, index) => guessScoreList += score}\n\
    \        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList\
    \ = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach{case (score,\
    \ index) => gameScoreList += score}\n        guessScoreMap.foreach{case (score,\
    \ index) => guessScoreList += score}\n        val gameScores = gameScoreList.toList\n\
    \        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new\
    \ mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n\
    \        gameScoreMap.foreach{case (score, index) => gameScoreList += score}\n\
    \        guessScoreMap.foreach{case (score, index) => guessScoreList += score}\n\
    \        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreList\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_gggwcpr.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_gggwcpr.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScores\e[0m = gameScoreList.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_gggwcpr.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mguessScores\e[0m = guessScoreList.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScores is already defined as \e[33mvalue\e[0m \e[35mguessScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_gggwcpr.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_gggwcpr.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_gggwcpr.scala:26:12 ----------"
  stdout: ''
  timestamp: 1660013718
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else\
    \ x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n       \
    \ val diffs = gameScores zip guessScores\n        diffs.map(x => if (x._1 == x._2)\
    \ 0 else x._1 - x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList\
    \ = new mutable.ListBuffer[Long]()\n        val guessesScoreList = new mutable.ListBuffer[Long]()\n\
    \        gameScoreMap.foreach { case (score, index) =>\n            val guess\
    \ = guessesScoreMap(index)\n            val difference = if (guess == score) 0\
    \ else abs(guess - score)\n            gameScoreList += difference\n         \
    \   guessesScoreList += difference\n        }\n        gameScoreList.take(guessesScoreList.size)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpy9qb_c1k.scala:17:32 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = \e\
    [33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m    \
    \                            ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpy9qb_c1k.scala:18:35 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m        \e[33mval\e[0m \e[36mguessesScoreList\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                   ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                   Not found: mutable\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013713
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.map(x => Math.abs(x - game(x)))\n\
    \        guesses.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn2bnbsdy.scala:13:55\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mguesses\e\
    [0m = guess.map(\e[36mx\e[0m => Math.abs(x - game(x)))\n\e[31m\e[31m   |\e[0m\
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                                    Found:    (x : Long)\n\e\
    [31m   |\e[0m                                                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val result: List[Long] = guesses.map(guess => {\n            val score\
    \ = scores.get(guess)\n            if (score == -1L) -1L\n            else Math.abs(score\
    \ - guess)\n        }).toList\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp3dppw589.scala:16:31 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mscore\e[0m = scores.get(guess)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \       value get is not a member of Set[Long] - did you mean scores.seq?\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val diffs = mutable.ArrayBuffer.empty[Long]\n        for(score <- scores)\
    \ {\n            val guess = guesses.find(_ == score)\n            if(guess ==\
    \ None) diffs += abs(score - score)\n            else diffs += abs(guess - score)\n\
    \        }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk07b749p.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mdiffs\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013712
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.map(x => Math.abs(x - game))\n\
    \        val correct = game.zip(guesses).map(x => if (x._1 == x._2) 0 else x._1\
    \ - x._2)\n        correct.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpnpofifin.scala:13:48 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mguesses\e[0m = guess.map(\e\
    [36mx\e[0m => Math.abs(x - game))\n\e[31m\e[31m   |\e[0m                     \
    \                         ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((game : List[Long]))\n\e[31m\e[31m-- [E051] Reference\
    \ Error: /tmp/tmpnpofifin.scala:14:58 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mcorrect\e[0m = game.zip(guesses).map(\e[36mx\e\
    [0m => \e[33mif\e[0m (x._1 == x._2) \e[31m0\e[0m \e[33melse\e[0m x._1 - x._2)\n\
    \e[31m\e[31m   |\e[0m                                                     ^^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m==\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float): Boolean\n\e[31m   |\e[0m\
    \ (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\e[31m   |\e[0m (x: Char):\
    \ Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m   |\e[0m (x: Byte): Boolean\n\
    \e[31m   |\e[0m (x$0: Any): Boolean\n\e[31m   |\e[0mall match arguments ((x._2\
    \ : => Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E051] Reference Error: /tmp/tmpnpofifin.scala:14:79\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mcorrect\e[0m = game.zip(guesses).map(\e[36mx\e[0m => \e[33mif\e[0m (x._1 ==\
    \ x._2) \e[31m0\e[0m \e[33melse\e[0m x._1 - x._2)\n\e[31m\e[31m   |\e[0m     \
    \                                                                     ^^^^^^\e\
    [0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e\
    [0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e\
    [0m (x: D"
  stdout: ''
  timestamp: 1660013717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesWithScores\
    \ = guessesScores.map { case (score, index) => index -> score }.toMap\n      \
    \  val guessesWithIndexes = guessesScores.map { case (score, index) => index ->\
    \ index }.toMap\n        val guessesWithIndexesWithScores = guessesWithIndexes.map\
    \ { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexes\
    \ = guessesWithIndexes.map { case (score, index) => index -> index }.toMap\n \
    \       val guessesWithIndexesWithIndexesWithScores = guessesWithIndexesWithIndexes.map\
    \ { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithScores\
    \ = guessesWithIndexesWithIndexesWithIndexes.map { case (score, index) => index\
    \ -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithScores\
    \ = guessesWithIndexesWithIndexesWithIndexesWithIndexes.map { case (score, index)\
    \ => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores\
    \ = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes.map { case\
    \ (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores\
    \ = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes.map\
    \ { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores\
    \ = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes.map\
    \ { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores\
    \ = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpah00294z.scala:20:65 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mguessesWithIndexesWithIndexesWithIndexesWithScores\e\
    [0m = guessesWithIndexesWithIndexesWithIndexes.map { \e[33mcase\e[0m (score, index)\
    \ => index -> score }.toMap\n\e[31m\e[31m   |\e[0m                           \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: guessesWithIndexesWithIndexesWithIndexes\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpah00294z.scala:21:76\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesWithIndexesWithIndexesWithIndexesWithIndexesWithScores\e[0m = guessesWithIndexesWithIndexesWithIndexesWithIndexes.map\
    \ { \e[33mcase\e[0m (score, index) => index -> score }.toMap\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \         Not found: guessesWithIndexesWithIndexesWithIndexesWithIndexes\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpah00294z.scala:22:87 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mguessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores\e\
    [0m = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes.map { \e\
    [33mcase\e[0m (score, index) => index -> score }.toMap\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mNot found: guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpah00294z.scala:23:98\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m      "
  stdout: ''
  timestamp: 1660013717
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val differences = guessScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        val difference = differences.sum\n\
    \        differences.toList\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013719
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new Array[Long](guessesCount)\n        var i = 0\n     \
    \   while (i < guessesCount) {\n            val guess = guesses(i)\n         \
    \   val score = scores(i)\n            val difference = abs(guess - score)\n \
    \           result(i) = difference\n            i += 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptkvd4wtv.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreSet = gameScores.toSet\n        val\
    \ guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreSetMap =\
    \ gameScores.toSetMap\n        val guessScoreSetMap = guessScores.toSetMap\n \
    \       val gameScoreSetSet = gameScores.toSetSet\n        val guessScoreSetSet\
    \ = guessScores.toSetSet\n        val gameScoreSetList = gameScores.toSetList\n\
    \        val guessScoreSetList = guessScores.toSetList\n        val gameScoreSetMap\
    \ = gameScores.toSetMap\n        val guessScoreSetMap = guessScores.toSetMap\n\
    \        val gameScoreSetSetMap = gameScores.toSetSetMap\n        val guessScoreSetSetMap\
    \ = guessScores.toSetSetMap\n        val gameScoreSetSetSetMap = gameScores.toSetSetSetMap\n\
    \        val guessScoreSetSetSetMap = guessScores.toSetSetSetMap\n        val\
    \ gameScoreSetSetSetSetMap = gameScores.toSetSetSetSetMap\n        val guessScoreSetSetSetSetMap\
    \ = guessScores.toSetSetSetSetMap\n        val gameScoreSetSetSetSetSetMap = gameScores.toSetSetSetSetSetMap\n\
    \        val guessScoreSetSetSetSetSetMap = guessScores.toSetSetSetSetSetMap\n\
    \        val gameScoreSetSetSetSetSetSetMap = gameScores.toSetSetSetSetSetSetMap\n\
    \        val guessScoreSetSetSetSetSetSetMap = guessScores.toSetSetSetSetSetSetMap\n\
    \        val gameScoreSetSetSetSetSetSetSetMap = gameScores.toSetSetSetSetSetSetSetMap\n\
    \        val guessScoreSetSetSetSetSetSetSetMap = guessScores.toSetSetSetSetSetSetSetMap\n\
    \        val gameScoreSetSetSetSetSetSetSetSetMap = gameScores.toSetSetSetSetSetSetSetSetMap\n\
    \        val guessScoreSetSetSetSetSetSetSetSetMap = guessScores.toSetSetSetSetSetSetSetSetMap\n\
    \        val game\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph2pt8kh4.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph2pt8kh4.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreSetMap\e[0m = gameScores.toSetMap\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgameScoreSetMap\
    \ is already defined as \e[33mvalue\e[0m \e[35mgameScoreSetMap\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph2pt8kh4.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessScoreSetMap\e[0m = guessScores.toSetMap\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mguessScoreSetMap\
    \ is already defined as \e[33mvalue\e[0m \e[35mguessScoreSetMap\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmph2pt8kh4.scala:13:30 ------------------------\e[0m\e[0m\n\e[31m13 |\e\
    [0m        \e[33mval\e[0m \e[36mgameScores\e[0m = game.zipWithIndex.map { \e[33mcase\e\
    [0m (score, index) => score }\n\e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue zipWithIndex is not a member of Null, but could be made\
    \ available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the\
    \ following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m \
    \ import Option.option2Iterable\n\e[31m   |\e[0m  import collection.LazyZip2.lazyZip2ToIterable\n\
    \e[31m   |\e[0m  import collection.LazyZip3.lazyZip3ToIterable\n\e[31m   |\e[0m\
    \  import collection.LazyZip4.lazyZip4ToIterable\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.list\
    \ asScalaBuffer\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m  import collection.convert.ImplicitCon"
  stdout: ''
  timestamp: 1660013720
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guessesWithScore = game.zip(guess)\n        val\
    \ guessesWithScoreSortedByScore = guessesWithScore.sortBy(_._1)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByGuess =\
    \ guessesWithScoreSortedByGuess.map(_._1 - _._2)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n\
    \        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_\
    \ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n\
    \        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_\
    \ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n\
    \        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_\
    \ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n\
    \        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWith\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcy0xjoza.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.map(_._1 - _._2)\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcy0xjoza.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.filter(_ > \e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcy0xjoza.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcy0xjoza.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.filter(_ > \e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val gameScoreMap =\
    \ gameScores.toSeq.sortBy(_._1).reverse.map { case (score, index) => index ->\
    \ score }.toMap\n        val guessScoreMap = guessScores.toSeq.sortBy(_._1).reverse.map\
    \ { case (score, index) => index -> score }.toMap\n        val gameScoreArray\
    \ = gameScoreMap.values\n        val guessScoreArray = guessScoreMap.values\n\
    \        val gameScoreArrayLength = gameScoreArray.length\n        val guessScoreArrayLength\
    \ = guessScoreArray.length\n        val gameScoreArrayCopy = gameScoreArray.clone()\n\
    \        val guessScoreArrayCopy = guessScoreArray.clone()\n        val gameScoreArrayCopyLength\
    \ = gameScoreArrayCopy.length\n        val guessScoreArrayCopyLength = guessScoreArrayCopy.length\n\
    \        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val\
    \ guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength\
    \ = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n\
    \        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val\
    \ guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength\
    \ = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n\
    \        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val\
    \ guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength\
    \ = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n\
    \        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val\
    \ guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength\
    \ = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n\
    \        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val\
    \ guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength\
    \ = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n\
    \        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val\
    \ guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength\
    \ = gameScoreArrayCopyLength\n        val guessScoreArrayCopy\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp75kadk8f.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp75kadk8f.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreArrayCopyLength\e[0m = gameScoreArrayCopyLength\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mgameScoreArrayCopyLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mgameScoreArrayCopyLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp75kadk8f.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mguessScoreArrayCopyLength\e\
    [0m = guessScoreArrayCopyLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreArrayCopyLength is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreArrayCopyLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp75kadk8f.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mgameScoreArrayCopyLength\e\
    [0m = gameScoreArrayCopyLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreArrayCopyLength is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreArrayCopyLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp75kadk8f.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mguessScoreArrayCopyLength\e\
    [0m = guessScoreArrayCopyLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreArrayCopyLength is alre"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}\n        val guessScores = guess.zipWithIndex.map{case (score,\
    \ index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap\
    \ = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n     \
    \   val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case\
    \ (score, index) => score}\n        val guessScores = guessScoreList.map{case\
    \ (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n    \
    \    val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case\
    \ (score, index) => score}\n        val guessScores = guessScoreList.map{case\
    \ (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n    \
    \    val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case\
    \ (score, index) => score}\n        val guessScores = guessScoreList.map{case\
    \ (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n    \
    \    val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case\
    \ (score, index) => score}\n        val guessScores = guessScoreList.map{case\
    \ (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n    \
    \    val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case\
    \ (score, index) => score}\n        val guessScores = guessScoreList.map{case\
    \ (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n    \
    \    val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case\
    \ (score, index) => score}\n        val guessScores = guessScoreList.map\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv75mvhhi.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mgameScores\e[0m = gameScoreList.map{\e\
    [33mcase\e[0m (score, index) => score}\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv75mvhhi.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mguessScores\e[0m = guessScoreList.map{\e\
    [33mcase\e[0m (score, index) => score}\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScores is already defined as \e[33mvalue\e[0m \e[35mguessScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv75mvhhi.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv75mvhhi.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv75mvhhi.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36m"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n\
    \        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreKeySetSize = gameScore\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreKeySetSize\e[0m\
    \ = gameScoreKeySet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreKeySetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mgameScoreKeySetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySetSize\e[0m\
    \ = guessScoreKeySet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeySetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreKeySetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreKeySetSize\e[0m\
    \ = gameScoreKeySet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreKeySetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mgameScoreKeySetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySetSize\e[0m\
    \ = guessScoreKeySet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeySetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreKeySetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        "
  stdout: ''
  timestamp: 1660013726
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new mutable.ListBuffer[Long]()\n        var i = 0\n    \
    \    while(i < guessesCount) {\n            val guess = guesses(i)\n         \
    \   val score = scores(i)\n            val diff = Math.abs(guess - score)\n  \
    \          result.add(diff)\n            i += 1\n        }\n        return result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpk10dnqws.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013722
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameSet = game.distinct\n        val guessSet\
    \ = guess.distinct\n        val result = gameSet.zip(guessSet).map { case (game,\
    \ guess) => Math.abs(guess - game) }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6gf83l64.scala:19)\n\tat Problem.main(tmp6gf83l64.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score,\
    \ index) => score }.toList\n        val guessScores = guess.zipWithIndex.map{\
    \ case (score, index) => score }.toList\n        val gameScoreMap = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap2 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap2 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap3 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap3 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap4 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap4 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap5 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap5 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap6 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap6 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap7 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap7 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap8 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap8 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap9 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap9 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap10 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap10 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMap11 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap11 = guess\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:15:48 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^\e[0m\n\
    \e[31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:15:70\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mgameScoreMap\e[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^^^^\e[0m\n\e[31m   |\e[0m                                        value _2\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:16:50\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mguessScoreMap\e[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\e\
    [31m\e[31m   |\e[0m                                                ^^^^\e[0m\n\
    \e[31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:16:72\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mguessScoreMap\e[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \  value _2 is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:17:49\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mgameScoreMap2\e[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\e[31m\e\
    [31m   |\e[0m                                               ^^^^\e[0m\n\e[31m\
    \   |\e[0m                                        value _1 is not a member of\
    \ Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:17:71 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap2\e[0m = gameScores.group"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcompare\e\
    [0m(\e[36mgame\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mguess\e[0m : \e\
    [35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^\e[0m\n\e[31m   |\e[0m                                               \
    \     Found:    Unit\n\e[31m   |\e[0m                                        \
    \            Required: List[Long]\n\e[31m13 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m14 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.map(x => if (x == -1) 0 else\
    \ x)\n        val guessScores = guess.map(x => if (x == -1) 0 else x)\n      \
    \  val diffs = gameScores zip guessScores\n        val diffsSorted = diffs.sortBy(_._1).reverse\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n\
    \        val diffs\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuc8c5oc1.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpuc8c5oc1.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mdiffsSortedWithZeros\e[0m = diffsSorted.map(\e[36mx\e[0m => (x._1 - x._2,\
    \ x._2))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiffsSortedWithZeros is already defined as \e[33mvalue\e[0m\
    \ \e[35mdiffsSortedWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuc8c5oc1.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mdiffsSortedWithZeros\e[0m\
    \ = diffsSorted.map(\e[36mx\e[0m => (x._1 - x._2, x._2))\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiffsSortedWithZeros is already defined as \e[33mvalue\e[0m\
    \ \e[35mdiffsSortedWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuc8c5oc1.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mdiffsSortedWithZeros\e[0m\
    \ = diffsSorted.map(\e[36mx\e[0m => (x._1 - x._2, x._2))\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mdiffsSortedWithZeros is already defined as \e[33mvalue\e[0m\
    \ \e[35mdiffsSortedWithZeros\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpuc8c5oc1.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mdiffsSortedWithZeros\e[0m\
    \ = diffsSorted.map(\e[36mx\e[0m => (x._1 - x._2, x._2))\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660013728
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}\n        val guessesScores = guess.zipWithIndex.map{case (score,\
    \ index) => score}\n        val guessesDiff = guessesScores.zip(gameScores).map{case\
    \ (guess, score) => Math.abs(guess - score)}\n        guessesDiff.map{case (guess,\
    \ score) => if (guess == score) 0 else Math.abs(guess - score)}\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp9c2nyhke.scala:16:89 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        guessesDiff.map{\e[33mcase\e[0m (guess, score)\
    \ => \e[33mif\e[0m (guess == score) \e[31m0\e[0m \e[33melse\e[0m Math.abs(guess\
    \ - score)}\n\e[31m\e[31m   |\e[0m                                           \
    \                                        ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue -\
    \ is not a member of Any, but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might make progress\
    \ towards fixing the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660013730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // TODO: Implement this function\n        val game\
    \ = game.sorted\n        val guess = guess.sorted\n        val diffs = mutable.ArrayBuffer.empty[Long]\n\
    \        val gameSize = game.size\n        val guessSize = guess.size\n      \
    \  val gameIndex = 0\n        val guessIndex = 0\n        while (gameIndex < gameSize\
    \ && guessIndex < guessSize) {\n            if (game(gameIndex) == guess(guessIndex))\
    \ {\n                diffs += abs(game(gameIndex) - guess(guessIndex))\n     \
    \           gameIndex += 1\n                guessIndex += 1\n            } else\
    \ if (game(gameIndex) < guess(guessIndex)) {\n                gameIndex += 1\n\
    \            } else {\n                guessIndex += 1\n            }\n      \
    \  }\n        diffs\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxad35qbk.scala:14:19 ---------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mgame\e[0m = game.sorted\n\
    \e[31m\e[31m   |\e[0m                   ^\e[0m\n\e[31m   |\e[0m              \
    \     Recursive \e[33mvalue\e[0m \e[35mgame\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxad35qbk.scala:15:20 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mguess\e[0m = guess.sorted\n\
    \e[31m\e[31m   |\e[0m                    ^\e[0m\n\e[31m   |\e[0m             \
    \       Recursive \e[33mvalue\e[0m \e[35mguess\e[0m needs type\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpxad35qbk.scala:16:20 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mdiffs\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpxad35qbk.scala:24:26 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                gameIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean gameIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxad35qbk.scala:25:27 ------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                guessIndex += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value +=\
    \ is not a member of Int - did you mean guessIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpxad35qbk.scala:27:26 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                gameIndex += \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value +=\
    \ is not a member of Int - did you mean gameIndex.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmp"
  stdout: ''
  timestamp: 1660013729
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, score) => (guess - score) }\n        guessesDiff.zipWithIndex.map\
    \ { case (guess, index) => (if (guess == 0) 0 else abs(guess - game(index)) )\
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy0m1wq_o.scala:19)\n\tat Problem.main(tmpy0m1wq_o.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val differences = gameScores zip guessScores\n  \
    \      differences.map { case (guess, score) =>\n            if (guess == score)\
    \ 0 else Math.abs(guess - score)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013731
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val result = guesses.zip(scores).map { case (guess, score) =>\n     \
    \       if (guess == score) {\n                0\n            } else {\n     \
    \           Math.abs(guess - score)\n            }\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013730
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else\
    \ x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n       \
    \ val diffs = guessScores.zip(gameScores).map(x => if (x._1 == x._2) 0 else abs(x._1\
    \ - x._2))\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new Array[Long](guessesCount)\n        var i = 0\n     \
    \   while (i < guessesCount) {\n            val guess = guesses(i)\n         \
    \   val score = scores(i)\n            val diff = Math.abs(guess - score)\n  \
    \          result(i) = diff\n            i += 1\n        }\n        result\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjq0bipzl.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013729
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score,\
    \ index) => score }.toList\n        val guessesScores = guess.zipWithIndex.map{\
    \ case (score, index) => score }.toList\n        val gameScore = gameScores.sum\n\
    \        val guessesScore = guessesScores.sum\n        val diffs = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013731
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val gameScore = gameScores.sum\n  \
    \      val guessScore = guessScores.sum\n        val diffs = guessScores.zip(gameScores).map{case\
    \ (guess, game) => math.abs(guess - game)}\n        diffs.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new Array[Long](guessesCount)\n        var i = 0\n     \
    \   while (i < guessesCount) {\n            var j = 0\n            while (j <\
    \ scoresCount) {\n                if (guesses(i) == scores(j)) {\n           \
    \         result(i) = guesses(i) - scores(j)\n                    j++\n      \
    \          }\n                else {\n                    result(i) = abs(guesses(i)\
    \ - scores(j))\n                }\n                j++\n            }\n      \
    \      i++\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb4rlnumg.scala:24:23 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                    j++\n\e[31m\e[31m   |\e[0m      \
    \                 ^\e[0m\n\e[31m   |\e[0m                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E018] Syntax Error:\
    \ /tmp/tmpb4rlnumg.scala:29:19 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m                j++\n\e[31m\e[31m   |\e[0m                   ^\e[0m\n\e\
    [31m   |\e[0m                   expression expected but \e[31m'}'\e[0m found\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb4rlnumg.scala:31:15\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            i++\n\e[31m\e\
    [31m   |\e[0m               ^\e[0m\n\e[31m   |\e[0m               expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpb4rlnumg.scala:33:8 ---------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    (result : Array[Long])\n\e[31m   |\e[0m        Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guessesCount = guess.size\n        val gameCount\
    \ = game.size\n        val result = new Array[Long](guessesCount)\n        val\
    \ gameScores = game.zipWithIndex.map(_._2)\n        val guessesScores = guess.zipWithIndex.map(_._2)\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n\
    \        guessesScoreMap.foreach {\n            case (guess, score) =>\n     \
    \           val gameScore = gameScoreMap.get(guess)\n                if (gameScore\
    \ == score) {\n                    result(0)\n                } else {\n     \
    \               val diff = abs(gameScore - score)\n                    result(diff)\n\
    \                }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpj26c2fuz.scala:18:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                        Cannot prove that Int <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       \
    \ where:    K is a type variable\n\e[31m   |\e[0m                            \
    \                      V is a type variable\n\e[31m   |\e[0m                 \
    \                       .\n\e[31m\e[31m-- Error: /tmp/tmpj26c2fuz.scala:19:49\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \ \e[33mval\e[0m \e[36mguessesScoreMap\e[0m = guessesScores.toMap\n\e[31m\e[31m\
    \   |\e[0m                                                 ^\e[0m\n\e[31m   |\e\
    [0m                                        Cannot prove that Int <:< (K, V)\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m                                        where: \
    \   K is a type variable\n\e[31m   |\e[0m                                    \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \               .\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpj26c2fuz.scala:30:8\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new Array[Long](guessesCount)\n        var i = 0\n     \
    \   while (i < guessesCount) {\n            val guess = guesses(i)\n         \
    \   val score = scores(i)\n            val difference = guess - score\n      \
    \      result(i) = difference\n            i += 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzig84gbc.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n\
    \        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpzptrsuc0.scala:51:35 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSize\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreKeySetSize\e[0m = gameScoreKeySet.size\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgameScoreKeySetSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySetSize\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzptrsuc0.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySetSize\e[0m = guessScoreKeySet.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeySetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreKeySetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSize\e\
    [0m = gameScoreValueSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreValueSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreValueSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSetSize\e\
    [0m = guessScoreValueSet.si"
  stdout: ''
  timestamp: 1660013731
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else\
    \ x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n       \
    \ val diffs = gameScores zip guessScores\n        diffs.map(x => if (x._1 == 0)\
    \ 0 else x._1 - x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013731
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}.toList\n        val guessesScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val diffs = guessesScores.zip(gameScores).map{case\
    \ (guess, game) => math.abs(guess - game)}\n        diffs.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guessesWithScore = game.zip(guess)\n        val\
    \ guessesWithScoreSortedByScore = guessesWithScore.sortBy(_._1)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByGuess =\
    \ guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.to\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.map(\e[36mx\e[0m => (x._1, x._2))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.map(\e[36mx\e[0m => (x._1, x._2))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.map(x => abs(x - game))\n    \
    \    val correct = guesses.filter(x => x == 0)\n        val wrong = guesses.filter(x\
    \ => x != 0)\n        correct.toList ++ wrong.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpdebmcjeh.scala:13:43 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mguesses\e[0m = guess.map(\e\
    [36mx\e[0m => abs(x - game))\n\e[31m\e[31m   |\e[0m                          \
    \               ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives of\
    \ \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((game : List[Long]))\n1 error found\n"
  stdout: ''
  timestamp: 1660013729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }\n        val guessScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n\
    \        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val game\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbrn4bkur.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbrn4bkur.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreKeySetSize\e[0m = gameScoreKeySet.size\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgameScoreKeySetSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySetSize\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbrn4bkur.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySetSize\e[0m = guessScoreKeySet.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeySetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreKeySetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpbrn4bkur.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSize\e\
    [0m = gameScoreValueSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreValueSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreValueSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbrn4bkur.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSetSize\e\
    [0m = guessScoreValueSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValueSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreValueSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660013733
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val result: List[Long] = guesses.map(x => if (scores.contains(x)) 0 else\
    \ abs(x - scores.head))\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3qm7pp7q.scala:15:44\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = guesses.map(\e[36mx\e[0m => \e[33mif\e\
    [0m (scores.contains(x)) \e[31m0\e[0m \e[33melse\e[0m abs(x - scores.head))\n\e\
    [31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    \e[1m\e[31mSet\e\
    [0m[Long]\n\e[31m   |\e[0m                                 Required: \e[1m\e[32mList\e\
    [0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013733
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val result = guesses.zip(scores).map {\n            case (guess, score)\
    \ => if (guess == score) 0 else abs(guess - score)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => guess - game }\n        guessesDiff.map { case (guess,\
    \ game) => guess }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjmpetp1h.scala:16:48\
    \ --------------------\e[0m\e[0m\n\e[31m16 |\e[0m        guessesDiff.map { \e\
    [33mcase\e[0m (guess, game) => guess }\n\e[31m\e[31m   |\e[0m                \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                               Found:    (guess : Any)\n\e[31m   |\e[0m     \
    \                                           Required: Long\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660013739
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val diffs = guessScores.zip(gameScores).map { case\
    \ (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSorted\
    \ = guessesWithScores.sortBy(_._1).reverse\n        val guessesWithScoresSortedWithCorrect\
    \ = guessesWithScoresSorted.filter(_._2 == 0)\n        val guessesWithScoresSortedWithIncorrect\
    \ = guessesWithScoresSorted.filter(_._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndIncorrect\
    \ = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrect\
    \ = guessesWithScoresSorted.filter(_._2 == 0 && _._2 == 0)\n        val guessesWithScoresSortedWithCorrectAndIncorrectAndCorrect\
    \ = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0)\n    \
    \    val guessesWithScoresSortedWithCorrectAndIncorrectAndIncorrect = guessesWithScoresSorted.filter(_._2\
    \ == 0 && _._2 != 0 && _._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndIncorrect\
    \ = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2\
    \ != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndCorrectAndIncorrect\
    \ = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2\
    \ != 0 && _._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndIncorrectAndCorrect\
    \ = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2\
    \ != 0 && _._2 != 0 && _._2 == 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndIncorrectAndIncorrectAndCorrect\
    \ = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2\
    \ != 0 && _._2 != 0 && _._2 != 0 && _._2 == 0 && _._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndCorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2\
    \ != 0 && _._2 != 0 && _._2 != 0 && \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpuucj8zef.scala:27:201 --------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedWithCorrectAndCorrectAndCorrectAndIncorrectAndIncorrect\e\
    [0m = guessesWithScoresSorted.filter(_._2 == \e[31m0\e[0m && _._2 != \e[31m0\e\
    [0m && _._2 == \e[31m0\e[0m && _._2 != \e[31m0\e[0m && _._2 != \e[31m0\e[0m &&\
    \ _._2 != \e[31m0\e[0m && \n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \                                                                            \
    \                     ^\e[0m\n\e[31m   |\e[0m                                \
    \       expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpuucj8zef.scala:19:94 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedWithCorrectAndIncorrect\e\
    [0m = guessesWithScoresSorted.filter(_._2 == \e[31m0\e[0m && _._2 != \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \                                          ^^^^\e[0m\n\e[31m   |\e[0m        \
    \                                value _2 is not a member of Long\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpuucj8zef.scala:20:92 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedWithCorrectAndCorrect\e\
    [0m = guessesWithScoresSorted.filter(_._2 == \e[31m0\e[0m && _._2 == \e[31m0\e\
    [0m)\n\e[31m\e[31m   |\e[0m                                                  \
    \                                        ^^^^\e[0m\n\e[31m   |\e[0m          \
    \                              value _2 is not a member of Long\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmpuucj8zef.scala:21:102 --------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedWithCorrectAndIncorrectAndCorrect\e\
    [0m = guessesWithScoresSorted.filter(_._2 == \e[31m0\e[0m && _._2 != \e[31m0\e\
    [0m && _._2 == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m     "
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map {\
    \ case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map\
    \ { case (guess, index) => guess }\n        val guessesWithScores : List[(Long,\
    \ Long)] = guesses.zipWithIndex.map { case (guess, index) => (guess, scores(index))\
    \ }\n        val guessesWithScoresWithIndices : List[(Long, Long, Int)] = guessesWithScores.zipWithIndex.map\
    \ { case (guess, score, index) => (guess, score, index) }\n        val guessesWithScoresWithIndicesAndIndices\
    \ : List[(Long, Long, Int, Int)] = guessesWithScoresWithIndices.zipWithIndex.map\
    \ { case (guess, score, index, index2) => (guess, score, index, index2) }\n  \
    \      val guessesWithScoresWithIndicesAndIndicesAndIndices : List[(Long, Long,\
    \ Int, Int, Int)] = guessesWithScoresWithIndicesAndIndices.zipWithIndex.map {\
    \ case (guess, score, index, index2, index3) => (guess, score, index, index2,\
    \ index3) }\n        val guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndices\
    \ : List[(Long, Long, Int, Int, Int, Int)] = guessesWithScoresWithIndicesAndIndicesAndIndices.zipWithIndex.map\
    \ { case (guess, score, index, index2, index3, index4) => (guess, score, index,\
    \ index2, index3, index4) }\n        val guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndicesAndIndicesAndIndices\
    \ : List[(Long, Long, Int, Int, Int, Int, Int)] = guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndices.zipWithIndex.map\
    \ { case (guess, score, index, index2, index3, index4, index5) => (guess, score,\
    \ index, index2, index3, index4, index5) }\n        val guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndicesAndIndicesAndIndicesAndIndices\
    \ : List[(Long, Long, Int, Int, Int, Int, Int, Int)] = guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndicesAndIndices.zipWithIndex.map\
    \ { case (guess, score, index, index2, index3, index4, index5, index6) => (guess,\
    \ score, index, index2, index3, index4, index5, index6) }\n        val guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndices\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu8r8jzhy.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpu8r8jzhy.scala:16:137 -------------------\e[0m\e[0m\n\e[31m16 |\e[0m\
    \        \e[33mval\e[0m \e[36mguessesWithScoresWithIndices\e[0m : \e[35mList\e\
    [0m[(\e[35mLong\e[0m, \e[35mLong\e[0m, \e[35mInt\e[0m)] = guessesWithScores.zipWithIndex.map\
    \ { \e[33mcase\e[0m (guess, score, index) => (guess, score, index) }\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                         ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 Found:  \
    \  (guess : Any)\n\e[31m   |\e[0m                                            \
    \     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu8r8jzhy.scala:16:144\
    \ -------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresWithIndices\e\
    [0m : \e[35mList\e[0m[(\e[35mLong\e[0m, \e[35mLong\e[0m, \e[35mInt\e[0m)] = guessesWithScores.zipWithIndex.map\
    \ { \e[33mcase\e[0m (guess, score, index) => (guess, score, index) }\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \    ^^^^^\e[0m\n\e[31m   |\e[0m                                             \
    \    Found:    (score : Any)\n\e[31m   |\e[0m                                \
    \                 Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpu8r8jzhy.scala:16:151 -------------------\e[0m\e[0m\n\e[31m16\
    \ |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresWithIndices\e[0m : \e[35mList\e\
    [0m[(\e[35mLong\e[0m, \e[35mLong\e[0m, \e[35mInt\e[0m)] = guessesWithScores.zipWithIndex.map\
    \ { \e[33mcase\e[0m (guess, score, index) => (guess, score, index) }\n\e[31m\e\
    [31m   "
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score,\
    \ index) => score }.toList\n        val guessScores = guess.zipWithIndex.map{\
    \ case (score, index) => score }.toList\n        val gameScoreMap = gameScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toList\n        val guessScoreList =\
    \ guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toList\n\
    \        val gameScoreSet = gameScores.zipWithIndex.map{ case (score, index) =>\
    \ index -> score }.toSet\n        val guessScoreSet = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toSet\n        val gameScoreMap = gameScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toList\n        val guessScoreList =\
    \ guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toList\n\
    \        val gameScoreSet = gameScores.zipWithIndex.map{ case (score, index) =>\
    \ index -> score }.toSet\n        val guessScoreSet = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toSet\n        val gameScoreMap = gameScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toList\n        val guessScoreList =\
    \ guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toList\n\
    \        val gameScoreSet = gameScores.zipWithIndex.map{ case (score, index) =>\
    \ index -> score }.toSet\n        val guessScoreSet = guessScores.zipWithIndex.map{\
    \ case (score, index) => \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1__kj3in.scala:42:0 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1__kj3in.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreMap\e[0m = gameScores.zipWithIndex.map{ \e[33mcase\e[0m (score,\
    \ index) => index -> score }.toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1__kj3in.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.zipWithIndex.map{\
    \ \e[33mcase\e[0m (score, index) => index -> score }.toMap\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1__kj3in.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.zipWithIndex.map{\
    \ \e[33mcase\e[0m (score, index) => index -> score }.toList\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1__kj3in.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e["
  stdout: ''
  timestamp: 1660013741
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameSet = game.distinct\n        val guessSet\
    \ = guess.distinct\n        val gameSetSize = gameSet.size\n        val guessSetSize\
    \ = guessSet.size\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize\
    \ = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n      \
    \  val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n\
    \        val guessSet\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8wwzfbyx.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8wwzfbyx.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameSetSize\e[0m = gameSetSize.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameSetSize is already defined as \e[33mvalue\e[0m \e[35mgameSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8wwzfbyx.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mguessSetSize\e[0m = guessSetSize.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessSetSize is already defined as \e[33mvalue\e[0m \e[35mguessSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8wwzfbyx.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mgameSetSize\e[0m = gameSetSize.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameSetSize is already defined as \e[33mvalue\e[0m \e[35mgameSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8wwzfbyx.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mguessSetSize\e[0m = guessSetSize.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessSetSize is already defined as \e[33mvalue\e[0m \e[35mguessSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8wwzfbyx.scala:21:12 ----------"
  stdout: ''
  timestamp: 1660013740
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val differences = guessScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        differences.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n\
    \        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpzptrsuc0.scala:51:35 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSize\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreKeySetSize\e[0m = gameScoreKeySet.size\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgameScoreKeySetSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySetSize\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzptrsuc0.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySetSize\e[0m = guessScoreKeySet.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeySetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreKeySetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSize\e\
    [0m = gameScoreValueSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreValueSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreValueSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSetSize\e\
    [0m = guessScoreValueSet.si"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val gameScoreCount = gameScores.count\n \
    \       val guessesScoreCount = guessesScores.count\n        val gameScoreDiff\
    \ = gameScoreCount - guessesScoreCount\n        val guessesScoreDiff = guessesScoreCount\
    \ - gameScoreCount\n        val gameScoreDiffList = gameScoreDiff.toList.map(x\
    \ => gameScoreDiff.minus(x))\n        val guessesScoreDiffList = guessesScoreDiff.toList.map(x\
    \ => guessesScoreDiff.minus(x))\n        val gameScoreDiffSum = gameScoreDiffList.sum\n\
    \        val guessesScoreDiffSum = guessesScoreDiffList.sum\n        val gameScoreDiffSumAbs\
    \ = gameScoreDiffSum.abs\n        val guessesScoreDiffSumAbs = guessesScoreDiffSum.abs\n\
    \        val gameScoreDiffSumAbsArray = gameScoreDiffSumAbs.toArray\n        val\
    \ guessesScoreDiffSumAbsArray = guessesScoreDiffSumAbs.toArray\n        val gameScoreDiffSumAbsArrayLength\
    \ = gameScoreDiffSumAbsArray.length\n        val guessesScoreDiffSumAbsArrayLength\
    \ = guessesScoreDiffSumAbsArray.length\n        val gameScoreDiffSumAbsArrayLength\
    \ = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength\
    \ = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength\
    \ = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength\
    \ = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength\
    \ = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength\
    \ = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength\
    \ = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength\
    \ = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength\
    \ = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength\
    \ = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength\
    \ = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpoo5cd4x4.scala:40:47 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreDiffSumAbsArrayLength\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                               ^\e\
    [0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpoo5cd4x4.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mgameScoreDiffSumAbsArrayLength\e[0m = gameScoreDiffSumAbsArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreDiffSumAbsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreDiffSumAbsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoo5cd4x4.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreDiffSumAbsArrayLength\e\
    [0m = guessesScoreDiffSumAbsArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScoreDiffSumAbsArrayLength is already defined as \e\
    [33mvalue\e[0m \e[35mguessesScoreDiffSumAbsArrayLength\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpoo5cd4x4.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreDiffSumAbsArrayLength\e[0m = gameScoreDiffSumAbsArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreDiffSumAbsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreDiffSumAbsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the sam"
  stdout: ''
  timestamp: 1660013743
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else\
    \ x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n       \
    \ val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n \
    \       val diffs = guessScores.zip(gameScores).map(x => if (x._1 == 0) 0 else\
    \ x._1 - x._2)\n        diffs.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2vbjskoi.scala:21)\n\tat Problem.main(tmp2vbjskoi.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessesScoreSet = guessesScores.toSet\n        val gameScoreList\
    \ = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n \
    \       val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n\
    \        val gameScoreSetMap = gameScores.toMap.toSet\n        val guessesScoreSetMap\
    \ = guessesScores.toMap.toSet\n        val gameScoreSetMapList = gameScores.toMap.toList.toSet\n\
    \        val guessesScoreSetMapList = guessesScores.toMap.toList.toSet\n     \
    \   val gameScoreSetMapMap = gameScores.toMap.toMap.toSet\n        val guessesScoreSetMapMap\
    \ = guessesScores.toMap.toMap.toSet\n        val gameScoreSetMapMapList = gameScores.toMap.toMap.toList.toSet\n\
    \        val guessesScoreSetMapMapList = guessesScores.toMap.toMap.toList.toSet\n\
    \        val gameScoreSetMapMapMap = gameScores.toMap.toMap.toMap.toSet\n    \
    \    val guessesScoreSetMapMapMap = guessesScores.toMap.toMap.toMap.toSet\n  \
    \      val gameScoreSetMapMapMapList = gameScores.toMap.toMap.toMap.toList.toSet\n\
    \        val guessesScoreSetMapMapMapList = guessesScores.toMap.toMap.toMap.toList.toSet\n\
    \        val gameScoreSetMapMapMapMap = gameScores.toMap.toMap.toMap.toMap.toSet\n\
    \        val guessesScoreSetMapMapMapMap = guessesScores.toMap.toMap.toMap.toMap.toSet\n\
    \        val gameScoreSetMapMapMapMapList = gameScores.toMap.toMap.toMap.toMap.toList.toSet\n\
    \        val guessesScoreSetMapMapMapMapList = guessesScores.toMap.toMap.toMap.toMap.toList.toSet\n\
    \        val gameScoreSetMapMapMapMapMap = gameScores.toMap.toMap.toMap.toMap.toMap.toSet\n\
    \        val guessesScoreSetMapMapMapMapMapList = guessesScores.toMap.toMap.toMap.toMap.toList.toSet\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq30b8f61.scala:40:5\
    \ ---------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013742
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        guessesDiff.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013744
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, gameScore) => math.abs(guess - gameScore) }\n        guessesDiff.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScoreList is already defined as \e[33mvalue\e[0m \e[35mguessScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSet\e[0m = gameScores.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.map(x => math.abs(x - _))\n\
    \        val guessesScores = guess.map(x => math.abs(x - _))\n        val guessesCorrect\
    \ = guessesScores.zip(gameScores).filter(_._1 == 0).map(_._2)\n        val guessesWrong\
    \ = guessesScores.zip(gameScores).filter(_._1 == 0).map(_._1)\n        guessesCorrect\
    \ ++ guessesWrong\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp31jvbaoj.scala:13:44 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mgameScores\e[0m = game.map(\e\
    [36mx\e[0m => math.abs(x - _))\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m\
    \   |\e[0mmatch arguments (<?> => <?>)\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp31jvbaoj.scala:14:48\
    \ -----------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e\
    [0m \e[36mguessesScores\e[0m = guess.map(\e[36mx\e[0m => math.abs(x - _))\n\e\
    [31m\e[31m   |\e[0m                                           ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mabs\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m   |\e[0mmatch arguments (<?> =>\
    \ <?>)\n2 errors found\n"
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val diffs = guesses.map { guess =>\n            val score = scores.get(guess)\n\
    \            if (score == null) 0 else abs(guess - score)\n        }\n       \
    \ diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpol11ljzh.scala:16:31 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mscore\e[0m = scores.get(guess)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \       value get is not a member of Set[Long] - did you mean scores.seq?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpol11ljzh.scala:19:14 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        diffs.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val guessesWithScore = guesses.map(x => (x, scores(x)))\n        val\
    \ guessesWithScoreSortedByScore = guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByScoreReversed\
    \ = guessesWithScoreSortedByScore.reverse\n        val guessesWithScoreSortedByScoreReversedWithCorrect\
    \ = guessesWithScoreSortedByScoreReversed.filter(_._1 == 0)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversed\
    \ = guessesWithScoreSortedByScoreReversedWithCorrect.map(x => x._1)\n        val\
    \ guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScore = guessesWithScoreSortedByScoreReversedWithCorrectReversed.sortBy(_._2)\n\
    \        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversed\
    \ = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScore.reverse\n\
    \        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect\
    \ = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversed.filter(_._1\
    \ == 0)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversed\
    \ = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect.map(x\
    \ => x._1)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScore\
    \ = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversed.sortBy(_._2)\n\
    \        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversed\
    \ = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScore.reverse\n\
    \        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect\
    \ = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect.map(x\
    \ => x._1)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversed\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpeikc157y.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpeikc157y.scala:16:61\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesWithScoreSortedByScore\e[0m = guessesWithScore.sortBy(_._2)\n\e[31m\e\
    [31m   |\e[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    value sortBy is not a member of Set[(Long,\
    \ Boolean)]\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpeikc157y.scala:26:143\
    \ --------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect\e\
    [0m = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect.map(\e\
    [36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m                                   \
    \                                                                            \
    \                                ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpeikc157y.scala:28:5 ---------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map {\
    \ case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map\
    \ { case (guess, index) => guess }\n        val guessesCorrect : List[Long] =\
    \ guesses.filter(x => x == game(index))\n        val guessesIncorrect : List[Long]\
    \ = guesses.filter(x => x != game(index))\n        val guessesCorrect : Long =\
    \ guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n\
    \        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect\
    \ : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n\
    \        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect\
    \ : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n\
    \        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect\
    \ : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n\
    \        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect\
    \ : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n\
    \        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect\
    \ : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n\
    \        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect\
    \ : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n\
    \        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect\
    \ : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n\
    \        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect\
    \ : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n\
    \        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect\
    \ : Long = guessesIncorrect.length\n        val guessesCorre\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps_tkk21c.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps_tkk21c.scala:17:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesCorrect\e[0m : \e[35mLong\e[0m = guessesCorrect.length\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessesCorrect is already defined as \e[33mvalue\e[0m \e[35mguessesCorrect\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps_tkk21c.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mguessesIncorrect\e[0m : \e[35mLong\e\
    [0m = guessesIncorrect.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesIncorrect is already defined as \e[33mvalue\e[0m \e\
    [35mguessesIncorrect\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmps_tkk21c.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mguessesCorrect\e[0m : \e\
    [35mLong\e[0m = guessesCorrect.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesCorrect is already defined as \e[33mvalue\e[0m \e[35mguessesCorrect\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps_tkk21c.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mguessesIncorrect\e[0m : \e[35mLong\e\
    [0m = guessesIncorrect.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesIncorrect is already defined as \e[33mvalue\e[0m \e\
    [35mguessesIncorrect\e[0m\n\e[31m   |\e[0m\n\e"
  stdout: ''
  timestamp: 1660013743
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val diffs = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013744
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val result = guesses.zip(scores).map { case (guess, score) =>\n     \
    \       if (guess == score) 0\n            else Math.abs(guess - score)\n    \
    \    }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013744
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val result = guesses.zip(scores).map {\n            case (guess, score)\
    \ => (guess - score)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm0sqitnv.scala:21)\n\tat Problem.main(tmpm0sqitnv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013746
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val diffs = guessScores.zip(gameScores).map { case\
    \ (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013746
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val diffs = gameScores diff guessScores\n\
    \        diffs.zipWithIndex.map{case (diff, index) => diff}.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5j6rc8ne.scala:19)\n\tat Problem.main(tmp5j6rc8ne.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013747
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guessesWithScore = game.zip(guess)\n        val\
    \ guessesWithScoreSortedByScore = guessesWithScore.sortBy(_._1)\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByGuess =\
    \ guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess\
    \ = guessesWithScoreSortedByGuess.to\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:16:12 ---------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.map(\e[36mx\e[0m => (x._1, x._2))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.map(\e[36mx\e[0m => (x._1, x._2))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m"
  stdout: ''
  timestamp: 1660013731
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesWithScores\
    \ = guess.zip(game).map { case (guess, score) => guess -> score }.toMap\n    \
    \    val guessesWithIndexes = guess.zipWithIndex.map { case (guess, index) =>\
    \ guess -> index }.toMap\n        val guessesWithScoreAndIndex = guess.zip(game).map\
    \ { case (guess, score) => guess -> score -> index }.toMap\n        val guessesWithScoreAndIndexAndScore\
    \ = guess.zip(game).map { case (guess, score, index) => guess -> score -> index\
    \ -> score }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuess = guess.zip(game).map\
    \ { case (guess, score, index, guess) => guess -> score -> index -> score -> guess\
    \ }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuessAndGuess = guess.zip(game).map\
    \ { case (guess, score, index, guess) => guess -> score -> index -> score -> guess\
    \ -> guess }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuessAndGuessAndGuess\
    \ = guess.zip(game).map { case (guess, score, index, guess) => guess -> score\
    \ -> index -> score -> guess -> guess -> guess }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuessAndGuessAndGuessAndGuess\
    \ = guess.zip(game).map { case (guess, score, index, guess) => guess -> score\
    \ -> index -> score -> guess -> guess -> guess -> guess }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuessAndGuessAndGuessAndGuessAndGuess\
    \ = guess.zip(game).map { case (guess, score, index, guess) => guess -> score\
    \ -> index -> score -> guess -> guess -> guess -> guess -> guess }.toMap\n   \
    \     val guessesWithScoreAndIndexAndScoreAndGuessAndGuessAndGuessAndGuessAndGuessAndGuess\
    \ = guess.zip(game).map { case (guess, score, index, guess) => guess -> score\
    \ -> index -> score -> guess -> guess -> guess -> guess -> guess -> guess -> guess\
    \ }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuess\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf9mskc85.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf9mskc85.scala:17:102\
    \ -----------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesWithScoreAndIndex\e[0m = guess.zip(game).map { \e[33mcase\e[0m (guess,\
    \ score) => guess -> score -> index }.toMap\n\e[31m\e[31m   |\e[0m           \
    \                                                                            \
    \               ^^^^^\e[0m\n\e[31m   |\e[0m                                  \
    \                      Not found: index\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E005]\
    \ Naming Error: /tmp/tmpf9mskc85.scala:19:104 --------------------------\e[0m\e\
    [0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndexAndScoreAndGuess\e\
    [0m = guess.zip(game).map { \e[33mcase\e[0m (guess, score, index, guess) => guess\
    \ -> score -> index -> score -> guess }.toMap\n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \                   ^^^^^\e[0m\n\e[31m   |\e[0m                              \
    \         duplicate pattern variable: guess\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E005] Naming Error: /tmp/tmpf9mskc85.scala:20:112 --------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndexAndScoreAndGuessAndGuess\e\
    [0m = guess.zip(game).map { \e[33mcase\e[0m (guess, score, index, guess) => guess\
    \ -> score -> index -> score -> guess -> guess }.toMap\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                                    ^^^^^\e[0m\n\e[31m   |\e[0m             \
    \                          duplicate pattern variable: guess\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E005] Naming Error: /tmp/tmpf9mskc85.scal"
  stdout: ''
  timestamp: 1660013752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n\
    \        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues\
    \ = gameScoreMap.values\n        val guessScoreValues = guessScoreMap.values\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2m8whb9p.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreKeySet\e[0m = gameScoreKeys.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgameScoreKeySet is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2m8whb9p.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySet\e[0m = guessScoreKeys.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mguessScoreKeySet is already defined as \e[33mvalue\e[0m \e[35mguessScoreKeySet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2m8whb9p.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSet\e[0m = gameScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mgameScoreValueSet is already defined as \e[33mvalue\e[0m \e[35mgameScoreValueSet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2m8whb9p.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSet\e[0m = guessScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValueSet is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreValueSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2m8whb9p.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mgameScoreKeySet\e[0m = gameScor"
  stdout: ''
  timestamp: 1660013752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new mutable.ListBuffer[Long]()\n        val guessesRemaining\
    \ = guessesCount - 1\n        val scoresRemaining = scoresCount - 1\n        val\
    \ guessesRemainingIndex = guessesRemaining - 1\n        val scoresRemainingIndex\
    \ = scoresRemaining - 1\n        val guessesRemainingScore = scores.get(guessesRemainingIndex)\n\
    \        val scoresRemainingScore = scores.get(scoresRemainingIndex)\n       \
    \ val guessesRemainingGuess = guesses.get(guessesRemainingIndex)\n        val\
    \ scoresRemainingGuess = guesses.get(scoresRemainingIndex)\n        val guessesRemainingGuessIndex\
    \ = guessesRemainingIndex - 1\n        val scoresRemainingGuessIndex = scoresRemainingIndex\
    \ - 1\n        val guessesRemainingGuessScore = scores.get(guessesRemainingGuessIndex)\n\
    \        val scoresRemainingGuessScore = scores.get(scoresRemainingGuessIndex)\n\
    \        val guessesRemainingGuessGuess = guesses.get(guessesRemainingGuessIndex)\n\
    \        val scoresRemainingGuessGuess = guesses.get(scoresRemainingGuessIndex)\n\
    \        val guessesRemainingGuessGuessIndex = guessesRemainingGuessIndex - 1\n\
    \        val scoresRemainingGuessGuessIndex = scoresRemainingGuessIndex - 1\n\
    \        val guessesRemainingGuessGuessScore = scores.get(guessesRemainingGuessGuessIndex)\n\
    \        val scoresRemainingGuessGuessScore = scores.get(scoresRemainingGuessGuessIndex)\n\
    \        val guessesRemainingGuessGuessGuess = guesses.get(guessesRemainingGuessGuessIndex)\n\
    \        val scoresRemainingGuessGuessGuess = guesses.get(scoresRemainingGuessGuessIndex)\n\
    \        val guessesRemainingGuessGuessGuessIndex = guessesRemainingGuessGuessIndex\
    \ - 1\n        val scoresRemainingGuessGuessGuessIndex = scoresRemainingGuessGuessGuessIndex\
    \ - 1\n        val guessesRemainingGuessGuessGuessScore = scores.get(guessesRemainingGuessGuessGuessIndex)\n\
    \        val scoresRemainingGuessGuessGuessScore = scores.get(scoresRemainingGuessGuessGuessIndex)\n\
    \        val guessesRemainingGuessGuessGuess\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp741qan66.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp741qan66.scala:17:25\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmp741qan66.scala:22:43 ------------------------\e[0m\e[0m\n\e[31m22 |\e\
    [0m        \e[33mval\e[0m \e[36mguessesRemainingScore\e[0m = scores.get(guessesRemainingIndex)\n\
    \e[31m\e[31m   |\e[0m                                    ^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m      value get is not a member of List[Long] - did you mean scores.seq?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp741qan66.scala:23:42 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mscoresRemainingScore\e[0m\
    \ = scores.get(scoresRemainingIndex)\n\e[31m\e[31m   |\e[0m                  \
    \                 ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue get is not a member of\
    \ List[Long], but could be made available as an extension method.\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp741qan66.scala:24:44\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesRemainingGuess\e[0m = guesses.get(guessesRemainingIndex)\n\e[31m\e\
    [31m   |\e[0m                                    ^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue get is not a member of List[Long], but could be made available as an\
    \ extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports\
    \ might fix the problem:\n\e[31m   |"
  stdout: ''
  timestamp: 1660013755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guessesCount = guess.size\n        val gameCount\
    \ = game.size\n        val result = new Array[Long](guessesCount)\n        var\
    \ i = 0\n        while (i < guessesCount) {\n            val guess = guess(i)\n\
    \            val game = game(i)\n            val diff = abs(guess - game)\n  \
    \          result(i) = diff\n            i += 1\n        }\n        result\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpju99f8k0.scala:18:24 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mguess\e[0m = guess(i)\n\
    \e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m         \
    \               Recursive \e[33mvalue\e[0m \e[35mguess\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpju99f8k0.scala:19:23 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m \e[36mgame\e[0m = game(i)\n\
    \e[31m\e[31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m          \
    \             Recursive \e[33mvalue\e[0m \e[35mgame\e[0m needs type\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpju99f8k0.scala:24:8 ---------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\e[31m   |\e[0m\
    \        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013751
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val guessesToScores = guesses.zip(scores)\n        val scoresToGuesses\
    \ = scores.zip(guesses)\n        val guessesToGuesses = guesses.zip(guesses)\n\
    \        val guessesToGuessesCount = guessesToGuesses.size\n        val scoresToGuessesCount\
    \ = scoresToGuesses.size\n        val guessesToGuessesToScores = guessesToGuesses.zip(scoresToGuesses)\n\
    \        val scoresToGuessesToGuesses = scoresToGuesses.zip(guessesToGuesses)\n\
    \        val guessesToGuessesToGuessesCount = guessesToGuessesToScores.size\n\
    \        val scoresToGuessesToGuessesCount = scoresToGuessesToGuesses.size\n \
    \       val guessesToGuessesToGuessesToScores = guessesToGuessesToGuesses.zip(scoresToGuessesToGuesses)\n\
    \        val scoresToGuessesToGuessesToGuesses = scoresToGuessesToGuesses.zip(guessesToGuessesToGuesses)\n\
    \        val guessesToGuessesToGuessesToGuessesCount = guessesToGuessesToGuessesToScores.size\n\
    \        val scoresToGuessesToGuessesToGuessesCount = scoresToGuessesToGuessesToGuesses.size\n\
    \        val guessesToGuessesToGuessesToGuessesToScores = guessesToGuessesToGuessesToGuesses.zip(scoresToGuessesToGuessesToGuesses)\n\
    \        val scoresToGuessesToGuessesToGuessesToGuessesCount = scoresToGuessesToGuessesToGuessesToGuesses.size\n\
    \        val guessesToGuessesToGuessesToGuessesToGuessesCount = guessesToGuessesToGuessesToGuessesToScores.size\n\
    \        val guessesToGuessesToGuessesToGuessesToGuessesToScores = guessesToGuessesToGuessesToGuesses\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp010sznjo.scala:26:48 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mguessesToGuessesToGuessesToScores\e\
    [0m = guessesToGuessesToGuesses.zip(scoresToGuessesToGuesses)\n\e[31m\e[31m  \
    \ |\e[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    Not found: guessesToGuessesToGuesses\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp010sznjo.scala:27:77\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mscoresToGuessesToGuessesToGuesses\e[0m = scoresToGuessesToGuesses.zip(guessesToGuessesToGuesses)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                     ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                            Not found: guessesToGuessesToGuesses\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp010sznjo.scala:30:57 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mguessesToGuessesToGuessesToGuessesToScores\e\
    [0m = guessesToGuessesToGuessesToGuesses.zip(scoresToGuessesToGuessesToGuesses)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \        Not found: guessesToGuessesToGuessesToGuesses\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp010sznjo.scala:31:62 ------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mscoresToGuessesToGuessesToGuessesToGuessesCount\e\
    [0m = scoresToGuessesToGuessesToGuessesToGuesses.size\n\e[31m\e[31m   |\e[0m \
    \                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                   Not found: scoresToGuessesToGuessesToGuessesToGuesses\n\
    \e[31m   |"
  stdout: ''
  timestamp: 1660013752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n\
    \        val guessScoreList = guessScoreMap.values.toList\n        val gameScoreSet\
    \ = gameScoreList.distinct\n        val guessScoreSet = guessScoreList.distinct\n\
    \        val gameScoreList = gameScoreSet.map { score => gameScoreMap.getOrElse(score,0)\
    \ }\n        val guessScoreList = guessScoreSet.map { score => guessScoreMap.getOrElse(score,0)\
    \ }\n        val gameScoreList = gameScoreList.sortBy(-_)\n        val guessScoreList\
    \ = guessScoreList.sortBy(-_)\n        val gameScoreList = gameScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map\
    \ { case (score, \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu92o011b.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu92o011b.scala:49:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m49 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu92o011b.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScoreSet.map\
    \ { \e[36mscore\e[0m => gameScoreMap.getOrElse(score,\e[31m0\e[0m) }\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu92o011b.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScoreSet.map\
    \ { \e[36mscore\e[0m => guessScoreMap.getOrElse(score,\e[31m0\e[0m) }\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreList is already defined as \e[33mvalue\e[0m \e[35mguessScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu92o011b.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScoreList.sortBy(-_)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpu92o011b.scala:24:12 ---------------------------\e[0m\e[0m"
  stdout: ''
  timestamp: 1660013755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.map(x => math.abs(x - _))\n\
    \        val guessesScores = guess.map(x => math.abs(x - _))\n        val guessesCorrect\
    \ = guessesScores.zip(gameScores).filter(_._1 == 0).map(_._2)\n        val guessesWrong\
    \ = guessesScores.zip(gameScores).filter(_._1 == 0).map(_._1)\n        guessesCorrect\
    \ ++ guessesWrong\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp31jvbaoj.scala:13:44 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mgameScores\e[0m = game.map(\e\
    [36mx\e[0m => math.abs(x - _))\n\e[31m\e[31m   |\e[0m                        \
    \               ^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35mabs\e[0m in \e[33mpackage\e[0m \e[35mscala.math\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m\
    \   |\e[0mmatch arguments (<?> => <?>)\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmp31jvbaoj.scala:14:48\
    \ -----------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e\
    [0m \e[36mguessesScores\e[0m = guess.map(\e[36mx\e[0m => math.abs(x - _))\n\e\
    [31m\e[31m   |\e[0m                                           ^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35mabs\e\
    [0m in \e[33mpackage\e[0m \e[35mscala.math\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Int\n\e[31m   |\e[0mmatch arguments (<?> =>\
    \ <?>)\n2 errors found\n"
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guessesWithScore = game.zip(guess)\n        val\
    \ guessesWithScoreWithCorrect = guessesWithScore\n            .filter(x => x._2\
    \ == x._1)\n            .map(x => (x._2, x._1))\n        val guessesWithScoreWithIncorrect\
    \ = guessesWithScore\n            .filter(x => x._2 != x._1)\n            .map(x\
    \ => (x._2, x._1))\n        val guessesWithScoreWithCorrectAndIncorrect = guessesWithScoreWithCorrect\
    \ ++ guessesWithScoreWithIncorrect\n        val guessesWithScoreWithCorrectAndCorrect\
    \ = guessesWithScoreWithCorrect ++ guessesWithScoreWithCorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndCorrect\
    \ = guessesWithScoreWithCorrectAndIncorrect ++ guessesWithScoreWithCorrectAndCorrect\n\
    \        val guessesWithScoreWithCorrectAndIncorrectAndIncorrect = guessesWithScoreWithCorrectAndIncorrect\
    \ ++ guessesWithScoreWithIncorrectAndIncorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndCorrect\
    \ = guessesWithScoreWithCorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithCorrectAndIncorrectAndCorrect\n\
    \        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect =\
    \ guessesWithScoreWithCorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrect\n\
    \        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\
    \ = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndCorrect\n\
    \        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\
    \ = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ ++ guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\n\
    \        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrectAndIncorrect\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzm3bgczj.scala:23:109 -----------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreWithCorrectAndIncorrectAndIncorrect\e\
    [0m = guessesWithScoreWithCorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrect\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: guessesWithScoreWithIncorrectAndIncorrect\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzm3bgczj.scala:25:133\
    \ -----------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect\e[0m = guessesWithScoreWithCorrectAndIncorrectAndIncorrect\
    \ ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrect\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Not found: guessesWithScoreWithIncorrectAndIncorrectAndIncorrect\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzm3bgczj.scala:27:157\
    \ -----------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\e\
    [0m = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: guessesWithScoreWithIncorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m long"
  stdout: ''
  timestamp: 1660013752
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val result = guesses.zip(scores).map { case (guess, score) =>\n     \
    \       if (guess == score) 0 else Math.abs(guess - score)\n        }\n      \
    \  result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameLen = game.length\n        val guessLen =\
    \ guess.length\n        val result = new Array[Long](guessLen)\n        val gameScores\
    \ = game.zipWithIndex.filter(_._1 == 1).map(_._2)\n        val guessScores = guess.zipWithIndex.filter(_._1\
    \ == 1).map(_._2)\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap\
    \ = guessScores.toMap\n        guessScoreMap.foreach { case (guess, score) =>\n\
    \            val gameScore = gameScoreMap.get(guess)\n            if (gameScore\
    \ == null) {\n                result(guess) = 0\n            } else {\n      \
    \          result(guess) = math.abs(guess - gameScore)\n            }\n      \
    \  }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp6n2_yqa4.scala:18:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                        Cannot prove that Int <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       \
    \ where:    K is a type variable\n\e[31m   |\e[0m                            \
    \                      V is a type variable\n\e[31m   |\e[0m                 \
    \                       .\n\e[31m\e[31m-- Error: /tmp/tmp6n2_yqa4.scala:19:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m19 |\e[0m       \
    \ \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\e[31m\e[31m  \
    \ |\e[0m                                             ^\e[0m\n\e[31m   |\e[0m \
    \                                       Cannot prove that Int <:< (K, V)\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m                                        where:    K\
    \ is a type variable\n\e[31m   |\e[0m                                        \
    \          V is a type variable\n\e[31m   |\e[0m                             \
    \           .\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6n2_yqa4.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // your code here\n        val gameArray = game.toArray\n\
    \        val guessArray = guess.toArray\n        val gameLength = gameArray.length\n\
    \        val guessLength = guessArray.length\n        val gameArrayLength = gameArray.length\n\
    \        val guessArrayLength = guessArray.length\n        val gameArrayLength\
    \ = gameArray.length\n        val guessArrayLength = guessArray.length\n     \
    \   val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n\
    \        val gameArrayLength = gameArray.length\n        val guessArrayLength\
    \ = guessArray.length\n        val gameArrayLength = gameArray.length\n      \
    \  val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n\
    \        val guessArrayLength = guessArray.length\n        val gameArrayLength\
    \ = gameArray.length\n        val guessArrayLength = guessArray.length\n     \
    \   val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n\
    \        val gameArrayLength = gameArray.length\n        val guessArrayLength\
    \ = guessArray.length\n        val gameArrayLength = gameArray.length\n      \
    \  val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n\
    \        val guessArrayLength = guessArray.length\n        val gameArrayLength\
    \ = gameArray.length\n        val guessArrayLength = guessArray.length\n     \
    \   val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n\
    \        val gameArrayLength = gameArray.length\n        val guessArrayLength\
    \ = guessArray.length\n        val gameArrayLength = gameArray.length\n      \
    \  val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n\
    \        val guessArrayLength = guessArray.length\n        val gameArrayLength\
    \ = gameArray.length\n        val guessArrayLength = guessArray.length\n     \
    \   val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n\
    \        val gameArrayLength = gameArray.length\n        val guessArrayLength\
    \ = guessArray.length\n        val gameArrayLength = gameArray.length\n      \
    \  val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n\
    \        val guessArrayLength = guessArray.length\n        val gameArrayLength\
    \ = gameArray.length\n        val guessArrayLength = guessArray.length\n     \
    \   val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n\
    \        val gameArrayLength = gameArray.length\n        val guessArrayLength\
    \ = guessArray.length\n        val gameArrayLength = gameArray.length\n      \
    \  val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n\
    \        val guessArrayLength = guessArray.length\n        val gameArrayLength\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpyz_qpqb2.scala:70:29 ---------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m        \e[33mval\e[0m \e[36mgameArrayLength\e[0m = \n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpyz_qpqb2.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mgameArrayLength\e[0m = gameArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameArrayLength is already defined as \e[33mvalue\e[0m \e[35mgameArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyz_qpqb2.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mguessArrayLength\e[0m = guessArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessArrayLength is already defined as \e[33mvalue\e[0m \e[35mguessArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyz_qpqb2.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mgameArrayLength\e[0m = gameArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameArrayLength is already defined as \e[33mvalue\e[0m \e[35mgameArrayLength\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpyz_qpqb2.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mguessArrayLength\e[0m = guessArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessArrayLength is already"
  stdout: ''
  timestamp: 1660013755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSorted\
    \ = guessesWithScores.sortBy(_._1)\n        val guessesWithScoresSortedReversed\
    \ = guessesWithScoresSorted.reverse\n        val guessesWithScoresSortedReversedWithCorrect\
    \ = guessesWithScoresSortedReversed.takeWhile(_._2 == 0).reverse\n        val\
    \ guessesWithScoresSortedReversedWithCorrectWithIndex = guessesWithScoresSortedReversedWithCorrect.zipWithIndex\n\
    \        val guessesWithScoresSortedReversedWithCorrectWithIndexSorted = guessesWithScoresSortedReversedWithCorrectWithIndex.sortBy(_._1)\n\
    \        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrect\
    \ = guessesWithScoresSortedReversedWithCorrectWithIndexSorted.takeWhile(_._2 ==\
    \ 1).reverse\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndex\
    \ = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrect.zipWithIndex\n\
    \        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSorted\
    \ = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndex.sortBy(_._1)\n\
    \        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\
    \ = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.takeWhile(_._2\
    \ == 2).reverse\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndex\
    \ = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.zipWithIndex\n\
    \        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSorted\
    \ = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndex.sortBy(_._1)\n\
    \        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\
    \ = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.takeWhile(_._2\
    \ == 3).reverse\n        val guessesWithScoresSorted\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi0z9se_2.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpi0z9se_2.scala:24:109\
    \ --------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\e\
    [0m = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.takeWhile(_._2\
    \ == \e[31m2\e[0m).reverse\n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m\
    \  guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpi0z9se_2.scala:27:135 --------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\e\
    [0m = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.takeWhile(_._2\
    \ == \e[31m3\e[0m).reverse\n\e[31m\e[31m   |\e[0m                            \
    \                                                                            \
    \                               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpi0z9se_2.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Req"
  stdout: ''
  timestamp: 1660013755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val results = new mutable.ArrayList[Long]()\n        for(score <- scores)\
    \ {\n            val guess = guesses.find(_ == score)\n            if(guess ==\
    \ None) results += abs(score - game(0))\n            else results += abs(guess\
    \ - score)\n        }\n        results\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdy9bzq3i.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresults\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013750
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else\
    \ x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n       \
    \ val diffs = guessScores.zip(gameScores).map(x => if (x._1 == x._2) 0 else abs(x._1\
    \ - x._2))\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013730
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map {\
    \ case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map\
    \ { case (guess, index) => guess }\n        val guessesWithScores : List[(Long,\
    \ Long)] = guesses.zipWithIndex.map { case (guess, index) => (score, guess) }\n\
    \        val guessesWithScoreAndIndex : List[(Long, Long, Int)] = guessesWithScores.zipWithIndex.map\
    \ { case (score, guess, index) => (score, guess, index) }\n        val guessesWithScoreAndIndexAndGuessed\
    \ : List[(Long, Long, Int, Boolean)] = guessesWithScoreAndIndex.map { case (score,\
    \ guess, index, guessed) => (score, guess, index, guessed) }\n        val guessesWithScoreAndIndexAndGuessedAndGame\
    \ : List[(Long, Long, Int, Boolean, List[Long])] = guessesWithScoreAndIndexAndGuessed.map\
    \ { case (score, guess, index, guessed, game) => (score, guess, index, guessed,\
    \ game) }\n        val guessesWithScoreAndIndexAndGuessedAndGameAndGuessed : List[(Long,\
    \ Long, Int, Boolean, List[Long], List[Long])] = guessesWithScoreAndIndexAndGuessed.map\
    \ { case (score, guess, index, guessed, game, guessed) => (score, guess, index,\
    \ guessed, game, guessed) }\n        guessesWithScoreAndIndexAndGuessedAndGameAndGuessed.map\
    \ { case (score, guess, index, guessed, game, guessed, guessesWithScoreAndIndexAndGuessedAndGameAndGuessed)\
    \ =>\n            val guessesWithScoreAndIndexAndGuessedAndGameAndGuessedAndGuessedAndGuessedAndGuessed\
    \ : List[(Long, Long, Int, Boolean, List[Long], List[Long], List[Long], List[Long])]\
    \ = guessesWithScoreAndIndexAndGuessedAndGameAndGuessed.map { case (score, guess,\
    \ index, guessed, game, guessed, guessesWithScoreAndIndexAndGuessedAndGameAndGuessedAndGuessed)\
    \ =>\n                val guessesWithScoreAndIndexAndGuessedAndGameAndGuessedAndGuessedAndGuessedAndGuessedAndGuessed\
    \ : List[(Long, Long, Int, Boolean, List[Long\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm783k5nv.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm783k5nv.scala:32:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m32 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpm783k5nv.scala:15:104 -----------------------\e[0m\e[0m\n\
    \e[31m15 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScores\e[0m : \e[35mList\e\
    [0m[(\e[35mLong\e[0m, \e[35mLong\e[0m)] = guesses.zipWithIndex.map { \e[33mcase\e\
    [0m (guess, index) => (score, guess) }\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \            ^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \                   Not found: score\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpm783k5nv.scala:16:133 -------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndex\e[0m\
    \ : \e[35mList\e[0m[(\e[35mLong\e[0m, \e[35mLong\e[0m, \e[35mInt\e[0m)] = guessesWithScores.zipWithIndex.map\
    \ { \e[33mcase\e[0m (score, guess, index) => (score, guess, index) }\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                     ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                 Found:  \
    \  (score : Any)\n\e[31m   |\e[0m                                            \
    \     Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm783k5nv.scala:16:140\
    \ -------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndex\e\
    [0m : \e[35mList\e[0m[(\e[35mLong\e[0m, \e[35mLong\e[0m, \e[35mInt\e[0m)] = guessesWithScores.zipWithIndex.map\
    \ { \e[33mcase\e[0m (score, guess, index) => (score, guess, index) }\n\e[31m\e\
    [31m   "
  stdout: ''
  timestamp: 1660013758
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcompare\e\
    [0m(\e[36mgame\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mguess\e[0m : \e\
    [35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^\e[0m\n\e[31m   |\e[0m                                               \
    \     Found:    Unit\n\e[31m   |\e[0m                                        \
    \            Required: List[Long]\n\e[31m13 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m14 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n        val gameScore = game.zipWithIndex.filter(_._1\
    \ == 1).map(_._2)\n        val guessScore = guess.zipWithIndex.filter(_._1 ==\
    \ 1).map(_._2)\n        val gameScoreList = gameScore.toList\n        val guessScoreList\
    \ = guessScore.toList\n        val gameScoreMap = gameScoreList.zipWithIndex.toMap\n\
    \        val guessScoreMap = guessScoreList.zipWithIndex.toMap\n        val gameScoreSet\
    \ = gameScoreList.map(x => gameScoreMap.get(x))\n        val guessScoreSet = guessScoreList.map(x\
    \ => guessScoreMap.get(x))\n        val gameScoreSetSet = gameScoreSet.union(guessScoreSet)\n\
    \        val gameScoreSetSetSet = gameScoreSetSet.toSet\n        val gameScoreSetSetSetSet\
    \ = gameScoreSetSetSet.toSet\n        val gameScoreSetSetSetSetSet = gameScoreSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSet = gameScoreSetSetSetSetSet.toSet\n  \
    \      val gameScoreSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \        val gameScoreSetSetSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSet\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw55gfcwk.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSetSetSetSetSetSetSetSet\e\
    [0m = gameScoreSetSetSetSetSetSetSetSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreSetSetSetSetSetSetSetSet is already defined as \e\
    [33mvalue\e[0m \e[35mgameScoreSetSetSetSetSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw55gfcwk.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreSetSetSetSetSetSetSetSetSetSet\e[0m = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreSetSetSetSetSetSetSetSetSetSet is already defined\
    \ as \e[33mvalue\e[0m \e[35mgameScoreSetSetSetSetSetSetSetSetSetSet\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpw55gfcwk.scala:34:12 ---------------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m        \e[33mval\e[0m \e[36mgameScoreSetSetSetSetSetSetSetSetSetSetSet\e\
    [0m = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreSetSetSetSetSetSetSetSetSetSetSet is already defined\
    \ as \e[33mvalue\e[0m \e[35mgameScoreSetSetSetSetSetSetSetSetSetSetSet\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpw55gfcwk.scala:36:12 ---------------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        \e[33mval\e[0m \e[36mgameScoreSetSetSetSetSetSetSetSetSetSetSetSet\e\
    [0m = gameScoreSetSetSetSetSetSetSetSetSetSetSet\n"
  stdout: ''
  timestamp: 1660013755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val guessesPerScore = guessesCount / scoresCount\n        val guessesPerGame\
    \ = guessesCount / gameCount\n        val guessesPerGameAbs = guessesPerGame -\
    \ guessesPerScore\n        val guessesPerScoreAbs = guessesPerScore - guessesPerGame\n\
    \        val guessesPerGameAbsDiff = guessesPerGameAbs.toList\n        val guessesPerScoreAbsDiff\
    \ = guessesPerScoreAbs.toList\n        val guessesPerGameAbsDiffDiff = guessesPerGameAbsDiff.zip(guessesPerScoreAbsDiff).map\
    \ {\n            case (diff, diff2) => diff - diff2\n        }\n        val guessesPerScoreAbsDiffDiff\
    \ = guessesPerScoreAbsDiff.zip(guessesPerGameAbsDiff).map {\n            case\
    \ (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff\
    \ = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n        \
    \    case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff\
    \ = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n        \
    \    case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff\
    \ = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n        \
    \    case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff\
    \ = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n        \
    \    case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff\
    \ = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n        \
    \    case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff\
    \ = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n        \
    \    case (diff, diff2) => diff - diff2\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0b1i3mxn.scala:56:0 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0b1i3mxn.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesPerGameAbsDiffDiffDiff\e[0m = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mguessesPerGameAbsDiffDiffDiff\
    \ is already defined as \e[33mvalue\e[0m \e[35mguessesPerGameAbsDiffDiffDiff\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m33 |\e[0m         \
    \   \e[33mcase\e[0m (diff, diff2) => diff - diff2\n\e[31m34 |\e[0m        }\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmp0b1i3mxn.scala:35:12 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mguessesPerGameAbsDiffDiffDiff\e\
    [0m = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n\e[31m\e\
    [31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mguessesPerGameAbsDiffDiffDiff is already\
    \ defined as \e[33mvalue\e[0m \e[35mguessesPerGameAbsDiffDiffDiff\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m36 |\e[0m            \e[33mcase\e\
    [0m (diff, diff2) => diff - diff2\n\e[31m37 |\e[0m        }\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmp0b1i3mxn.scala:38:12 ---------------------------\e[0m\e\
    [0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mguessesPerGameAbsDiffDiffDiff\e\
    [0m = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n\e[31m\e\
    [31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mguessesPerGameAbsDiffDiffDiff is already\
    \ defined as \e[33mvalue\e[0m \e[35mguessesPerGameAbsDiffDiffDiff\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m39 |\e[0m            \e[33mcase\e\
    [0m (diff, diff2) => diff - diff2\n\e[31m40 |\e[0m        }\n\e[31m\e[31m-- [E161]\
    \ Naming Error: /tmp/tmp0b1i3mxn.scala:41:12 ----------"
  stdout: ''
  timestamp: 1660013755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n   \
    \     val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n\
    \        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores\
    \ = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val\
    \ guessesScores = guessesScoreList.zipWithIndex.map { case (score, index) => score\
    \ }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap\
    \ = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n\
    \        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores\
    \ = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val\
    \ guessesScores = guessesScoreList.zipWithIndex.map { case (score, index) => score\
    \ }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap\
    \ = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n\
    \        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores\
    \ = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val\
    \ guessesScores = guessesScoreList.zipWithIndex.map { case (score, index) => score\
    \ }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap\
    \ = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n\
    \        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores\
    \ = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val\
    \ guessesScores = guessesScoreList.zipWithIndex.map { case (score, index) => score\
    \ }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap\
    \ = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n\
    \        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores\
    \ = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val\
    \ guesses\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl0p0x1_x.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpl0p0x1_x.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScores\e[0m = gameScoreList.zipWithIndex.map { \e[33mcase\e[0m (score,\
    \ index) => score }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl0p0x1_x.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mguessesScores\e[0m = guessesScoreList.zipWithIndex.map\
    \ { \e[33mcase\e[0m (score, index) => score }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScores is already defined as \e[33mvalue\e[0m \e[35mguessesScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl0p0x1_x.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpl0p0x1_x.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreMap\e[0m = guessesScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessesScoreMap is already defined as \e[33mvalue\e[0m \e["
  stdout: ''
  timestamp: 1660013755
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.foldLeft(0)(_ + _)\n \
    \       val guessScore = guessScores.foldLeft(0)(_ + _)\n        val difference\
    \ = guessScore - gameScore\n        val differences = guessScores.zip(gameScores).map\
    \ { case (guess, game) => guess - game }\n        differences.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjsccwusb.scala:15:47\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgameScore\e\
    [0m = gameScores.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        \
    \                                       ^^^^^\e[0m\n\e[31m   |\e[0m          \
    \                                     Found:    Long\n\e[31m   |\e[0m        \
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpjsccwusb.scala:16:49 --------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessScore\e[0m = guessScores.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \             ^^^^^\e[0m\n\e[31m   |\e[0m                                    \
    \             Found:    Long\n\e[31m   |\e[0m                                \
    \                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013755
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val difference = guessScore - gameScore\n       \
    \ val differences = guessScores.zip(gameScores).map { case (guess, game) =>\n\
    \            if (guess == game) {\n                0\n            } else {\n \
    \               Math.abs(guess - game)\n            }\n        }\n        differences.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013757
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val results = new mutable.ArrayList[Long]()\n        for(score <- scores)\
    \ {\n            val guess = guesses.find(_ == score)\n            if(guess ==\
    \ None) results += Math.abs(score - game(0))\n            else results += Math.abs(guess\
    \ - score)\n        }\n        results\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaob12tyh.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresults\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013752
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreSet = gameScores.toSet\n        val\
    \ guessScoreSet = guessScores.toSet\n        val gameScoreDiff = gameScores.toList.zip(guessScores).map\
    \ { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet\
    \ = gameScoreDiff.toSet\n        val gameScoreDiffSet2 = gameScoreDiff.zip(guessScores).map\
    \ { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet3\
    \ = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score)\
    \ }\n        val gameScoreDiffSet4 = gameScoreDiff.zip(guessScores).map { case\
    \ (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet5 = gameScoreDiff.zip(guessScores).map\
    \ { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet6\
    \ = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score)\
    \ }\n        val gameScoreDiffSet7 = gameScoreDiff.zip(guessScores).map { case\
    \ (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet8 = gameScoreDiff.zip(guessScores).map\
    \ { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet9\
    \ = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score)\
    \ }\n        val gameScoreDiffSet10 = gameScoreDiff.zip(guessScores).map { case\
    \ (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet11 = gameScoreDiff.zip(guessScores).map\
    \ { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet12\
    \ = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score)\
    \ }\n        val gameScoreDiffSet13 = gameScoreDiff.zip(guessScores).map { case\
    \ (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet14 = gameScoreDiff.zip(guessScores).map\
    \ { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet15\
    \ = gameScoreDiff.\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqysmytgt.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpqysmytgt.scala:33:5 ---------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013756
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map(x => x._2)\n\
    \        val guessScores = guess.zipWithIndex.map(x => x._2)\n        val gameScoreMap\
    \ = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val\
    \ gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmptwvd9e32.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptwvd9e32.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptwvd9e32.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptwvd9e32.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScoreList is already defined as \e[33mvalue\e[0m \e[35mguessScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmptwvd9e32.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSet\e[0m = gameScores.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0"
  stdout: ''
  timestamp: 1660013760
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcompare\e\
    [0m(\e[36mgame\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mguess\e[0m : \e\
    [35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^\e[0m\n\e[31m   |\e[0m                                               \
    \     Found:    Unit\n\e[31m   |\e[0m                                        \
    \            Required: List[Long]\n\e[31m13 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m14 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcompare\e\
    [0m(\e[36mgame\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mguess\e[0m : \e\
    [35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^\e[0m\n\e[31m   |\e[0m                                               \
    \     Found:    Unit\n\e[31m   |\e[0m                                        \
    \            Required: List[Long]\n\e[31m13 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m14 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new Array[Long](guessesCount)\n        var i = 0\n     \
    \   while (i < guessesCount) {\n            val guess = guesses(i)\n         \
    \   val score = scores(i)\n            val difference = guess - score\n      \
    \      result(i) = difference\n            i += 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzig84gbc.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val gameScoreDiff = gameScore - guessScore\n    \
    \    val gameScoreDiffs = gameScoreDiff.zipWithIndex.map { case (diff, index)\
    \ => diff }\n        val gameScoreDiffsSum = gameScoreDiffs.sum\n        val gameScoreDiffsSumAbs\
    \ = gameScoreDiffsSum.abs\n        val gameScoreDiffsSumAbsArray = gameScoreDiffsSumAbs.toArray\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArray.length\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n\
    \        val gameScoreDiff\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp62r_nzel.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp62r_nzel.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreDiffsSumAbsArrayLength\e[0m = gameScoreDiffsSumAbsArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreDiffsSumAbsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreDiffsSumAbsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp62r_nzel.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreDiffsSumAbsArrayLength\e[0m = gameScoreDiffsSumAbsArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreDiffsSumAbsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreDiffsSumAbsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp62r_nzel.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreDiffsSumAbsArrayLength\e[0m = gameScoreDiffsSumAbsArrayLength\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreDiffsSumAbsArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreDiffsSumAbsArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp62r_nzel.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreDiffsSumAbsArrayLength\e[0m = gameScoreDiffsSumAbsArrayLength\n\
    \e["
  stdout: ''
  timestamp: 1660013760
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map{ case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n\
    \        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp83i3aoxc.scala:51:35 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSize\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp83i3aoxc.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreKeySetSize\e[0m = gameScoreKeySet.size\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgameScoreKeySetSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySetSize\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp83i3aoxc.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySetSize\e[0m = guessScoreKeySet.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeySetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreKeySetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp83i3aoxc.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSize\e\
    [0m = gameScoreValueSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreValueSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreValueSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp83i3aoxc.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSetSize\e\
    [0m = guessScoreValueSet.si"
  stdout: ''
  timestamp: 1660013762
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameLength = game.size\n        val guessLength\
    \ = guess.size\n        val result = new Array[Long](guessLength)\n        val\
    \ gameScores = game.zipWithIndex.map { case (score, index) => score }\n      \
    \  val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n\
    \        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreSet = gameScores.toSet\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpaykluvmy.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpaykluvmy.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaykluvmy.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaykluvmy.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSet\e[0m = gameScores.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreSet is already defined as \e[33mvalue\e[0m \e[35mgameScoreSet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaykluvmy.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mguessScoreSet\e[0m = guessScores.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreSet is already defined as \e[33mvalue\e[0m \e[35mguessScoreSet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the s"
  stdout: ''
  timestamp: 1660013765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesWithScores\
    \ = guessesScores.map { case (score, index) => gameScores(index) -> score }\n\
    \        val guessesWithIndexes = guessesWithScores.map { case (score, index)\
    \ => index -> score }\n        val guessesWithScoreAndIndex = guessesWithIndexes.map\
    \ { case (score, index) => score -> index }\n        val guessesWithScoreAndIndexSorted\
    \ = guessesWithScoreAndIndex.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversed\
    \ = guessesWithScoreAndIndexSorted.reverse\n        val guessesWithScoreAndIndexSortedReversedSorted\
    \ = guessesWithScoreAndIndexSortedReversed.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndex\
    \ = guessesWithScoreAndIndexSortedReversedSorted.map { case (score, index) =>\
    \ index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSorted\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndex.sortBy(_._1)\n     \
    \   val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex =\
    \ guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex.map { case\
    \ (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted.sortBy(_._1)\n\
    \        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.map\
    \ { case (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortBy(_._1)\n\
    \        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.map\
    \ { case (score, index) => index -> score }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpxn54n9k1.scala:18:70 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndexSorted\e\
    [0m = guessesWithScoreAndIndex.sortBy(_._1)\n\e[31m\e[31m   |\e[0m           \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          value sortBy is not a member of Map[Long,\
    \ Int]\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxn54n9k1.scala:23:83 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex\e\
    [0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex.map\
    \ { \e[33mcase\e[0m (score, index) => index -> score }\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxn54n9k1.scala:24:89\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\e\
    [0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                 ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpxn54n9k1.scala:25:98\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex\e\
    [0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.map\
    \ { \e[33mcase\e[0m (score, index) => "
  stdout: ''
  timestamp: 1660013765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesWithScores\
    \ = guessesScores.map { case (score, index) => index -> score }\n        val guessesWithIndexes\
    \ = guessesWithScores.map { case (score, index) => index -> guess }\n        val\
    \ guessesWithIndexesWithScores = guessesWithIndexes.map { case (score, index)\
    \ => index -> gameScores(index) }\n        val guessesWithIndexesWithScoresWithIndex\
    \ = guessesWithIndexesWithScores.map { case (score, index, gameScore) => index\
    \ -> gameScore }\n        val guessesWithIndexesWithScoresWithIndexAndScore =\
    \ guessesWithIndexesWithScoresWithIndex.map { case (score, index, gameScore) =>\
    \ index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndex\
    \ = guessesWithIndexesWithScoresWithIndexAndScore.map { case (score, index, gameScore)\
    \ => index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScore\
    \ = guessesWithIndexesWithScoresWithIndexAndScoreWithIndex.map { case (score,\
    \ index, gameScore) => index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndex\
    \ = guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScore.map { case\
    \ (score, index, gameScore) => index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScore\
    \ = guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndex.map\
    \ { case (score, index, gameScore) => index -> gameScore(index) }\n        val\
    \ guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScoreWithIndex\
    \ = guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScore.map\
    \ { case (score, index, gameScore) => index -> gameScore(index) }\n        val\
    \ guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScoreWithIndexAndScore\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpt6q2nop9.scala:25:110 --------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mguessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScoreWithIndexAndScore\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                                              ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt6q2nop9.scala:17:111\
    \ -------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mguessesWithIndexesWithScores\e\
    [0m = guessesWithIndexes.map { \e[33mcase\e[0m (score, index) => index -> gameScores(index)\
    \ }\n\e[31m\e[31m   |\e[0m                                                   \
    \                                                            ^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                          Found:    (index : List[Long])\n\
    \e[31m   |\e[0m                                          Required: Long\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E050] Type Error: /tmp/tmpt6q2nop9.scala:19:147 ----------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mguessesWithIndexesWithScoresWithIndexAndScore\e\
    [0m = guessesWithIndexesWithScoresWithIndex.map { \e[33mcase\e[0m (score, index,\
    \ gameScore) => index -> gameScore(index) }\n\e[31m\e[31m   |\e[0m           \
    \                                                                            \
    \                                                            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                                \e[33mvalue\e[0m \e[35mgameScore\e\
    [0m does not take parameters\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E050] Type Error:\
    \ /tmp/tmpt6q2nop9.scala:20:164 ----------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mguessesWithIndexesWithScoresWithI"
  stdout: ''
  timestamp: 1660013766
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new Array[Long](guessesCount)\n        var i = 0\n     \
    \   while (i < guessesCount) {\n            val guess = guesses(i)\n         \
    \   val score = scores(i)\n            val difference = abs(guess - score)\n \
    \           result(i) = difference\n            i += 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptkvd4wtv.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013717
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val diffs = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013744
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}\n        val guessesScores = guess.zipWithIndex.map{case (score,\
    \ index) => score}\n        val gameScore = gameScores.sum\n        val guessesScore\
    \ = guessesScores.sum\n        val differences = guessesScores.zip(gameScores).map{case\
    \ (guess, game) => math.abs(guess - game)}\n        differences.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013767
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val diffs = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013744
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val differences = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        differences.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesWithScores\
    \ = guessesScores.map { case (score, index) => gameScores(index) -> score }\n\
    \        val guessesWithIndexes = guessesWithScores.map { case (score, index)\
    \ => index -> score }\n        val guessesWithScoreAndIndex = guessesWithIndexes.map\
    \ { case (score, index) => (score, index) }\n        val guessesWithScoreAndIndexSorted\
    \ = guessesWithScoreAndIndex.sortBy(_._1).reverse\n        val guessesWithScoreAndIndexSortedWithIndex\
    \ = guessesWithScoreAndIndexSorted.map { case (score, index) => (score, index._2)\
    \ }\n        val guessesWithScoreAndIndexSortedWithIndexSorted = guessesWithScoreAndIndexSortedWithIndex.sortBy(_._1).reverse\n\
    \        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedWithIndexSortedWithIndex.map\
    \ { case (score, index) => (score, index._2) }\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSorted\
    \ = guessesWithScoreAndIndexSortedWithIndexSortedWithIndex.sortBy(_._1).reverse\n\
    \        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex.map\
    \ { case (score, index) => (score, index._2) }\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortBy(_._1).reverse\n\
    \        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.map\
    \ { case (score, index) => (score, index._2) }\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.sortBy(_._1).reverse\n\
    \        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = guessesWithScore\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv65r_06s.scala:18:70 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndexSorted\e\
    [0m = guessesWithScoreAndIndex.sortBy(_._1).reverse\n\e[31m\e[31m   |\e[0m   \
    \                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          value sortBy is not a member of Map[Long,\
    \ Int]\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv65r_06s.scala:21:69 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndexSortedWithIndexSortedWithIndex\e\
    [0m = guessesWithScoreAndIndexSortedWithIndexSortedWithIndex.map { \e[33mcase\e\
    [0m (score, index) => (score, index._2) }\n\e[31m\e[31m   |\e[0m             \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0mRecursive \e[33mvalue\e[0m \e[35mguessesWithScoreAndIndexSortedWithIndexSortedWithIndex\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv65r_06s.scala:23:84\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex\e\
    [0m = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex.map\
    \ { \e[33mcase\e[0m (score, index) => (score, index._2) }\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \          ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mguessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpv65r_06s.scala:24:90\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\e\
    [0m = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortBy(_._1).reverse\n\
    \e[31m\e[31m   |\e[0m                                   "
  stdout: ''
  timestamp: 1660013765
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSorted\
    \ = guessesWithScores.sortBy(_._1)\n        val guessesWithScoresSortedReversed\
    \ = guessesWithScoresSorted.reverse\n        val guessesWithScoresSortedReversedWithCorrect\
    \ = guessesWithScoresSortedReversed.filter(_._2 == 0)\n        val guessesWithScoresSortedReversedWithIncorrect\
    \ = guessesWithScoresSortedReversed.filter(_._2 != 0)\n        val guessesWithScoresSortedReversedWithCorrectAndIncorrect\
    \ = guessesWithScoresSortedReversedWithCorrect ++ guessesWithScoresSortedReversedWithIncorrect\n\
    \        val guessesWithScoresSortedReversedWithCorrectAndCorrect = guessesWithScoresSortedReversedWithCorrect\
    \ ++ guessesWithScoresSortedReversedWithCorrect\n        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndCorrect\
    \ = guessesWithScoresSortedReversedWithCorrectAndIncorrect ++ guessesWithScoresSortedReversedWithCorrectAndCorrect\n\
    \        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect\n\
    \        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\
    \ ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\
    \ = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\n\
    \        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp96rjq9ke.scala:23:149 --------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect\e\
    [0m = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                 ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mguessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp96rjq9ke.scala:24:93\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\e\
    [0m = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\
    \ ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp96rjq9ke.scala:25:103 -----------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\e\
    [0m = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\
    \ ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                               ^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660013765
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesCorrect = guessesScores.zip(gameScores).map\
    \ { case (guess, score) =>\n            if (guess == score) 0 else Math.abs(guess\
    \ - score)\n        }\n        guessesCorrect.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n\
    \        val guessScoreList = new mutable.ListBuffer[Long]()\n        val gameScoreMapKeys\
    \ = gameScoreMap.keySet\n        val guessScoreMapKeys = guessScoreMap.keySet\n\
    \        gameScoreMapKeys.foreach(gameScoreList.+=)\n        guessScoreMapKeys.foreach(guessScoreList.+=)\n\
    \        val gameScoreMapValues = gameScoreMap.values.toList\n        val guessScoreMapValues\
    \ = guessScoreMap.values.toList\n        val gameScoreMapValuesMap = gameScoreMapValues.toMap\n\
    \        val guessScoreMapValuesMap = guessScoreMapValues.toMap\n        val gameScoreMapValuesMapKeys\
    \ = gameScoreMapValuesMap.keySet\n        val guessScoreMapValuesMapKeys = guessScoreMapValuesMap.keySet\n\
    \        gameScoreMapValuesMapKeys.foreach(gameScoreMapValuesList.+=)\n      \
    \  guessScoreMapValuesMapKeys.foreach(guessScoreMapValuesList.+=)\n        val\
    \ gameScoreMapValuesMapValues = gameScoreMapValuesMap.values.toList\n        val\
    \ guessScoreMapValuesMapValues = guessScoreMapValuesMap.values.toList\n      \
    \  val gameScoreMapValuesMapValuesMap = gameScoreMapValuesMapValues.toMap\n  \
    \      val guessScoreMapValuesMapValuesMap = guessScoreMapValuesMapValues.toMap\n\
    \        val gameScoreMapValuesMapValuesMapKeys = gameScoreMapValuesMapValuesMap.keySet\n\
    \        val guessScoreMapValuesMapValuesMapKeys = guessScoreMapValuesMapValuesMap.keySet\n\
    \        gameScoreMapValuesMapValuesMapKeys.foreach(gameScoreMapValuesMapValuesList.+=)\n\
    \        guessScoreMapValuesMapValuesMapKeys.foreach(guessScoreMapValuesMapValuesList.+=)\n\
    \        val gameScoreMapValuesMapValuesMapValues = gameScoreMapValuesMapValuesMap.values.toList\n\
    \        val guessScoreMapValuesMapValuesMapValues = guessScoreMapValuesMapValuesMap.values.toList\n\
    \        val gameScoreMapValuesMapValuesMapValuesMap = gameScoreMapValuesMapValuesMapValues.toMap\n\
    \        val guessScoreMapValuesMapValuesMapValues\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp27t8dsvy.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp27t8dsvy.scala:15:43\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \ \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\e[31m\e[31m   |\e\
    [0m                                           ^\e[0m\n\e[31m   |\e[0m        \
    \                               Cannot prove that Long <:< (K, V)\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                                       where:    K is a type\
    \ variable\n\e[31m   |\e[0m                                                 V\
    \ is a type variable\n\e[31m   |\e[0m                                       .\n\
    \e[31m\e[31m-- Error: /tmp/tmp27t8dsvy.scala:16:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                       Cannot prove that Long <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \              .\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp27t8dsvy.scala:17:32\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mgameScoreList\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp27t8dsvy.scala:18:33 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = \e\
    [33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m    \
    \                             ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \        "
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}.toList\n        val guessesScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val gameScoreMap = gameScores.zipWithIndex.map{case\
    \ (score, index) => index.toLong -> score}.toMap\n        val guessesScoreMap\
    \ = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toMap\n\
    \        val gameScoreArray = gameScores.zipWithIndex.map{case (score, index)\
    \ => index.toLong -> score}.toArray\n        val guessesScoreArray = guessesScores.zipWithIndex.map{case\
    \ (score, index) => index.toLong -> score}.toArray\n        val gameScoreSet =\
    \ gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toSet\n\
    \        val guessesScoreSet = guessesScores.zipWithIndex.map{case (score, index)\
    \ => index.toLong -> score}.toSet\n        val gameScoreMap = gameScores.zipWithIndex.map{case\
    \ (score, index) => index.toLong -> score}.toMap\n        val guessesScoreMap\
    \ = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toMap\n\
    \        val gameScoreArray = gameScores.zipWithIndex.map{case (score, index)\
    \ => index.toLong -> score}.toArray\n        val guessesScoreArray = guessesScores.zipWithIndex.map{case\
    \ (score, index) => index.toLong -> score}.toArray\n        val gameScoreSet =\
    \ gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toSet\n\
    \        val guessesScoreSet = guessesScores.zipWithIndex.map{case (score, index)\
    \ => index.toLong -> score}.toSet\n        val gameScoreMap = gameScores.zipWithIndex.map{case\
    \ (score, index) => index.toLong -> score}.toMap\n        val guessesScoreMap\
    \ = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toMap\n\
    \        val gameScoreArray = gameScores.zipWithIndex.map{case (score, index)\
    \ => index.toLong -> score}.toArray\n        val guessesScoreArray = guessesScores.zipWithIndex.map{case\
    \ (score, index) => index\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpe54p3y27.scala:40:0 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpe54p3y27.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreMap\e[0m = gameScores.zipWithIndex.map{\e[33mcase\e[0m (score,\
    \ index) => index.toLong -> score}.toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpe54p3y27.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreMap\e[0m = guessesScores.zipWithIndex.map{\e\
    [33mcase\e[0m (score, index) => index.toLong -> score}.toMap\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScoreMap is already defined as \e[33mvalue\e[0m \e\
    [35mguessesScoreMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpe54p3y27.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreArray\e[0m = gameScores.zipWithIndex.map{\e\
    [33mcase\e[0m (score, index) => index.toLong -> score}.toArray\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreArray is already defined as \e[33mvalue\e[0m \e[35mgameScoreArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpe54p3y27.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24"
  stdout: ''
  timestamp: 1660013768
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n        val gameScores = game.zipWithIndex.map\
    \ { case (score, index) => index -> score }.toMap\n        val guessesScores =\
    \ guess.zipWithIndex.map { case (score, index) => index -> score }.toMap\n   \
    \     val gameScore = gameScores.map { case (index, score) => score }.toList\n\
    \        val guessesScore = guessesScores.map { case (index, score) => score }.toList\n\
    \        val gameScoreDiff = gameScore zip guessesScore map { case (gameScore,\
    \ guessesScore) => Math.abs(gameScore - guessesScore) }\n        gameScoreDiff.map\
    \ { case (gameScoreDiff, index) => gameScoreDiff -> index }.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmgtei84r.scala:19:84\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        gameScoreDiff.map { \e\
    [33mcase\e[0m (gameScoreDiff, index) => gameScoreDiff -> index }.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[(Any, Any)]\n\e[31m   |\e[0m      \
    \  Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map{ case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfye81tef.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfye81tef.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfye81tef.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScoreList is already defined as \e[33mvalue\e[0m \e[35mguessScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpfye81tef.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSet\e[0m = gameScores.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val result: List[Long] = guesses.map{g => if (scores.contains(g)) 0 else\
    \ abs(g - scores.head)}\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprtdt5c46.scala:15:44\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = guesses.map{\e[36mg\e[0m => \e[33mif\e\
    [0m (scores.contains(g)) \e[31m0\e[0m \e[33melse\e[0m abs(g - scores.head)}\n\e\
    [31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    \e[1m\e[31mSet\e\
    [0m[Long]\n\e[31m   |\e[0m                                 Required: \e[1m\e[32mList\e\
    [0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n   \
    \     val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessesScoreList = guessesScores.toList\n        val gameScoreSet\
    \ = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n    \
    \    val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessesScoreList =\
    \ guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val\
    \ guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList\
    \ = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n \
    \       val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessesScoreList =\
    \ guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val\
    \ guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList\
    \ = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n \
    \       val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessesScoreList =\
    \ guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val\
    \ guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessesScoreMap = guessesScores.toMap\n        val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmppr_z980i.scala:53:11 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmppr_z980i.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppr_z980i.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreMap\e[0m = guessesScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessesScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessesScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppr_z980i.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppr_z980i.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreList\e[0m = guessesScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mguessesScoreList is already defined as \e[33mvalue\e[0m \e[35mguessesScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded "
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesCorrect = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => guess == game }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => Math.abs(guess - game) }\n        guessesCorrect ++\
    \ guessesDiff\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppau4va0u.scala:17:8\
    \ ---------------------\e[0m\e[0m\n\e[31m17 |\e[0m        guessesCorrect ++ guessesDiff\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m        Found:    List[\e[1m\e[31mAnyVal\e[0m]\n\e[31m   |\e[0m        Required:\
    \ List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013767
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val result: List[Long] = guesses.map(guess => if (scores.contains(guess))\
    \ 0 else abs(guess - scores.head))\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6p6k1pru.scala:15:44\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e\
    [0m: \e[35mList\e[0m[\e[35mLong\e[0m] = guesses.map(\e[36mguess\e[0m => \e[33mif\e\
    [0m (scores.contains(guess)) \e[31m0\e[0m \e[33melse\e[0m abs(guess - scores.head))\n\
    \e[31m\e[31m   |\e[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                 Found:    \e[1m\e[31mSet\e\
    [0m[Long]\n\e[31m   |\e[0m                                 Required: \e[1m\e[32mList\e\
    [0m[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013767
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val result = guesses.zip(scores).map { case (guess, score) =>\n     \
    \       if (guess == score) {\n                0\n            } else {\n     \
    \           Math.abs(guess - score)\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val result = guesses.zip(scores).map {\n            case (guess, score)\
    \ => if (guess == score) 0 else abs(guess - score)\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013739
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guessesWithScores = game.zip(guess)\n        val\
    \ guessesWithScoresSortedByScore = guessesWithScores.sortBy(_._1)\n        val\
    \ guessesWithScoresSortedByGuess = guessesWithScoresSortedByScore.sortBy(_._2)\n\
    \        val guessesWithScoresSortedByGuessWithCorrect = guessesWithScoresSortedByGuess.filter(_._1\
    \ == _._2)\n        val guessesWithScoresSortedByGuessWithCorrectWithCorrect =\
    \ guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithCorrectWithIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == _._2)\n        val\
    \ guessesWithScoresSortedByGuessWithIncorrectWithCorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1\
    \ == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == _._2)\n        val\
    \ guessesWithScoresSortedByGuessWithCorrectWithIncorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1\
    \ == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithCorrect =\
    \ guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithCorrectWithCorrect\
    \ = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithCorrectWithCorrect\
    \ = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithCorrectWithCorrect\
    \ = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithIncorrect\
    \ = guessesWithScoresSortedByGuessWithCorrect.filter(_\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplcv1k55d.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplcv1k55d.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoresSortedByGuessWithCorrectWithIncorrect\e[0m = guessesWithScoresSortedByGuessWithCorrect.filter(_._1\
    \ == \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoresSortedByGuessWithCorrectWithIncorrect is\
    \ already defined as \e[33mvalue\e[0m \e[35mguessesWithScoresSortedByGuessWithCorrectWithIncorrect\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplcv1k55d.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedByGuessWithIncorrectWithCorrect\e\
    [0m = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoresSortedByGuessWithIncorrectWithCorrect is\
    \ already defined as \e[33mvalue\e[0m \e[35mguessesWithScoresSortedByGuessWithIncorrectWithCorrect\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplcv1k55d.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedByGuessWithCorrectWithCorrect\e\
    [0m = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == \e[31m0\e[0m)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScores"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val differences = guessScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        val correct = differences.filter(_\
    \ == 0).length\n        val wrong = differences.filter(_ != 0).length\n      \
    \  val result = (correct + wrong).toList\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpfsfba9iw.scala:20:39 ------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = (correct +\
    \ wrong).toList\n\e[31m\e[31m   |\e[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m           value toList is not a member of Int - did you mean\
    \ Int.toInt?\n1 error found\n"
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet =\
    \ gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n    \
    \    val gameScoreList = gameScoreList.filter(gameScoreSet.contains)\n       \
    \ val guessScoreList = guessScoreList.filter(guessScoreSet.contains)\n       \
    \ val gameScoreList = gameScoreList.map(gameScoreMap(_))\n        val guessScoreList\
    \ = guessScoreList.map(guessScoreMap(_))\n        val gameScoreList = gameScoreList.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val guessScoreList = guessScoreList.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val gameScoreList = gameScoreList.zipWithIndex.filter(_._2\
    \ % 2 == 0).map{case (score, index) => score}.toList\n        val guessScoreList\
    \ = guessScoreList.zipWithIndex.filter(_._2 % 2 == 0).map{case (score, index)\
    \ => score}.toList\n        val gameScoreList = gameScoreList.zipWithIndex.filter(_._2\
    \ % 2 == 1).map{case (score, index) => score}.toList\n        val guessScoreList\
    \ = guessScoreList.zipWithIndex.filter(_._2 % 2 == 1).map{case (score, index)\
    \ => score}.toList\n        val gameScoreList = gameScoreList.zipWithIndex.filter(_._2\
    \ % 2 == 0).filter(_._2 % 2 == 1).map{case (score, index) => score}.toList\n \
    \       val guessScoreList = guessScoreList.zipWithIndex.filter(_._2 % 2 == 0).filter(_._2\
    \ % 2 == 1).map{case (score, index) => score}.toList\n        val gameScoreList\
    \ = gameScoreList.zipWithIndex.filter(_._2 % 2 == 1).filter(_._2 % 2 == 0).map{case\
    \ (score, index) => score}.toList\n        val guessScoreList = guessScoreList.zipWithIndex.filter(_._2\
    \ % 2 == 1).filter(_._2 % 2 == 0).map{case (score, index) => score}.toList\n \
    \       val gameScoreList = gameScoreList.zipWithIndex.filter(_._\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbz2hop8a.scala:35:64 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScoreList.zipWithIndex.filter(_._\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \        ^\e[0m\n\e[31m   |\e[0m                                   an identifier\
    \ expected, but '_' found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbz2hop8a.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScoreList.filter(gameScoreSet.contains)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbz2hop8a.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScoreList.filter(guessScoreSet.contains)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreList is already defined as \e[33mvalue\e[0m \e[35mguessScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbz2hop8a.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScoreList.map(gameScoreMap(_))\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpbz2hop8a.scala:24:12 ---------------------------\e[0m\e[0"
  stdout: ''
  timestamp: 1660013772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new Array[Long](guessesCount)\n        var i = 0\n     \
    \   while (i < guessesCount) {\n            val guess = guesses(i)\n         \
    \   val score = scores(i)\n            val diff = Math.abs(guess - score)\n  \
    \          result(i) = diff\n            i += 1\n        }\n        result\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjq0bipzl.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013729
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppgttl6qo.scala:12:70\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcompare\e\
    [0m(\e[36mgame\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mguess\e[0m : \e\
    [35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^\e[0m\n\e[31m   |\e[0m                                               \
    \     Found:    Unit\n\e[31m   |\e[0m                                        \
    \            Required: List[Long]\n\e[31m13 |\e[0m        \e[34m// your code here\e\
    [0m\n\e[31m14 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013771
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesScores =\
    \ guessesScores.filter(_._2 > gameScores.size)\n        val guessesScores = guessesScores.map\
    \ { case (score, index) => (gameScores(score) - gameScores(index)) }\n       \
    \ guessesScores.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpswe2btee.scala:15:12 ---------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mguessesScores\e[0m = guessesScores.filter(_._2\
    \ > gameScores.size)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScores is already defined as \e[33mvalue\e[0m \e[35mguessesScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpswe2btee.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesScores\e[0m = guessesScores.map\
    \ { \e[33mcase\e[0m (score, index) => (gameScores(score) - gameScores(index))\
    \ }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScores is already defined as \e[33mvalue\e[0m \e[35mguessesScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpswe2btee.scala:17:22 --------------------\e[0m\e[0m\n\
    \e[31m17 |\e[0m        guessesScores.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31m(\e[0mLong\e[1m\e[31m,\e\
    [0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m\e[1m\e[31m)\e[0m]\n\e[31m   |\e[0m   \
    \     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013772
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}\n        val guessScores = guess.zipWithIndex.map{case (score,\
    \ index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap\
    \ = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n     \
    \   val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues = gameScoreMap.values.toList\n\
    \        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpet_5gz59.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpet_5gz59.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreKeySet\e[0m = gameScoreKeys.toSet\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgameScoreKeySet\
    \ is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySet\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpet_5gz59.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessScoreKeySet\e[0m = guessScoreKeys.toSet\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mguessScoreKeySet\
    \ is already defined as \e[33mvalue\e[0m \e[35mguessScoreKeySet\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpet_5gz59.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSet\e[0m = gameScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mgameScoreValueSet is already defined as \e[33mvalue\e[0m \e[35mgameScoreValueSet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpet_5gz59.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSet\e[0m = guessScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValueSet is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreValueSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group o"
  stdout: ''
  timestamp: 1660013774
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val differences = guessScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        val correct = differences.filter(x\
    \ => x == 0).length\n        val wrong = differences.filter(x => x != 0).length\n\
    \        val result = if (correct == guessScore) 0 else wrong\n        gameScores.zip(guesses).map\
    \ { case (score, guess) => math.abs(guess - score) }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzn7usman.scala:21:23 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        gameScores.zip(guesses).map { \e[33mcase\e[0m\
    \ (score, guess) => math.abs(guess - score) }\n\e[31m\e[31m   |\e[0m         \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                       Not found:\
    \ guesses\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzn7usman.scala:21:76\
    \ ------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        gameScores.zip(guesses).map\
    \ { \e[33mcase\e[0m (score, guess) => math.abs(guess - score) }\n\e[31m\e[31m\
    \   |\e[0m                                                                   \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of Nothing, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might fix the problem:\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m  import Byte.byte2double\n\e[31m   |\e[0m  import Byte.byte2float\n\e[31m\
    \   |\e[0m  import Byte.byte2int\n\e[31m   |\e[0m  import Byte.byte2long\n\e[31m\
    \   |\e[0m  import Byte.byte2short\n\e[31m   |\e[0m  import Char.char2double\n\
    \e[31m   |\e[0m  import Char.char2float\n\e[31m   |\e[0m  import Char.char2int\n\
    \e[31m   |\e[0m  import Char.char2long\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.properties\
    \ AsScalaMap\n\e[31m   |\e[0m\n2 errors found\n"
  stdout: ''
  timestamp: 1660013775
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val differences = gameScores zip guessScores\n  \
    \      val correct = differences.filter(_._1 == 0)\n        val wrong = differences.filter(_._1\
    \ == 1)\n        val result = correct.map(_._2).zip(wrong.map(_._2)).map { case\
    \ (correct, wrong) => Math.abs(correct - wrong) }\n        result\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpj1zt6_qe.scala:22)\n\tat Problem.main(tmpj1zt6_qe.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val diffs = guesses.map { guess =>\n            val score = scores.get(guess)\n\
    \            if (score == None) 0 else abs(guess - score)\n        }\n       \
    \ diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz0nfgcr6.scala:16:31 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m            \e[33mval\e[0m \e[36mscore\e[0m = scores.get(guess)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \       value get is not a member of Set[Long] - did you mean scores.seq?\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz0nfgcr6.scala:19:14 --------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        diffs.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    List[\e[1m\e[31mInt\e[0m]\n\e[31m   |\e\
    [0m        Required: List[\e[1m\e[32mLong\e[0m]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660013778
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val result = guesses.zip(scores).map { case (guess, score) =>\n     \
    \       if (guess == score) {\n                0\n            } else {\n     \
    \           Math.abs(guess - score)\n            }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013769
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val scores = new mutable.HashMap[Int, Long]()\n  \
    \      val guesses = new mutable.HashMap[Int, Long]()\n        val scoreDiff =\
    \ new mutable.HashMap[Int, Long]()\n        val guesseDiff = new mutable.HashMap[Int,\
    \ Long]()\n        val scoreDiff2 = new mutable.HashMap[Int, Long]()\n       \
    \ val guesseDiff2 = new mutable.HashMap[Int, Long]()\n        val scoreDiff3 =\
    \ new mutable.HashMap[Int, Long]()\n        val guesseDiff3 = new mutable.HashMap[Int,\
    \ Long]()\n        val scoreDiff4 = new mutable.HashMap[Int, Long]()\n       \
    \ val guesseDiff4 = new mutable.HashMap[Int, Long]()\n        val scoreDiff5 =\
    \ new mutable.HashMap[Int, Long]()\n        val guesseDiff5 = new mutable.HashMap[Int,\
    \ Long]()\n        val scoreDiff6 = new mutable.HashMap[Int, Long]()\n       \
    \ val guesseDiff6 = new mutable.HashMap[Int, Long]()\n        val scoreDiff7 =\
    \ new mutable.HashMap[Int, Long]()\n        val guesseDiff7 = new mutable.HashMap[Int,\
    \ Long]()\n        val scoreDiff8 = new mutable.HashMap[Int, Long]()\n       \
    \ val guesseDiff8 = new mutable.HashMap[Int, Long]()\n        val scoreDiff9 =\
    \ new mutable.HashMap[Int, Long]()\n        val guesseDiff9 = new mutable.HashMap[Int,\
    \ Long]()\n        val scoreDiff10 = new mutable.HashMap[Int, Long]()\n      \
    \  val guesseDiff10 = new mutable.HashMap[Int, Long]()\n        val scoreDiff11\
    \ = new mutable.HashMap[Int, Long]()\n        val guesseDiff11 = new mutable.HashMap[Int,\
    \ Long]()\n        val scoreDiff12 = new mutable.HashMap[Int, Long]()\n      \
    \  val guesseDiff12 = new mutable.HashMap[Int, Long]()\n        val scoreDiff13\
    \ = new mutable.HashMap[Int, Long]()\n        val guesseDiff13 = new mutable.HashMap[Int,\
    \ Long]()\n        val scoreDiff14 = new mutable.HashMap[Int, Long]()\n      \
    \  val guesseDiff14 = new mutable.HashMap[Int, Long]()\n        val scoreDiff15\
    \ = new mutable.HashMap[Int, Long]()\n        val guesseDiff15 = new \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd_pa01ge.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpd_pa01ge.scala:13:25 ------------------------\e[0m\e[0m\n\e[31m13\
    \ |\e[0m        \e[33mval\e[0m \e[36mscores\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \   ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_pa01ge.scala:14:26\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mguesses\e[0m = \e[33mnew\e[0m mutable.HashMap[\e[35mInt\e[0m, \e[35mLong\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd_pa01ge.scala:15:28 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mscoreDiff\e[0m = \e[33mnew\e\
    [0m mutable.HashMap[\e[35mInt\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                            ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpd_pa01ge.scala:16:29 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mval\e[0m \e[36mguesseDiff\e[0m = \e[33mnew\e[0m mutable.HashMap[\e\
    [35mInt\e[0m, \e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      \
    \       ^^^^^^^\e[0m\n\e[31m   |\e[0m                             Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd_pa01ge.scala:17:29\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mscoreDiff2\e[0m = \e[33mnew\e[0m mutable.Has"
  stdout: ''
  timestamp: 1660013777
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        guessesDiff.zipWithIndex.map\
    \ { case (diff, index) => diff }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map\
    \ { case (score, index) => score }.toList\n        val guessesScore = guessesScores.map\
    \ { case (score, index) => score }.toList\n        val gameScores = gameScores.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesScores =\
    \ guessesScores.map { case (score, index) => score -> index }.toMap\n        val\
    \ gameScore = gameScores.map { case (score, index) => score }.toList\n       \
    \ val guessesScore = guessesScores.map { case (score, index) => score }.toList\n\
    \        val gameScores = gameScores.map { case (score, index) => score -> index\
    \ }.toMap\n        val guessesScores = guessesScores.map { case (score, index)\
    \ => score -> index }.toMap\n        val gameScore = gameScores.map { case (score,\
    \ index) => score }.toList\n        val guessesScore = guessesScores.map { case\
    \ (score, index) => score }.toList\n        val gameScores = gameScores.map {\
    \ case (score, index) => score -> index }.toMap\n        val guessesScores = guessesScores.map\
    \ { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map\
    \ { case (score, index) => score }.toList\n        val guessesScore = guessesScores.map\
    \ { case (score, index) => score }.toList\n        val gameScores = gameScores.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesScores =\
    \ guessesScores.map { case (score, index) => score -> index }.toMap\n        val\
    \ gameScore = gameScores.map { case (score, index) => score }.toList\n       \
    \ val guessesScore = guessesScores.map { case (score, index) => score }.toList\n\
    \        val gameScores = gameScores.map { case (score, index) => score -> index\
    \ }.toMap\n        val guessesScores = guessesScores.map { case (score, index)\
    \ => score -> index }.toMap\n        val gameScore = gameScores.map { case (score,\
    \ index) => score }.toList\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpv4tyrcxg.scala:36:11 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpv4tyrcxg.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mgameScores\e[0m = gameScores.map\
    \ { \e[33mcase\e[0m (score, index) => score -> index }.toMap\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4tyrcxg.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mguessesScores\e[0m = guessesScores.map\
    \ { \e[33mcase\e[0m (score, index) => score -> index }.toMap\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScores is already defined as \e[33mvalue\e[0m \e[35mguessesScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4tyrcxg.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mgameScore\e[0m = gameScores.map { \e\
    [33mcase\e[0m (score, index) => score }.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScore is already defined as \e[33mvalue\e[0m \e[35mgameScore\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpv4tyrcxg.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mguesse"
  stdout: ''
  timestamp: 1660013779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val guessesWithScores\
    \ = guessesScores.map { case (score, index) => gameScores(index) -> score }\n\
    \        val guessesWithIndexes = guessesWithScores.map { case (score, index)\
    \ => index -> score }\n        val guessesWithScoreAndIndex = guessesWithIndexes.map\
    \ { case (score, index) => score -> index }\n        val guessesWithScoreAndIndexSorted\
    \ = guessesWithScoreAndIndex.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversed\
    \ = guessesWithScoreAndIndexSorted.reverse\n        val guessesWithScoreAndIndexSortedReversedSorted\
    \ = guessesWithScoreAndIndexSortedReversed.sortBy(_._2)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndex\
    \ = guessesWithScoreAndIndexSortedReversedSorted.map { case (score, index) =>\
    \ index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSorted\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndex.sortBy(_._1)\n     \
    \   val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex =\
    \ guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex.map { case\
    \ (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted.sortBy(_._2)\n\
    \        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.map\
    \ { case (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortBy(_._2)\n\
    \        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex\
    \ = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.map\
    \ { case (score, index) => index -> score }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb8wxs4jb.scala:18:70 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndexSorted\e\
    [0m = guessesWithScoreAndIndex.sortBy(_._1)\n\e[31m\e[31m   |\e[0m           \
    \                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                          value sortBy is not a member of Map[Long,\
    \ Int]\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb8wxs4jb.scala:23:83 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex\e\
    [0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex.map\
    \ { \e[33mcase\e[0m (score, index) => index -> score }\n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb8wxs4jb.scala:24:89\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\e\
    [0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted.sortBy(_._2)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                 ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb8wxs4jb.scala:25:98\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex\e\
    [0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.map\
    \ { \e[33mcase\e[0m (score, index) => "
  stdout: ''
  timestamp: 1660013779
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new Array[Long](guessesCount)\n        val guessesIndex\
    \ = 0\n        val scoresIndex = 0\n        val guessesCount = guesses.size\n\
    \        val scoresCount = scores.size\n        while (guessesIndex < guessesCount\
    \ && scoresIndex < scoresCount) {\n            if (guesses(guessesIndex) == scores(scoresIndex))\
    \ {\n                result(guessesIndex) = results(guessesIndex)\n          \
    \      guessesIndex += 1\n                scoresIndex += 1\n            } else\
    \ if (guesses(guessesIndex) < scores(scoresIndex)) {\n                result(guessesIndex)\
    \ = results(guessesIndex) - abs(scores(scoresIndex) - guesses(guessesIndex))\n\
    \                guessesIndex += 1\n            } else {\n                result(guessesIndex)\
    \ = abs(guesses(guessesIndex) - scores(scoresIndex))\n                scoresIndex\
    \ += 1\n            }\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpbk1_j5nu.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mguessesCount\e[0m = guesses.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mguessesCount is already defined as \e[33mvalue\e[0m \e[35mguessesCount\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpbk1_j5nu.scala:21:12 ---------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mscoresCount\e[0m = scores.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mscoresCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mscoresCount\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbk1_j5nu.scala:24:39\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                result(guessesIndex)\
    \ = results(guessesIndex)\n\e[31m\e[31m   |\e[0m                             \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \  Not found: results\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbk1_j5nu.scala:25:29\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m                guessesIndex\
    \ += \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m         value += is not a member of Int - did you mean guessesIndex.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbk1_j5nu.scala:26:28 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                scoresIndex += \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ += is not a member of Int - did you mean scoresIndex.!=?\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbk1_j5nu.scala:28:39 ------------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m                result(guessesIndex) = results(guessesIndex)\
    \ - abs(scores(scoresInd"
  stdout: ''
  timestamp: 1660013781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet =\
    \ gameScoreList.map(x => x._2)\n        val guessScoreSet = guessScoreList.map(x\
    \ => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x =>\
    \ (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap\
    \ = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n    \
    \    val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x\
    \ => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x =>\
    \ (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap\
    \ = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n    \
    \    val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x\
    \ => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x =>\
    \ (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap\
    \ = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n    \
    \    val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x\
    \ => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x =>\
    \ (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap\
    \ = gameScoreSet.zip(guess\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7hozn4mq.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp7hozn4mq.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreMap\e[0m = gameScoreSet.zip(guessScoreSet).map(\e[36mx\e[0m =>\
    \ (x._1, x._2 - x._1)).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7hozn4mq.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScoreMap.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7hozn4mq.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSet\e[0m = gameScoreList.map(\e\
    [36mx\e[0m => x._2)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreSet is already defined as \e[33mvalue\e[0m \e[35mgameScoreSet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp7hozn4mq.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScoreSet.zip(guessScoreSet).map(\e\
    [36mx\e[0m => (x._1, x._2 - x._1)).toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreM"
  stdout: ''
  timestamp: 1660013780
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, score) =>\n            if (guess == score) 0 else math.abs(guess\
    \ - score)\n        }\n        guessesDiff.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val results = new mutable.ArrayBuffer[Long]()\n        val correct =\
    \ guesses.filter(x => x == scores(0))\n        val wrong = guesses.filter(x =>\
    \ x != scores(0))\n        val diff = wrong.map(x => Math.abs(x - scores(0)))\
    \ \n        diff foreach { x => results += x }\n        correct foreach { x =>\
    \ results += 0 }\n        results\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4jkgcqir.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresults\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013776
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameLen = game.size\n        val guessLen = guess.size\n\
    \        val result = new Array[Long](guessLen)\n        val gameScores = game.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n\
    \        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScore\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9o1vhjhi.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9o1vhjhi.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreKeySet\e[0m = gameScoreKeys.toSet\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgameScoreKeySet\
    \ is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySet\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9o1vhjhi.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessScoreKeySet\e[0m = guessScoreKeys.toSet\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mguessScoreKeySet\
    \ is already defined as \e[33mvalue\e[0m \e[35mguessScoreKeySet\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9o1vhjhi.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSet\e[0m = gameScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mgameScoreValueSet is already defined as \e[33mvalue\e[0m \e[35mgameScoreValueSet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9o1vhjhi.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSet\e[0m = guessScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValueSet is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreValueSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group o"
  stdout: ''
  timestamp: 1660013781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.map(x => Math.abs(x - game(x)))\n\
    \        guesses.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpn2bnbsdy.scala:13:55\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mguesses\e\
    [0m = guess.map(\e[36mx\e[0m => Math.abs(x - game(x)))\n\e[31m\e[31m   |\e[0m\
    \                                                       ^\e[0m\n\e[31m   |\e[0m\
    \                                                    Found:    (x : Long)\n\e\
    [31m   |\e[0m                                                    Required: Int\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val results = new mutable.ArrayList[Long](guessesCount)\n        val\
    \ guessesDiff = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiff\
    \ = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount = new\
    \ mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount = new mutable.ArrayList[Long](scoresCount)\n\
    \        val guessesDiffCount2 = new mutable.ArrayList[Long](guessesCount)\n \
    \       val scoresDiffCount2 = new mutable.ArrayList[Long](scoresCount)\n    \
    \    val guessesDiffCount3 = new mutable.ArrayList[Long](guessesCount)\n     \
    \   val scoresDiffCount3 = new mutable.ArrayList[Long](scoresCount)\n        val\
    \ guessesDiffCount4 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount4\
    \ = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount5 =\
    \ new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount5 = new\
    \ mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount6 = new mutable.ArrayList[Long](guessesCount)\n\
    \        val scoresDiffCount6 = new mutable.ArrayList[Long](scoresCount)\n   \
    \     val guessesDiffCount7 = new mutable.ArrayList[Long](guessesCount)\n    \
    \    val scoresDiffCount7 = new mutable.ArrayList[Long](scoresCount)\n       \
    \ val guessesDiffCount8 = new mutable.ArrayList[Long](guessesCount)\n        val\
    \ scoresDiffCount8 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount9\
    \ = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount9 =\
    \ new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount10 = new\
    \ mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount10 = new mutable.ArrayList[Long](scoresCount)\n\
    \        val guessesDiffCount11 = new mutable.ArrayList[Long](guessesCount)\n\
    \        val scoresDiffCount11 = new mutable.ArrayList[Long](scoresCount)\n  \
    \      val guessesDiffCount12 = new mutable.ArrayList[Long](guessesCount)\n  \
    \      val scoresDiffCount12 = new mutable.ArrayList[Long](scoresCount)\n    \
    \    val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmppmbrukrg.scala:44:11 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmppmbrukrg.scala:17:26 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresults\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m](guessesCount)\n\e[31m\e[31m   |\e[0m  \
    \                        ^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppmbrukrg.scala:18:30\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesDiff\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e[35mLong\e[0m](guessesCount)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppmbrukrg.scala:19:29 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mscoresDiff\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m](scoresCount)\n\e[31m\e[31m   |\e[0m   \
    \                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \        Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmppmbrukrg.scala:20:35 ------------------------\e[0m\e[0m\n\e[31m20 |\e\
    [0m        \e[33mval\e[0m \e[36mguessesDiffCount\e[0m = \e[33mnew\e[0m mutable.ArrayList[\e\
    [35mLong\e[0m](guessesCount)\n\e[31m\e[31m   |\e[0m                          \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                                   Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppm"
  stdout: ''
  timestamp: 1660013781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n\
    \        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp9la7r8y5.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9la7r8y5.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreKeySet\e[0m = gameScoreKeys.toSet\n\e[31m\e[31m   |\e[0m    \
    \    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgameScoreKeySet\
    \ is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySet\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9la7r8y5.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessScoreKeySet\e[0m = guessScoreKeys.toSet\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mguessScoreKeySet\
    \ is already defined as \e[33mvalue\e[0m \e[35mguessScoreKeySet\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp9la7r8y5.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSet\e[0m = gameScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mgameScoreValueSet is already defined as \e[33mvalue\e[0m \e[35mgameScoreValueSet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp9la7r8y5.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSet\e[0m = guessScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValueSet is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreValueSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group o"
  stdout: ''
  timestamp: 1660013782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScores = gameScores.toList\n        val guessScores\
    \ = guessScores.toList\n        val gameScores = gameScores.sortBy(_._1)\n   \
    \     val guessScores = guessScores.sortBy(_._1)\n        val gameScores = gameScores.reverse\n\
    \        val guessScores = guessScores.reverse\n        val gameScores = gameScores.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScores = guessScores.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScores = gameScores.toList\n\
    \        val guessScores = guessScores.toList\n        val gameScores = gameScores.sortBy(_._1)\n\
    \        val guessScores = guessScores.sortBy(_._1)\n        val gameScores =\
    \ gameScores.reverse\n        val guessScores = guessScores.reverse\n        val\
    \ gameScores = gameScores.zipWithIndex.map { case (score, index) => score }\n\
    \        val guessScores = guessScores.zipWithIndex.map { case (score, index)\
    \ => score }\n        val gameScores = gameScores.toList\n        val guessScores\
    \ = guessScores.toList\n        val gameScores = gameScores.sortBy(_._1)\n   \
    \     val guessScores = guessScores.sortBy(_._1)\n        val gameScores = gameScores.reverse\n\
    \        val guessScores = guessScores.reverse\n        val gameScores = gameScores.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessScores = guessScores.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScores = gameScores.toList\n\
    \        val guessScores = guessScores.toList\n        val gameScores = gameScores.sortBy(_._1)\n\
    \        val guessScores = guessScores.sortBy(_._1)\n        val gameScores =\
    \ gameScores.reverse\n        val guessScores = guessScores.reverse\n        val\
    \ gameScores = gameScores.zipWithIndex.map { case (score, index) => score }\n\
    \        val guessScores = guessScores.zipWithIndex.map { case (score, index)\
    \ => score }\n        val gameScores = gameScores.toList\n        val guessScore\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpisn0of2m.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpisn0of2m.scala:15:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScores\e[0m = gameScores.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpisn0of2m.scala:16:12 ---------------------------\e[0m\e[0m\n\e\
    [31m16 |\e[0m        \e[33mval\e[0m \e[36mguessScores\e[0m = guessScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScores is already defined as \e[33mvalue\e[0m \e[35mguessScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpisn0of2m.scala:17:12 ---------------------------\e[0m\e[0m\n\e\
    [31m17 |\e[0m        \e[33mval\e[0m \e[36mgameScores\e[0m = gameScores.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpisn0of2m.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mguessScores\e[0m = guessScores.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mguessScores is already defined as \e[33mvalue\e[0m \e[35mguessScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpisn0of2m.scala:19:12 ----------"
  stdout: ''
  timestamp: 1660013781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.map(_.toInt)\n        val guessScores\
    \ = guess.map(_.toInt)\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n\
    \        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet\
    \ = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n\
    \        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet\
    \ = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet\
    \ = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n\
    \        val gameScoreValueSet = gameScoreValues.\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpnpgb_d4n.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpnpgb_d4n.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36mgameScoreKeySet\e[0m = gameScoreKeys.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgameScoreKeySet is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnpgb_d4n.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySet\e[0m = guessScoreKeys.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mguessScoreKeySet is already defined as \e[33mvalue\e[0m \e[35mguessScoreKeySet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnpgb_d4n.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSet\e[0m = gameScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mgameScoreValueSet is already defined as \e[33mvalue\e[0m \e[35mgameScoreValueSet\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpnpgb_d4n.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSet\e[0m = guessScoreValues.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValueSet is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreValueSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the sa"
  stdout: ''
  timestamp: 1660013782
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}.toList\n        val guessesScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val guessesScoreMap = guessesScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val gameScoreArray = gameScoreMap.values\n        val guessesScoreArray\
    \ = guessesScoreMap.values\n        val gameScoreArrayLength = gameScoreArray.length\n\
    \        val guessesScoreArrayLength = guessesScoreArray.length\n        val gameScoreArrayLength\
    \ = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n\
    \        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength\
    \ = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n\
    \        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength\
    \ = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n\
    \        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength\
    \ = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n\
    \        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength\
    \ = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n\
    \        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength\
    \ = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n\
    \        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength\
    \ = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n\
    \        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength\
    \ = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n\
    \        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength\
    \ = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n\
    \        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength\
    \ = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n\
    \        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength\
    \ = gameScoreArrayLength\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreArrayLength\e[0m\
    \ = gameScoreArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mgameScoreArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreArrayLength\e\
    [0m = guessesScoreArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScoreArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mguessesScoreArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreArrayLength\e[0m\
    \ = gameScoreArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mgameScoreArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreArrayLength\e\
    [0m = guessesScoreArrayLength\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScoreArrayLength is already defined as \e[33mvalue\e\
    [0m \e[35mguessesScoreArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:25:12 -----------------"
  stdout: ''
  timestamp: 1660013784
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessesScoreMap = guessesScores.toMap\n        val gameScoreKeys\
    \ = gameScoreMap.keys\n        val guessesScoreKeys = guessesScoreMap.keys\n \
    \       val gameScoreValues = gameScoreMap.values.toList\n        val guessesScoreValues\
    \ = guessesScoreMap.values.toList\n        val gameScoreKeysSet = gameScoreKeys.toSet\n\
    \        val guessesScoreKeysSet = guessesScoreKeys.toSet\n        val gameScoreValuesSet\
    \ = gameScoreValues.toSet\n        val guessesScoreValuesSet = guessesScoreValues.toSet\n\
    \        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize\
    \ = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n\
    \        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val\
    \ gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize\
    \ = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n\
    \        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val\
    \ gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize\
    \ = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n\
    \        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val\
    \ gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize\
    \ = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n\
    \        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val\
    \ gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize\
    \ = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n\
    \        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val\
    \ gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize\
    \ = guessesScoreKey\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz2uh075q.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mgameScoreKeysSetSize\e[0m\
    \ = gameScoreKeysSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreKeysSetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mgameScoreKeysSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpz2uh075q.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreKeysSetSize\e\
    [0m = guessesScoreKeysSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScoreKeysSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mguessesScoreKeysSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz2uh075q.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValuesSetSize\e\
    [0m = gameScoreValuesSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreValuesSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreValuesSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz2uh075q.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreValuesSetSize\e\
    [0m = guessesScoreValuesSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScoreValuesSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mguessesScoreValuesSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz2uh07"
  stdout: ''
  timestamp: 1660013781
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val guessesWithScore = guesses.map(x => (x, scores(x)))\n        val\
    \ guessesWithScoreSorted = guessesWithScore.sortBy(_._1)\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSorted.sortBy(_._2)\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => x._1)\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess\
    \ = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp70su5jqn.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedSortedByGuess\e\
    [0m = guessesWithScoreSortedSortedByGuess.map(\e[36mx\e[0m => x._1)\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedSortedByGuess is already defined as\
    \ \e[33mvalue\e[0m \e[35mguessesWithScoreSortedSortedByGuess\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp70su5jqn.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreSortedSortedByGuess\e[0m = guessesWithScoreSortedSortedByGuess.map(\e\
    [36mx\e[0m => (x, x._2))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedSortedByGuess is already defined as\
    \ \e[33mvalue\e[0m \e[35mguessesWithScoreSortedSortedByGuess\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp70su5jqn.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreSortedSortedByGuess\e[0m = guessesWithScoreSortedSortedByGuess.map(\e\
    [36mx\e[0m => (x, x._1))\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedSortedByGuess is already defined as\
    \ \e[33mvalue\e[0m \e[35mguessesWithScoreSortedSortedByGuess\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp70su5jqn.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreSortedSortedByGuess\e[0m = guessesWithS"
  stdout: ''
  timestamp: 1660013783
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map(x => x._2)\n\
    \        val guessesScores = guess.zipWithIndex.map(x => x._2)\n        val guessesCorrect\
    \ = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n      \
    \  val guessesDiff = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1\
    \ - x._2))\n        val guessesDiff2 = guessesScores.map(x => if (x._1 == x._2)\
    \ 0 else abs(x._1 - x._2))\n        val guessesDiff3 = guessesScores.map(x =>\
    \ if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff4 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff5 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff6 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff7 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff8 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff9 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff10 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff11 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff12 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff13 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff14 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff15 = guessesScores.map(x\
    \ => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff16 = guesses\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgzvdfub2.scala:15:58 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mguessesCorrect\e[0m = guessesScores.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x._1 == x._2) \e[31m0\e[0m \e[33melse\e[0m abs(x._1\
    \ - x._2))\n\e[31m\e[31m   |\e[0m                                            \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \   value _1 is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgzvdfub2.scala:15:83\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesCorrect\e[0m = guessesScores.map(\e[36mx\e[0m => \e[33mif\e[0m (x._1\
    \ == x._2) \e[31m0\e[0m \e[33melse\e[0m abs(x._1 - x._2))\n\e[31m\e[31m   |\e\
    [0m                                                                          \
    \       ^^^^\e[0m\n\e[31m   |\e[0m                                         value\
    \ _1 is not a member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpgzvdfub2.scala:16:55\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mguessesDiff\e[0m = guessesScores.map(\e[36mx\e[0m => \e[33mif\e[0m (x._1 ==\
    \ x._2) \e[31m0\e[0m \e[33melse\e[0m abs(x._1 - x._2))\n\e[31m\e[31m   |\e[0m\
    \                                                     ^^^^\e[0m\n\e[31m   |\e\
    [0m                                         value _1 is not a member of Int\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpgzvdfub2.scala:16:80 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesDiff\e[0m = guessesScores.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x._1 == x._2) \e[31m0\e[0m \e[33melse\e[0m abs(x._1\
    \ - x._2))\n\e[31m\e[31m   |\e[0m                                            \
    \                                  ^^^^\e[0m\n\e[31m   |\e[0m                \
    \                         value _1 is not a member of Int\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpgzvdfub2.scala:17:56 ------------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mguessesDiff2\e[0m = guessesScores.map(\e\
    [36mx\e[0m => \e[33mif\e[0m (x._1 == x._2) \e[31m0\e[0m \e[33melse\e[0m abs(x._1\
    \ - x._2))\n\e[31m\e[31m   |\e[0m             "
  stdout: ''
  timestamp: 1660013788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n\
    \        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize\
    \ = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n\
    \        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize\
    \ = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n\
    \        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize\
    \ = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n\
    \        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize\
    \ = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n\
    \        val gameScoreValueSetSize = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpzptrsuc0.scala:51:35 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSize\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                   ^\e[0m\n\e[31m\
    \   |\e[0m                                   expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreKeySetSize\e[0m = gameScoreKeySet.size\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mgameScoreKeySetSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeySetSize\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzptrsuc0.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySetSize\e[0m = guessScoreKeySet.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeySetSize is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreKeySetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSize\e\
    [0m = gameScoreValueSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreValueSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreValueSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSetSize\e\
    [0m = guessScoreValueSet.si"
  stdout: ''
  timestamp: 1660013731
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        guessesDiff.zipWithIndex.map\
    \ { case (diff, index) => diff }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n        val gameScores = game.zipWithIndex.map\
    \ { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map\
    \ { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessesScoreMap = guessesScores.toMap\n        val gameScoreArray\
    \ = gameScores.toArray\n        val guessesScoreArray = guessesScores.toArray\n\
    \        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap\
    \ = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n\
    \        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap\
    \ = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n\
    \        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap\
    \ = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n\
    \        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap\
    \ = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n\
    \        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap\
    \ = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n\
    \        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap\
    \ = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n\
    \        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap\
    \ = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n\
    \        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap\
    \ = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n\
    \        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap\
    \ = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n\
    \        val guessesScoreArrayMap = guessesScores.\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp86jznm8c.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp86jznm8c.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36mgameScoreArrayMap\e[0m = gameScores.toMap.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreArrayMap is already defined as \e[33mvalue\e[0m \e\
    [35mgameScoreArrayMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp86jznm8c.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreArrayMap\e[0m\
    \ = guessesScores.toMap.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScoreArrayMap is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessesScoreArrayMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp86jznm8c.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mgameScoreArrayMap\e[0m =\
    \ gameScores.toMap.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreArrayMap is already defined as \e[33mvalue\e[0m \e\
    [35mgameScoreArrayMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp86jznm8c.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreArrayMap\e[0m\
    \ = guessesScores.toMap.toArray\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScoreArrayMap is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessesScoreArrayMap\e[0m\n\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1660013787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val gameScoreMap = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreMapWithIndex = gameScoreMap.zipWithIndex\n        val guessScoreMapWithIndex\
    \ = guessScoreMap.zipWithIndex\n        val gameScoreMapWithIndexAndGuess = gameScoreMapWithIndex.zip(guessScoreMapWithIndex)\n\
    \        val gameScoreMapWithIndexAndGuessAndScore = gameScoreMapWithIndexAndGuess.map{case\
    \ (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val\
    \ gameScoreMapWithIndexAndGuessAndScoreAndGuess = gameScoreMapWithIndexAndGuessAndScore.map{case\
    \ (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val\
    \ gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScore = gameScoreMapWithIndexAndGuessAndScoreAndGuess.map{case\
    \ (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val\
    \ gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuess = gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScore.map{case\
    \ (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val\
    \ gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScore = gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuess.map{case\
    \ (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val\
    \ gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScoreAndGuess\
    \ = gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScore.map{case\
    \ (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val\
    \ gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScoreAndGuessAndScore\
    \ = gameScoreMapWithIndexAndGuessAnd\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuou6gwgs.scala:15:48 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^\e[0m\n\
    \e[31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuou6gwgs.scala:15:70\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mgameScoreMap\e[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^^^^\e[0m\n\e[31m   |\e[0m                                        value _2\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuou6gwgs.scala:16:50\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mguessScoreMap\e[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\e\
    [31m\e[31m   |\e[0m                                                ^^^^\e[0m\n\
    \e[31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuou6gwgs.scala:16:72\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mguessScoreMap\e[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \  value _2 is not a member of Long\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuou6gwgs.scala:26:100\
    \ -----------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mgameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScoreAndGuessAndScore\e\
    [0m = gameScoreMapWithIndexAndGuessAnd\n\e[31m\e[31m   |\e[0m                \
    \                                                                            \
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \               Not found: gameScoreMapWithIndexAndGuessAnd\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer e"
  stdout: ''
  timestamp: 1660013787
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val result = new mutable.ArrayList[Long]()\n        for(i <- 0 until\
    \ guess.size) {\n            val score = scores.get(i)\n            val guess\
    \ = guesses.get(i)\n            val diff = abs(guess - score)\n            if(guess\
    \ == score) {\n                result.add(0)\n            } else {\n         \
    \       result.add(diff)\n            }\n        }\n        return result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz62iian2.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz62iian2.scala:17:31\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m\
    \ \e[36mscore\e[0m = scores.get(i)\n\e[31m\e[31m   |\e[0m                    \
    \    ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value get is not a member of Set[Long]\
    \ - did you mean scores.seq?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz62iian2.scala:18:32\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m\
    \ \e[36mguess\e[0m = guesses.get(i)\n\e[31m\e[31m   |\e[0m                   \
    \     ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m      value get is not a member of Set[Long]\
    \ - did you mean guesses.seq?\n3 errors found\n"
  stdout: ''
  timestamp: 1660013788
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameLen = game.length\n        val guessLen =\
    \ guess.length\n        val result = new Array[Long](guessLen)\n        val gameScores\
    \ = game.zipWithIndex.filter(_._2 != 0).map(_._1)\n        val guessScores = guess.zipWithIndex.filter(_._2\
    \ != 0).map(_._1)\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap\
    \ = guessScores.toMap\n        guessScoreMap.foreach { case (score, index) =>\n\
    \            val guess = guessScoreMap(index)\n            if (gameScoreMap(index)\
    \ == score) {\n                result(index) = guess\n            } else {\n \
    \               result(index) = abs(guess - score)\n            }\n        }\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp57ii_dz2.scala:18:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                       Cannot prove that Long <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \              .\n\e[31m\e[31m-- Error: /tmp/tmp57ii_dz2.scala:19:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                       Cannot prove that Long <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \              .\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp57ii_dz2.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660013788
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val result = guesses.map(x => if (x == scores(0)) 0 else abs(x - scores(0)))\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpi8bp86br.scala:19)\n\tat Problem.main(tmpi8bp86br.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013792
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}\n        val guessScores = guess.zipWithIndex.map{case (score,\
    \ index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap\
    \ = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n     \
    \   val guessScoreList = guessScoreMap.toList\n        val gameScoreSet = gameScoreList.toSet\n\
    \        val guessScoreSet = guessScoreList.toSet\n        val gameScoreMap =\
    \ gameScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n       \
    \ val guessScoreMap = guessScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n\
    \        val gameScoreList = gameScoreMap.toList\n        val guessScoreList =\
    \ guessScoreMap.toList\n        val gameScoreSet = gameScoreList.toSet\n     \
    \   val guessScoreSet = guessScoreList.toSet\n        val gameScoreMap = gameScoreList.zipWithIndex.map{case\
    \ (score, index) => score}.toMap\n        val guessScoreMap = guessScoreList.zipWithIndex.map{case\
    \ (score, index) => score}.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet =\
    \ gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n    \
    \    val gameScoreMap = gameScoreList.zipWithIndex.map{case (score, index) =>\
    \ score}.toMap\n        val guessScoreMap = guessScoreList.zipWithIndex.map{case\
    \ (score, index) => score}.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet =\
    \ gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n    \
    \    val gameScoreMap = gameScoreList.zipWithIndex.map{case (score, index) =>\
    \ score}.toMap\n        val guessScoreMap = guessScoreList.zipWithIndex.map{case\
    \ (score, index) => score}.toMap\n        val gameScoreList = gameScoreMap.toList\n\
    \        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet =\
    \ gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n    \
    \    val gameScoreMap = gameScoreList.zipWithIndex.map{case (score, index) =>\
    \ score}.toMap\n        val guess\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppn6kwwe4.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppn6kwwe4.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreMap\e[0m = gameScoreList.zipWithIndex.map{\e[33mcase\e[0m (score,\
    \ index) => score}.toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppn6kwwe4.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScoreList.zipWithIndex.map{\e\
    [33mcase\e[0m (score, index) => score}.toMap\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppn6kwwe4.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScoreMap.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmppn6kwwe4.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScoreMap.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScoreList is already def"
  stdout: ''
  timestamp: 1660013792
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score,\
    \ index) => score }.toList\n        val guessScores = guess.zipWithIndex.map{\
    \ case (score, index) => score }.toList\n        val gameScoreMap = gameScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreArray =\
    \ gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n    \
    \    val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index\
    \ -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreArray =\
    \ gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n    \
    \    val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index\
    \ -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreArray =\
    \ gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n    \
    \    val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index\
    \ -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreArray =\
    \ gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n    \
    \    val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index\
    \ -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreArray =\
    \ gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n    \
    \    val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index\
    \ -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreArray =\
    \ gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n    \
    \    val gameScoreMap = gameScores.zipWithIndex\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaqn85pz3.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.zipWithIndex.map{\
    \ \e[33mcase\e[0m (score, index) => index -> score }.toMap\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaqn85pz3.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.zipWithIndex.map{\
    \ \e[33mcase\e[0m (score, index) => index -> score }.toMap\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaqn85pz3.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreArray\e[0m = gameScores.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mgameScoreArray is already defined as \e[33mvalue\e[0m \e[35mgameScoreArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaqn85pz3.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreArray\e[0m = guessScores.toArray\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScoreArray is already defined as \e[33mvalue\e[0m \e[35mguessScoreArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel de"
  stdout: ''
  timestamp: 1660013791
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val result = new mutable.ArrayBuffer[Long]()\n        for(i <- 0 until\
    \ guess.size) {\n            val score = scores(i)\n            val guess = guesses(i)\n\
    \            val difference = guess - score\n            if(guess == score) {\n\
    \                result.push(0)\n            } else {\n                result.push(difference)\n\
    \            }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb525p5qr.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb525p5qr.scala:19:35\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mval\e[0m\
    \ \e[36mdifference\e[0m = guess - score\n\e[31m\e[31m   |\e[0m               \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of Boolean,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013792
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n\
    \        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\
    \ = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n\
    \        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSet\
    \ = gameScoreKeySet.toSet\n        val guessScoreKeySetSet = guessScoreKeySet.toSet\n\
    \        val gameScoreValueSetSet = gameScoreValueSet.toSet\n        val guessScoreValueSetSet\
    \ = guessScoreValueSet.toSet\n        val gameScoreKeySetSetSet = gameScoreKeySetSet.toSet\n\
    \        val guessScoreKeySetSetSet = guessScoreKeySetSet.toSet\n        val gameScoreValueSetSetSet\
    \ = gameScoreValueSetSet.toSet\n        val guessScoreValueSetSetSet = guessScoreValueSetSet.toSet\n\
    \        val gameScoreKeySetSetSetSet = gameScoreKeySetSetSet.toSet\n        val\
    \ guessScoreKeySetSetSetSet = guessScoreKeySetSetSet.toSet\n        val gameScoreValueSetSetSetSet\
    \ = gameScoreValueSetSetSet.toSet\n        val guessScoreValueSetSetSet = guessScoreValueSetSet.toSet\n\
    \        val gameScoreKeySetSetSetSetSet = gameScoreKeySetSetSet.toSet\n     \
    \   val guessScoreKeySetSetSetSet = guessScoreKeySetSet.toSet\n        val gameScoreValueSetSetSetSet\
    \ = gameScoreValueSetSet.toSet\n        val guessScoreValueSetSetSet = guessScoreValueSetSet.toSet\n\
    \        val gameScoreKeySetSetSetSetSet = gameScoreKeySetSetSet.toSet\n     \
    \   val guessScoreKeySetSetSetSet = guessScoreKeySetSet.toSet\n        val gameScoreValueSetSetSetSet\
    \ = gameScoreValueSetSet.toSet\n        val guessScoreValueSetSetSet = guessScoreValue\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3_0_2uhf.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSetSetSet\e\
    [0m = guessScoreValueSetSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValueSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreValueSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3_0_2uhf.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeySetSetSetSet\e\
    [0m = guessScoreKeySetSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeySetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreKeySetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3_0_2uhf.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValueSetSetSetSet\e\
    [0m = gameScoreValueSetSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreValueSetSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreValueSetSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3_0_2uhf.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValueSetSetSet\e\
    [0m = guessScoreValueSetSet.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValueSetSetSet is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreValueSetSetSet\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel de"
  stdout: ''
  timestamp: 1660013794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}\n        val guessesScores = guess.zipWithIndex.map{case (score,\
    \ index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap\
    \ = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n     \
    \   val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap =\
    \ gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n      \
    \  val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n\
    \        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessesScoreList =\
    \ guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val\
    \ guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList\
    \ = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n \
    \       val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n\
    \        val gameScoreList = gameScores.toList\n        val guessesScoreList =\
    \ guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val\
    \ guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList\
    \ = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n \
    \       val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n\
    \        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpcmzhzfao.scala:53:11 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpcmzhzfao.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcmzhzfao.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreMap\e[0m = guessesScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessesScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessesScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcmzhzfao.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpcmzhzfao.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreList\e[0m = guessesScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mguessesScoreList is already defined as \e[33mvalue\e[0m \e[35mguessesScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded "
  stdout: ''
  timestamp: 1660013794
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val diffs = guessScores.zip(gameScores).map { case\
    \ (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013742
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new mutable.ListBuffer[Long]()\n        var i = 0\n    \
    \    while (i < guessesCount) {\n            val guess = guesses(i)\n        \
    \    val score = scores(i)\n            val difference = abs(guess - score)\n\
    \            if (difference < score) {\n                result.clear()\n     \
    \           result.add(difference)\n            } else {\n                result.add(0)\n\
    \            }\n            i += 1\n        }\n        result.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp83cf57gp.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n   \
    \     val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n\
    \        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores\
    \ = gameScoreList.zip(guessesScoreList).map { case (gameScore, guessesScore) =>\
    \ Math.abs(gameScore - guessesScore) }\n        gameScores\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2aa4t3zx.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mgameScores\e[0m = gameScoreList.zip(guessesScoreList).map\
    \ { \e[33mcase\e[0m (gameScore, guessesScore) => Math.abs(gameScore - guessesScore)\
    \ }\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- Error: /tmp/tmp2aa4t3zx.scala:15:43\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m15 |\e[0m       \
    \ \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\e[31m\e[31m   |\e\
    [0m                                           ^\e[0m\n\e[31m   |\e[0m        \
    \                               Cannot prove that Long <:< (K, V)\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m                                       where:    K is a type\
    \ variable\n\e[31m   |\e[0m                                                 V\
    \ is a type variable\n\e[31m   |\e[0m                                       .\n\
    \e[31m\e[31m-- Error: /tmp/tmp2aa4t3zx.scala:16:49 -----------------------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreMap\e[0m = guessesScores.toMap\n\
    \e[31m\e[31m   |\e[0m                                                 ^\e[0m\n\
    \e[31m   |\e[0m                                       Cannot prove that Long <:<\
    \ (K, V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                   \
    \    where:    K is a type variable\n\e[31m   |\e[0m                         \
    \                        V is a type variable\n\e[31m   |\e[0m               \
    \                        .\n3 errors found\n"
  stdout: ''
  timestamp: 1660013793
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val result = new mutable.ArrayList[Long]()\n        val guessesWithScore\
    \ = scores.map(x => (x, game(x)))\n        val guessesWithScoreSortedByScore =\
    \ guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByScore.map(x\
    \ => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2\
    \ > 0)\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpv_dj0s_j.scala:35:11 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpv_dj0s_j.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.filter(_._2 > \e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv_dj0s_j.scala:20:12 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.filter(_._2 > \e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpv_dj0s_j.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mguessesWithScoreSortedByGuess\e\
    [0m = guessesWithScoreSortedByGuess.filter(_._2 > \e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreSortedByGuess is already defined as \e[33mvalue\e\
    [0m \e[35mguessesWithScoreSortedByGuess\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m"
  stdout: ''
  timestamp: 1660013794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val gameScoreMap = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val guessScoreMap = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \        val gameScoreList: List[Long] = gameScoreMap.map(_._2).flatten.toList\n\
    \        val guessScoreList: List[Long] = guessScoreMap.map(_._2).flatten.toList\n\
    \        val gameScoreDiff = gameScoreList.zip(guessScoreList).map{case (gameScore,\
    \ guessScore) => Math.abs(gameScore - guessScore)}\n        gameScoreDiff.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpatsgys6z.scala:15:48 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\
    \e[31m\e[31m   |\e[0m                                              ^^^^\e[0m\n\
    \e[31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpatsgys6z.scala:15:70\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mgameScoreMap\e[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \    ^^^^\e[0m\n\e[31m   |\e[0m                                        value _2\
    \ is not a member of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpatsgys6z.scala:16:50\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mguessScoreMap\e[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\e\
    [31m\e[31m   |\e[0m                                                ^^^^\e[0m\n\
    \e[31m   |\e[0m                                        value _1 is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpatsgys6z.scala:16:72\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mguessScoreMap\e[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\e\
    [31m\e[31m   |\e[0m                                                          \
    \            ^^^^\e[0m\n\e[31m   |\e[0m                                      \
    \  value _2 is not a member of Long\n4 errors found\n"
  stdout: ''
  timestamp: 1660013795
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map {\
    \ case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map\
    \ { case (guess, index) => guess }\n        val diffs : List[Long] = guesses.zip(scores).map\
    \ { case (guess, score) =>\n            val diff = guess - score\n           \
    \ if (diff < 0) diff else diff\n        }\n        diffs\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplhtue0ke.scala:22)\n\tat Problem.main(tmplhtue0ke.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val results = new mutable.ArrayList[Long]()\n        val guessesWithScore\
    \ = guess.zip(game)\n        val scoresWithGuesses = scores.zip(guesses)\n   \
    \     guessesWithScore.foreach { case (guess, score) =>\n            if (score\
    \ == guess) {\n                results.add(0)\n            } else {\n        \
    \        val difference = guess - score\n                results.add(difference)\n\
    \            }\n        }\n        results.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4spmmyh9.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresults\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013790
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreCount = gameScores.count\n        val\
    \ guessScoreCount = guessScores.count\n        val gameScoreDiff = gameScoreCount\
    \ - guessScoreCount\n        val guessScoreDiff = guessScoreCount - gameScoreCount\n\
    \        val gameScoreDiffs = gameScores.zip(guessScores).map { case (gameScore,\
    \ guessScore) =>\n            val gameScoreDiff = gameScore - guessScore\n   \
    \         if (gameScoreDiff < 0)\n                gameScoreDiff\n            else\n\
    \                gameScoreDiff + gameScoreDiff\n        }\n        val guessScoreDiffs\
    \ = guessScores.zip(gameScores).map { case (guessScore, gameScore) =>\n      \
    \      val guessScoreDiff = guessScore - gameScore\n            if (guessScoreDiff\
    \ < 0)\n                guessScoreDiff\n            else\n                guessScoreDiff\
    \ + guessScoreDiff\n        }\n        gameScoreDiffs.zip(guessScoreDiffs).map\
    \ { case (gameScoreDiff, guessScoreDiff) =>\n            if (gameScoreDiff < 0)\n\
    \                guessScoreDiff\n            else\n                gameScoreDiff\
    \ + guessScoreDiff\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpj30v_0sn.scala:17:43 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mgameScoreDiff\e[0m = gameScoreCount\
    \ - guessScoreCount\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of (Long => Boolean) => Int, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpj30v_0sn.scala:18:45 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mguessScoreDiff\e[0m = guessScoreCount\
    \ - gameScoreCount\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue - is not a member of (Long => Boolean) => Int, but could\
    \ be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne\
    \ of the following imports might make progress towards fixing the problem:\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660013796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map {\
    \ case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map\
    \ { case (guess, index) => guess }\n        val guessesWithScores : List[(Long,\
    \ Long)] = guesses.zipWithIndex.map { case (guess, index) => (guess, scores(index))\
    \ }\n        val guessesWithScoreAndIndex : List[(Long, Long, Int)] = guessesWithScores.zipWithIndex.map\
    \ { case (guess, score, index) => (guess, score, index) }\n        val guessesWithScoreAndIndexAndGuessed\
    \ : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed\
    \ : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed\
    \ : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed\
    \ : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed\
    \ : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed\
    \ : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed\
    \ : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed\
    \ : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1dm6oec0.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1dm6oec0.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreAndIndexAndGuessed\e[0m : \e[35mSet\e[0m[\e[35mLong\e\
    [0m] = guessesWithScoreAndIndex.map { \e[33mcase\e[0m (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreAndIndexAndGuessed is already defined as \e\
    [33mvalue\e[0m \e[35mguessesWithScoreAndIndexAndGuessed\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1dm6oec0.scala:19:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreAndIndexAndGuessed\e[0m : \e[35mSet\e[0m[\e[35mLong\e\
    [0m] = guessesWithScoreAndIndex.map { \e[33mcase\e[0m (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSet\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesWithScoreAndIndexAndGuessed is already defined as \e\
    [33mvalue\e[0m \e[35mguessesWithScoreAndIndexAndGuessed\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1dm6oec0.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoreAndIndexAndGuessed\e[0m : \e[35mSet\e[0m[\e[35mLong\e\
    [0m] = guessesWithScoreAndIndex.map { \e[33mcase\e[0m (guess, score, index, guessed)\
    \ => (guess, score, index, guessed) }.toSe"
  stdout: ''
  timestamp: 1660013796
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreSet = gameScores.toSet\n        val\
    \ guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreSetMap =\
    \ gameScores.toMap.toSet\n        val guessScoreSetMap = guessScores.toMap.toSet\n\
    \        val gameScoreSetSetMap = gameScores.toMap.toSet.toSet\n        val guessScoreSetSetMap\
    \ = guessScores.toMap.toSet.toSet\n        val gameScoreSetListMap = gameScores.toMap.toSet.toList\n\
    \        val guessScoreSetListMap = guessScores.toMap.toSet.toList\n        val\
    \ gameScoreSetMapMap = gameScores.toMap.toSet.toMap\n        val guessScoreSetMapMap\
    \ = guessScores.toMap.toSet.toMap\n        val gameScoreSetSetMapMap = gameScores.toMap.toSet.toMap.toMap\n\
    \        val guessScoreSetSetMapMap = guessScores.toMap.toSet.toMap.toMap\n  \
    \      val gameScoreSetListMapMap = gameScores.toMap.toSet.toList.toMap\n    \
    \    val guessScoreSetListMapMap = guessScores.toMap.toSet.toList.toMap\n    \
    \    val gameScoreSetMapMapMap = gameScores.toMap.toSet.toMap.toMap\n        val\
    \ guessScoreSetMapMapMap = guessScores.toMap.toSet.toMap.toMap\n        val gameScoreSetSetMapMapMap\
    \ = gameScores.toMap.toSet.toMap.toMap.toMap\n        val guessScoreSetSetMapMapMap\
    \ = guessScores.toMap.toSet.toMap.toMap.toMap\n        val gameScoreSetListMapMap\
    \ = gameScores.toMap.toSet.toList.toMap.toMap\n        val guessScoreSetListMapMap\
    \ = guessScores.toMap.toSet.toList.toMap.toMap\n        val gameScoreSetMapMapMapMap\
    \ = gameScores.toMap.toSet.toMap.toMap.toMap\n        val guessScoreSetMapMapMapMap\
    \ = guessScores.toMap.toSet.toMap.toMap.toMap\n        val gameScoreSetSetMapMapMapMap\
    \ = gameScores.toMap.toSet\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmphahv2j41.scala:37:12 ---------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSetListMapMap\e\
    [0m = gameScores.toMap.toSet.toList.toMap.toMap\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mgameScoreSetListMapMap is already defined as \e[33mvalue\e[0m \e\
    [35mgameScoreSetListMapMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphahv2j41.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mguessScoreSetListMapMap\e\
    [0m = guessScores.toMap.toSet.toList.toMap.toMap\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreSetListMapMap is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreSetListMapMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- Error: /tmp/tmphahv2j41.scala:19:43 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m                                           ^\e[0m\n\e[31m\
    \   |\e[0m                                       Cannot prove that Long <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       where:\
    \    K is a type variable\n\e[31m   |\e[0m                                   \
    \              V is a type variable\n\e[31m   |\e[0m                         \
    \              .\n\e[31m\e[31m-- Error: /tmp/tmphahv2j41.scala:20:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m                                             ^\e[0m\n\e[31m\
    \   |\e[0m                                       Cannot prove that Long <:< (K,\
    \ V)\n\e[31m   |\e[0m\n\e[31m   |\e[0m                                       where:\
    \    K is a t"
  stdout: ''
  timestamp: 1660013797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}\n        val guessScores = guess.zipWithIndex.map{case (score,\
    \ index) => score}\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet\
    \ = guessScores.toSet\n        val gameScoreList = gameScores.toList\n       \
    \ val guessScoreList = guessScores.toList\n        val gameScoreSetList = gameScores.toList\n\
    \        val guessScoreSetList = guessScores.toList\n        val gameScoreSetSet\
    \ = gameScores.toSet.toSet\n        val guessScoreSetSet = guessScores.toSet.toSet\n\
    \        val gameScoreSetList = gameScores.toList.toList\n        val guessScoreSetList\
    \ = guessScores.toList.toList\n        val gameScoreSetSetList = gameScores.toSet.toList.toList\n\
    \        val guessScoreSetSetList = guessScores.toSet.toList.toList\n        val\
    \ gameScoreSetSetSet = gameScores.toSet.toSet.toSet\n        val guessScoreSetSetSet\
    \ = guessScores.toSet.toSet.toSet\n        val gameScoreSetSetList = gameScores.toSet.toList.toList\n\
    \        val guessScoreSetSetList = guessScores.toSet.toList.toList\n        val\
    \ gameScoreSetSetSet = gameScores.toSet.toSet.toSet\n        val guessScoreSetSetSet\
    \ = guessScores.toSet.toSet.toSet\n        val gameScoreSetSetSetList = gameScores.toSet.toList.toList.toList\n\
    \        val guessScoreSetSetSetList = guessScores.toSet.toList.toList.toList\n\
    \        val gameScoreSetSetSetSet = gameScores.toSet.toSet.toSet.toSet\n    \
    \    val guessScoreSetSetSetSet = guessScores.toSet.toSet.toSet.toSet\n      \
    \  val gameScoreSetSetSetSetList = gameScores.toSet.toSet.toList.toList.toList\n\
    \        val guessScoreSetSetSetSetList = guessScores.toSet.toSet.toList.toList.toList\n\
    \        val gameScoreSetSetSetSetSet = gameScores.toSet.toSet.toSet.toSet.toSet\n\
    \        val guessScoreSetSetSetSetSet = guessScores.toSet.toSet.toSet.toSet.toSet\n\
    \        val gameScoreSetSetSetSetSetList = gameScores.toSet.toSet.toList.toList.toList.toList\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSetList\e[0m =\
    \ gameScores.toList.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreSetList is already defined as \e[33mvalue\e[0m \e\
    [35mgameScoreSetList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreSetList\e[0m =\
    \ guessScores.toList.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreSetList is already defined as \e[33mvalue\e[0m \e\
    [35mguessScoreSetList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSetSetList\e[0m\
    \ = gameScores.toSet.toList.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreSetSetList is already defined as \e[33mvalue\e[0m\
    \ \e[35mgameScoreSetSetList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mguessScoreSetSetList\e[0m\
    \ = guessScores.toSet.toList.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreSetSetList is already defined as \e[33mvalue\e[0m\
    \ \e[35mguessScoreSetSetList\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:31:12 -------------------------"
  stdout: ''
  timestamp: 1660013794
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val gameScoreDiff = gameScore - guessScore\n    \
    \    val gameScoreDiffs = gameScoreDiff.zipWithIndex.map { case (score, index)\
    \ => score }\n        val gameScoreDiffsSorted = gameScoreDiffs.sortWith(_ < _)\n\
    \        val gameScoreDiffsSortedIndex = gameScoreDiffsSorted.zipWithIndex.map\
    \ { case (score, index) => index }\n        val gameScoreDiffsSortedIndexReversed\
    \ = gameScoreDiffsSortedIndex.zipWithIndex.map { case (index, score) => score\
    \ }\n        val gameScoreDiffsSortedIndexReversedSorted = gameScoreDiffsSortedIndexReversed.sortWith(_\
    \ < _)\n        val gameScoreDiffsSortedIndexReversedSortedIndex = gameScoreDiffsSortedIndexReversedSorted.zipWithIndex.map\
    \ { case (score, index) => index }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversed\
    \ = gameScoreDiffsSortedIndexReversedSortedIndex.zipWithIndex.map { case (index,\
    \ score) => score }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversedSorted\
    \ = gameScoreDiffsSortedIndexReversedSortedIndexReversed.sortWith(_ < _)\n   \
    \     val gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex.zipWithIndex.map\
    \ { case (score, index) => index }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed\
    \ = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed.zipWithIndex.map\
    \ { case (index, score) => score }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversedSorted\
    \ = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversedSorted.zipWithIndex.map\
    \ { case (score, index) => index }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversedSortedIndex\
    \ = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversedSortedIndex.zipWithIndex.map\
    \ { case (score, index) => index }\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpiyxmj2cg.scala:30:11 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpiyxmj2cg.scala:18:43 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mgameScoreDiffs\e[0m = gameScoreDiff.zipWithIndex.map\
    \ { \e[33mcase\e[0m (score, index) => score }\n\e[31m\e[31m   |\e[0m         \
    \                    ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                     value zipWithIndex is not a member of Long\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpiyxmj2cg.scala:26:78 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mgameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex\e\
    [0m = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex.zipWithIndex.map\
    \ { \e[33mcase\e[0m (score, index) => index }\n\e[31m\e[31m   |\e[0m         \
    \                                                                     ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mgameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpiyxmj2cg.scala:27:86\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed\e\
    [0m = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed.zipWithIndex.map\
    \ { \e[33mcase\e[0m (index, score) => score }\n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \ ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mgameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tm"
  stdout: ''
  timestamp: 1660013797
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        guessesDiff.zipWithIndex.map\
    \ { case (diff, index) => diff }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013780
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70\
    \ --------------------\e[0m\e[0m\n\e[31m12 |\e[0m    \e[33mdef\e[0m \e[36mcompare\e\
    [0m(\e[36mgame\e[0m : \e[35mList\e[0m[\e[35mLong\e[0m], \e[36mguess\e[0m : \e\
    [35mList\e[0m[\e[35mLong\e[0m]) : \e[35mList\e[0m[\e[35mLong\e[0m] = {\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \      ^\e[0m\n\e[31m   |\e[0m                                               \
    \     Found:    Unit\n\e[31m   |\e[0m                                        \
    \            Required: List[Long]\n\e[31m13 |\e[0m        \e[34m// Your code here\e\
    [0m\n\e[31m14 |\e[0m    }\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013718
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val results = new mutable.ArrayList[Long](guessesCount)\n        val\
    \ guessesRemaining = guessesCount - 1\n        val scoresRemaining = scoresCount\
    \ - 1\n        val guessesRemainingCount = guessesRemaining\n        val scoresRemainingCount\
    \ = scoresRemaining\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n\
    \        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n\
    \        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n\
    \        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n\
    \        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n\
    \        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n\
    \        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n\
    \        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n\
    \        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n\
    \        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n\
    \        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n\
    \        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n\
    \        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n\
    \        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n\
    \        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n\
    \        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n\
    \        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n\
    \        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n\
    \        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n\
    \        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n\
    \        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n\
    \        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n\
    \        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n\
    \        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n\
    \        var l = 0\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:48:12 ---------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m        \e[33mvar\e[0m \e[36mi\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mi is already defined\
    \ as \e[33mvariable\e[0m \e[35mi\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:49:12 ---------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m        \e[33mvar\e[0m \e[36mj\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mj is already defined\
    \ as \e[33mvariable\e[0m \e[35mj\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:50:12 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m        \e[33mvar\e[0m \e[36mk\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mk is already defined\
    \ as \e[33mvariable\e[0m \e[35mk\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:51:12 ---------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m        \e[33mvar\e[0m \e[36ml\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0ml is already defined\
    \ as \e[33mvariable\e[0m \e[35ml\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:52:12 ---------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m        \e[33mvar\e[0m \e[36mm\e[0m = \e[31m0\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^\e[0m\n\e[31m   |\e[0mm is already defined\
    \ as \e[33mvariable\e[0m \e[35mm\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:53:12 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mvar\e[0m \e[36mn\e[0m"
  stdout: ''
  timestamp: 1660013796
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, score) => (guess - score) }\n        guessesDiff.filter(x =>\
    \ x < 0).map(x => math.abs(x))\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpads6c7qg.scala:19)\n\tat Problem.main(tmpads6c7qg.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new Array[Long](guessesCount)\n        var i = 0\n     \
    \   while (i < guessesCount) {\n            val guess = guesses(i)\n         \
    \   val score = scores(i)\n            val difference = abs(guess - score)\n \
    \           result(i) = difference\n            i += 1\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptkvd4wtv.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013717
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score -> index }.toMap\n        val guessScores = guess.zipWithIndex.map\
    \ { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map\
    \ { case (score, index) => score }.toList\n        val guessScore = guessScores.map\
    \ { case (score, index) => score }.toList\n        val gameScoreDiff = gameScore\
    \ diff guessScore\n        val gameScoreDiffList = gameScoreDiff.map { case (score,\
    \ index) => score -> index }.toMap\n        val gameScoreDiffListSorted = gameScoreDiffList.sortBy(_._1)\n\
    \        val gameScoreDiffListSortedReversed = gameScoreDiffListSorted.reverse\n\
    \        val gameScoreDiffListSortedReversedList = gameScoreDiffListSortedReversed.map\
    \ { case (score, index) => index -> score }.toList\n        val gameScoreDiffListSortedReversedListSorted\
    \ = gameScoreDiffListSortedReversedList.sortBy(_._1)\n        val gameScoreDiffListSortedReversedListSortedReversed\
    \ = gameScoreDiffListSortedReversedListSorted.reverse\n        val gameScoreDiffListSortedReversedListSortedReversedList\
    \ = gameScoreDiffListSortedReversedListSortedReversed.map { case (score, index)\
    \ => index -> score }.toList\n        val gameScoreDiffListSortedReversedListSortedReversedListSorted\
    \ = gameScoreDiffListSortedReversedListSortedReversedListSorted.sortBy(_._1)\n\
    \        val gameScoreDiffListSortedReversedListSortedReversedListSortedReversed\
    \ = gameScoreDiffListSortedReversedListSortedReversedListSortedReversed.map {\
    \ case (score, index) => index -> score }.toList\n        val gameScoreDiffListSortedReversedListSortedReversedListSortedReversedList\
    \ = gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSorted.reverse\n\
    \        val gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSorted\
    \ = gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSortedReversed.map\
    \ { case (score, index) => index -> score }.toList\n        val gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSortedReversed\
    \ = gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSortedReversedListSorted.reverse\n\
    \        val gameScoreDiffListSortedReversedListSortedReversed\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpuk9qhajo.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpuk9qhajo.scala:19:56\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e\
    [36mgameScoreDiffListSorted\e[0m = gameScoreDiffList.sortBy(_._1)\n\e[31m\e[31m\
    \   |\e[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           value sortBy is not a member of Map[Any,\
    \ Any]\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuk9qhajo.scala:25:74 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreDiffListSortedReversedListSortedReversedListSorted\e\
    [0m = gameScoreDiffListSortedReversedListSortedReversedListSorted.sortBy(_._1)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mgameScoreDiffListSortedReversedListSortedReversedListSorted\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpuk9qhajo.scala:26:82\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreDiffListSortedReversedListSortedReversedListSortedReversed\e\
    [0m = gameScoreDiffListSortedReversedListSortedReversedListSortedReversed.map\
    \ { \e[33mcase\e[0m (score, index) => index -> score }.toList\n\e[31m\e[31m  \
    \ |\e[0m                                                                     \
    \             ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mgameScoreDiffListSortedReversedListSortedReversedListSortedReversed\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuk9qhajo.scala:29:100\
    \ -----------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e\
    [36mgameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSortedReversed\e\
    [0m = gameScoreDiffL"
  stdout: ''
  timestamp: 1660013800
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n        val gameScores = game.map(x\
    \ => if (x == 0) 0 else x)\n        val guessesScores = guess.map(x => if (x ==\
    \ 0) 0 else x)\n        val diffs = guessesScores.zip(gameScores).map(x => if\
    \ (x._1 == x._2) 0 else x._1 - x._2)\n        diffs\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnxikx8o2.scala:20)\n\tat Problem.main(tmpnxikx8o2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013800
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScoreList is already defined as \e[33mvalue\e[0m \e[35mguessScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSet\e[0m = gameScores.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScore = gameScores.sum\n        val guessScore\
    \ = guessScores.sum\n        val gameScoreDiff = gameScore - guessScore\n    \
    \    val gameScoreDiffs = gameScoreDiff.zipWithIndex.map { case (diff, index)\
    \ => diff }\n        val gameScoreDiffsSum = gameScoreDiffs.sum\n        val gameScoreDiffsSumAbs\
    \ = gameScoreDiffsSum.abs\n        val guessScoreDiff = guessScore - gameScore\n\
    \        val guessScoreDiffs = guessScoreDiff.zipWithIndex.map { case (diff, index)\
    \ => diff }\n        val guessScoreDiffsSum = guessScoreDiffs.sum\n        val\
    \ guessScoreDiffsSumAbs = guessScoreDiffsSum.abs\n        val gameScoreDiffsSumAbsDiffs\
    \ = gameScoreDiffsSumAbs.zipWithIndex.map { case (diff, index) => diff }\n   \
    \     val gameScoreDiffsSumAbsDiffsSum = gameScoreDiffsSumAbsDiffs.sum\n     \
    \   val gameScoreDiffsSumAbsDiffsSumAbs = gameScoreDiffsSumAbsDiffsSum.abs\n \
    \       val guessScoreDiffsSumAbsDiff = guessScoreDiffsSumAbs - gameScoreDiff\n\
    \        val guessScoreDiffsSumAbsDiffs = guessScoreDiffsSumAbsDiff.zipWithIndex.map\
    \ { case (diff, index) => diff }\n        val guessScoreDiffsSumAbsDiffsSum =\
    \ guessScoreDiffsSumAbsDiffsSum.sum\n        val guessScoreDiffsSumAbsDiffsSumAbs\
    \ = guessScoreDiffsSumAbsDiffsSum.abs\n        val gameScoreDiffsSumAbsDiffsSumAbsDiffs\
    \ = gameScoreDiffsSumAbsDiffsSumAbs.zipWithIndex.map { case (diff, index) => diff\
    \ }\n        val gameScoreDiffsSumAbsDiffsSumAbsDiffsSum = gameScoreDiffsSumAbsDiffsSumAbsDiffs.sum\n\
    \        val gameScoreDiffsSumAbsDiffsSumAbsDiffsSumAbs = gameScoreDiffsSumAbsDiffsSumAbsDiffsSum.abs\n\
    \        val guessScoreDiffsSum\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpujqqhadx.scala:36:4 ----------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpujqqhadx.scala:18:43\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mgameScoreDiffs\e[0m = gameScoreDiff.zipWithIndex.map { \e[33mcase\e[0m (diff,\
    \ index) => diff }\n\e[31m\e[31m   |\e[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                             value zipWithIndex is not a member\
    \ of Long\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpujqqhadx.scala:22:45\
    \ ------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36mguessScoreDiffs\e[0m = guessScoreDiff.zipWithIndex.map { \e[33mcase\e[0m (diff,\
    \ index) => diff }\n\e[31m\e[31m   |\e[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              value zipWithIndex is not a\
    \ member of Long\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpujqqhadx.scala:30:44\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessScoreDiffsSumAbsDiffsSum\e[0m = guessScoreDiffsSumAbsDiffsSum.sum\n\
    \e[31m\e[31m   |\e[0m                                            ^\e[0m\n\e[31m\
    \   |\e[0m                Recursive \e[33mvalue\e[0m \e[35mguessScoreDiffsSumAbsDiffsSum\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpujqqhadx.scala:36:5\
    \ ---------------------\e[0m\e[0m\n\e[31m36 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660013801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val results = new mutable.ArrayBuffer[Long]()\n        for(score <- scores)\
    \ {\n            val guess = guesses.find(_ == score)\n            if (guess ==\
    \ None) results += score\n            else results += abs(guess - score)\n   \
    \     }\n        results\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6xpc28ql.scala:15:26 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresults\e[0m = \e[33mnew\e\
    [0m mutable.ArrayBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m            \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                          Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013797
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val result = new mutable.ArrayList[Long](guessesCount)\n        var i\
    \ = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n\
    \            val score = scores(i)\n            val difference = abs(guess - score)\n\
    \            if (difference == 0) {\n                result(i) = difference\n\
    \            } else {\n                result(i) = difference\n            }\n\
    \            i += 1\n        }\n        result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong,\
    \ 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph39fl_9r.scala:17:25 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ArrayList[\e[35mLong\e[0m](guessesCount)\n\e[31m\e[31m   |\e[0m  \
    \                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013799
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesCount = guesses.size\n        val scoresCount = scores.size\n\
    \        val diffs = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n    \
    \    while (i < guessesCount) {\n            val guess = guesses(i)\n        \
    \    val score = scores(i)\n            val diff = Math.abs(guess - score)\n \
    \           diffs += diff\n            i += 1\n        }\n        diffs\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4ltt6oqz.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mdiffs\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013800
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val gameScore = gameScores.sum\n        val\
    \ guessesScore = guessesScores.sum\n        val diffs = guessesScores.zip(gameScores).map\
    \ { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n\
    \        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach\
    \ { case (score, index) => gameScoreList.add(score) }\n        guessScoreMap.foreach\
    \ { case (score, index) => guessScoreList.add(score) }\n        val gameScores\
    \ = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n  \
    \      val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n\
    \        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList\
    \ = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach { case (score,\
    \ index) => gameScoreList.add(score) }\n        guessScoreMap.foreach { case (score,\
    \ index) => guessScoreList.add(score) }\n        val gameScores = gameScoreList.toList\n\
    \        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new\
    \ mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n\
    \        gameScoreMap.foreach { case (score, index) => gameScoreList.add(score)\
    \ }\n        guessScoreMap.foreach { case (score, index) => guessScoreList.add(score)\
    \ }\n        val gameScores = gameScoreList.toList\n        val guessScores =\
    \ guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n       \
    \ val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n\
    \        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach\
    \ { case (score, index) => gameScoreList.add(score) }\n        guessScoreMap.foreach\
    \ { case (score, index) => guessScoreList.add(score) }\n        val gameScores\
    \ = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n  \
    \      val gameScoreMap = gameScores.toMap\n        val guessScore\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3nfl9a5z.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3nfl9a5z.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScores\e[0m = gameScoreList.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3nfl9a5z.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScores\e[0m = guessScoreList.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScores is already defined as \e[33mvalue\e[0m \e[35mguessScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3nfl9a5z.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3nfl9a5z.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3nfl9a5z.scala:25:12 ----------"
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessesScores = guess.zipWithIndex.map { case\
    \ (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map\
    \ { case (guess, score) => (guess - score) }\n        guessesDiff.map { case (guess,\
    \ score) => (guess - score) }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_50qp5r_.scala:16:56 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        guessesDiff.map { \e[33mcase\e[0m (guess, score)\
    \ => (guess - score) }\n\e[31m\e[31m   |\e[0m                                \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0mvalue - is not a member of Any,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n1 error found\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScoreList is already defined as \e[33mvalue\e[0m \e[35mguessScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSet\e[0m = gameScores.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        // Your code here\n        val gameScores = game.zipWithIndex.map{\
    \ case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map{\
    \ case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList\
    \ = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n\
    \        val gameScoreSet = gameScoreList.distinct\n        val guessesScoreSet\
    \ = guessesScoreList.distinct\n        val gameScoreMap = gameScoreSet.zip(gameScoreList).map{\
    \ case (score, index) => index -> score }.toMap\n        val guessesScoreMap =\
    \ guessesScoreSet.zip(guessesScoreList).map{ case (score, index) => index -> score\
    \ }.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val\
    \ guessesScoreList = guessesScoreMap.values.toList\n        val gameScoreSet =\
    \ gameScoreList.distinct\n        val guessesScoreSet = guessesScoreList.distinct\n\
    \        val gameScoreMap = gameScoreSet.zip(gameScoreList).map{ case (score,\
    \ index) => index -> score }.toMap\n        val guessesScoreMap = guessesScoreSet.zip(guessesScoreList).map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScoreMap.values.toList\n\
    \        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScoreSet\
    \ = gameScoreList.distinct\n        val guessesScoreSet = guessesScoreList.distinct\n\
    \        val gameScoreMap = gameScoreSet.zip(gameScoreList).map{ case (score,\
    \ index) => index -> score }.toMap\n        val guessesScoreMap = guessesScoreSet.zip(guessesScoreList).map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScoreMap.values.toList\n\
    \        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScoreSet\
    \ = gameScoreList.distinct\n        val guessesScoreSet = guessesScoreList.distinct\n\
    \        val gameScoreMap = gameScoreSet.zip(gameScoreList).map{ case (score,\
    \ index) => index -> score }.toMap\n        val guessesScoreMap = guessesScoreSet.zip(guessesScoreList).map{\
    \ case (score, index) => index -> score }.toMap\n        val gameScoreList = \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphkbytu0_.scala:42:27 ---------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmphkbytu0_.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScoreSet.zip(gameScoreList).map{\
    \ \e[33mcase\e[0m (score, index) => index -> score }.toMap\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphkbytu0_.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mguessesScoreMap\e[0m = guessesScoreSet.zip(guessesScoreList).map{\
    \ \e[33mcase\e[0m (score, index) => index -> score }.toMap\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessesScoreMap is already defined as \e[33mvalue\e[0m \e\
    [35mguessesScoreMap\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphkbytu0_.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScoreMap.values.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[3"
  stdout: ''
  timestamp: 1660013803
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val games = game.toSet\n\
    \        val result = game.zip(guess).map { case (game, guess) =>\n          \
    \  if (games.contains(guess))\n                0\n            else\n         \
    \       Math.abs(guess - game)\n        }\n        result.toList\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp07sztydo.scala:24)\n\tat Problem.main(tmp07sztydo.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n\
    \        val result = new mutable.ListBuffer[Long]()\n        for(score <- scores)\
    \ {\n            val guess = guesses.find(_ == score)\n            if(guess ==\
    \ None) result += score\n            else result += abs(guess - score)\n     \
    \   }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong,\
    \ 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong,\
    \ -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong,\
    \ 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwaztp0ph.scala:15:25 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660013801
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n\
    \        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues\
    \ = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n\
    \        val gameScoreKeysSet = gameScoreKeys.toSet\n        val guessScoreKeysSet\
    \ = guessScoreKeys.toSet\n        val gameScoreValuesSet = gameScoreValues.toSet\n\
    \        val guessScoreValuesSet = guessScoreValues.toSet\n        val gameScoreKeysSetSize\
    \ = gameScoreKeysSet.size\n        val guessScoreKeysSetSize = guessScoreKeysSet.size\n\
    \        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessScoreValuesSetSize\
    \ = guessScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n\
    \        val guessScoreKeysSetSize = guessScoreKeysSet.size\n        val gameScoreValuesSetSize\
    \ = gameScoreValuesSet.size\n        val guessScoreValuesSetSize = guessScoreValuesSet.size\n\
    \        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessScoreKeysSetSize\
    \ = guessScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n\
    \        val guessScoreValuesSetSize = guessScoreValuesSet.size\n        val gameScoreKeysSetSize\
    \ = gameScoreKeysSet.size\n        val guessScoreKeysSetSize = guessScoreKeysSet.size\n\
    \        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessScoreValuesSetSize\
    \ = guessScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n\
    \        val guessScoreKeysSetSize = guessScoreKeysSet.size\n        val gameScoreValuesSetSize\
    \ = gameScoreValuesSet.size\n        val guessScoreValuesSetSize = guessScoreValuesSet.size\n\
    \        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessScoreKeysSetSize\
    \ = guessScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n\
    \        val guessScoreValuesSetSize = guessScoreValuesSet.size\n        val gameScoreKey\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3pr7n19s.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3pr7n19s.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mgameScoreKeysSetSize\e[0m = gameScoreKeysSet.size\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mgameScoreKeysSetSize is already defined as \e[33mvalue\e[0m \e[35mgameScoreKeysSetSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp3pr7n19s.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mguessScoreKeysSetSize\e[0m = guessScoreKeysSet.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreKeysSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreKeysSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3pr7n19s.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mgameScoreValuesSetSize\e\
    [0m = gameScoreValuesSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScoreValuesSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mgameScoreValuesSetSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp3pr7n19s.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mguessScoreValuesSetSize\e\
    [0m = guessScoreValuesSet.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScoreValuesSetSize is already defined as \e[33mvalue\e\
    [0m \e[35mguessScoreValuesSetSize\e[0m"
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n\
    \        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSortedByScore\
    \ = guessesWithScores.sortBy(_._2)\n        val guessesWithScoresSortedByGuess\
    \ = guessesWithScoresSortedByScore.map(x => x._1)\n        val guessesWithScoresSortedByGuessWithScores\
    \ = guessesWithScoresSortedByGuess.zip(scores)\n        val guessesWithScoresSortedByGuessWithScoresSortedByScore\
    \ = guessesWithScoresSortedByGuessWithScores.sortBy(_._2)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuess\
    \ = guessesWithScoresSortedByGuessWithScoresSortedByScore.map(x => x._1)\n   \
    \     val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScores = guessesWithScoresSortedByGuessWithScoresSortedByGuess.zip(scores)\n\
    \        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\
    \ = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(x\
    \ => x._1)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScores\
    \ = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuess.zip(scores)\n\
    \        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\
    \ = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(x\
    \ => x._1)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScores\
    \ = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(x\
    \ => x._1)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwbh_kfbf.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwbh_kfbf.scala:22:91\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\e\
    [0m = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(\e\
    [36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m                                   \
    \                                                        ^\e[0m\n\e[31m   |\e\
    [0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpwbh_kfbf.scala:23:101 -----------------------\e[0m\e[0m\n\e[31m23 |\e\
    [0m        \e[33mval\e[0m \e[36mguessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScores\e\
    [0m = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuess.zip(scores)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuess\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpwbh_kfbf.scala:24:114\
    \ --------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mguessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\e\
    [0m = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(\e\
    [36mx\e[0m => x._1)\n\e[31m\e[31m   |\e[0m                                   \
    \                                     "
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val guesses = guess.map(x => Math.abs(x - game))\n\
    \        val correct = game.zip(guesses).map { case (x, y) => if (x == y) 0 else\
    \ Math.abs(x - y) }\n        correct.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmp5erz9l6i.scala:13:48 -----------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mguesses\e[0m = guess.map(\e\
    [36mx\e[0m => Math.abs(x - game))\n\e[31m\e[31m   |\e[0m                     \
    \                         ^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((game : List[Long]))\n\e[31m\e[31m-- [E051] Reference\
    \ Error: /tmp/tmp5erz9l6i.scala:14:67 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36mcorrect\e[0m = game.zip(guesses).map { \e\
    [33mcase\e[0m (x, y) => \e[33mif\e[0m (x == y) \e[31m0\e[0m \e[33melse\e[0m Math.abs(x\
    \ - y) }\n\e[31m\e[31m   |\e[0m                                              \
    \                   ^^^^\e[0m\n\e[31m   |\e[0mAmbiguous overload. The overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m==\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Boolean\n\e[31m   |\e[0m (x: Float):\
    \ Boolean\n\e[31m   |\e[0m (x: Long): Boolean\n\e[31m   |\e[0m (x: Int): Boolean\n\
    \e[31m   |\e[0m (x: Char): Boolean\n\e[31m   |\e[0m (x: Short): Boolean\n\e[31m\
    \   |\e[0m (x: Byte): Boolean\n\e[31m   |\e[0m (x$0: Any): Boolean\n\e[31m   |\e\
    [0mall match arguments ((y : Nothing))\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E051]\
    \ Reference Error: /tmp/tmp5erz9l6i.scala:14:91 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mcorrect\e[0m = game.zip(guesses).map\
    \ { \e[33mcase\e[0m (x, y) => \e[33mif\e[0m (x == y) \e[31m0\e[0m \e[33melse\e\
    [0m Math.abs(x - y) }\n\e[31m\e[31m   |\e[0m                                 \
    \                                                        ^^^\e[0m\n\e[31m   |\e\
    [0mAmbiguous overload. The overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mLo"
  stdout: ''
  timestamp: 1660013803
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score,\
    \ index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score,\
    \ index) => score }\n        val gameScoreMap = gameScores.toMap\n        val\
    \ guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n\
    \        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n\
    \        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n\
    \        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong,\
    \ 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong,\
    \ 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36mgameScoreMap\e[0m = gameScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreMap is already defined as \e[33mvalue\e[0m \e[35mgameScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mguessScoreMap\e[0m = guessScores.toMap\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScoreMap is already defined as \e[33mvalue\e[0m \e[35mguessScoreMap\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:23:12 ---------------------------\e[0m\e[0m\n\e\
    [31m23 |\e[0m        \e[33mval\e[0m \e[36mgameScoreList\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mgameScoreList is already defined as \e[33mvalue\e[0m \e[35mgameScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36mguessScoreList\e[0m = guessScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mguessScoreList is already defined as \e[33mvalue\e[0m \e[35mguessScoreList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmps2vlxvc8.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mgameScoreSet\e[0m = gameScores.toSet\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0"
  stdout: ''
  timestamp: 1660013743
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // I think we all remember that feeling when the result of some long-awaited\n\
    \    // event is finally known. The feelings and thoughts you have at that moment\
    \ are\n    // definitely worth noting down and comparing.\n    // Your task is\
    \ to determine if a person correctly guessed the results of a number of matches.\n\
    \    // You are given two arrays of scores and guesses of equal length, where\
    \ each index shows a match. \n    // Return an array of the same length denoting\
    \ how far off each guess was. If they have guessed correctly,\n    // the value\
    \ is 0, and if not, the value is the absolute difference between the guess and\
    \ the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long])\
    \ : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score,\
    \ index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case\
    \ (score, index) => score}.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val guessScoreMap = guessScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val gameScores = gameScoreMap.map{case (score, index) => gameScoreMap.getOrElse(index,\
    \ score)}\n        val guessScores = guessScoreMap.map{case (score, index) =>\
    \ guessScoreMap.getOrElse(index, score)}\n        val gameScores = gameScores.toList\n\
    \        val guessScores = guessScores.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val guessScoreMap = guessScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val gameScores = gameScoreMap.map{case (score, index) => gameScoreMap.getOrElse(index,\
    \ score)}\n        val guessScores = guessScoreMap.map{case (score, index) =>\
    \ guessScoreMap.getOrElse(index, score)}\n        val gameScores = gameScores.toList\n\
    \        val guessScores = guessScores.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val guessScoreMap = guessScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val gameScores = gameScoreMap.map{case (score, index) => gameScoreMap.getOrElse(index,\
    \ score)}\n        val guessScores = guessScoreMap.map{case (score, index) =>\
    \ guessScoreMap.getOrElse(index, score)}\n        val gameScores = gameScores.toList\n\
    \        val guessScores = guessScores.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val guessScoreMap = guessScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n\
    \        val gameScores = gameScoreMap.map{case (score, index) => gameScoreMap.getOrElse(index,\
    \ score)}\n        val guessScores = guessScoreMap.map{case (score, index) =>\
    \ guessScoreMap.getOrElse(index, score)}\n        val gameScores = gameScores.to\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong,\
    \ 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong,\
    \ 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong,\
    \ 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong,\
    \ 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpabyebevl.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mgameScores\e[0m = gameScoreMap.map{\e\
    [33mcase\e[0m (score, index) => gameScoreMap.getOrElse(index, score)}\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpabyebevl.scala:18:12 ---------------------------\e[0m\e[0m\n\e\
    [31m18 |\e[0m        \e[33mval\e[0m \e[36mguessScores\e[0m = guessScoreMap.map{\e\
    [33mcase\e[0m (score, index) => guessScoreMap.getOrElse(index, score)}\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mguessScores is already defined as \e[33mvalue\e[0m \e[35mguessScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpabyebevl.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mgameScores\e[0m = gameScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mgameScores is already defined as \e[33mvalue\e[0m \e[35mgameScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpabyebevl.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mguessScores\e[0m = guessScores.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mguessScores is already defined as \e[33mvalue\e[0m \e[35mguessScores\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ E"
  stdout: ''
  timestamp: 1660013804
