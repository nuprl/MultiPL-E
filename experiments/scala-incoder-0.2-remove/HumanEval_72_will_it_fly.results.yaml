language: scala
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sum = 0L\n        q.foreach\
    \ { x => sum += x }\n        sum <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv80j3nxp.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        q.foreach { \e[36mx\e[0m => sum += x }\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      value += is not a member of Long - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxWeight = w.toLong\n        val maxSumOfElements\
    \ = w.toLong\n        val maxWeightOfElements = w.toLong\n        val maxSumOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElements = w.toLong\n        val\
    \ maxSumOfElementsOfElementsOfElements = w.toLong\n        val maxWeightOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxWeightOfElementsOfElementsOfElementsOfElements = w.toLong\n  \
    \      val maxSumOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElement\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp54fgpxb1.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp54fgpxb1.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val maxSumLessOrEqualToMaxWeight\
    \ = maxSum - maxWeight\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        val isBalanced = q.forall(x => x <= maxWeight && x >= 0)\n  \
    \      val isLessOrEqualToMaxWeight = q.forall(x => x <= maxWeight && x >= 0)\n\
    \        val isLessOrEqualToMaxSum = q.forall(x => x <= maxSumLessOrEqualToMaxWeight\
    \ && x >= 0)\n        val isLessOrEqualToMaxSumLessOrEqualToMaxWeight = q.forall(x\
    \ => x <= maxSumLessOrEqualToMaxWeight && x >= 0)\n        val isLessOrEqualToMaxSumLessOrEqualToMaxWeightAndBalanced\
    \ = q.forall(x => x <= maxSumLessOrEqualToMaxWeight && x >= 0 && isBalanced)\n\
    \        val isLessOrEqualToMaxSumLessOrEqualToMaxWeightAndBalancedAndPalindromic\
    \ = q.forall(x => x <= maxSumLessOrEqualToMaxWeight && x >= 0 && isBalanced &&\
    \ isPalindromic)\n        val isLessOrEqualToMaxSumLessOrEqualToMaxWeightAndBalancedAndPalindromicAndLessOrEqualToMaxSumLessOrEqualToMaxWeight\
    \ = q.forall(x => x <= maxSumLessOrEqualToMaxWeight && x >= 0 && isBalanced &&\
    \ isPalindromic && isLessOrEqualToMaxSumLessOrEqualToMaxWeight)\n        val isLessOrEqualToMaxSumLessOrEqualToMaxWeightAndBalancedAndPalindromicAndLessOrEqualToMaxSumLessOrEqualToMaxWeightAndBalanced\
    \ = q.forall(x => x <= maxSumLessOrEqualToMaxWeight && x >= 0 && isBalanced &&\
    \ isPalindromic && isLessOrEqualToMaxSumLessOrEqualToMaxWeightAndBalanced)\n \
    \       val isLessOrEqualToMaxSumLessOrEqualToMaxWeightAndBalancedAndPalindromicAndLessOrEqualToMaxSumLessOrEqualToMaxWeightAndBalancedAndPalindromic\
    \ = q.forall(x => x <= maxSumLessOrEqualToMaxWeight && x >= 0 && isBalanced &&\
    \ isPalindromic && isLessOrEqualToMaxSumLessOrEqualToMaxWeightAndBalancedAndPalindromic)\n\
    \        val isLessOrEqualToMaxSum\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp7owjjw9p.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp7owjjw9p.scala:26:5 ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        isPalindromic && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp98flqjmh.scala:19)\n\tat Problem.main(tmp98flqjmh.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010354
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced = maxSum < maxWeight\
    \ && maxSum == maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isPalindromic && !isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw2oyclqw.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpw2oyclqw.scala:26:5 ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxWeightSum = w.toLong * q.length\n        val maxWeightSumPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromic = w.toLong\
    \ * q.length\n        val maxWeightSumPalindromicPalindromicPalindromic = w.toLong\
    \ * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = w.toLong * q.length\n        val maxWeightSumPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp60tnvg15.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp60tnvg15.scala:27:5 ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q.head)\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThan\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpd8ud0a0z.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpd8ud0a0z.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxButNotBalancedAndPalindromic\e[0m = maxSum < maxWeight &&\
    \ !isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpd8ud0a0z.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndPalindromic\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpd8ud0a0z.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel "
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sum = 0L\n        q.foreach(x\
    \ => sum += x)\n        sum < maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpakbue5ni.scala:14:27 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        q.foreach(\e[36mx\e[0m => sum += x)\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \    value += is not a member of Long - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxWeight\n        val isPalindromic = q.reverse.forall(_ == q.head) && maxSumOfElements\
    \ == maxWeight\n        isBalanced && isPalindromic\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp96kusofe.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q.head)\n        val isBalanced =\
    \ maxSum == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n      \
    \  val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        val isLessThanMaxAndBalancedAndPalindromic\
    \ = isLessThanMaxAndBalanced && isPalindromic\n        isLessThanMaxAndBalancedAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt9jlrzic.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val sums = mutable.ListBuffer.empty[Long]\n\
    \        val palindromes = mutable.ListBuffer.empty[Long]\n        val maxPalindromes\
    \ = mutable.ListBuffer.empty[Long]\n        val maxWeight = mutable.ListBuffer.empty[Long]\n\
    \        q.foreach { x =>\n            sums += x\n            palindromes += x\n\
    \            if (sums.last < maxSum) {\n                maxSum = sums.last\n \
    \           }\n            if (palindromes.last < maxPalindromes.last) {\n   \
    \             maxPalindromes = palindromes.last\n            }\n            if\
    \ (maxWeight.last < x) {\n                maxWeight = maxWeight.last\n       \
    \     }\n        }\n        sums.last <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp67dph1dg.scala:13:19 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp67dph1dg.scala:14:26 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mpalindromes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp67dph1dg.scala:15:29 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxPalindromes\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                             ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                             Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp67dph1dg.scala:16:24 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mmaxWeight\e[0m = mutable.ListBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E052] Type Error: /tmp/tmp67dph1dg.scala:21:23 -----------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m                maxSum = sums.last\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val maxSum\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp67dph1dg.scala:24:31\
    \ -----------------------------\e[0m\e[0m\n\e[31m24 |\e[0m              "
  stdout: ''
  timestamp: 1660010345
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxWeightSum = w.toLong * q.length\n        val maxWeightSumOfQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n \
    \       val maxWeightSumOfQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n     \
    \   val maxWeightSumOfQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n     \
    \   val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n \
    \       val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ =\
    \ q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_iuhd7ns.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_iuhd7ns.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\e[0m = q.foldLeft(\e[31m0\e\
    [0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_iuhd7ns.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_iuhd7ns.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31"
  stdout: ''
  timestamp: 1660010356
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val maxSumLessOrEqualToMaxWeight\
    \ = maxSum - maxWeight\n        val maxSumLessOrEqualToMaxWeightPalindromic =\
    \ maxSumLessOrEqualToMaxWeight == q.reverse.sum\n        val isPalindromic = maxSumLessOrEqualToMaxWeightPalindromic\n\
    \        val isBalanced = isPalindromic && q.forall(x => x == q.reverse.head)\n\
    \        val isLessOrEqualToMaxWeight = maxSumLessOrEqualToMaxWeight <= maxWeight\n\
    \        val isLessOrEqualToMaxWeightPalindromic = isLessOrEqualToMaxWeight &&\
    \ isPalindromic\n        val isLessOrEqualToMaxWeightAndBalanced = isLessOrEqualToMaxWeight\
    \ && isBalanced\n        isLessOrEqualToMaxWeightAndBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2f9ff2i9.scala:24)\n\tat Problem.main(tmp2f9ff2i9.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfWeights = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfWeights\
    \ <= maxWeight\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        isBalanced && isPalindromic\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5lchscu6.scala:14:44\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfWeights\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                           ^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \                     Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.last\n\
    \        val maxWeightSum = maxSum - maxWeight\n        val maxWeightSumInt =\
    \ maxWeightSum.toInt\n        val maxWeightSumLong = maxWeightSum.toLong\n   \
    \     val maxWeightSumDouble = maxWeightSum.toDouble\n        val maxWeightSumFloat\
    \ = maxWeightSum.toFloat\n        val maxWeightSumInt = maxWeightSum.toInt\n \
    \       val maxWeightSumLong = maxWeightSum.toLong\n        val maxWeightSumDouble\
    \ = maxWeightSum.toDouble\n        val maxWeightSumFloat = maxWeightSum.toFloat\n\
    \        val maxWeightSumInt = maxWeightSum.toInt\n        val maxWeightSumLong\
    \ = maxWeightSum.toLong\n        val maxWeightSumDouble = maxWeightSum.toDouble\n\
    \        val maxWeightSumFloat = maxWeightSum.toFloat\n        val maxWeightSumInt\
    \ = maxWeightSum.toInt\n        val maxWeightSumLong = maxWeightSum.toLong\n \
    \       val maxWeightSumDouble = maxWeightSum.toDouble\n        val maxWeightSumFloat\
    \ = maxWeightSum.toFloat\n        val maxWeightSumInt = maxWeightSum.toInt\n \
    \       val maxWeightSumLong = maxWeightSum.toLong\n        val maxWeightSumDouble\
    \ = maxWeightSum.toDouble\n        val maxWeightSumFloat = maxWeightSum.toFloat\n\
    \        val maxWeightSumInt = maxWeightSum.toInt\n        val maxWeightSumLong\
    \ = maxWeightSum.toLong\n        val maxWeightSumDouble = maxWeightSum.toDouble\n\
    \        val maxWeightSumFloat = maxWeightSum.toFloat\n        val maxWeightSumInt\
    \ = maxWeightSum.toInt\n        val maxWeightSumLong = maxWeightSum.toLong\n \
    \       val maxWeightSumDouble = maxWeightSum.toDouble\n        val maxWeightSumFloat\
    \ = maxWeightSum.toFloat\n        val maxWeightSumInt = maxWeightSum.toInt\n \
    \       val maxWeightSumLong = maxWeightSum.toLong\n        val maxWeightSumDouble\
    \ = maxWeightSum.toDouble\n        val maxWeightSumFloat = maxWeightSum.toFloat\n\
    \        val maxWeightSumInt = maxWeightSum.toInt\n        val maxWeightSumLong\
    \ = maxWeightSum.toLong\n        val maxWeightSumDouble = maxWeightSum.toDouble\n\
    \        val maxWeightSumFloat = maxWeightSum.toFloat\n        val maxWeightSumInt\
    \ = max\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplu9gx_so.scala:19:12 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumInt\e[0m = maxWeightSum.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmaxWeightSumInt is already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplu9gx_so.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumLong\e[0m = maxWeightSum.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmaxWeightSumLong is already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumLong\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplu9gx_so.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumDouble\e[0m = maxWeightSum.toDouble\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumDouble is already defined as \e[33mvalue\e[0m\
    \ \e[35mmaxWeightSumDouble\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplu9gx_so.scala:22:12 ---------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumFloat\e[0m =\
    \ maxWeightSum.toFloat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumFloat is already defined as \e[33mvalue\e[0m \e\
    [35mmaxWeightSumFloat\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmplu9gx_so.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumInt\e[0m = maxWeightSum.toI"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sumOfElements = q.foldLeft(0)(_\
    \ + _)\n        sumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpku7kcy3a.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual = maxSumOfElements\
    \ <= w\n        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1p72pzl7.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualToMaxSumOfElements = maxSumOfElements <=\
    \ maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndIsBalanced =\
    \ isLessOrEqualToMaxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSumOfElementsAndIsBalanced && isLessOrEqualToMaxSumOfElementsAndIsPalindromic\n\
    \        isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppnhat5_r.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = isLessThanMax && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax\
    \ && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromic = isLessThanMaxAndBalanced\
    \ && isPalindromic\n        isLessThanMaxAndBalancedAndPalindromic\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp1t3fp6ze.scala:14:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == q)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val sumsReversed = sums.reverse\n        val isPalindromic = sumsReversed.forall(x\
    \ => x == x)\n        val isBalanced = sums.forall(x => x <= maxSum)\n       \
    \ isPalindromic && isBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpkmjev023.scala:21)\n\tat Problem.main(tmpkmjev023.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010355
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        isPalindromic && isBalanced && isLessThanMax\
    \ && isLessThanMaxButNotBalanced && isLessThanMaxButBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpey0r6g8z.scala:22)\n\tat Problem.main(tmpey0r6g8z.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010355
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppuco0gy5.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppuco0gy5.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndPalindromic\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppuco0gy5.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppuco0gy5.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromic\e\
    [0"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < q.reduce(_ + _)\n        isPalindromic && isBalanced && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmplqwkmcku.scala:14:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == q)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == _)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpg9b1fnfc.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpg9b1fnfc.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndPalindromic\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpg9b1fnfc.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpg9b1fnfc.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromic\e\
    [0"
  stdout: ''
  timestamp: 1660010368
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x\
    \ => x <= maxWeight && x >= 0)\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        val\
    \ isLessThanMaxAndPalindromic = isLessThanMax && isPalindromic\n        isLessThanMaxAndBalanced\
    \ || isLessThanMaxAndPalindromic\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxo5g_4f6.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010371
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum < maxWeight\n  \
    \      val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalanced = maxSum <\
    \ maxWeight\n        val isLessThanMaxSumAndBalanced = maxSum < maxWeight\n  \
    \      val isLessThanMaxWeightAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic = maxSum\
    \ < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcmk4jh9o.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpcmk4jh9o.scala:14:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m14 |\e[0m       \
    \ \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_ == q)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    Values of types Long and List[Long] cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcmk4jh9o.scala:32:5 ---------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val maxSums = sums.map(x => x.toLong)\n        val maxSumsReversed =\
    \ maxSums.reverse\n        val maxSumsReversedReversed = maxSumsReversed.reverse\n\
    \        val maxSumsReversedReversedReversed = maxSumsReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversed = maxSumsReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversed = maxSumsReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversed = maxSumsReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversed =\
    \ maxSumsReversedReversedReversedReversedReversedReversed.reverse\n        val\
    \ maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversed\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq2ofm7fd.scala:22:94 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = maxSumsReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxSumsReversedReversedReversedReversedReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq2ofm7fd.scala:23:102\
    \ -----------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = maxSumsReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxSumsReversedReversedReversedReversedReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpq2ofm7fd.scala:28:5\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum\
    \ == maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi2qxtfuw.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isBalanced = maxSumOfElements <= maxWeight\n       \
    \ isPalindromic && isBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp8uhdz5ke.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSumOfElements\
    \ < w\n        val isLessThanMaxOfElements = q.foldLeft(0)(_ + _) < w\n      \
    \  isBalanced && isPalindromic && isLessThanMax && isLessThanMaxOfElements\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp42xtlcoj.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp42xtlcoj.scala:17:52 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxOfElements\e[0m\
    \ = q.foldLeft(\e[31m0\e[0m)(_ + _) < w\n\e[31m\e[31m   |\e[0m               \
    \                                     ^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                                        Found:    Long\n\e[31m   |\e[0m     \
    \                                               Required: Int\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010376
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == _)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic\n  \
    \      val isLessThanMaxButBalancedAndPalindromicButNotPalindromic = maxSum <\
    \ maxWeight && isBalanced && isPalindromic && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxButBalancedAndPalindromicButNotPalindromic = maxSum\
    \ < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isPalindromic\
    \ && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isPalindromic\
    \ && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isPalindromic\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpok8rtzw5.scala:27:72 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                        ^\e[0m\n\e[31m   |\e[0m                             \
    \          expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpok8rtzw5.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic &&\
    \ !isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpok8rtzw5.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromicButNotPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isPalindromic\
    \ && !isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPalindromicButNotPalindromic is\
    \ already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndPalindromicButNotPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e["
  stdout: ''
  timestamp: 1660010374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sum = 0L\n        q.foreach\
    \ { x => sum += x }\n        sum <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv80j3nxp.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        q.foreach { \e[36mx\e[0m => sum += x }\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      value += is not a member of Long - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxWeight\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        val isLessOrEqualToMaxWeight = maxSumOfElements <= maxWeight\n      \
    \  val isLessOrEqualToMaxSum = maxSumOfElements <= maxSum\n        val isLessOrEqualToMaxSumOfElements\
    \ = maxSumOfElements <= maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndBalanced\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndPalindromic\
    \ = maxSumOfElements <= maxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromic\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic\n    \
    \    val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxWeight\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxWeight\n\
    \        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSum\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\n\
    \        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSumOfElements\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSumOfElements\n\
    \        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSumOfElementsAndBalanced\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSumOfElementsAndBalanced\n\
    \        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSumOfElementsAndBalancedPalindromic\
    \ = maxSumOfElements <= maxSumOf\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06yx3guz.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp06yx3guz.scala:27:142 -----------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSumOfElementsAndBalancedPalindromic\e\
    [0m = maxSumOfElements <= maxSumOf\n\e[31m\e[31m   |\e[0m                    \
    \                                                                            \
    \                                              ^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                                                     Not found: maxSumOf\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp06yx3guz.scala:28:5\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q.head)\n        val isBalanced =\
    \ maxSum == maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < q.foldLeft(0)(_ + _)\n        isPalindromic\
    \ && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1kfr_q6d.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1kfr_q6d.scala:17:54\
    \ --------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSum\e\
    [0m = maxSum < q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        \
    \                                              ^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                                                   Found:    Long\n\e[31m   |\e\
    [0m                                                      Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxWeight = w.toLong\n        val maxSumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightOfElements = q.foldLeft(0)(_ +\
    \ _)\n        val isBalanced = maxSumOfElements <= maxWeight\n        val isPalindromic\
    \ = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxWeight\
    \ = maxSumOfElements <= maxWeight\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualToMaxWeightAndBalanced = isLessOrEqualToMaxWeight\
    \ && isBalanced\n        val isLessOrEqualToMaxSumAndBalanced = isLessOrEqualToMaxSum\
    \ && isBalanced\n        val isLessOrEqualToMaxWeightAndPalindromic = isLessOrEqualToMaxWeight\
    \ && isPalindromic\n        val isLessOrEqualToMaxSumAndPalindromic = isLessOrEqualToMaxSum\
    \ && isPalindromic\n        val isLessOrEqualToMaxWeightAndBalancedAndPalindromic\
    \ = isLessOrEqualToMaxWeightAndBalanced && isPalindromic\n        val isLessOrEqualToMaxSumAndBalancedAndPalindromic\
    \ = isLessOrEqualToMaxSumAndBalanced && isPalindromic\n        val isLessOrEqualToMaxWeightAndBalancedAndPalindromicAndLessOrEqualToMaxSumAndBalancedAndPalindromic\
    \ = isLessOrEqualToMaxWeightAndBalancedAndPalindromic && isLessOrEqualToMaxSumAndBalancedAndPalindromic\n\
    \        val isLessOrEqualToMaxSumAndBalancedAndPalindromicAndLessOrEqualToMaxWeightAndBalancedAndPalindromic\
    \ = isLessOrEqualToMaxSumAndBalancedAndPalindromic && isLessOrEqualToMaxWeightAndBalancedAndPalindromic\n\
    \        val isLessOrEqualToMaxWeightAndPalindromicAndLessOrEqualToMaxSumAndBalancedAndPalindromic\
    \ = isLessOrEqualToMaxWeightAndPalindromic && isLessOrEqualToMaxSumAndBalancedAndPalindromic\n\
    \        val isLessOrEqualToMaxSumAndBalancedAndPalindromicAndLessOr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3cpqhqxa.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3cpqhqxa.scala:14:45 --------------------\e[0m\e[0m\n\e[31m14 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp3cpqhqxa.scala:15:48\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                               ^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                              Found:    Long\n\e[31m   |\e[0m               \
    \                                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp3cpqhqxa.scala:30:5 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010376
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val maxSums = sums.max\n        val isBalanced = sums.forall(x => x ==\
    \ maxSums)\n        val isPalindromic = sums.forall(x => x == sums.reverse.head)\n\
    \        val isLessOrEqual = sums.forall(x => x <= maxSum)\n        isBalanced\
    \ && isPalindromic && isLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnnf2h5ee.scala:21)\n\tat Problem.main(tmpnnf2h5ee.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010376
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMaxSum = maxSumOfElements\
    \ < maxSum\n        val isLessThanMaxSumOfElements = maxSumOfElements < maxSumOfElements\n\
    \        val isLessThanMaxSumOfElementsOfElements = maxSumOfElements < maxSumOfElements.toLong\n\
    \        val isLessThanMaxSumOfElementsOfElementsOfElements = maxSumOfElements\
    \ < maxSumOfElements.toLong * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length * q.length\n       \
    \ val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElements = maxSumOfElements\
    \ < maxSumOfElements.toLong * q.length * q.length * q.length * q.length\n    \
    \    val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length * q.length * q.length\
    \ * q.length * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\n\
    \        val isLessThanMaxSumOfElement\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpu3e83zeu.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpu3e83zeu.scala:13:45 --------------------\e[0m\e[0m\n\e[31m13 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpu3e83zeu.scala:27:5\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q(0)\n\
    \        val maxWeightSum = maxSum - maxWeight\n        val maxWeightSumInt =\
    \ maxWeightSum.toInt\n        val maxWeightSumLong = maxWeightSum.toLong\n   \
    \     val maxWeightSumLongInt = maxWeightSumLong.toInt\n        val maxWeightSumLongLong\
    \ = maxWeightSumLong.toLongLong\n        val maxWeightSumLongLongInt = maxWeightSumLongLong.toInt\n\
    \        val maxWeightSumLongLongLong = maxWeightSumLongLong.toLongLongLong\n\
    \        val maxWeightSumLongLongLongInt = maxWeightSumLongLongLong.toInt\n  \
    \      val maxWeightSumLongLongLongLong = maxWeightSumLongLongLong.toLongLongLongLong\n\
    \        val maxWeightSumLongLongLongLongInt = maxWeightSumLongLongLongLong.toInt\n\
    \        val maxWeightSumLongLongLongLongLong = maxWeightSumLongLongLongLong.toLongLongLongLong\n\
    \        val maxWeightSumLongLongLongLongLongInt = maxWeightSumLongLongLongLongLong.toInt\n\
    \        val maxWeightSumLongLongLongLongLongLong = maxWeightSumLongLongLongLongLong.toLongLongLongLongLong\n\
    \        val maxWeightSumLongLongLongLongLongLongInt = maxWeightSumLongLongLongLongLongLong.toInt\n\
    \        val maxWeightSumLongLongLongLongLongLongLong = maxWeightSumLongLongLongLongLongLong.toLongLongLongLongLong\n\
    \        val maxWeightSumLongLongLongLongLongLongLongInt = maxWeightSumLongLongLongLongLongLongLongLong.toInt\n\
    \        val maxWeightSumLongLongLongLongLongLongLongLong = maxWeightSumLongLongLongLongLongLongLongLong.toLongLongLongLongLongLong\n\
    \        val maxWeightSumLongLongLongLongLongLongLongLongInt = maxWeightSumLongLongLongLongLongLongLongLongLong.toInt\n\
    \        val maxWeightSumLongLongLongLongLongLongLongLongLong = maxWeightSumLongLongLongLongLongLongLongLongLong.toLongLongLongLongLongLongLong\n\
    \        val maxWeightSumLongLongLongLongLongLongLongLongLongInt = maxWeightSumLongLongLongLongLongLongLongLongLongLongLong.toInt\n\
    \        val maxWeightSumLongLongLongLongLongLongLongLongLongLongLong = maxWeightSumLongLongLongLongLongLongLongLongLongLongLong.toLong\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmppikr0axs.scala:18:52 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumLongLong\e[0m\
    \ = maxWeightSumLong.toLongLong\n\e[31m\e[31m   |\e[0m                       \
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                 value toLongLong is not a member of Long\n\e[31m\e[31m-- [E045]\
    \ Cyclic Error: /tmp/tmppikr0axs.scala:30:59 ---------------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumLongLongLongLongLongLongLongLong\e\
    [0m = maxWeightSumLongLongLongLongLongLongLongLong.toLongLongLongLongLongLong\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \   ^\e[0m\n\e[31m   |\e[0m Recursive \e[33mvalue\e[0m \e[35mmaxWeightSumLongLongLongLongLongLongLongLong\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppikr0axs.scala:32:63\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumLongLongLongLongLongLongLongLongLong\e[0m = maxWeightSumLongLongLongLongLongLongLongLongLong.toLongLongLongLongLongLongLong\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmaxWeightSumLongLongLongLongLongLongLongLongLong\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmppikr0axs.scala:34:71\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumLongLongLongLongLongLongLongLongLongLongLong\e[0m = maxWeightSumLongLongLongLongLongLongLongLongLongLongLong.toLong\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \               ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmaxWeightSumLongLongLongLongLongLongLongLongLongLongLong\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Misma"
  stdout: ''
  timestamp: 1660010374
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced = maxSum < maxWeight\
    \ && maxSum == maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && !isPalindromic\
    \ && !isBalanced && !isPalindromic && !isPalindromic && !isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotP\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp4oj75kzf.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp4oj75kzf.scala:14:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m14 |\e[0m       \
    \ \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_ == q)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    Values of types Long and List[Long] cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4oj75kzf.scala:26:5 ---------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010375
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val maxSums = sums.map(x => x.toLong)\n        val maxSumsReversed =\
    \ maxSums.reverse\n        val maxSumsReversedSum = maxSumsReversed.sum\n    \
    \    val maxSumsReversedSumLessThanMax = maxSumsReversedSum <= maxSum\n      \
    \  val maxSumsReversedSumLessThanMaxButNotBalanced = maxSumsReversedSumLessThanMax\
    \ && !isBalanced(sums)\n        val maxSumsReversedSumLessThanMaxButBalanced =\
    \ maxSumsReversedSumLessThanMax && isBalanced(sums)\n        val maxSumsReversedSumLessThanMaxButNotBalancedAndNotAllZero\
    \ = maxSumsReversedSumLessThanMaxButNotBalanced && !allZero(maxSumsReversed)\n\
    \        val maxSumsReversedSumLessThanMaxButBalancedAndNotAllZero = maxSumsReversedSumLessThanMaxButBalanced\
    \ && !allZero(maxSumsReversed)\n        val maxSumsReversedSumLessThanMaxButNotBalancedAndAllZero\
    \ = maxSumsReversedSumLessThanMaxButNotBalanced && allZero(maxSumsReversed)\n\
    \        val maxSumsReversedSumLessThanMaxButBalancedAndAllZero = maxSumsReversedSumLessThanMaxButBalanced\
    \ && allZero(maxSumsReversed)\n        val maxSumsReversedSumLessThanMaxButNotBalancedAndAllZero\
    \ = maxSumsReversedSumLessThanMaxButNotBalanced && allZero(maxSumsReversed)\n\
    \        val maxSumsReversedSumLessThanMaxButBalancedAndAllZero = maxSumsReversedSumLessThanMaxButBalanced\
    \ && allZero(maxSumsReversed)\n        val maxSumsReversedSumLessThanMaxButNotBalancedAndAllZero\
    \ = maxSumsReversedSumLessThanMaxButNotBalanced && allZero(maxSumsReversed)\n\
    \        val maxSumsReversedSumLessThanMaxButNotBalancedAndNotAllZero = maxSumsReversedSumLessThanMaxButNotBalanced\
    \ && !allZero(maxSumsReversed)\n        val maxSumsReversedSumLessThanMaxButBalancedAndNotAllZero\
    \ = maxSumsReversedSumLessThan\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8t9ako_n.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmaxSumsReversedSumLessThanMaxButNotBalancedAndAllZero\e\
    [0m = maxSumsReversedSumLessThanMaxButNotBalanced && allZero(maxSumsReversed)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSumsReversedSumLessThanMaxButNotBalancedAndAllZero is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxSumsReversedSumLessThanMaxButNotBalancedAndAllZero\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8t9ako_n.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36mmaxSumsReversedSumLessThanMaxButBalancedAndAllZero\e\
    [0m = maxSumsReversedSumLessThanMaxButBalanced && allZero(maxSumsReversed)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSumsReversedSumLessThanMaxButBalancedAndAllZero is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxSumsReversedSumLessThanMaxButBalancedAndAllZero\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8t9ako_n.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxSumsReversedSumLessThanMaxButNotBalancedAndAllZero\e\
    [0m = maxSumsReversedSumLessThanMaxButNotBalanced && allZero(maxSumsReversed)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSumsReversedSumLessThanMaxButNotBalancedAndAllZero is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxSumsReversedSumLessThanMaxButNotBalancedAndAllZero\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote t"
  stdout: ''
  timestamp: 1660010373
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxWeightSum = w.toLong * q.length\n        val maxWeightSumOfQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n \
    \       val maxWeightSumOfQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n     \
    \   val maxWeightSumOfQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n     \
    \   val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n \
    \       val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ =\
    \ q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_iuhd7ns.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_iuhd7ns.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\e[0m = q.foldLeft(\e[31m0\e\
    [0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_iuhd7ns.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_iuhd7ns.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31"
  stdout: ''
  timestamp: 1660010356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum < maxWeight\n  \
    \      val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalanced = maxSum <\
    \ maxWeight\n        val isLessThanMaxSumAndBalanced = maxSum < maxWeight\n  \
    \      val isLessThanMaxWeightAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic = maxSum\
    \ < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromicAndNotPalindromicAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmple54akgy.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmple54akgy.scala:14:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m14 |\e[0m       \
    \ \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_ == q)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    Values of types Long and List[Long] cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmple54akgy.scala:31:5 ---------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010376
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isPalindromic = maxSumOfElements\
    \ == maxSum\n        val isBalanced = maxWeight == maxSum\n        val isLessThanMaxWeight\
    \ = maxSumOfElements < maxWeight\n        val isLessThanMaxSum = maxSumOfElements\
    \ < maxSum\n        isPalindromic && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpalc9urng.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010375
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val sumOfElements = q.sum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = sumOfElements <=\
    \ maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdb0nhypu.scala:19)\n\tat Problem.main(tmpdb0nhypu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        return maxSumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa5f16enf.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010376
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxWeight = w.toLong\n        val maxSumOfElements\
    \ = w.toLong\n        val maxWeightOfElements = w.toLong\n        val maxSumOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElements = w.toLong\n        val\
    \ maxSumOfElementsOfElementsOfElements = w.toLong\n        val maxWeightOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxWeightOfElementsOfElementsOfElementsOfElements = w.toLong\n  \
    \      val maxSumOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElements = w.toLong\n\
    \        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = w.toLong\n        val maxWeightOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElement\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp54fgpxb1.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp54fgpxb1.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum < maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalanced\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced\n      \
    \  val isLessThanMaxButBalancedAndPalindromicAndBalanced = maxSum < maxWeight\
    \ && isBalanced && isPalindromic && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic =\
    \ maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && \n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdzv7_jvt.scala:27:167 --------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && \n\e[31m\e[31m   |\e[0m                                                 \
    \                                                                            \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                            expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdzv7_jvt.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e[0m\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpdzv7_jvt.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPa"
  stdout: ''
  timestamp: 1660010377
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val isPalindromic = sums.reverse.forall(x => x == x)\n        val isBalanced\
    \ = sums.forall(x => x <= maxSum)\n        isPalindromic && isBalanced\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbnh1lg2s.scala:20)\n\tat Problem.main(tmpbnh1lg2s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSumOfElements\
    \ < w\n        val isLessThanMaxButNotBalanced = isLessThanMax && !isBalanced\n\
    \        val isLessThanMaxButBalanced = isLessThanMax && isBalanced\n        isLessThanMaxButNotBalanced\
    \ || isLessThanMaxButBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5hd25ids.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010378
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.isPalindromic\n        val isBalanced = q.isBalanced\n        val isLessOrEqual\
    \ = maxSum < maxWeight\n        val isMoreThan = maxSum > maxWeight\n        val\
    \ isEqual = maxSum == maxWeight\n        val isLessThan = maxSum < maxWeight\n\
    \        val isMoreThan = maxSum > maxWeight\n        val isEqual = maxSum ==\
    \ maxWeight\n        val isLessThan = maxSum < maxWeight\n        val isMoreThan\
    \ = maxSum > maxWeight\n        val isEqual = maxSum == maxWeight\n        val\
    \ isLessThan = maxSum < maxWeight\n        val isMoreThan = maxSum > maxWeight\n\
    \        val isEqual = maxSum == maxWeight\n        val isLessThan = maxSum <\
    \ maxWeight\n        val isMoreThan = maxSum > maxWeight\n        val isEqual\
    \ = maxSum == maxWeight\n        val isLessThan = maxSum < maxWeight\n       \
    \ val isMoreThan = maxSum > maxWeight\n        val isEqual = maxSum == maxWeight\n\
    \        val isLessThan = maxSum < maxWeight\n        val isMoreThan = maxSum\
    \ > maxWeight\n        val isEqual = maxSum == maxWeight\n        val isLessThan\
    \ = maxSum < maxWeight\n        val isMoreThan = maxSum > maxWeight\n        val\
    \ isEqual = maxSum == maxWeight\n        val isLessThan = maxSum < maxWeight\n\
    \        val isMoreThan = maxSum > maxWeight\n        val isEqual = maxSum ==\
    \ maxWeight\n        val isLessThan = maxSum < maxWeight\n        val isMoreThan\
    \ = maxSum > maxWeight\n        val isEqual = maxSum == maxWeight\n        val\
    \ isLessThan = maxSum < maxWeight\n        val isMoreThan = maxSum > maxWeight\n\
    \        val isEqual = maxSum == maxWeight\n        val isLessThan = maxSum <\
    \ maxWeight\n        val isMoreThan = maxSum > maxWeight\n        val isEqual\
    \ = maxSum == maxWeight\n        val isLessThan = maxSum < maxWeight\n       \
    \ val isMoreThan = maxSum > maxWeight\n        val isEqual = maxSum == maxWeight\n\
    \        val isLessThan = maxSum < maxWeight\n        val isMore\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqg9odgdx.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqg9odgdx.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36misMoreThan\e[0m = maxSum > maxWeight\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misMoreThan is already defined as \e[33mvalue\e[0m \e[35misMoreThan\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqg9odgdx.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36misEqual\e[0m = maxSum == maxWeight\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0misEqual is already defined as \e[33mvalue\e[0m \e[35misEqual\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqg9odgdx.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThan\e[0m = maxSum < maxWeight\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0misLessThan is already defined as \e[33mvalue\e[0m \e[35misLessThan\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqg9odgdx.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36misMoreThan\e[0m = maxSum > maxWeight\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0misMoreThan is already defined as \e[33mvalue\e[0m \e[35misMoreThan\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpqg9odgdx.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0"
  stdout: ''
  timestamp: 1660010394
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x => x ==\
    \ q(0)) && q.forall(x => x == q(q.length-1))\n        val isLessOrEqual = maxWeight\
    \ <= maxSum && maxWeight <= q.sum\n        isPalindromic && isBalanced && isLessOrEqual\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp5mr2mq45.scala:20)\n\tat Problem.main(tmp5mr2mq45.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.isReverse.forall(x => x == q.head)\n        val isBalanced = maxSum == q.sum\n\
    \        val isLessThanMaxWeight = maxWeight < q.sum\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced = isLessThanMaxWeight\
    \ && isBalanced\n        val isLessThanMaxSumAndPalindromic = isLessThanMaxWeight\
    \ && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromic = isLessThanMaxSumAndBalanced\
    \ && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = isLessThanMaxSumAndBalanced && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxSumAndBalanced && !isPalindromic && !isBalanced\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxSumAndBalanced && !isPalindromic && !isBalanced && !isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxSumAndBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxSumAndBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxSumAndBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !is\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpg0ftg4ga.scala:14:30 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isReverse.forall(\e\
    [36mx\e[0m => x == q.head)\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m value isReverse is not a member of List[Long] - did you mean\
    \ q.reverse?\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg0ftg4ga.scala:26:235\
    \ -----------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36misLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\e\
    [0m = isLessThanMaxSumAndBalanced && !isPalindromic && !isBalanced && !isPalindromic\
    \ && !is\n\e[31m\e[31m   |\e[0m                                              \
    \                                                                            \
    \                                                                            \
    \                                     ^^\e[0m\n\e[31m   |\e[0m               \
    \                                            Not found: is\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpg0ftg4ga.scala:27:5 ---------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q.reverse.head)\n        val isBalanced\
    \ = q.forall(x => x == q.last)\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < q.sum\n        val isLessThanMaxSumAndBalanced\
    \ = isLessThanMaxWeight && isBalanced\n        val isLessThanMaxSumAndPalindromic\
    \ = isLessThanMaxWeight && isPalindromic\n        isLessThanMaxSumAndBalanced\
    \ || isLessThanMaxSumAndPalindromic\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbh50q9dw.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010393
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isPalindromic = q.reverse.forall(_\
    \ == q.head)\n        val isBalanced = maxSumOfElements <= maxWeight\n       \
    \ val isLessThanMaxWeight = maxSumOfElements < maxWeight\n        val isLessThanMaxSum\
    \ = maxSumOfElements < maxSum\n        val isLessThanMaxSumOfElements = maxSumOfElements\
    \ < maxSumOfElements\n        val isLessThanMaxSumOfElementsAndBalanced = maxSumOfElements\
    \ < maxSumOfElements && maxSumOfElements <= maxWeight\n        val isLessThanMaxSumOfElementsAndPalindromic\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && isPalindromic\n\
    \        val isLessThanMaxSumOfElementsAndBalancedAndPalindromic = maxSumOfElements\
    \ < maxSumOfElements && maxSumOfElements <= maxWeight && isBalanced && isPalindromic\n\
    \        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicAndLessThanMaxWeight\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && isBalanced\
    \ && isPalindromic && isLessThanMaxWeight\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicAndLessThanMaxSum\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && isBalanced\
    \ && isPalindromic && isLessThanMaxSum\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicAndLessThanMaxSumOfElements\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && isBalanced\
    \ && isPalindromic && isLessThanMaxSumOfElements\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicAndLessThanMaxSumOfElementsAndBalanced\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && isBalanced\
    \ && isPalindromic && isLessThanMaxSumOfElementsAndBalanced\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicAndLessThan\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv263j19r.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpv263j19r.scala:14:45 --------------------\e[0m\e[0m\n\e[31m14 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpv263j19r.scala:28:5\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010393
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val maxSumLessOrEqual\
    \ = maxSum - maxWeight\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        val isBalanced = q.forall(x => x == q(0) - q.length)\n      \
    \  isPalindromic && isBalanced && maxSumLessOrEqual <= maxWeight\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbk6xdju0.scala:20)\n\tat Problem.main(tmpbk6xdju0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010396
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum == maxWeight\n\
    \        isPalindromic && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpotlzdll6.scala:19)\n\tat Problem.main(tmpotlzdll6.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.foldLeft(0)(_\
    \ + _) == maxSum\n        val isLessThanMaxWeight = maxWeight - q.sum < 0\n  \
    \      val isLessThanMaxSum = maxSum - q.sum < 0\n        isPalindromic && isBalanced\
    \ && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1phft0nv.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1phft0nv.scala:15:39\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36misBalanced\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) == maxSum\n\e[31m\e[31m   |\e[0m       \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                      Found:    Long\n\e[31m   |\e[0m                       \
    \                Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum < maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedButBalanced\
    \ = maxSum < maxWeight && !isBalanced && isBalanced\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\n\
    \        val isLessThanMaxButBalancedButNotPalindromic = maxSum < maxWeight &&\
    \ isBalanced && !isPalindromic && !isLessThanMaxButBalancedButPalindromic\n  \
    \      val isLessThanMaxButNotBalancedButPalindromic = maxSum < maxWeight && !isBalanced\
    \ && isPalindromic && !isLessThanMaxButNotBalancedButNotPalindromic\n        val\
    \ isLessThanMaxButBalancedButPalindromic = maxSum < maxWeight && isBalanced &&\
    \ isPalindromic && !isLessThanMaxButNotBalancedButPalindromic\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\
    \ && !isLessThanMaxButNotBalancedButPalindromic\n        val \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpdru25ckb.scala:29:11 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpdru25ckb.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButNotPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdru25ckb.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedButNotPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && !isPalindromic && !isLessThanMaxButBalancedButPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedButNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedButNotPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpdru25ckb.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && isPalindromic && !isLessThanMaxButNotBalancedButNotPalindromic\n\
    \e[31m\e[31m   |\e[0m"
  stdout: ''
  timestamp: 1660010394
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessOrEqual = maxSum < maxWeight\n        isPalindromic && isBalanced\
    \ && isLessOrEqual\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp7b1c3rt_.scala:20)\n\tat Problem.main(tmp7b1c3rt_.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMaxWeight = maxSumOfElements\
    \ < w\n        val isLessThanMaxWeightAndBalanced = isLessThanMaxWeight && isBalanced\n\
    \        val isLessThanMaxWeightAndPalindromic = isLessThanMaxWeight && isPalindromic\n\
    \        isLessThanMaxWeightAndBalanced || isLessThanMaxWeightAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpht_se3f2.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        return maxSumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfjwdzwgg.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sumOfElements = q.foldLeft(0)(_\
    \ + _)\n        sumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpku7kcy3a.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum < maxWeight\n  \
    \      val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedButBalanced\
    \ = maxSum < maxWeight && !isBalanced && isBalanced\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\n\
    \        val isLessThanMaxButBalancedButNotPalindromic = maxSum < maxWeight &&\
    \ isBalanced && !isPalindromic && !isLessThanMaxButNotBalancedButPalindromic\n\
    \        val isLessThanMaxButNotBalancedButPalindromic = maxSum < maxWeight &&\
    \ !isBalanced && isPalindromic && !isLessThanMaxButBalancedButPalindromic\n  \
    \      val isLessThanMaxButBalancedButPalindromic = maxSum < maxWeight && isBalanced\
    \ && isPalindromic && !isLessThanMaxButNotBalancedButNotPalindromic\n        val\
    \ isLessThanMaxButNotBalancedButNotPalindromic = maxSum < maxWeight && !isBalanced\
    \ && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic && !isLessThanMaxButNotBalancedButPalindromic\
    \ && !isLess\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpwvjlst62.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButNotPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwvjlst62.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedButNotPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && !isPalindromic && !isLessThanMaxButNotBalancedButPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedButNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedButNotPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpwvjlst62.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && isPalindromic && !isLessThanMaxButBalancedButPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButPalindromic\e[0m\n\e"
  stdout: ''
  timestamp: 1660010398
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.isEmpty\n        val isBalanced = maxSum == maxWeight\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n\
    \        isPalindromic && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplkggvsx4.scala:21)\n\tat Problem.main(tmplkggvsx4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010399
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong).sorted\n\
    \        val isPalindromic = sums.reverse == sums\n        val isBalanced = sums.sum\
    \ == maxSum\n        isPalindromic && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6w7tp27c.scala:19)\n\tat Problem.main(tmp6w7tp27c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isLessOrEqualToMaxWeight = maxSumOfElements\
    \ <= w\n        isBalanced && isPalindromic && isLessOrEqualToMaxWeight\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpta4syp3h.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.sum\n\
    \        val maxWeightPalindromic = maxWeight * q.length\n        val maxWeightPalindromicSum\
    \ = maxWeightPalindromic * q.sum\n        val maxWeightPalindromicSumLessOrEqualToMaxWeight\
    \ = maxWeightPalindromicSum - maxWeight\n        val maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromic\
    \ = maxWeightPalindromicSumLessOrEqualToMaxWeight * q.length\n        val maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSum\
    \ = maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromic - maxWeightPalindromicSumLessOrEqualToMaxWeight\n\
    \        val maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSumLessOrEqualToMaxSum\
    \ = maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSum\
    \ - maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSum\
    \ * q.length\n        val maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSumLessOrEqualToMaxSumLessOrEqualToMaxSum\
    \ = maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSumLessOrEqualToMaxSum\
    \ - maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSum\
    \ * q.length\n        val maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSumLessOrEqualToMaxSumLessOrEqualToMaxSumLessOrEqualToMaxSum\
    \ = maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSumLessOrEqualToMaxSumLessOrEqualToMaxSum\
    \ - maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSum\
    \ * q.length\n        val maxWeightPalindromicSumLessOrEqualToMaxWeightPalindromicLessOrEqualToMaxSumLessOrEqualToMaxSumLessOrEqualToMaxSumLessOrEqualToMaxSumLessOrEqual\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2u7ly7ck.scala:23:4 ----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp2u7ly7ck.scala:23:5 ---------------------\e[0m\e[0m\n\e[31m23 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum\
    \ - q.sum < 0\n        val isLessThanMax = maxSum - q.sum <= 0\n        val isLessThanMaxButNotBalanced\
    \ = maxSum - q.sum < 0 && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum - q.sum < 0 && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum - q.sum < 0 && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum - q.sum < 0 && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalanced\
    \ = maxSum - q.sum < 0 && !isBalanced && !isPalindromic && isBalanced\n      \
    \  val isLessThanMaxButBalancedAndPalindromicAndBalanced = maxSum - q.sum < 0\
    \ && isBalanced && isPalindromic && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum - q.sum < 0 && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic =\
    \ maxSum - q.sum < 0 && isBalanced && isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum - q.sum < 0 && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum - q.sum < 0 && isBalanced && isPalindromic && isBalanced && !isPalindromic\
    \ && !isBalanced && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum - q.sum < 0 \n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp44xehlha.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum - q.sum < \e[31m0\e[0m && !isBalanced && !isPalindromic && isBalanced\
    \ && !isPalindromic && !isBalanced\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp44xehlha.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum - q.sum < \e[31m0\e[0m && isBalanced && isPalindromic && isBalanced\
    \ && !isPalindromic && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp44xehlha.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum - q.sum < \e[31m0\e[0m \n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e["
  stdout: ''
  timestamp: 1660010398
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val sumOfElements = q.foldLeft(0)(_ + _)\n    \
    \    sumOfElements <= maxWeight\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplx5nge13.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010397
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxWeightSum = w.toLong * q.length\n        val maxWeightSumOfQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n \
    \       val maxWeightSumOfQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n     \
    \   val maxWeightSumOfQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n     \
    \   val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n \
    \       val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_ + _)\n\
    \        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ = q.foldLeft(0)(_\
    \ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ =\
    \ q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightSumOfQ\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_iuhd7ns.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_iuhd7ns.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\e[0m = q.foldLeft(\e[31m0\e\
    [0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ is already defined\
    \ as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQ\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_iuhd7ns.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ is already\
    \ defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp_iuhd7ns.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\
    \ is already defined as \e[33mvalue\e[0m \e[35mmaxWeightSumOfQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQAndQ\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31"
  stdout: ''
  timestamp: 1660010356
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxWeight\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        val isLessThanMaxWeight = maxSumOfElements < maxWeight\n        val isLessThanMaxSum\
    \ = maxSumOfElements < maxSum\n        val isLessThanMaxSumOfElements = maxSumOfElements\
    \ < maxSumOfElements\n        val isLessThanMaxSumOfElementsOfElements = maxSumOfElements\
    \ < maxSumOfElements.toLong\n        val isLessThanMaxSumOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length * q.length\n       \
    \ val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElements = maxSumOfElements\
    \ < maxSumOfElements.toLong * q.length * q.length * q.length * q.length\n    \
    \    val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length * q.length * q.length\
    \ * q.length * q.length * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length * q.length\n        val\
    \ isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements < maxSumOfElements.toLong\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqvs6tsci.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpqvs6tsci.scala:28:5 ---------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x\
    \ => x == q(0) - q.reverse.head)\n        val isLessThanMaxWeight = maxSum < maxWeight\n\
    \        val isLessThanMaxSum = maxSum < q.sum\n        isPalindromic && isBalanced\
    \ && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpskxyum0i.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010400
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = isLessThanMax && isBalanced\n        val isLessThanMaxAndBalancedAndPalindromic\
    \ = isLessThanMaxAndBalanced && isPalindromic\n        isLessThanMaxAndBalancedAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpjsucuwy6.scala:14:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == q)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660010401
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isBalanced\
    \ = q.length == q.reverse.length && maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpswpwvgsv.scala:20)\n\tat Problem.main(tmpswpwvgsv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010403
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualToMaxSumOfElements = maxSumOfElements <=\
    \ maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndBalanced = maxSumOfElements\
    \ <= maxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndPalindromic\
    \ = maxSumOfElements <= maxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndBalancedAndPalindromic\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic\n    \
    \    val isLessOrEqualToMaxSumOfElementsAndBalancedAndPalindromicAndLessOrEqualToMaxSumOfElements\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\n\
    \        val isLessOrEqualToMaxSumOfElementsAndBalancedAndPalindromicAndLessOrEqualToMaxSumOfElementsAndLessOrEqualToMaxSum\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\
    \ && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndBalancedAndPalindromicAndLessOrEqualToMaxSumOfElementsAndLessOrEqualToMaxSumAndLessOrEqualToMaxSum\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\
    \ && isLessOrEqualToMaxSum && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndBalancedAndPalindromicAndLessOrEqualToMaxSumOfElementsAndLessOrEqualToMaxSumAndLessOrEqualToMaxSumAndLessOrEqualToMaxSum\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\
    \ && isLessOr\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7vpqf7i8.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp7vpqf7i8.scala:24:265 -----------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxSumOfElementsAndBalancedAndPalindromicAndLessOrEqualToMaxSumOfElementsAndLessOrEqualToMaxSumAndLessOrEqualToMaxSumAndLessOrEqualToMaxSum\e\
    [0m = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\
    \ && isLessOr\n\e[31m\e[31m   |\e[0m                                         \
    \                                                                            \
    \                                                                            \
    \                                                                        ^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                     Not found:\
    \ isLessOr\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7vpqf7i8.scala:25:5\
    \ ---------------------\e[0m\e[0m\n\e[31m25 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010413
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isBalanced\
    \ = q.length == q.reverse.length && maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxPalindromic = maxSum < maxWeight && isPalindromic\n\
    \        val isLessThanMaxPalindromic2 = maxSum < maxWeight && isPalindromic &&\
    \ isBalanced\n        val isLessThanMaxPalindromic3 = maxSum < maxWeight && isPalindromic\
    \ && isBalanced && isLessThanMax\n        val isLessThanMaxPalindromic4 = maxSum\
    \ < maxWeight && isPalindromic && isBalanced && isLessThanMax && isLessThanMaxPalindromic\n\
    \        val isLessThanMaxPalindromic5 = maxSum < maxWeight && isPalindromic &&\
    \ isBalanced && isLessThanMax && isLessThanMaxPalindromic && isLessThanMaxPalindromic2\n\
    \        val isLessThanMaxPalindromic6 = maxSum < maxWeight && isPalindromic &&\
    \ isBalanced && isLessThanMax && isLessThanMaxPalindromic && isLessThanMaxPalindromic2\
    \ && isLessThanMaxPalindromic3\n        val isLessThanMaxPalindromic7 = maxSum\
    \ < maxWeight && isPalindromic && isBalanced && isLessThanMax && isLessThanMaxPalindromic\
    \ && isLessThanMaxPalindromic2 && isLessThanMaxPalindromic3 && isLessThanMaxPalindromic4\n\
    \        val isLessThanMaxPalindromic8 = maxSum < maxWeight && isPalindromic &&\
    \ isBalanced && isLessThanMax && isLessThanMaxPalindromic && isLessThanMaxPalindromic2\
    \ && isLessThanMaxPalindromic3 && isLessThanMaxPalindromic4 && isLessThanMaxPalindromic5\n\
    \        val isLessThanMaxPalindromic9 = maxSum < maxWeight && isPalindromic &&\
    \ isBalanced && isLessThanMax && isLessThanMaxPalindromic && is\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn69_dn2k.scala:25:138 -----------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxPalindromic9\e\
    [0m = maxSum < maxWeight && isPalindromic && isBalanced && isLessThanMax && isLessThanMaxPalindromic\
    \ && is\n\e[31m\e[31m   |\e[0m                                               \
    \                                                                            \
    \               ^^\e[0m\n\e[31m   |\e[0m                                     \
    \                      Not found: is\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpn69_dn2k.scala:26:5 ---------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.length\n\
    \        val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced =\
    \ maxSumOfElements <= maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessThanMaxWeight = maxSumOfElements < maxWeight\n\
    \        val isLessThanMaxSum = maxSumOfElements < maxSum\n        val isLessThanMaxSumOfElements\
    \ = maxSumOfElements < maxSumOfElements\n        val isLessThanMaxSumOfElementsAndIsBalanced\
    \ = isLessThanMaxSumOfElements && isBalanced\n        val isLessThanMaxSumOfElementsAndIsPalindromic\
    \ = isLessThanMaxSumOfElements && isPalindromic\n        val isLessThanMaxSumOfElementsAndIsLessThanMaxWeight\
    \ = isLessThanMaxSumOfElements && isLessThanMaxWeight\n        val isLessThanMaxSumOfElementsAndIsLessThanMaxSum\
    \ = isLessThanMaxSumOfElements && isLessThanMaxSum\n        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElements\
    \ = isLessThanMaxSumOfElements && isLessThanMaxSumOfElements\n        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsBalanced\
    \ = isLessThanMaxSumOfElementsAndIsLessThanMaxWeight && isLessThanMaxSumOfElementsAndIsBalanced\n\
    \        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsPalindromic\
    \ = isLessThanMaxSumOfElementsAndIsLessThanMaxWeight && isLessThanMaxSumOfElementsAndIsPalindromic\n\
    \        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxWeight\
    \ = isLessThanMaxSumOfElementsAndIsLessThanMaxWeight && isLessThanMaxSumOfElementsAndIsLessThanMaxWeight\n\
    \        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxSum\
    \ = isLessThanMaxSumOfElementsAndIsLessThanMaxSum && isLessThanMaxSumOfElementsAndIsLessThanMaxSum\n\
    \        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElements\
    \ = isLessThanMaxSumOfElementsAndIsLess\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2i5uzdrg.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp2i5uzdrg.scala:29:99 ------------------------\e[0m\e\
    [0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElements\e\
    [0m = isLessThanMaxSumOfElementsAndIsLess\n\e[31m\e[31m   |\e[0m             \
    \                                                                            \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \                 Not found: isLessThanMaxSumOfElementsAndIsLess\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2i5uzdrg.scala:30:5 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010415
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = isLessThanMax && !isBalanced\n        val isLessThanMaxButBalanced = isLessThanMax\
    \ && isBalanced\n        val isLessThanMaxButNotPalindromic = isLessThanMax &&\
    \ !isPalindromic\n        val isLessThanMaxButPalindromic = isLessThanMax && isPalindromic\n\
    \        val isLessThanMaxButNotBalancedAndNotPalindromic = isLessThanMax && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButBalancedAndNotPalindromic = isLessThanMax\
    \ && isBalanced && !isPalindromic\n        val isLessThanMaxButNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic\n       \
    \ val isLessThanMaxButBalancedAndPalindromic = isLessThanMax && isBalanced &&\
    \ isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic = isLessThanMax\
    \ && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedAndNotPalindromic\
    \ = isLessThanMax && isBalanced && !isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isBalanced && !isPalindromic\n        val isLessThanMaxButNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic\n       \
    \ val isLessThanMaxButBalancedAndPalindromicAndNotPalindromic = isLessThanMax\
    \ && isBalanced && isPalindromic && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndNotPalindromic\
    \ = isLessThanMax && !isBalanced && isPalindromic && !isPalindromic\n        val\
    \ isLessThanMaxButBalancedAndNotPalin\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkh8g8vec.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkh8g8vec.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxButBalancedAndNotPalindromic\e[0m = isLessThanMax && isBalanced\
    \ && !isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndNotPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkh8g8vec.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndNotPalindromic\e\
    [0m = isLessThanMax && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e[0m  \
    \      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndNotPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkh8g8vec.scala:28:12 ---------------------------\e[0m\e[0m\n\e[31m28\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotPalindromicAndNotBalancedAndNotPalindromic\e\
    [0m = isLessThanMax && !isPalindromic && !isBalanced && !isPalindromic\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotPalindromicAndNotBalancedAndNotPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButNotPalindromicAndNotBalancedAndNotPalindro"
  stdout: ''
  timestamp: 1660010414
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = isLessThanMax && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax\
    \ && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromic = isLessThanMaxAndBalanced\
    \ && isPalindromic\n        isLessThanMaxAndBalancedAndPalindromic\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp53hql5z4.scala:23)\n\tat Problem.main(tmp53hql5z4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010418
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxWeight = w.toLong\n        val maxSumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val maxWeightOfElements = q.foldLeft(0)(_ +\
    \ _)\n        val isBalanced = maxSumOfElements == maxWeight\n        val isPalindromic\
    \ = maxSumOfElements == maxWeightOfElements\n        val isLessThanMaxWeight =\
    \ maxSumOfElements < maxWeight\n        val isLessThanMaxSum = maxSumOfElements\
    \ < maxSum\n        val isLessThanMaxSumOfElements = maxSumOfElements < maxSumOfElements\n\
    \        val isLessThanMaxWeightOfElements = maxSumOfElements < maxWeightOfElements\n\
    \        val isLessThanMaxSumOfElementsAndWeight = maxSumOfElements < maxSumOfElements\
    \ && maxSumOfElements < maxWeightOfElements\n        val isLessThanMaxSumOfElementsAndWeightAndBalanced\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\
    \ && maxSumOfElements < maxSum\n        val isLessThanMaxSumOfElementsAndWeightAndBalancedPalindromic\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\
    \ && maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\n\
    \        val isLessThanMaxSumOfElementsAndWeightAndBalancedPalindromicPalindromic\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\
    \ && maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\
    \ && maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\n\
    \        val isLessThanMaxSumOfElementsAndWeightAndBalancedPalindromicPalindromicPalindromic\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\
    \ && maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\
    \ && maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\
    \ && maxSumOfElements < maxSumOfElements && maxSumOfElements < maxWeightOfElements\n\
    \        val isLessThanMaxSumOfElementsAndWeightAndBalancedPalindromicPalindromicPalindromicPalindro\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaljln3k7.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpaljln3k7.scala:14:45 --------------------\e[0m\e[0m\n\e[31m14 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaljln3k7.scala:15:48\
    \ --------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                               ^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \                              Found:    Long\n\e[31m   |\e[0m               \
    \                                 Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmpaljln3k7.scala:28:5 ---------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010416
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = isLessThanMax && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax\
    \ && isPalindromic\n        isLessThanMaxAndBalanced || isLessThanMaxAndPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4ras47ii.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010414
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x => x\
    \ <= maxWeight && x >= 0)\n        val isLessThanMax = q.forall(x => x <= maxWeight\
    \ && x >= 0)\n        val isLessThanMaxButNotBalanced = q.forall(x => x <= maxWeight\
    \ && !isBalanced)\n        val isLessThanMaxButBalanced = q.forall(x => x <= maxWeight\
    \ && isBalanced)\n        val isLessThanMaxButNotBalancedButBalanced = q.forall(x\
    \ => x <= maxWeight && !isBalanced && isBalanced)\n        val isLessThanMaxButNotBalancedButNotBalanced\
    \ = q.forall(x => x <= maxWeight && !isBalanced && !isBalanced)\n        val isLessThanMaxButBalancedButNotBalanced\
    \ = q.forall(x => x <= maxWeight && isBalanced && !isBalanced)\n        val isLessThanMaxButNotBalancedButBalanced\
    \ = q.forall(x => x <= maxWeight && !isBalanced && isBalanced)\n        val isLessThanMaxButNotBalancedButNotBalanced\
    \ = q.forall(x => x <= maxWeight && !isBalanced && !isBalanced)\n        val isLessThanMaxButBalancedButBalanced\
    \ = q.forall(x => x <= maxWeight && isBalanced && isBalanced)\n        val isLessThanMaxButNotBalancedButBalancedButNotBalanced\
    \ = q.forall(x => x <= maxWeight && !isBalanced && isBalanced && !isBalanced)\n\
    \        val isLessThanMaxButBalancedButNotBalancedButNotBalanced = q.forall(x\
    \ => x <= maxWeight && isBalanced && !isBalanced && !isBalanced)\n        val\
    \ isLessThanMaxButNotBalancedButBalancedButNotBalanced = q.forall(x => x <= maxWeight\
    \ && !isBalanced && isBalanced && !isBalanced)\n        val isLessThanMaxButBalancedButBalancedButNotBalanced\
    \ = q.forall(x => x <= maxWeight && isBalanced && isBalanced && !isBalanced)\n\
    \        val isLessThanMaxButNotBalancedButBalancedButBalancedButNotBalanced =\
    \ q.forall(x => x <= maxWeight && !isBalanced && isBalanced && isBalanced && !isBalanced)\n\
    \        val isLessThanMaxButBalancedButNotBalancedButBalance\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong,\
    \ 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_czl5dc5.scala:31:4 ----------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_czl5dc5.scala:22:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxButNotBalancedButBalanced\e[0m = q.forall(\e[36mx\e[0m =>\
    \ x <= maxWeight && !isBalanced && isBalanced)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButBalanced is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButBalanced\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_czl5dc5.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButNotBalanced\e\
    [0m = q.forall(\e[36mx\e[0m => x <= maxWeight && !isBalanced && !isBalanced)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButNotBalanced is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButNotBalanced\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_czl5dc5.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButBalancedButNotBalanced\e\
    [0m = q.forall(\e[36mx\e[0m => x <= maxWeight && !isBalanced && isBalanced &&\
    \ !isBalanced)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButBalancedButNotBalanced is already\
    \ defined as \e[33mvalue\e[0m \e[35misLessThanMa"
  stdout: ''
  timestamp: 1660010415
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == _)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalanced\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced\n      \
    \  val isLessThanMaxButBalancedAndPalindromicAndBalanced = maxSum < maxWeight\
    \ && isBalanced && isPalindromic && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic =\
    \ maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && \n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpsd134u0q.scala:27:167 --------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && \n\e[31m\e[31m   |\e[0m                                                 \
    \                                                                            \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                            expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsd134u0q.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e[0m\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsd134u0q.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPa"
  stdout: ''
  timestamp: 1660010417
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        return maxSumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpa5f16enf.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010376
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_ == q(0))\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = isLessThanMax && !isBalanced\n        val isLessThanMaxButBalanced = isLessThanMax\
    \ && isBalanced\n        val isLessThanMaxButNotPalindromic = isLessThanMax &&\
    \ !isPalindromic\n        val isLessThanMaxButPalindromic = isLessThanMax && isPalindromic\n\
    \        val isLessThanMaxButNotBalancedAndNotPalindromic = isLessThanMaxButNotBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButBalancedAndNotPalindromic = isLessThanMaxButBalanced\
    \ && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic = isLessThanMaxButNotBalanced\
    \ && isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic = isLessThanMaxButBalanced\
    \ && isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndPalindromic\
    \ = isLessThanMaxButNotBalanced && !isPalindromic && isPalindromic\n        val\
    \ isLessThanMaxButBalancedAndNotPalindromicAndPalindromic = isLessThanMaxButBalanced\
    \ && !isPalindromic && isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxButNotBalanced && !isPalindromic && !isPalindromic\n        val\
    \ isLessThanMaxButBalancedAndNotPalindromicAndNotPalindromic = isLessThanMaxButBalanced\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxButNotBalanced && !isPalindromic && !isPalindromic\n        val\
    \ isLessThanMaxButBalancedAndNotPalindromicAndNotPalindromic = isLessThanMaxButBalanced\
    \ && !isPalindromic && !\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp54o5mj29.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndNotPalindromicAndNotPalindromic\e\
    [0m = isLessThanMaxButNotBalanced && !isPalindromic && !isPalindromic\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndNotPalindromicAndNotPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndNotPalindromicAndNotPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp54o5mj29.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndNotPalindromicAndNotPalindromic\e\
    [0m = isLessThanMaxButBalanced && !isPalindromic && !\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndNotPalindromicAndNotPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndNotPalindromicAndNotPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmp54o5mj29.scala:31:5 ---------------------\e[0m\e[0m\n\
    \e[31m31 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010417
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualToMaxSumOfElements = maxSumOfElements <=\
    \ maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsOfElements = maxSumOfElements\
    \ <= maxSumOfElements.toLong\n        val isLessOrEqualToMaxSumOfElementsOfElementsOfElements\
    \ = maxSumOfElements <= maxSumOfElements.toLong.toLong\n        val isLessOrEqualToMaxSumOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements <= maxSumOfElements.toLong.toLong.toLong\n        val isLessOrEqualToMaxSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements <= maxSumOfElements.toLong.toLong.toLong.toLong.toLong\n\
    \        val isLessOrEqualToMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements <= maxSumOfElements.toLong.toLong.toLong.toLong.toLong.toLong\n\
    \        val isLessOrEqualToMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements <= maxSumOfElements.toLong.toLong.toLong.toLong.toLong.toLong.toLong.toLong\n\
    \        val isLessOrEqualToMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements <= maxSumOfElements.toLong.toLong.toLong.toLong.toLong.toLong.toLong.toLong.toLong\n\
    \        val isLessOrEqualToMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements <= maxSumOfElements.toLong.toLong.toLong.toLong.toLong.toLong.toLong.toLong.toLong.toLong\n\
    \        val isLessOrEqualToMaxSumOfElementsOfElementsOfElementsOfElements\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz4dcafz0.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpz4dcafz0.scala:13:45 --------------------\e[0m\e[0m\n\e[31m13 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpz4dcafz0.scala:27:5\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010419
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sumOfElements = q.foldLeft(0)(_\
    \ + _)\n        sumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpku7kcy3a.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessOrEqual = maxSum <= maxWeight\n        val isLessOrEqualPalindromic\
    \ = maxSum <= maxWeight && isPalindromic\n        val isLessOrEqualBalanced =\
    \ maxSum <= maxWeight && isBalanced\n        val isLessOrEqualBalancedPalindromic\
    \ = maxSum <= maxWeight && isPalindromic && isBalanced\n        val isLessOrEqualBalancedAndPalindromic\
    \ = maxSum <= maxWeight && isBalanced && isPalindromic\n        val isLessOrEqualBalancedAndPalindromicPalindromic\
    \ = maxSum <= maxWeight && isBalanced && isPalindromic && isPalindromic\n    \
    \    val isLessOrEqualBalancedAndPalindromicPalindromicPalindromic = maxSum <=\
    \ maxWeight && isBalanced && isPalindromic && isPalindromic && isPalindromic\n\
    \        val isLessOrEqualBalancedAndPalindromicPalindromicPalindromicPalindromic\
    \ = maxSum <= maxWeight && isBalanced && isPalindromic && isPalindromic && isPalindromic\
    \ && isPalindromic\n        val isLessOrEqualBalancedAndPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxSum <= maxWeight && isBalanced && isPalindromic && isPalindromic && isPalindromic\
    \ && isPalindromic && isPalindromic\n        val isLessOrEqualBalancedAndPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxSum <= maxWeight && isBalanced && isPalindromic && isPalindromic && isPalindromic\
    \ && isPalindromic && isPalindromic && isPalindromic\n        val isLessOrEqualBalancedAndPalindromicPalindromicPalindromicPalin\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6nzx7my6.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmp6nzx7my6.scala:14:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m14 |\e[0m       \
    \ \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_ == q)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    Values of types Long and List[Long] cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6nzx7my6.scala:27:5 ---------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010419
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxWeight\n        val isPalindromic = q.reverse.forall(_ == q.head)\n  \
    \      val isLessOrEqualToMaxWeight = maxSumOfElements <= maxWeight\n        val\
    \ isLessOrEqualToMaxSum = maxSumOfElements <= maxSum\n        val isLessOrEqualToMaxSumOfElements\
    \ = maxSumOfElements <= maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxWeight\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxWeight\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSumOfElements\n     \
    \   val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElementsAndIsBalanced && isLessOrEqualToMaxSumOfElementsAndIsPalindromic\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxWeight\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxWeight && isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum && isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\n\
    \        val isLessOrEqualToMaxSumOfElement\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpbt811scp.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpbt811scp.scala:14:45 --------------------\e[0m\e[0m\n\e[31m14 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpbt811scp.scala:29:5\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010419
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSumOfElements\
    \ < w\n        val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n  \
    \      val isLessThanMaxAndPalindromic = isLessThanMax && isPalindromic\n    \
    \    val isLessThanMaxAndBalancedAndPalindromic = isLessThanMaxAndPalindromic\
    \ && isBalanced\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxAndBalancedAndPalindromic && isBalanced && q(0) > 0\n       \
    \ val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegative = isLessThanMaxAndBalancedAndPalindromic\
    \ && isBalanced && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegativeAndNotNegative\
    \ = isLessThanMaxAndBalancedAndPalindromic && isBalanced && q(0) > 0 && q(0) >\
    \ 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegativeAndNotNegativeAndNotNegative\
    \ = isLessThanMaxAndBalancedAndPalindromic && isBalanced && q(0) > 0 && q(0) >\
    \ 0 && q(0) > 0 && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegativeAndNotNegativeAndNotNegativeAndNotNegative\
    \ = isLessThanMaxAndBalancedAndPalindromic && isBalanced && q(0) > 0 && q(0) >\
    \ 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 &&\
    \ q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0\
    \ && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0 && \n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphh87lrf4.scala:24:534 --------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegativeAndNotNegativeAndNotNegativeAndNotNegative\e\
    [0m = isLessThanMaxAndBalancedAndPalindromic && isBalanced && q(\e[31m0\e[0m)\
    \ > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e\
    [0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e\
    [31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m)\
    \ > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e\
    [0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e\
    [31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m)\
    \ > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e\
    [0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e\
    [31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m)\
    \ > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e\
    [0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e\
    [31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m)\
    \ > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && \n\e[31m\e[31m   |\e[0m\
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \  ^\e[0m\n\e[31m   |\e[0m                                       expression expected\
    \ but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphh87lrf4.scala:13:45 --------------------\e[0m\e[0m\n\e["
  stdout: ''
  timestamp: 1660010420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessOrEqual = maxSum <= maxWeight\n        isPalindromic\
    \ && isBalanced && isLessOrEqual\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprp_67qs1.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010419
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.length\n\
    \        val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val maxWeightOfElements\
    \ = q.foldLeft(0)(_ * _)\n        val balanced = maxSumOfElements <= maxWeight\n\
    \        val unbalanced = maxSumOfElements > maxWeight\n        val unbalancedAndBalanced\
    \ = unbalanced && balanced\n        val unbalancedAndBalancedAndUnbalanced = unbalancedAndBalanced\
    \ && unbalanced\n        val unbalancedAndBalancedAndUnbalancedAndUnbalanced =\
    \ unbalancedAndBalancedAndUnbalanced && unbalancedAndBalanced\n        val unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = unbalancedAndBalancedAndUnbalancedAndUnbalanced && unbalancedAndBalancedAndUnbalancedAndUnbalanced\n\
    \        val unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalanced && unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalanced\n\
    \        val unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ && unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\n\
    \        val unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ && unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\n\
    \        val unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5fwrxgc6.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp5fwrxgc6.scala:15:48 --------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightOfElements\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ * _)\n\e[31m\e[31m   |\e[0m                                    \
    \            ^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \           Found:    Long\n\e[31m   |\e[0m                                  \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp5fwrxgc6.scala:23:178 --------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36munbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\e\
    [0m = unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ && unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                              ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  unbalancedAndBalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp5fwrxgc6.scala:24:114 --------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36munbalancedAndBalancedAndUnbalancedAndUnbalan"
  stdout: ''
  timestamp: 1660010420
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val sumOfElements = q.sum\n        val isBalanced\
    \ = q.isBalanced\n        val isPalindromic = q.isPalindromic\n        val isLessOrEqualToMaxWeight\
    \ = sumOfElements <= maxWeight\n        val isLessOrEqualToMaxWeightAndBalanced\
    \ = sumOfElements <= maxWeight && isBalanced\n        val isLessOrEqualToMaxWeightAndPalindromic\
    \ = sumOfElements <= maxWeight && isPalindromic\n        val isLessOrEqualToMaxWeightAndBalancedPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isPalindromic\n        val isLessOrEqualToMaxWeightAndBalancedAndPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isPalindromic && isLessOrEqualToMaxWeight\n\
    \        val isLessOrEqualToMaxWeightAndBalancedPalindromicAndPalindromic = sumOfElements\
    \ <= maxWeight && isBalanced && isPalindromic && isLessOrEqualToMaxWeight && isLessOrEqualToMaxWeight\n\
    \        val isLessOrEqualToMaxWeightAndBalancedPalindromicAndPalindromicAndPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isPalindromic && isLessOrEqualToMaxWeight\
    \ && isLessOrEqualToMaxWeight && isLessOrEqualToMaxWeight\n        val isLessOrEqualToMaxWeightAndBalancedPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isPalindromic && isLessOrEqualToMaxWeight\
    \ && isLessOrEqualToMaxWeight && isLessOrEqualToMaxWeight && isLessOrEqualToMaxWeight\n\
    \        val isLessOrEqualToMaxWeightAndBalancedPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isPalindromic && isLessOrEqualToMaxWeight\
    \ && isLessOrEqualToMaxWeight && isLessOrEqualToMaxWeight && isLessOrEqualToMaxWeight\
    \ && isLessOrEqualToMaxWeight\n        val isLessOrEqualToMaxWeightAndBalancedPalindromicAndPalindro\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjgq_xiey.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjgq_xiey.scala:14:27\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36misBalanced\e[0m = q.isBalanced\n\e[31m\e[31m   |\e[0m                    \
    \     ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                         value isBalanced\
    \ is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjgq_xiey.scala:15:30\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36misPalindromic\e[0m = q.isPalindromic\n\e[31m\e[31m   |\e[0m              \
    \              ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value\
    \ isPalindromic is not a member of List[Long]\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpjgq_xiey.scala:26:5 ---------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010421
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        isBalanced && isPalindromic && isLessOrEqualToMaxSum\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmxerqfa9.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010420
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val sums = q.map(x => x.toLong)\n        val isPalindromic = sums.reverse.forall(x\
    \ => x == sums.head)\n        val isBalanced = sums.forall(x => x <= maxWeight)\n\
    \        isPalindromic && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmppwtyxe76.scala:20)\n\tat Problem.main(tmppwtyxe76.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMax\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph8y7fxec.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph8y7fxec.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxButNotBalancedAndPalindromic\e[0m = maxSum < maxWeight &&\
    \ !isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph8y7fxec.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndPalindromic\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmph8y7fxec.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel "
  stdout: ''
  timestamp: 1660010422
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x\
    \ => x == q(0) - q.reverse.head)\n        val isLessThanMax = maxSum < maxWeight\n\
    \        val isLessThanMaxButNotBalanced = maxSum < maxWeight && !isBalanced\n\
    \        val isLessThanMaxButBalanced = maxSum < maxWeight && isBalanced\n   \
    \     val isLessThanMaxButNotPalindromic = maxSum < maxWeight && !isPalindromic\n\
    \        val isLessThanMaxButPalindromic = maxSum < maxWeight && isPalindromic\n\
    \        val isLessThanMaxButNotBalancedAndNotPalindromic = maxSum < maxWeight\
    \ && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedAndPalindromic\n\
    \        val isLessThanMaxButBalancedAndNotPalindromic = maxSum < maxWeight &&\
    \ isBalanced && !isPalindromic && !isLessThanMaxButBalancedAndNotPalindromic\n\
    \        val isLessThanMaxButNotBalancedAndPalindromic = maxSum < maxWeight &&\
    \ !isBalanced && isPalindromic && !isLessThanMaxButBalancedAndNotPalindromic\n\
    \        val isLessThanMaxButBalancedAndPalindromic = maxSum < maxWeight && isBalanced\
    \ && isPalindromic && !isLessThanMaxButBalancedAndNotPalindromic\n        val\
    \ isLessThanMaxButNotBalancedAndNotPalindromic = maxSum < maxWeight && !isBalanced\
    \ && !isPalindromic && !is\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) == (true));\n\
    \    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) == (false));\n\
    \    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong, 3l.toLong)), (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)),\
    \ (5l)) == (true));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkgql52x_.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedAndPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndNotPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkgql52x_.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndNotPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && !isPalindromic && !isLessThanMaxButBalancedAndNotPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndNotPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpkgql52x_.scala:27:12 ---------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && isPalindromic && !isLessThanMaxButBalancedAndNotPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromic\e[0m\n\e"
  stdout: ''
  timestamp: 1660010424
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q.head)\n        val isBalanced = q.forall(x => x\
    \ <= maxWeight && x >= 0)\n        val isLessThanMax = q.sum < maxWeight\n   \
    \     val isLessThanMaxAndBalanced = q.sum < maxWeight && q.forall(x => x <= maxWeight\
    \ && x >= 0)\n        val isLessThanMaxAndBalancedAndPalindromic = q.sum < maxWeight\
    \ && q.forall(x => x <= maxWeight && x >= 0 && x == q.reverse.head)\n        val\
    \ isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic = q.sum < maxWeight\
    \ && q.forall(x => x <= maxWeight && x >= 0 && x == q.reverse.head && !q.reverse.forall(x\
    \ => x == q.head))\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= 0 && x == q.reverse.head\
    \ && !q.reverse.forall(x => x == q.head && !q.forall(x => x == q.reverse.head)))\n\
    \        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= 0 && x == q.reverse.head\
    \ && !q.reverse.forall(x => x == q.head && !q.forall(x => x == q.reverse.head\
    \ && !q.reverse.forall(x => x == q.head))))\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalanced\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= 0 && x == q.reverse.head\
    \ && !q.reverse.forall(x => x == q.head && !q.forall(x => x == q.reverse.head\
    \ && !q.reverse.forall(x => x == q.head && !q.forall(x => x == q.reverse.head)))))\n\
    \        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = q.sum < maxWeight && q.forall(x => x <= maxWeight && x >= 0 && x == q.reverse.head\
    \ && !q.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjgi6tpfs.scala:24:4 ----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpjgi6tpfs.scala:23:218\
    \ -----------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36misLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotBalancedAndNotPalindromic\e\
    [0m = q.sum < maxWeight && q.forall(\e[36mx\e[0m => x <= maxWeight && x >= \e\
    [31m0\e[0m && x == q.reverse.head && !q.reverse\n\e[31m\e[31m   |\e[0m       \
    \                                                                            \
    \                                                                            \
    \                                                           ^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                             value unary_! is not a member of List[Long]\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjgi6tpfs.scala:24:5 ---------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        isBalanced\
    \ && isPalindromic && isLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4uq7c8b7.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010425
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum\
    \ == maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi2qxtfuw.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced = maxSum < maxWeight\
    \ && maxSum == maxWeight\n        val isLessThanMaxWeightAndBalanced = maxSum\
    \ < maxWeight && maxSum == maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalanced\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndUnbalanced = maxSum\
    \ < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalanced = maxSum\
    \ < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced && isPalindromic\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndUnbalancedAndUnbalanced\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced &&\
    \ isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced &&\
    \ isPalindromic && isBalanced\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced &&\
    \ isPalindromic && isBalanced && isPalindromic\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpot6z6qjz.scala:14:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == q)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpot6z6qjz.scala:29:5\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010436
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        isBalanced && isPalindromic\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm4kflhif.scala:19)\n\tat Problem.main(tmpm4kflhif.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sumOfElements = q.foldLeft(0)(_\
    \ + _)\n        sumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpku7kcy3a.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x\
    \ => x <= maxWeight && x >= maxSum - maxWeight)\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw_fuvy41.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSumOfElements\
    \ < w\n        isBalanced && isPalindromic && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpac9yk24r.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isBalanced = q.length == q.reverse.length && q.forall(_ <= maxWeight)\n    \
    \    val isPalindromic = q.length == q.reverse.length && q.forall(_ == q.reverse(_))\n\
    \        val isLessOrEqual = maxSum < maxWeight\n        isBalanced && isPalindromic\
    \ && isLessOrEqual\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7l9p7yvq.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmp7l9p7yvq.scala:15:69\
    \ ---------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m\
    \ \e[36misPalindromic\e[0m = q.length == q.reverse.length && q.forall(_ == q.reverse(_))\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \             ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \         Wrong number of parameters, expected: 1\n2 errors found\n"
  stdout: ''
  timestamp: 1660010436
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMaxWeight = maxSumOfElements\
    \ < w\n        val isLessThanMaxWeightAndBalanced = isLessThanMaxWeight && isBalanced\n\
    \        val isLessThanMaxWeightAndPalindromic = isLessThanMaxWeight && isPalindromic\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromic = isLessThanMaxWeightAndBalanced\
    \ && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeightAndBalancedAndPalindromic && !isPalindromic\n        val\
    \ isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic && !isBalanced\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic && !isBalanced\
    \ && !isPalindromic && !isBalanced && !isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotBalanced\
    \ = isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic && !isBalanced\
    \ && !isPalindromic && !isBalanced && !isPalindromic && !isBalanced && !isPalindromic\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5zc4abhx.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp5zc4abhx.scala:13:45 --------------------\e[0m\e[0m\n\e[31m13 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5zc4abhx.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010438
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val sumOfElements = q.sum\n        val isBalanced\
    \ = q.isEmpty\n        val isPalindromic = q.reverse.forall(_ == q.head)\n   \
    \     val isLessOrEqualToMaxWeight = sumOfElements <= maxWeight\n        val isLessOrEqualToMaxWeightAndBalanced\
    \ = sumOfElements <= maxWeight && isBalanced\n        val isLessOrEqualToMaxWeightAndPalindromic\
    \ = sumOfElements <= maxWeight && isPalindromic\n        val isLessOrEqualToMaxWeightAndBalancedPalindromic\
    \ = sumOfElements <= maxWeight && isBalanced && isPalindromic\n        isLessOrEqualToMaxWeight\
    \ || isLessOrEqualToMaxWeightAndBalanced || isLessOrEqualToMaxWeightAndPalindromic\
    \ || isLessOrEqualToMaxWeightAndBalancedPalindromic\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzbff_9xk.scala:24)\n\tat Problem.main(tmpzbff_9xk.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced = maxSum < maxWeight\
    \ && maxWeight == maxSum\n        val isLessThanMaxSumAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && maxWeight == maxSum && isPalindromic\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZero\
    \ = maxSum < maxWeight && maxWeight == maxSum && isPalindromic && maxSum != 0\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZeroAndNotZero = maxSum\
    \ < maxWeight && maxWeight == maxSum && isPalindromic && maxSum != 0 && maxWeight\
    \ != 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum < maxWeight && maxWeight == maxSum && isPalindromic && maxSum != 0\
    \ && maxWeight != 0 && maxSum != 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum < maxWeight && maxWeight == maxSum && isPalindromic && maxSum != 0\
    \ && maxWeight != 0 && maxSum != 0 && maxWeight != 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum < maxWeight && maxWeight == maxSum && isPalindromic && maxSum != 0\
    \ && maxWeight != 0 && maxSum != 0 && maxWeight != 0 && maxSum != 0\n        val\
    \ isLessThanMaxSumAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum < maxWeight && maxWeight == maxSum && isPalindromic && maxSum != 0\
    \ && maxWeight != 0 && maxSum != 0 && maxWeight != 0 && maxSum != 0 && maxWeight\
    \ != 0\n        val isLessThanMax\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3t6p4gcb.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3t6p4gcb.scala:27:5 ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x\
    \ => x == q(0) - q.reverse.head)\n        val isLessThanMaxWeight = maxSum - maxWeight\
    \ < 0\n        val isLessThanMaxSum = maxSum < 0\n        isPalindromic && isBalanced\
    \ && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpgky_mj24.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010438
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x\
    \ => x == q(0) - q.length)\n        val isLessThanMax = maxSum < maxWeight\n \
    \       val isLessThanMaxButNotBalanced = maxSum < maxWeight && !isBalanced\n\
    \        val isLessThanMaxButBalanced = maxSum < maxWeight && isBalanced\n   \
    \     val isLessThanMaxButNotPalindromic = maxSum < maxWeight && !isPalindromic\n\
    \        val isLessThanMaxButPalindromic = maxSum < maxWeight && isPalindromic\n\
    \        val isLessThanMaxButNotBalancedButPalindromic = maxSum < maxWeight &&\
    \ !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLess\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmgl6oi5_.scala:33:4 ----------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmgl6oi5_.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxButNotBalancedButPalindromic\e[0m = maxSum < maxWeight &&\
    \ !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmgl6oi5_.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedButPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedButPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedButPalindromic\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpmgl6oi5_.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of topleve"
  stdout: ''
  timestamp: 1660010440
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x => x >\
    \ 0 && x <= maxWeight)\n        val isLessThanMax = maxSum - q.sum < maxWeight\n\
    \        val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n        isPalindromic\
    \ && isLessThanMaxAndBalanced\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp_6z9t4qd.scala:21)\n\tat Problem.main(tmp_6z9t4qd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010443
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4mwvf4cu.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum < maxWeight\n  \
    \      val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalanced = maxSum <\
    \ maxWeight\n        val isLessThanMaxSumAndBalanced = maxSum < maxWeight\n  \
    \      val isLessThanMaxWeightAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromic = maxSum < maxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromic = maxSum\
    \ < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight\n        val isLessThanMaxSumAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpcmk4jh9o.scala:32:4 ----------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- Error: /tmp/tmpcmk4jh9o.scala:14:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m14 |\e[0m       \
    \ \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_ == q)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    Values of types Long and List[Long] cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcmk4jh9o.scala:32:5 ---------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010373
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_ == q(0))\n\
    \        isBalanced && isPalindromic\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpnmgjxkbd.scala:19)\n\tat Problem.main(tmpnmgjxkbd.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010442
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        isPalindromic && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpxenbtg6l.scala:19)\n\tat Problem.main(tmpxenbtg6l.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010443
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val sumOfElements = q.foldLeft(0)(_ + _)\n    \
    \    sumOfElements <= maxWeight\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplx5nge13.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong).sum\n\
    \        sums <= maxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf38vvhe7.scala:18)\n\tat Problem.main(tmpf38vvhe7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010443
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMaxSum = maxSumOfElements\
    \ < maxSum\n        val isLessThanMaxSumOfElements = maxSumOfElements < maxSumOfElements\n\
    \        val isLessThanMaxSumOfElementsAndIsBalanced = isLessThanMaxSum && isBalanced\n\
    \        val isLessThanMaxSumOfElementsAndIsPalindromic = isLessThanMaxSum &&\
    \ isPalindromic\n        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElements\
    \ = isLessThanMaxSum && isLessThanMaxSumOfElements\n        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsBalanced\
    \ = isLessThanMaxSumOfElementsAndIsBalanced && isLessThanMaxSumOfElements\n  \
    \      val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsPalindromic\
    \ = isLessThanMaxSumOfElementsAndIsPalindromic && isLessThanMaxSumOfElements\n\
    \        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElements\
    \ = isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElements && isLessThanMaxSumOfElements\n\
    \        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsBalanced\
    \ = isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsBalanced && isLessThanMaxSumOfElements\n\
    \        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsPalindromic\
    \ = isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsPalindromic &&\
    \ isLessThanMaxSumOfElements\n        val isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElements\
    \ = isLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElementsAndIsLessThanMaxSumOfElements\
    \ && isLessThanMaxSumOfElements\n        \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp956_y4si.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp956_y4si.scala:28:5 ---------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010443
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        return maxSumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfjwdzwgg.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010395
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxWeight\n        val isPalindromic = q.reverse.forall(_ == q.head)\n  \
    \      val isLessThanMax = maxSumOfElements < maxWeight\n        isBalanced &&\
    \ isPalindromic && isLessThanMax\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpcjm5cjce.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.sum\n\
    \        val maxWeightPalindromic = maxWeight / 2\n        val maxWeightPalindromicPalindromic\
    \ = maxWeightPalindromic / 2\n        val maxWeightPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromic / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromic / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromic / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromic\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6mamq1cx.scala:24:4 ----------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6mamq1cx.scala:19:90\
    \ ---------------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\e\
    [0m = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                    ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp6mamq1cx.scala:20:112 --------------------------\e[0m\e[0m\n\e[31m20\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\e\
    [0m = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \                                                                          ^\e\
    [0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp6mamq1cx.scala:21:134 --------------------------\e[0m\e[0m\n\e[31m21\
    \ |\e[0m        \e[33mval\e[0m \e[36mmaxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\e\
    [0m = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / \e[31m2\e[0m\n\e[31m\e[31m   |\e[0m    "
  stdout: ''
  timestamp: 1660010441
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.isPalindromic\n        val isBalanced = q.isBalanced\n        val isFlippable\
    \ = q.forall(x => x != maxSum)\n        val isLessThanMaxWeight = q.forall(x =>\
    \ x <= maxWeight)\n        val isLessThanMaxSum = q.forall(x => x <= maxSum)\n\
    \        val isLessThanMaxSumAndBalanced = q.forall(x => x <= maxSum && q.isBalanced)\n\
    \        val isLessThanMaxSumAndFlippable = q.forall(x => x <= maxSum && q.isPalindromic)\n\
    \        val isLessThanMaxSumAndFlippableAndBalanced = q.forall(x => x <= maxSum\
    \ && q.isPalindromic && q.isBalanced)\n        val isLessThanMaxSumAndFlippableAndBalancedAndPalindromic\
    \ = q.forall(x => x <= maxSum && q.isPalindromic && q.isBalanced && q.isPalindromic)\n\
    \        val isLessThanMaxSumAndFlippableAndBalancedAndPalindromicAndFlippable\
    \ = q.forall(x => x <= maxSum && q.isPalindromic && q.isBalanced && q.isPalindromic\
    \ && q.isFlippable)\n        val isLessThanMaxSumAndFlippableAndBalancedAndPalindromicAndFlippableAndFlippable\
    \ = q.forall(x => x <= maxSum && q.isPalindromic && q.isBalanced && q.isPalindromic\
    \ && q.isFlippable && q.isFlippable)\n        val isLessThanMaxSumAndFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippable\
    \ = q.forall(x => x <= maxSum && q.isPalindromic && q.isBalanced && q.isPalindromic\
    \ && q.isFlippable && q.isFlippable && q.isFlippable && q.isFlippable)\n     \
    \   val isLessThanMaxSumAndFlippableAndBalancedAndPalindromicAndFlippableAndFlippableAndFlippableAndFli\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpel6ghlri.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpel6ghlri.scala:14:30\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36misPalindromic\e[0m = q.isPalindromic\n\e[31m\e[31m   |\e[0m              \
    \              ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       value\
    \ isPalindromic is not a member of List[Long]\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmpel6ghlri.scala:15:27 ------------------------\e[0m\e[0m\n\e[31m15\
    \ |\e[0m        \e[33mval\e[0m \e[36misBalanced\e[0m = q.isBalanced\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                    value isBalanced is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpel6ghlri.scala:19:73 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalanced\e\
    [0m = q.forall(\e[36mx\e[0m => x <= maxSum && q.isBalanced)\n\e[31m\e[31m   |\e\
    [0m                                                                       ^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                          value isBalanced is not a member\
    \ of List[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpel6ghlri.scala:20:74\
    \ ------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e\
    [36misLessThanMaxSumAndFlippable\e[0m = q.forall(\e[36mx\e[0m => x <= maxSum &&\
    \ q.isPalindromic)\n\e[31m\e[31m   |\e[0m                                    \
    \                                    ^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                    value isPalindromic is not a member of List[Long]\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpel6ghlri.scala:21:85 ------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndFlippableAndBalanced\e\
    [0m = q.forall(\e[36mx\e[0m => x <= maxSum && q.isPalindromic && q.isBalanced)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                           ^^^^^^^^^^^^^^^\e[0m\n\e["
  stdout: ''
  timestamp: 1660010450
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualToMaxSumOfElements = maxSumOfElements <=\
    \ maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndIsBalanced =\
    \ isLessOrEqualToMaxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSumOfElementsAndIsBalanced && isLessOrEqualToMaxSumOfElements\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElementsAndIsPalindromic && isLessOrEqualToMaxSumOfElementsAndIsBalanced\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSumOfElementsAndIsPalindromic\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ && isLessOrEqualToMaxSumOfElementsAndIsLess\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuz4t7pph.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpuz4t7pph.scala:25:209 -----------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\e\
    [0m = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ && isLessOrEqualToMaxSumOfElementsAndIsLess\n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \                                                                            \
    \                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: isLessOrEqualToMaxSumOfElementsAndIsLess\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuz4t7pph.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010446
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val palindromic = q.reverse.forall(x\
    \ => x == q.head)\n        val balanced = palindromic && q.sum < maxWeight\n \
    \       val unbalanced = palindromic && !q.sum < maxWeight\n        val unbalancedSum\
    \ = q.sum - maxSum\n        val unbalancedWeight = maxWeight - unbalancedSum\n\
    \        val unbalancedMaxSum = maxSum - unbalancedSum\n        val unbalancedMaxWeight\
    \ = maxWeight - unbalancedMaxSum\n        val unbalancedMaxSumWeight = unbalancedMaxSum\
    \ * unbalancedWeight\n        val unbalancedMaxSumWeightPalindromic = unbalancedMaxSumWeight\
    \ * palindromic\n        val unbalancedMaxSumWeightPalindromicBalanced = unbalancedMaxSumWeightPalindromic\
    \ && balanced\n        val unbalancedMaxSumWeightPalindromicUnbalanced = unbalancedMaxSumWeightPalindromic\
    \ && !balanced\n        val unbalancedMaxSumWeightPalindromicUnbalancedSum = unbalancedMaxSumWeightPalindromicUnbalanced\
    \ * unbalancedSum\n        val unbalancedMaxSumWeightPalindromicUnbalancedWeight\
    \ = unbalancedMaxSumWeightPalindromicUnbalanced * unbalancedWeight\n        val\
    \ unbalancedMaxSumWeightPalindromicUnbalancedMaxSum = unbalancedMaxSumWeightPalindromicUnbalancedSum\
    \ * unbalancedMaxSum\n        val unbalancedMaxSumWeightPalindromicUnbalancedMaxWeight\
    \ = unbalancedMaxSumWeightPalindromicUnbalancedMaxSum * unbalancedMaxWeight\n\
    \        val unbalancedMaxSumWeightPalindromicUnbalancedMaxSumWeight = unbalancedMaxSumWeightPalindromicUnbalancedMaxSum\
    \ * unbalancedMaxSumWeight\n        val unbalancedMaxSumWeightPalindromicUnbalancedMaxSumWeightPalindromic\
    \ = unbalancedMaxSumWeightPalindromicUnbalancedMaxSumWeight * palindromic\n  \
    \      val unbalancedMaxSumWeightPalindromicUnbalancedMaxSumWeightPalindromicBalanced\
    \ = unbalancedMaxSumWeightPalindromicUnbalancedMaxSumWeightPalindromic \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpb87kwhvo.scala:16:40 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36munbalanced\e[0m = palindromic\
    \ && !q.sum < maxWeight\n\e[31m\e[31m   |\e[0m                               \
    \         ^^^^^^\e[0m\n\e[31m   |\e[0m      value unary_! is not a member of Long\
    \ - did you mean Long.unary_+?\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpb87kwhvo.scala:22:71\
    \ -----------------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e\
    [0m \e[36munbalancedMaxSumWeightPalindromic\e[0m = unbalancedMaxSumWeight * palindromic\n\
    \e[31m\e[31m   |\e[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m*\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((palindromic : Boolean))\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpb87kwhvo.scala:32:5 ---------------------\e[0m\e[0m\n\e[31m32 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010448
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.length\n\
    \        val maxWeightSum = w.toLong * q.length\n        val maxWeightSum2 = w.toLong\
    \ * q.length\n        val maxWeightSum3 = w.toLong * q.length\n        val maxWeightSum4\
    \ = w.toLong * q.length\n        val maxWeightSum5 = w.toLong * q.length\n   \
    \     val maxWeightSum6 = w.toLong * q.length\n        val maxWeightSum7 = w.toLong\
    \ * q.length\n        val maxWeightSum8 = w.toLong * q.length\n        val maxWeightSum9\
    \ = w.toLong * q.length\n        val maxWeightSum10 = w.toLong * q.length\n  \
    \      val maxWeightSum11 = w.toLong * q.length\n        val maxWeightSum12 =\
    \ w.toLong * q.length\n        val maxWeightSum13 = w.toLong * q.length\n    \
    \    val maxWeightSum14 = w.toLong * q.length\n        val maxWeightSum15 = w.toLong\
    \ * q.length\n        val maxWeightSum16 = w.toLong * q.length\n        val maxWeightSum17\
    \ = w.toLong * q.length\n        val maxWeightSum18 = w.toLong * q.length\n  \
    \      val maxWeightSum19 = w.toLong * q.length\n        val maxWeightSum20 =\
    \ w.toLong * q.length\n        val maxWeightSum21 = w.toLong * q.length\n    \
    \    val maxWeightSum22 = w.toLong * q.length\n        val maxWeightSum23 = w.toLong\
    \ * q.length\n        val maxWeightSum24 = w.toLong * q.length\n        val maxWeightSum25\
    \ = w.toLong * q.length\n        val maxWeightSum26 = w.toLong * q.length\n  \
    \      val maxWeightSum27 = w.toLong * q.length\n        val maxWeightSum28 =\
    \ w.toLong * q.length\n        val maxWeightSum29 = w.toLong * q.length\n    \
    \    val maxWeightSum30 = w.toLong * q.length\n        val maxWeightSum31 = w.toLong\
    \ * q.length\n        val maxWeightSum32 = w.toLong * q.length\n        val maxWeightSum33\
    \ = w.toLong * q.length\n        val maxWeightSum34 = w.toLong * q.length\n  \
    \      val maxWeightSum35 = w.toLong * q.length\n        val maxWeightSum36 =\
    \ w.toLong\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk37nq79s.scala:50:5\
    \ ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010445
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sum = 0L\n        q.foreach\
    \ { x => sum += x }\n        sum <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpv80j3nxp.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        q.foreach { \e[36mx\e[0m => sum += x }\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      value += is not a member of Long - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong).sum\n\
    \        sums <= maxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf38vvhe7.scala:18)\n\tat Problem.main(tmpf38vvhe7.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010443
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedButBalanced\
    \ = maxSum < maxWeight && !isBalanced && isBalanced\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\n\
    \        val isLessThanMaxButBalancedButNotPalindromic = maxSum < maxWeight &&\
    \ isBalanced && !isPalindromic && !isLessThanMaxButBalancedButPalindromic\n  \
    \      val isLessThanMaxButNotBalancedButPalindromic = maxSum < maxWeight && !isBalanced\
    \ && isPalindromic && !isLessThanMaxButNotBalancedButNotPalindromic\n        val\
    \ isLessThanMaxButBalancedButPalindromic = maxSum < maxWeight && isBalanced &&\
    \ isPalindromic && !isLessThanMaxButNotBalancedButPalindromic\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\
    \ && !isLessThanMaxButNotBalancedButPalindromic\n        \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0w6m4tlv.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButNotPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0w6m4tlv.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedButNotPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && !isPalindromic && !isLessThanMaxButBalancedButPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedButNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedButNotPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp0w6m4tlv.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && isPalindromic && !isLessThanMaxButNotBalancedButNotPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButPalindromic"
  stdout: ''
  timestamp: 1660010446
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val sumOfElements = q.foldLeft(0)(_ + _)\n    \
    \    sumOfElements <= maxWeight\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplx5nge13.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight\n       \
    \ val isLessThanMaxSum = maxSum < q.reduce(_ + _)\n        isPalindromic && isBalanced\
    \ && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu3shiprl.scala:21)\n\tat Problem.main(tmpu3shiprl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualToMaxSumOfElements = maxSumOfElements <=\
    \ maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndIsBalanced =\
    \ isLessOrEqualToMaxSum && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSum && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSum && isLessOrEqualToMaxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSum && isLessOrEqualToMaxSumOfElementsAndIsBalanced\n  \
    \      val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSum && isLessOrEqualToMaxSumOfElementsAndIsPalindromic\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSum && isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSum && isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSum && isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsPalindromic\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmphcls60ku.scala:26:11 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmphcls60ku.scala:13:45 --------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m =\
    \ q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                     \
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \                    Found:    Long\n\e[31m   |\e[0m                         \
    \                    Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmphcls60ku.scala:27:5 ---------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010457
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.isReverse.forall(x => x == q.head)\n        val isBalanced = q.tail.forall(x\
    \ => x == q.last)\n        val isLessThanMax = maxSum - maxWeight < 0\n      \
    \  val isLessThanMaxButNotBalanced = maxSum - maxWeight > 0 && !isBalanced\n \
    \       val isLessThanMaxButBalanced = maxSum - maxWeight > 0 && isBalanced\n\
    \        val isLessThanMaxButNotPalindromic = maxSum - maxWeight > 0 && !isPalindromic\n\
    \        val isLessThanMaxButPalindromic = maxSum - maxWeight > 0 && isPalindromic\n\
    \        val isLessThanMaxButNotAll = maxSum - maxWeight > 0 && !isPalindromic\
    \ && !isBalanced\n        val isLessThanMaxButAll = maxSum - maxWeight > 0 &&\
    \ isPalindromic && isBalanced\n        val isLessThanMaxButAllButNotPalindromic\
    \ = maxSum - maxWeight > 0 && !isPalindromic && isBalanced\n        val isLessThanMaxButAllButPalindromic\
    \ = maxSum - maxWeight > 0 && isPalindromic && isBalanced\n        val isLessThanMaxButAllButNotBalanced\
    \ = maxSum - maxWeight > 0 && !isPalindromic && !isBalanced && !isLessThanMaxButAllButPalindromic\n\
    \        val isLessThanMaxButAllButBalanced = maxSum - maxWeight > 0 && isPalindromic\
    \ && isBalanced && !isLessThanMaxButAllButPalindromic\n        val isLessThanMaxButAllButNotPalindromic\
    \ = maxSum - maxWeight > 0 && !isPalindromic && !isBalanced && !isLessThanMaxButAllButPalindromic\n\
    \        val isLessThanMaxButAllButBalanced = maxSum - maxWeight > 0 && isPalindromic\
    \ && isBalanced && !isLessThanMaxButAllButPalindromic\n        val isLessThanMaxButAllButNotPalindromic\
    \ = maxSum - maxWeight > 0 && !isPalindromic && !isBalanced && !isLessThanMaxButAllButPalindromic\n\
    \        val isLessThanMaxButAllButBalanced = max\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnplvz4rx.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButAllButNotPalindromic\e\
    [0m = maxSum - maxWeight > \e[31m0\e[0m && !isPalindromic && !isBalanced && !isLessThanMaxButAllButPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButAllButNotPalindromic is already defined as\
    \ \e[33mvalue\e[0m \e[35misLessThanMaxButAllButNotPalindromic\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnplvz4rx.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxButAllButBalanced\e[0m = maxSum - maxWeight > \e[31m0\e[0m\
    \ && isPalindromic && isBalanced && !isLessThanMaxButAllButPalindromic\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButAllButBalanced is already defined as \e[33mvalue\e\
    [0m \e[35misLessThanMaxButAllButBalanced\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpnplvz4rx.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButAllButNotPalindromic\e\
    [0m = maxSum - maxWeight > \e[31m0\e[0m && !isPalindromic && !isBalanced && !isLessThanMaxButAllButPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButAllButNotPalindromic is already defined as\
    \ \e[33mvalue\e[0m \e[35misLessThanMaxButAllButNotPalindromic\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same "
  stdout: ''
  timestamp: 1660010459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualToMaxSumOfElements = maxSumOfElements <=\
    \ maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndIsBalanced =\
    \ isLessOrEqualToMaxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSumOfElementsAndIsBalanced && isLessOrEqualToMaxSumOfElementsAndIsPalindromic\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ && isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\n     \
    \   val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ && isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsPalindromic\n\
    \        isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfz0xwy_g.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010456
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSumOfElements\
    \ < w\n        isBalanced && isPalindromic && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpac9yk24r.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010435
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessThanMaxSumOfElements = q.foldLeft(0)(_ + _) <=\
    \ maxSumOfElements\n        val isLessThanMaxSumOfElementsButNotBalanced = isLessThanMaxSumOfElements\
    \ && !isBalanced\n        val isLessThanMaxSumOfElementsAndBalanced = isLessThanMaxSumOfElements\
    \ && isBalanced\n        val isLessThanMaxSumOfElementsAndPalindromic = isLessThanMaxSumOfElements\
    \ && isPalindromic\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromic\
    \ = isLessThanMaxSumOfElementsAndBalanced && isPalindromic\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicButNotPalindromic\
    \ = isLessThanMaxSumOfElementsAndBalancedAndPalindromic && !isPalindromic\n  \
    \      val isLessThanMaxSumOfElementsAndBalancedAndPalindromicButNotPalindromicButNotBalanced\
    \ = isLessThanMaxSumOfElementsAndBalancedAndPalindromic && !isPalindromic && !isBalanced\n\
    \        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicButNotPalindromicButNotBalancedAndPalindromic\
    \ = isLessThanMaxSumOfElementsAndBalancedAndPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicButNotPalindromicButNotBalancedAndPalindromicButNotPalindromic\
    \ = isLessThanMaxSumOfElementsAndBalancedAndPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicButNotPalindromicButNotBalancedAndPalindromicButNotPalindromicButNotBalanced\
    \ = isLessThanMaxSumOfElementsAnd\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph4hrgvkr.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmph4hrgvkr.scala:17:55 --------------------\e[0m\e\
    [0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) <= maxSumOfElements\n\e[31m\e[31m   |\e\
    [0m                                                       ^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                                       Found:    Long\n\
    \e[31m   |\e[0m                                                       Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmph4hrgvkr.scala:26:142\
    \ -----------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36misLessThanMaxSumOfElementsAndBalancedAndPalindromicButNotPalindromicButNotBalancedAndPalindromicButNotPalindromicButNotBalanced\e\
    [0m = isLessThanMaxSumOfElementsAnd\n\e[31m\e[31m   |\e[0m                   \
    \                                                                            \
    \                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: isLessThanMaxSumOfElementsAnd\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmph4hrgvkr.scala:27:5\
    \ ---------------------\e[0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong).sum\n\
    \        val isBalanced = sums == maxSum\n        val isPalindromic = q.reverse.forall(x\
    \ => x == x.reverse)\n        val isLessOrEqual = sums <= maxSum\n        isBalanced\
    \ && isPalindromic && isLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1j8cgj9f.scala:15:57 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(\e\
    [36mx\e[0m => x == x.reverse)\n\e[31m\e[31m   |\e[0m                         \
    \                              ^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                    value reverse is not a member of Long\n1 error found\n"
  stdout: ''
  timestamp: 1660010459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualToMaxSumOfElements = maxSumOfElements <=\
    \ maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndBalanced = maxSumOfElements\
    \ <= maxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndPalindromic\
    \ = maxSumOfElements <= maxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromic\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic\n    \
    \    val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSumOfElements\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\n\
    \        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSumOfElementsAndBalanced\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\
    \ && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSumOfElementsAndBalancedPalindromic\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\
    \ && isBalanced && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualToMaxSum\
    \ = maxSumOfElements <= maxSumOfElements && isBalanced && isPalindromic && isLessOrEqualToMaxSum\
    \ && isBalanced && isPalindromic && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndBalancedPalindromicAndLessOrEqualTo\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyn40_g6m.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpyn40_g6m.scala:13:45 --------------------\e[0m\e[0m\n\e[31m13 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpyn40_g6m.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010459
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val isPalindromic = sums.reverse.forall(x => x == sums.head)\n      \
    \  val isBalanced = sums.forall(x => x <= maxSum)\n        isPalindromic && isBalanced\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvj3jof38.scala:19)\n\tat Problem.main(tmpvj3jof38.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ - q.sum <= maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpvyjlywsd.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isBalanced\
    \ = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(_ == q(0))\n\
    \        val isLessThanMaxWeight = maxSum - maxWeight < 0\n        val isLessThanMaxSum\
    \ = maxSum - maxWeight > 0\n        isBalanced && isPalindromic && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpiwbs_zfw.scala:21)\n\tat Problem.main(tmpiwbs_zfw.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010463
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val sums = q.map(x => x.toLong)\n        val isPalindromic = sums.reverse\
    \ == sums\n        val isBalanced = sums.sum == maxSum\n        val isLessThanMaxWeight\
    \ = sums.sum < maxWeight\n        val isLessThanMaxSum = sums.sum < maxSum\n \
    \       isPalindromic && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpe5g60xg8.scala:22)\n\tat Problem.main(tmpe5g60xg8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010464
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual = maxSumOfElements\
    \ <= w\n        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1p72pzl7.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4mwvf4cu.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxSum = maxSumOfElements\
    \ <= maxSum\n        val isLessOrEqualToMaxSumOfElements = maxSumOfElements <=\
    \ maxSumOfElements\n        val isLessOrEqualToMaxSumOfElementsAndIsBalanced =\
    \ isLessOrEqualToMaxSumOfElements && isBalanced\n        val isLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElements && isPalindromic\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSum\n        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\
    \ = isLessOrEqualToMaxSumOfElementsAndIsBalanced && isLessOrEqualToMaxSumOfElements\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElementsAndIsPalindromic && isLessOrEqualToMaxSumOfElementsAndIsBalanced\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsPalindromic\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSumOfElementsAndIsPalindromic\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSum\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements && isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElements\n\
    \        val isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ && isLessOrEqualToMaxSumOfElementsAndIsLess\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuz4t7pph.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpuz4t7pph.scala:25:209 -----------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\e\
    [0m = isLessOrEqualToMaxSumOfElementsAndIsLessOrEqualToMaxSumOfElementsAndIsBalanced\
    \ && isLessOrEqualToMaxSumOfElementsAndIsLess\n\e[31m\e[31m   |\e[0m         \
    \                                                                            \
    \                                                                            \
    \                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                     Not found: isLessOrEqualToMaxSumOfElementsAndIsLess\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpuz4t7pph.scala:26:5\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010446
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sumOfElements = q.foldLeft(0)(_\
    \ + _)\n        sumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpku7kcy3a.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val sums = q.map(x => x.toLong)\n        val isBalanced = sums.forall(x =>\
    \ x == sums.sum)\n        val isPalindromic = sums.forall(x => x == sums.reverse.sum)\n\
    \        isBalanced && isPalindromic && sums.sum < maxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjgazb5ks.scala:20)\n\tat Problem.main(tmpjgazb5ks.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val maxSums = sums.map(x => x.toLong)\n        val maxSumsReversed =\
    \ maxSums.reverse\n        val maxSumsReversedReversed = maxSumsReversed.reverse\n\
    \        val maxSumsReversedReversedReversed = maxSumsReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversed = maxSumsReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversed = maxSumsReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversed = maxSumsReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversed =\
    \ maxSumsReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReverse\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8j7r5fd5.scala:28:4 ----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8j7r5fd5.scala:23:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp8j7r5fd5.scala:25:12 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in th"
  stdout: ''
  timestamp: 1660010462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.length\n\
    \        val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val maxWeightOfElements\
    \ = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements <= maxWeight\
    \ && maxWeightOfElements <= maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqualToMaxWeight = maxSumOfElements <= maxWeight\n\
    \        val isLessOrEqualToMaxSum = maxWeightOfElements <= maxWeight\n      \
    \  isBalanced && isPalindromic && isLessOrEqualToMaxWeight && isLessOrEqualToMaxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpux9k4x32.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpux9k4x32.scala:15:48 --------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mmaxWeightOfElements\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \            ^^^^^\e[0m\n\e[31m   |\e[0m                                     \
    \           Found:    Long\n\e[31m   |\e[0m                                  \
    \              Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.sum\n\
    \        val maxWeightPalindromic = maxWeight / 2\n        val maxWeightPalindromicPalindromic\
    \ = maxWeightPalindromic / 2\n        val maxWeightPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromic / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromic / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromic / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromic / 2\n   \
    \     val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromic / 2\n   \
    \     val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ / 2\n        val maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = maxWeightPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmprd36m98v.scala:24:5\
    \ ---------------------\e[0m\e[0m\n\e[31m24 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010464
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum < maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = maxSum < maxWeight && isBalanced\n        val isLessThanMaxAndPalindromic\
    \ = maxSum < maxWeight && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic\n    \
    \    val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalanced\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\n\
    \        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isBalanced\
    \ && !isPalindromic && !isPalindromic && !isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotPalindromicAndNotBalancedAndNotPalindromicAndNotPalindromicAndNotPalindromicAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpoap10qf7.scala:26:4 ----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpoap10qf7.scala:26:5 ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010464
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxWeight\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        val isLessThanMaxWeight = maxSumOfElements < maxWeight\n        val isLessThanMaxSum\
    \ = maxSumOfElements < maxSum\n        val isLessThanMaxSumOfElements = maxSumOfElements\
    \ < maxSumOfElements\n        val isLessThanMaxSumOfElementsAndBalanced = isLessThanMaxSumOfElements\
    \ && isBalanced\n        val isLessThanMaxSumOfElementsAndPalindromic = isLessThanMaxSumOfElements\
    \ && isPalindromic\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromic\
    \ = isLessThanMaxSumOfElementsAndBalanced && isPalindromic\n        val isLessThanMaxSumOfElementsAndBalancedAndPalindromicAndLessThanMaxWeight\
    \ = isLessThanMaxSumOfElementsAndBalanced && isPalindromic && isLessThanMaxWeight\n\
    \        isLessThanMaxSumOfElementsAndBalancedAndPalindromicAndLessThanMaxWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplaeroyg1.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010464
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val isPalindromic = sums.reverse.forall(x => x == x)\n        val isBalanced\
    \ = sums.forall(x => x <= maxSum)\n        isPalindromic && isBalanced\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpbnh1lg2s.scala:20)\n\tat Problem.main(tmpbnh1lg2s.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010379
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == _)\n        val isBalanced = maxSum < maxWeight\n  \
    \      val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalanced\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced\n      \
    \  val isLessThanMaxButBalancedAndPalindromicAndBalanced = maxSum < maxWeight\
    \ && isBalanced && isPalindromic && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic =\
    \ maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\n\
    \        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n        val isLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && \n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmplnt22ty9.scala:27:167 --------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && \n\e[31m\e[31m   |\e[0m                                                 \
    \                                                                            \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                            expression expected but \e[31m'}'\e[0m found\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmplnt22ty9.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e[0m\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmplnt22ty9.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromicAndBalancedAndPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && !isPalindromic\
    \ && isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPa"
  stdout: ''
  timestamp: 1660010465
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqual = maxSumOfElements\
    \ <= w\n        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1p72pzl7.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010353
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        isBalanced && isPalindromic\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp4mwvf4cu.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010440
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = isLessThanMax && isBalanced\n        val isLessThanMaxAndPalindromic = isLessThanMax\
    \ && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromic = isLessThanMaxAndBalanced\
    \ && isPalindromic\n        isLessThanMaxAndBalancedAndPalindromic\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpeo0ofjbe.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010467
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sum = 0L\n        for (i <-\
    \ 0 until q.length) {\n            sum += q(i)\n        }\n        sum < maxSum\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpzyrlvq7v.scala:15:16 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m            sum += q(i)\n\e[31m\e[31m   |\e[0m      \
    \      ^^^^^^\e[0m\n\e[31m   |\e[0m            value += is not a member of Long\
    \ - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010466
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.sum\n\
    \        val maxSumLessOrEqual = maxSum - maxWeight\n        val maxWeightLessOrEqual\
    \ = maxWeight - maxSum\n        val palindromic = q.reverse.forall(_ == q.head)\n\
    \        val balanced = palindromic && q.sum <= maxSumLessOrEqual\n        val\
    \ unbalanced = palindromic && q.sum > maxSumLessOrEqual\n        val unbalancedLessOrEqual\
    \ = unbalanced && q.sum <= maxWeightLessOrEqual\n        val balancedLessOrEqual\
    \ = balanced && q.sum > maxWeightLessOrEqual\n        val unbalancedLessOrEqualLessOrEqual\
    \ = unbalancedLessOrEqual && balancedLessOrEqual\n        val unbalancedLessOrEqualLessOrEqualLessOrEqual\
    \ = unbalancedLessOrEqualLessOrEqual && unbalancedLessOrEqual\n        val unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqual\
    \ = unbalancedLessOrEqualLessOrEqualLessOrEqual && unbalancedLessOrEqualLessOrEqual\n\
    \        val unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\
    \ = unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqual && unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqual\n\
    \        val unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\
    \ = unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\n\
    \        val unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\
    \ = unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\n\
    \        val unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\
    \ = unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\n\
    \        val unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\
    \ = unbalancedLessOrEqualLessOrEqualLessOrEqual\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp2uuttv_x.scala:26:102 --------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36munbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\e\
    [0m = unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                              ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp2uuttv_x.scala:27:113 --------------------------\e[0m\e[0m\n\e[31m27\
    \ |\e[0m        \e[33mval\e[0m \e[36munbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\e\
    [0m = unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                         ^\e[0m\n\e[31m   |\e\
    [0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  unbalancedLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqualLessOrEqual\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp2uuttv_x.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010467
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMaxSum = maxSumOfElements\
    \ < maxSum\n        val isLessThanMaxSumOfElements = maxSumOfElements < maxSumOfElements.toLong\n\
    \        val isLessThanMaxSumOfElementsOfElements = maxSumOfElements.toLong <\
    \ maxSumOfElements.toLong * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElements\
    \ = maxSumOfElements.toLong * q.length < maxSumOfElements.toLong * q.length *\
    \ q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements.toLong * q.length * q.length * q.length < maxSumOfElements.toLong\
    \ * q.length * q.length * q.length * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements.toLong * q.length * q.length * q.length * q.length * q.length\
    \ < maxSumOfElements.toLong * q.length * q.length * q.length * q.length * q.length\n\
    \        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements.toLong * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length < maxSumOfElements.toLong * q.length * q.length * q.length\
    \ * q.length * q.length * q.length * q.length\n        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = maxSumOfElements.toLong * q.length * q.length * q.length * q.length * q.length\
    \ * q.length * q.length * q.length < maxSumOfElements.toLong * q.length * q.length\
    \ * q.length * q.length * q.length * q.length * q.length * q.length * q.length\n\
    \        val isLessThanMaxSumOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = max\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpomxuden2.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpomxuden2.scala:25:5 ---------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010471
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sumOfElements = q.foldLeft(0)(_\
    \ + _)\n        sumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpku7kcy3a.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong * q.length\n\
    \        val sum = 0L\n        q.foreach { x => sum += x }\n        sum < maxSum\
    \ && sum >= maxWeight\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp7l61kamy.scala:15:29 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        q.foreach { \e[36mx\e[0m => sum += x }\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      value += is not a member of Long - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010470
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val balanced = maxSumOfElements <= maxSum\n        val palindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isBalanced = balanced && palindromic && isPalindromic\n\
    \        isBalanced\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptgpesa4e.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010475
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q.head)\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndIsPalindromic\
    \ = maxSum < maxWeight && !isBalance\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpim6xb8jb.scala:21:12 ---------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndIsPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndIsPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndIsPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpim6xb8jb.scala:22:12 ---------------------------\e[0m\e[0m\n\e[31m22\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndIsPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndIsPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndIsPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpim6xb8jb.scala:23:12 ---------------------------\e[0m\e[0m\n\e[31m23\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndIsPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndIsPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndIsPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpim6xb8jb.scala:24:12 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButB"
  stdout: ''
  timestamp: 1660010478
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isBalanced\
    \ = q.length == q.reverse.length && maxSum == maxWeight\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSum < maxWeight\n\
    \        isBalanced && isPalindromic && isLessThanMax\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9mjaq4kv.scala:20)\n\tat Problem.main(tmp9mjaq4kv.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010481
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sumOfElements = q.foldLeft(0)(_\
    \ + _)\n        sumOfElements <= maxSum\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpku7kcy3a.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010352
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val maxSumLessOrEqualToMaxWeight\
    \ = maxSum < maxWeight\n        val isPalindromic = q.isPalindromic\n        val\
    \ isBalanced = isPalindromic && q.size == q.size/2\n        val isLessOrEqualToMaxWeight\
    \ = maxSumLessOrEqualToMaxWeight && isBalanced\n        isLessOrEqualToMaxWeight\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpbokj6spk.scala:15:30 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isPalindromic\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                       value isPalindromic is not a member of List[Long]\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxSumOfElements = q.foldLeft(0)(_\
    \ + _)\n        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessOrEqualToMaxWeight = maxSumOfElements\
    \ <= w\n        isBalanced && isPalindromic && isLessOrEqualToMaxWeight\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_wv_g6fi.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMaxWeight = maxSum < maxWeight\n        val isLessThanMaxSum\
    \ = maxSum < maxWeight\n        isPalindromic && isBalanced && isLessThanMaxWeight\
    \ && isLessThanMaxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp55wm2lay.scala:14:45 -----------------------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_\
    \ == q)\n\e[31m\e[31m   |\e[0m                                             ^^^^^^\e\
    [0m\n\e[31m   |\e[0m    Values of types Long and List[Long] cannot be compared\
    \ with == or !=\n1 error found\n"
  stdout: ''
  timestamp: 1660010478
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.foldLeft(0)(_ + _)\n\
    \        sums <= maxSum\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9i0d7ai9.scala:13:33\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msums\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                                 Found:\
    \    Long\n\e[31m   |\e[0m                                 Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    1 error found\n"
  stdout: ''
  timestamp: 1660010479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val isPalindromic = sums.reverse == sums\n        val isBalanced = sums.sum\
    \ == maxSum\n        isPalindromic && isBalanced\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3j4g4e8r.scala:19)\n\tat Problem.main(tmp3j4g4e8r.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010484
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isBalanced\
    \ = maxSum < maxWeight\n        val isPalindromic = q.reverse.forall(x => x ==\
    \ q(0))\n        isBalanced && isPalindromic\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpm4kflhif.scala:19)\n\tat Problem.main(tmpm4kflhif.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010438
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessOrEqual = maxSum < maxWeight\n        isPalindromic && isBalanced\
    \ && isLessOrEqual\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpvwvn51c2.scala:20)\n\tat Problem.main(tmpvwvn51c2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010484
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.reverse.forall(x => x == q.head)\n        val isBalanced = maxSum < maxWeight\n\
    \        val isLessOrEqual = maxSum == maxWeight\n        isPalindromic && isBalanced\
    \ && isLessOrEqual\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpz502_v9f.scala:20)\n\tat Problem.main(tmpz502_v9f.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.map(x => x.toLong)\n\
    \        val maxSums = sums.map(x => x.toLong)\n        val maxSumsReversed =\
    \ maxSums.reverse\n        val maxSumsReversedReversed = maxSumsReversed.reverse\n\
    \        val maxSumsReversedReversedReversed = maxSumsReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversed = maxSumsReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversed = maxSumsReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversed = maxSumsReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversed =\
    \ maxSumsReversedReversedReversedReversedReversedReversed.reverse\n        val\
    \ maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \        val maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqm87p0gp.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  maxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqm87p0gp.scala:22:94 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e[36mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = maxSumsReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: maxSumsReversedReversedReversedReversedReversedReversedReversedReversed\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqm87p0gp.scala:23:102\
    \ -----------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mmaxSumsReversedReversedReversedReversedReversedReversedReversedReversedReversedReversed\e\
    [0m = maxSumsReversedReversedReversedReversedReversedReversedReversedReversed.reverse\n\
    \e[31m\e[31m   |\e[0m                               "
  stdout: ''
  timestamp: 1660010483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isLessThanMax = maxSumOfElements\
    \ < w\n        val isLessThanMaxAndBalanced = isLessThanMax && isBalanced\n  \
    \      val isLessThanMaxAndPalindromic = isLessThanMax && isPalindromic\n    \
    \    val isLessThanMaxAndBalancedAndPalindromic = isLessThanMaxAndBalanced &&\
    \ isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZero\
    \ = isLessThanMaxAndBalancedAndPalindromic && isPalindromic && q(0) > 0\n    \
    \    val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegative = isLessThanMaxAndBalancedAndPalindromicAndNotZero\
    \ && isPalindromic && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegativeAndNotNegative\
    \ = isLessThanMaxAndBalancedAndPalindromicAndNotZero && isPalindromic && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegativeAndNotNegativeAndNotNegative\
    \ = isLessThanMaxAndBalancedAndPalindromicAndNotZero && isPalindromic && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegativeAndNotNegativeAndNotNegativeAndNotNegative\
    \ = isLessThanMaxAndBalancedAndPalindromicAndNotZero && isPalindromic && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0\
    \ && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0)\
    \ > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0 && q(0) > 0\
    \ && q(0) > 0 && q(0) > 0 && q(0\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt4ahc78_.scala:25:4 ----------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpt4ahc78_.scala:13:45 --------------------\e[0m\e[0m\n\e[31m13 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSumOfElements\e[0m = q.foldLeft(\e[31m0\e[0m)(_\
    \ + _)\n\e[31m\e[31m   |\e[0m                                             ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                             Found:    Long\n\
    \e[31m   |\e[0m                                             Required: Int\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt4ahc78_.scala:24:453\
    \ -------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotNegativeAndNotNegativeAndNotNegativeAndNotNegative\e\
    [0m = isLessThanMaxAndBalancedAndPalindromicAndNotZero && isPalindromic && q(\e\
    [31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m)\
    \ > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e\
    [0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e\
    [31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m)\
    \ > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e\
    [0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e\
    [31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m)\
    \ > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e\
    [0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m) > \e[31m0\e[0m && q(\e\
    [31m0\e[0m) > \e[31m0\e[0m && q(\e[31m0\e[0m\n\e[31m\e[31m   |\e[0m          \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                                                            \
    \                                     "
  stdout: ''
  timestamp: 1660010486
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val sumOfElements = q.foldLeft(0)(_ + _)\n        sumOfElements <= maxSum\
    \ && sumOfElements <= maxWeight\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpur6q12t5.scala:14:42\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010485
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduce(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum < maxWeight\n  \
    \      val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxAndBalanced\
    \ = maxSum < maxWeight && isBalanced\n        val isLessThanMaxAndBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZero\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && q.forall(_ != 0)\n  \
    \      val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZero = maxSum\
    \ < maxWeight && isBalanced && isPalindromic && q.forall(_ != 0 && _ != 0)\n \
    \       val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && q.forall(_ != 0 && _\
    \ != 0 && _ != 0)\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && q.forall(_ != 0 && _\
    \ != 0 && _ != 0 && _ != 0)\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && q.forall(_ != 0 && _\
    \ != 0 && _ != 0 && _ != 0 && _ != 0)\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && q.forall(_ != 0 && _\
    \ != 0 && _ != 0 && _ != 0 && _ != 0 && _ != 0)\n        val isLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && q.forall(_ != 0 && \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmprf0fy1fj.scala:25:194 --------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZeroAndNotZero\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && q.forall(_ != \e[31m0\e\
    [0m && \n\e[31m\e[31m   |\e[0m                                               \
    \                                                                            \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0m                                       expression expected but\
    \ \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- Error: /tmp/tmprf0fy1fj.scala:14:45\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m14 |\e[0m       \
    \ \e[33mval\e[0m \e[36misPalindromic\e[0m = q.reverse.forall(_ == q)\n\e[31m\e\
    [31m   |\e[0m                                             ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m    Values of types Long and List[Long] cannot be compared with == or\
    \ !=\n\e[31m\e[31m-- [E086] Syntax Error: /tmp/tmprf0fy1fj.scala:20:135 --------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZero\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && q.forall(_ != \e[31m0\e\
    [0m && _ != \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                             \
    \                                                                            \
    \                              ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                         Wrong number of parameters, expected: 1\n\e[31m\e[31m--\
    \ [E086] Syntax Error: /tmp/tmprf0fy1fj.scala:21:145 --------------------------\e\
    [0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxAndBalancedAndPalindromicAndNotZeroAndNotZeroAndNotZero\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && q.forall(_ != \e[31m0\e\
    [0m && _ != \e[31m0\e[0m && _ != \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        \
    \                                                    "
  stdout: ''
  timestamp: 1660010487
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum - maxWeight\
    \ < 0\n        val isLessThanMaxWeight = maxSum - maxWeight > 0\n        val isLessThanMaxSum\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxSumAndBalanced = maxSum -\
    \ maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromic = maxSum\
    \ - maxWeight < 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalanced\
    \ = maxSum - maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalanced\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = maxSum - maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = maxSum - maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = maxSum - maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = maxSum - maxWeight < 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ = maxSum - maxWeight > 0\n        val isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAnd\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_kbjowyn.scala:30:4 ----------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp_kbjowyn.scala:24:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36misLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\e\
    [0m = maxSum - maxWeight > \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp_kbjowyn.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\e\
    [0m = maxSum - maxWeight < \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  isLessThanMaxSumAndBalancedAndPalindromicAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalancedAndUnbalanced\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp_kbjowyn.scala:30:5 ---------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m    }"
  stdout: ''
  timestamp: 1660010484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum\
    \ == maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi2qxtfuw.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val sum = 0L\n        q.foreach(x => sum += x)\n        sum < maxSum && sum\
    \ <= maxWeight\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpo92jyahh.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        q.foreach(\e[36mx\e[0m => sum += x)\n\e[31m\e\
    [31m   |\e[0m                       ^^^^^^\e[0m\n\e[31m   |\e[0m             \
    \    value += is not a member of Long - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010485
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sums = q.foldLeft(new mutable.HashMap[Long,\
    \ Long]()) { (acc, x) => acc + (x -> (acc.getOrElse(x, 0) + 1)) }\n        val\
    \ maxSums = sums.foldLeft(new mutable.HashMap[Long, Long]()) { (acc, x) => acc\
    \ + (x -> (acc.getOrElse(x, 0) + 1)) }\n        sums.forall { case (k, v) => k\
    \ <= maxSum && v <= maxSums }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_1p0ne8d.scala:13:34 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = q.foldLeft(\e\
    [33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()) { (\e[36macc\e\
    [0m, \e[36mx\e[0m) => acc + (x -> (acc.getOrElse(x, \e[31m0\e[0m) + \e[31m1\e\
    [0m)) }\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                                  Not found: mutable\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp_1p0ne8d.scala:13:83 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = q.foldLeft(\e\
    [33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()) { (\e[36macc\e\
    [0m, \e[36mx\e[0m) => acc + (x -> (acc.getOrElse(x, \e[31m0\e[0m) + \e[31m1\e\
    [0m)) }\n\e[31m\e[31m   |\e[0m                                               \
    \                                ^^^^^\e[0m\n\e[31m   |\e[0mvalue + is not a member\
    \ of Any, but could be made available as an extension method.\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mOne of the following imports might make progress towards fixing\
    \ the problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Fractional.Implicits.infixFractionalOps\n\
    \e[31m   |\e[0m  import math.Integral.Implicits.infixIntegralOps\n\e[31m   |\e\
    [0m  import math.Numeric.Implicits.infixNumericOps\n\e[31m   |\e[0m\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp_1p0ne8d.scala:13:96 ------------------------\e\
    [0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msums\e[0m = q.foldLeft(\e\
    [33mnew\e[0m mutable.HashMap[\e[35mLong\e[0m, \e[35mLong\e[0m]()) { (\e[36macc\e\
    [0m, \e[36mx\e[0m) => acc + (x -> (acc.getOrElse(x, \e[31m0\e[0m) + \e[31m1\e\
    [0m)) }\n\e[31m\e[31m   |\e[0m                                               \
    \                                             ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                                  value getOrElse is not a member of Any\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp_1p0ne8d.scala:14:27 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSums\e[0m "
  stdout: ''
  timestamp: 1660010488
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isBalanced = maxSum == maxWeight\n        val isPalindromic = q.reverse.forall(x\
    \ => x == q(0))\n        val isLessOrEqual = maxSum < maxWeight\n        val isMoreOrEqual\
    \ = maxSum > maxWeight\n        isBalanced && isPalindromic && isLessOrEqual &&\
    \ isMoreOrEqual\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppx3yhbbm.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010487
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val sum = 0L\n        q.foreach\
    \ { x => sum += x }\n        sum < maxSum && sum == q.reverse.sum\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmps2wrs2r5.scala:14:29 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        q.foreach { \e[36mx\e[0m => sum += x }\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \      value += is not a member of Long - did you mean sum.!=?\n1 error found\n"
  stdout: ''
  timestamp: 1660010487
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = q.forall(x\
    \ => x == q(0)) && q.forall(x => x == q(q.length-1))\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < w\n        isPalindromic\
    \ && isBalanced && isLessThanMaxWeight && isLessThanMaxSum\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpw38dg9fj.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010487
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpdu_yz8b0.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010487
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val sumOfQ = q.sum\n        val isPalindromic =\
    \ q.reverse.forall(_ == q.head)\n        val isBalanced = sumOfQ <= maxWeight\n\
    \        val isLessThanMaxWeight = sumOfQ < maxWeight\n        val isLessThanMaxWeightAndBalanced\
    \ = sumOfQ < maxWeight && isBalanced\n        val isLessThanMaxWeightAndPalindromic\
    \ = sumOfQ < maxWeight && isPalindromic\n        val isLessThanMaxWeightAndBalancedPalindromic\
    \ = sumOfQ < maxWeight && isPalindromic && isBalanced\n        val isLessThanMaxWeightAndBalancedAndPalindromic\
    \ = sumOfQ < maxWeight && isPalindromic && isBalanced && isLessThanMaxWeight\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicPalindromic = sumOfQ\
    \ < maxWeight && isPalindromic && isBalanced && isLessThanMaxWeightAndPalindromic\n\
    \        val isLessThanMaxWeightAndBalancedAndPalindromicPalindromicPalindromic\
    \ = sumOfQ < maxWeight && isPalindromic && isBalanced && isLessThanMaxWeightAndPalindromic\
    \ && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromicPalindromicPalindromicPalindromic\
    \ = sumOfQ < maxWeight && isPalindromic && isBalanced && isLessThanMaxWeightAndPalindromic\
    \ && isPalindromic && isLessThanMaxWeight\n        val isLessThanMaxWeightAndBalancedAndPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = sumOfQ < maxWeight && isPalindromic && isBalanced && isLessThanMaxWeightAndPalindromic\
    \ && isPalindromic && isLessThanMaxWeight && isPalindromic\n        val isLessThanMaxWeightAndBalancedAndPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\
    \ = sumOfQ < maxWeight && isPalindromic && isBalanced && isLessThanMaxWeightAndPalindromic\
    \ && isPalindrom\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2la38i9x.scala:25:204 -----------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxWeightAndBalancedAndPalindromicPalindromicPalindromicPalindromicPalindromicPalindromic\e\
    [0m = sumOfQ < maxWeight && isPalindromic && isBalanced && isLessThanMaxWeightAndPalindromic\
    \ && isPalindrom\n\e[31m\e[31m   |\e[0m                                      \
    \                                                                            \
    \                                                                            \
    \              ^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                             \
    \                     Not found: isPalindrom\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp2la38i9x.scala:26:5 ---------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010490
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.sum\n        val maxSumOfElementsLessOrEqualToMax\
    \ = maxSumOfElements.toLong <= maxSum\n        val isPalindromic = q.isEmpty ||\
    \ q.reverse.forall(x => x == q(0))\n        val isBalanced = isPalindromic &&\
    \ maxSumOfElementsLessOrEqualToMax\n        val isFlipped = q.forall(x => x ==\
    \ q.reverse(0))\n        isBalanced && isFlipped\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l))\
    \ == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l))\
    \ == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpdtpxcwb2.scala:21)\n\tat Problem.main(tmpdtpxcwb2.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010492
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum == maxWeight\n\
    \        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedButBalanced\
    \ = maxSum < maxWeight && !isBalanced && isBalanced\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && !isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\n\
    \        val isLessThanMaxButBalancedButNotPalindromic = maxSum < maxWeight &&\
    \ isBalanced && !isPalindromic && !isLessThanMaxButNotBalancedButPalindromic\n\
    \        val isLessThanMaxButNotBalancedButPalindromic = maxSum < maxWeight &&\
    \ !isBalanced && isPalindromic && !isLessThanMaxButBalancedButPalindromic\n  \
    \      val isLessThanMaxButBalancedButPalindromic = maxSum < maxWeight && isBalanced\
    \ && isPalindromic && !isLessThanMaxButNotBalancedButNotPalindromic\n        val\
    \ isLessThanMaxButNotBalancedButNotPalindromic = maxSum < maxWeight && !isBalanced\
    \ && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic && !isLessThanMaxButNotBalancedButPalindromic\
    \ && !\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1630107a.scala:24:12 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && !isLessThanMaxButBalancedButNotPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButNotPalindromic\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1630107a.scala:25:12 ---------------------------\e[0m\e[0m\n\e[31m25\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedButNotPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && !isPalindromic && !isLessThanMaxButNotBalancedButPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedButNotPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedButNotPalindromic\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp1630107a.scala:26:12 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedButPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && isPalindromic && !isLessThanMaxButBalancedButPalindromic\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedButPalindromic is already defined\
    \ as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedButPalindromic\e[0m\n\e"
  stdout: ''
  timestamp: 1660010493
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isPalindromic = maxSumOfElements\
    \ == maxSum\n        val isBalanced = maxSumOfElements <= maxWeight\n        val\
    \ isLessThanMaxWeight = maxSumOfElements < maxWeight\n        val isLessThanMaxSum\
    \ = maxSumOfElements < maxSum\n        val isLessThanMaxSumOfElements = maxSumOfElements\
    \ < maxSumOfElements\n        val isLessThanMaxSumOfElementsAndBalanced = maxSumOfElements\
    \ < maxSumOfElements && maxSumOfElements <= maxWeight\n        val isLessThanMaxSumOfElementsAndPalindromic\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && maxSumOfElements\
    \ == maxSumOfElements.reverse\n        val isLessThanMaxSumOfElementsAndBalancedPalindromic\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && maxSumOfElements\
    \ == maxSumOfElements.reverse\n        val isLessThanMaxSumOfElementsAndPalindromicBalanced\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && maxSumOfElements\
    \ == maxSumOfElements.reverse\n        val isLessThanMaxSumOfElementsAndBalancedPalindromicBalanced\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && maxSumOfElements\
    \ == maxSumOfElements.reverse\n        val isLessThanMaxSumOfElementsAndPalindromicBalancedPalindromic\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && maxSumOfElements\
    \ == maxSumOfElements.reverse && maxSumOfElements == maxSumOfElements.reverse.reverse\n\
    \        val isLessThanMaxSumOfElementsAndBalancedPalindromicBalancedPalindromic\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && maxSumOfElements\
    \ == maxSumOfElements.reverse && maxSumOfElements == maxSumOfElements.reverse.reverse.reverse\n\
    \        val isLessThanMaxSumOfElementsAndPalindromicBalancedPalindromicBalanced\
    \ = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight && max\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp2fejd3q2.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp2fejd3q2.scala:21:164 -----------------------\e[0m\e\
    [0m\n\e[31m21 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumOfElementsAndPalindromic\e\
    [0m = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight &&\
    \ maxSumOfElements == maxSumOfElements.reverse\n\e[31m\e[31m   |\e[0m        \
    \                                                                            \
    \                                                               ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                    value reverse is not a\
    \ member of Int\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp2fejd3q2.scala:22:172\
    \ -----------------------\e[0m\e[0m\n\e[31m22 |\e[0m        \e[33mval\e[0m \e\
    [36misLessThanMaxSumOfElementsAndBalancedPalindromic\e[0m = maxSumOfElements <\
    \ maxSumOfElements && maxSumOfElements <= maxWeight && maxSumOfElements == maxSumOfElements.reverse\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                       ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                             value reverse is not a member of Int\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp2fejd3q2.scala:23:172 -----------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxSumOfElementsAndPalindromicBalanced\e\
    [0m = maxSumOfElements < maxSumOfElements && maxSumOfElements <= maxWeight &&\
    \ maxSumOfElements == maxSumOfElements.reverse\n\e[31m\e[31m   |\e[0m        \
    \                                   "
  stdout: ''
  timestamp: 1660010496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val maxSumOfElements = q.foldLeft(0)(_ + _)\n\
    \        val isBalanced = maxSumOfElements <= maxSum\n        val isPalindromic\
    \ = q.reverse.forall(x => x == q.head)\n        val isLessOrEqual = maxSumOfElements\
    \ <= w\n        isBalanced && isPalindromic && isLessOrEqual\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx2qanz_w.scala:13:45\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010494
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.reverse.forall(_ == q)\n        val isBalanced = maxSum == maxWeight\n \
    \       val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotBalancedAndPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic\n  \
    \      val isLessThanMaxButBalancedAndPalindromicButNotPalindromic = maxSum <\
    \ maxWeight && isBalanced && isPalindromic && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isPalindromic\n\
    \        val isLessThanMaxButBalancedAndPalindromicButNotPalindromic = maxSum\
    \ < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isPalindromic\
    \ && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic && !isPalindromic\
    \ && !isPalindromic\n        val isLessThanMaxButBalancedAndPalindromicButNotPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isPalindromic\
    \ && !isPalindromic && !isPalindromic\n        val isLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ = max\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpaq83oulp.scala:23:12 ---------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic &&\
    \ !isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\
    \ is already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaq83oulp.scala:24:12 ---------------------------\e[0m\e[0m\n\e\
    [31m24 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButBalancedAndPalindromicButNotPalindromic\e\
    [0m = maxSum < maxWeight && isBalanced && isPalindromic && !isPalindromic && !isPalindromic\
    \ && !isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misLessThanMaxButBalancedAndPalindromicButNotPalindromic is\
    \ already defined as \e[33mvalue\e[0m \e[35misLessThanMaxButBalancedAndPalindromicButNotPalindromic\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpaq83oulp.scala:25:12 ---------------------------\e[0m\e[0m\n\e\
    [31m25 |\e[0m        \e[33mval\e[0m \e[36misLessThanMaxButNotBalancedAndPalindromicButNotPalindromic\e\
    [0m = maxSum < maxWeight && !isBalanced && !isPalindromic && !isPalindromic &&\
    \ !isPalindromic && !isPalindromic\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010495
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(_ == q.head)\n        val isBalanced = maxSum\
    \ == maxWeight\n        isPalindromic && isBalanced\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)),\
    \ (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi2qxtfuw.scala:13:35\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36mmaxSum\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                  ^^^^^\e[0m\n\e[31m   |\e[0m                               \
    \    Found:    Long\n\e[31m   |\e[0m                                   Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010372
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.foldLeft(0)(_ + _)\n        val\
    \ isPalindromic = q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessThanMaxWeight = maxSum < maxWeight\n       \
    \ val isLessThanMaxSum = maxSum < maxWeight\n        val isLessThanMaxSumAndBalanced\
    \ = maxSum < maxWeight && maxSum == maxWeight\n        val isLessThanMaxSumAndPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic\n        val isLessThanMaxSumAndBalancedPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced\n\
    \        val isLessThanMaxSumAndBalancedPalindromicAndPalindromic = maxSum < maxWeight\
    \ && maxSum == maxWeight && isPalindromic && isBalanced && isPalindromic\n   \
    \     val isLessThanMaxSumAndBalancedPalindromicAndPalindromicAndBalanced = maxSum\
    \ < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced && isPalindromic\
    \ && isBalanced\n        val isLessThanMaxSumAndBalancedPalindromicAndPalindromicAndBalancedPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced &&\
    \ isPalindromic && isBalanced && isPalindromic\n        val isLessThanMaxSumAndBalancedPalindromicAndPalindromicAndBalancedPalindromicAndBalanced\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced &&\
    \ isPalindromic && isBalanced && isPalindromic && isBalanced\n        val isLessThanMaxSumAndBalancedPalindromicAndPalindromicAndBalancedPalindromicAndBalancedPalindromic\
    \ = maxSum < maxWeight && maxSum == maxWeight && isPalindromic && isBalanced &&\
    \ isPalindromic && isBalanced && isPalindromic && isBalanced && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedPalindromicAndPalindromicAnd\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkdtjpei6.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpkdtjpei6.scala:13:35 --------------------\e[0m\e[0m\n\e[31m13 |\e[0m\
    \        \e[33mval\e[0m \e[36mmaxSum\e[0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e\
    [31m\e[31m   |\e[0m                                   ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                   Found:    Long\n\e[31m   |\e[0m        \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpkdtjpei6.scala:27:5 ---------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m \
    \    Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010495
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val maxSumOfElements = q.foldLeft(0)(_ + _)\n        val isBalanced = maxSumOfElements\
    \ <= maxWeight\n        val isPalindromic = q.reverse.forall(x => x == q(0))\n\
    \        val isLessOrEqualToMax = maxSumOfElements <= maxWeight\n        val isLessOrEqualToMaxOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)(_ + _) <= maxWeight\n        val isLessOrEqualToMaxOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElementsOfElements\
    \ = q.foldLeft(0)\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpznm5fxa_.scala:14:45\
    \ --------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mmaxSumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                            ^^^^^\e[0m\n\e[31m   |\e[0m                     \
    \                        Found:    Long\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmpznm5fxa_.scala:18:57 --------------------\e[0m\e\
    [0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) <= maxWeight\n\e[31m\e[31m   |\e[0m    \
    \                                                     ^^^^^\e[0m\n\e[31m   |\e\
    [0m                                                         Found:    Long\n\e\
    [31m   |\e[0m                                                         Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpznm5fxa_.scala:19:67\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxOfElementsOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) <= maxWeight\n\e[31m\e[31m   |\e[0m    \
    \                                                               ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                                          Found:\
    \    Long\n\e[31m   |\e[0m                                                   \
    \       Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpznm5fxa_.scala:20:77\
    \ --------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m \e[36misLessOrEqualToMaxOfElementsOfElementsOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _) <= maxWeight\n\e[31m\e[31m   |\e[0m    \
    \                                                                         ^^^^^\e\
    [0m\n\e[31m   |\e[0m                                                         \
    \ F"
  stdout: ''
  timestamp: 1660010497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.reduceLeft(_ + _)\n        val isPalindromic\
    \ = q.isEmpty || q.reverse.forall(x => x == q(0))\n        val isBalanced = maxSum\
    \ == maxWeight\n        val isLessThanMax = maxSum < maxWeight\n        val isLessThanMaxButNotBalanced\
    \ = maxSum < maxWeight && !isBalanced\n        val isLessThanMaxButBalanced =\
    \ maxSum < maxWeight && isBalanced\n        val isLessThanMaxButNotPalindromic\
    \ = maxSum < maxWeight && !isPalindromic\n        val isLessThanMaxButPalindromic\
    \ = maxSum < maxWeight && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic\n        val isLessThanMaxButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic\n        val isLessThanMaxButNotPalindromicButBalancedButPalindromic\
    \ = maxSum < maxWeight && !isPalindromic && isBalanced && isPalindromic\n    \
    \    val isLessThanMaxButPalindromicButBalancedButPalindromic = maxSum < maxWeight\
    \ && isPalindromic && isBalanced && isPalindromic\n        val isLessThanMaxButNotBalancedButPalindromicButBalancedButPalindromic\
    \ = maxSum < maxWeight && !isBalanced && !isPalindromic && isBalanced && isPalindromic\
    \ && isPalindromic\n        val isLessThanMaxButBalancedButPalindromicButBalancedButPalindromic\
    \ = maxSum < maxWeight && isBalanced && isPalindromic && isBalanced && isPalindromic\
    \ && isPalindromic\n        val isLessThanMaxButNotPalindromicButBalancedButPalindromicButBalancedButPalindromic\
    \ = maxSum < maxWeight && !isPalindromic && isBalanced && isPalindromic && isBalanced\
    \ && isPalindromic && isPalindromic\n        val isLessThanMaxButPalindromicButBalancedButPalindromic\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxocwnzwd.scala:29:4 ----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpxocwnzwd.scala:29:5 ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010496
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val maxSum = q.sum\n        val isPalindromic =\
    \ q.isPalindromic\n        val isBalanced = q.isBalanced\n        val isLessThanMaxWeight\
    \ = maxSum < maxWeight\n        val isLessThanMaxSum = maxSum < q.sum\n      \
    \  val isLessThanMaxSumAndBalanced = maxSum < q.sum && isBalanced\n        val\
    \ isLessThanMaxSumAndPalindromic = maxSum < q.sum && isPalindromic\n        val\
    \ isLessThanMaxSumAndBalancedPalindromic = maxSum < q.sum && isBalanced && isPalindromic\n\
    \        val isLessThanMaxSumAndBalancedAndPalindromic = maxSum < q.sum && isBalanced\
    \ && isPalindromic && isLessThanMaxWeight\n        val isLessThanMaxSumAndBalancedPalindromicAndPalindromic\
    \ = maxSum < q.sum && isBalanced && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum\n\
    \        val isLessThanMaxSumAndBalancedPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < q.sum && isBalanced && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum\
    \ && isLessThanMaxSumAndBalanced\n        val isLessThanMaxSumAndBalancedPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < q.sum && isBalanced && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum\
    \ && isLessThanMaxSumAndBalanced && isLessThanMaxSumAndPalindromic\n        val\
    \ isLessThanMaxSumAndBalancedPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < q.sum && isBalanced && isPalindromic && isLessThanMaxWeight && isLessThanMaxSum\
    \ && isLessThanMaxSumAndBalanced && isLessThanMaxSumAndPalindromic && isLessThanMaxSumAndBalancedPalindromic\n\
    \        val isLessThanMaxSumAndBalancedPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromicAndPalindromic\
    \ = maxSum < q.\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6n4rgyd3.scala:27:4 ----------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E008] Not Found\
    \ Error: /tmp/tmp6n4rgyd3.scala:14:30 ------------------------\e[0m\e[0m\n\e[31m14\
    \ |\e[0m        \e[33mval\e[0m \e[36misPalindromic\e[0m = q.isPalindromic\n\e\
    [31m\e[31m   |\e[0m                            ^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                       value isPalindromic is not a member of List[Long]\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6n4rgyd3.scala:15:27 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36misBalanced\e[0m = q.isBalanced\n\
    \e[31m\e[31m   |\e[0m                         ^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         value isBalanced is not a member of List[Long]\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp6n4rgyd3.scala:27:5 ---------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: Boolean\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxWeight = w\n        val sumOfElements = q.foldLeft(0)(_ + _)\n    \
    \    sumOfElements <= maxWeight\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (9l)) ==\
    \ (true));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong)), (5l)) ==\
    \ (false));\n    assert(willItFly((List[Long](3l.toLong)), (5l)) == (true));\n\
    \    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)), (1l)) ==\
    \ (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmplx5nge13.scala:13:42\
    \ --------------------\e[0m\e[0m\n\e[31m13 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e\
    [0m = q.foldLeft(\e[31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                 \
    \                         ^^^^^\e[0m\n\e[31m   |\e[0m                        \
    \                  Found:    Long\n\e[31m   |\e[0m                           \
    \               Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010397
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong\n        val sums = q.map(_.toLong)\n        val isPalindromic\
    \ = sums.reverse == sums\n        val isBalanced = sums.sum <= maxSum\n      \
    \  val isLessThanMax = sums.sum < maxSum\n        isPalindromic && isBalanced\
    \ && isLessThanMax\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp6b2rly9c.scala:25)\n\tat Problem.main(tmp6b2rly9c.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // Write a function that returns True if the object q will fly, and False\
    \ otherwise.\n    // The object q will fly if it's balanced (it is a palindromic\
    \ list) and the sum of its elements is less than or equal the maximum possible\
    \ weight w.\n    // Example:\n    // # 1+2 is less than the maximum possible weight,\
    \ but it's unbalanced.\n    // # it's balanced, but 3+2+3 is more than the maximum\
    \ possible weight.\n    // # 3+2+3 is less than the maximum possible weight, and\
    \ it's balanced.\n    // # 3 is less than the maximum possible weight, and it's\
    \ balanced.\n    def willItFly(q : List[Long], w : Long) : Boolean = {\n     \
    \   val maxSum = w.toLong * q.length\n        val maxWeight = w.toLong\n     \
    \   val palindromic = q.reverse.forall(x => x == x.reverse)\n        val sumOfElements\
    \ = q.foldLeft(0)(_ + _)\n        sumOfElements <= maxSum && palindromic && maxWeight\
    \ <= sumOfElements\n    }\n    def main(args: Array[String]) = {\n    assert(willItFly((List[Long](3l.toLong,\
    \ 2l.toLong, 3l.toLong)), (9l)) == (true));\n    assert(willItFly((List[Long](1l.toLong,\
    \ 2l.toLong)), (5l)) == (false));\n    assert(willItFly((List[Long](3l.toLong)),\
    \ (5l)) == (true));\n    assert(willItFly((List[Long](3l.toLong, 2l.toLong, 3l.toLong)),\
    \ (1l)) == (false));\n    assert(willItFly((List[Long](1l.toLong, 2l.toLong, 3l.toLong)),\
    \ (6l)) == (false));\n    assert(willItFly((List[Long](5l.toLong)), (5l)) == (true));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp__9y_t4u.scala:14:55 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mpalindromic\e[0m = q.reverse.forall(\e\
    [36mx\e[0m => x == x.reverse)\n\e[31m\e[31m   |\e[0m                         \
    \                            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                 \
    \                  value reverse is not a member of Long\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp__9y_t4u.scala:15:42 --------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36msumOfElements\e[0m = q.foldLeft(\e\
    [31m0\e[0m)(_ + _)\n\e[31m\e[31m   |\e[0m                                    \
    \      ^^^^^\e[0m\n\e[31m   |\e[0m                                          Found:\
    \    Long\n\e[31m   |\e[0m                                          Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010497
