{
  "language": "scala",
  "name": "HumanEval_152_compare",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSortedByScore = guessesWithScores.sortBy(_._2)\n        val guessesWithScoresSortedByGuess = guessesWithScoresSortedByScore.map(x => (x._1, x._2))\n        val guessesWithScoresSortedByGuessWithCorrect = guessesWithScoresSortedByGuess.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrect = guessesWithScoresSortedByGuess.filter(_._1 == 1)\n        val guessesWithScoresSortedByGuessWithCorrectAndIncorrect = guessesWithScoresSortedByGuessWithCorrect ++ guessesWithScoresSortedByGuessWithIncorrect\n        val guessesWithScoresSortedByGuessWithCorrectAndCorrect = guessesWithScoresSortedByGuessWithCorrect ++ guessesWithScoresSortedByGuessWithCorrect\n        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndCorrect = guessesWithScoresSortedByGuessWithCorrectAndIncorrect ++ guessesWithScoresSortedByGuessWithCorrectAndCorrect\n        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect\n        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrect = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrect\n        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\n        val guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAnd\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpsrh_lg7y.scala:23:147 --------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect\u001b[0m = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrect\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsrh_lg7y.scala:24:92 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrect\u001b[0m = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrect\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNot found: guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndCorrect\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpsrh_lg7y.scala:25:104 -----------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\u001b[0m = guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedByGuessWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660013717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeysSet = gameScoreKeys.toSet\n        val guessScoreKeysSet = guessScoreKeys.toSet\n        val gameScoreValuesSet = gameScoreValues.toSet\n        val guessScoreValuesSet = guessScoreValues.toSet\n        val gameScoreKeysSetSet = gameScoreKeysSet.toSet\n        val guessScoreKeysSetSet = guessScoreKeysSet.toSet\n        val gameScoreValuesSetSet = gameScoreValuesSet.toSet\n        val guessScoreValuesSetSet = guessScoreValuesSet.toSet\n        val gameScoreKeysSetSetSet = gameScoreKeysSetSet.toSet\n        val guessScoreKeysSetSetSet = guessScoreKeysSetSet.toSet\n        val gameScoreValuesSetSetSet = gameScoreValuesSetSet.toSet\n        val guessScoreValuesSetSetSet = guessScoreValuesSetSet.toSet\n        val gameScoreKeysSetSetSetSet = gameScoreKeysSetSetSet.toSet\n        val guessScoreKeysSetSetSetSet = guessScoreKeysSetSetSet.toSet\n        val gameScoreValuesSetSetSetSet = gameScoreValuesSetSet.toSet\n        val guessScoreValuesSetSetSet = guessScoreValuesSetSet.toSet\n        val gameScoreKeysSetSetSetSetSet = gameScoreKeysSetSetSet.toSet\n        val guessScoreKeysSetSetSetSet = guessScoreKeysSetSetSet.toSet\n        val gameScoreValuesSetSetSetSet = gameScoreValuesSetSet.toSet\n        val guessScoreValuesSetSetSet = guessScoreValuesSetSet.toSet\n        val gameScoreKeysSetSetSetSetSet = gameScoreKeysSetSetSet.toSet\n        val guessScoreKeysSetSetSetSet = guessScoreKeysSetSetSet.toSet\n        val gameScoreValuesSetSetSetSet\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp78tn52y7.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp78tn52y7.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValuesSetSetSet\u001b[0m = guessScoreValuesSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValuesSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValuesSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp78tn52y7.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeysSetSetSetSet\u001b[0m = guessScoreKeysSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeysSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeysSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp78tn52y7.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValuesSetSetSetSet\u001b[0m = gameScoreValuesSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValuesSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValuesSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp78tn52y7.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValuesSetSetSet\u001b[0m = guessScoreValuesSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0",
      "stdout": "",
      "timestamp": 1660013719
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesCorrect = guessesScores.filter(_._1 == gameScores.keys)\n        val guessesWrong = guessesScores.filter(_._1 != gameScores.keys)\n        val guessesDiff = guessesWrong.map { case (score, index) => Math.abs(score - gameScores.get(score)) }\n        guessesCorrect.map { case (score, index) => 0 }\n        ++ guessesDiff\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpdk96swc9.scala:15:50 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesCorrect\u001b[0m = guessesScores.filter(_._1 == gameScores.keys)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types Long and Iterable[Long] cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpdk96swc9.scala:16:48 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWrong\u001b[0m = guessesScores.filter(_._1 != gameScores.keys)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mValues of types Long and Iterable[Long] cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpdk96swc9.scala:17:83 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesDiff\u001b[0m = guessesWrong.map { \u001b[33mcase\u001b[0m (score, index) => Math.abs(score - gameScores.get(score)) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments (Option[Int])\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdk96swc9.scala:18:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        guessesCorrect.map { \u001b[33mcase\u001b[0m (score, index) => \u001b[31m0\u001b[0m }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    scala.collection.immutable.Iterable[Int]\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m19 |\u001b[0m        ++ guessesDiff\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameLen = game.size\n        val guessLen = guess.size\n        val result = new Array[Long](guessLen)\n        var i = 0\n        while (i < guessLen) {\n            val gameScore = game(i)\n            val guessScore = guess(i)\n            val diff = Math.abs(guessScore - gameScore)\n            result(i) = diff\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7z89l6r0.scala:24:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mcompare\u001b[0m(\u001b[36mgame\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m], \u001b[36mguess\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    Unit\n\u001b[31m   |\u001b[0m                                                    Required: List[Long]\n\u001b[31m13 |\u001b[0m        \u001b[34m// Your code here\u001b[0m\n\u001b[31m14 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreCount = gameScores.count\n        val guessScoreCount = guessScores.count\n        val gameScoreSum = gameScores.sum\n        val guessScoreSum = guessScores.sum\n        val gameScoreDiff = gameScoreSum - guessScoreSum\n        val guessScoreDiff = guessScoreSum - gameScoreSum\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiffPercent = gameScoreDiff / gameScoreCount * 100\n        val guessScoreDiffPercent = guessScoreDiff / guessScoreCount * 100\n        val gameScoreDiff\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp5g7mregq.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5g7mregq.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffPercent\u001b[0m = gameScoreDiff / gameScoreCount * \u001b[31m100\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreDiffPercent is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffPercent\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5g7mregq.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreDiffPercent\u001b[0m = guessScoreDiff / guessScoreCount * \u001b[31m100\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreDiffPercent is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreDiffPercent\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5g7mregq.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffPercent\u001b[0m = gameScoreDiff / gameScoreCount * \u001b[31m100\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreDiffPercent is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffPercent\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp5g7mregq.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreDiffPercent\u001b[0m = guessScoreDiff / guessScoreCount * \u001b[31m100\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map{ case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSet\u001b[0m = gameScores.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesCorrect = guessesScores.zip(gameScores).map { case (guess, gameScore) => if (guess == gameScore) 0 else Math.abs(guess - gameScore) }\n        guessesCorrect.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val gameDiff = gameScore - guessScore\n        val gameDiffs = gameScores.zip(guessScores).map { case (gameScore, guessScore) =>\n            if (gameScore == guessScore) 0 else Math.abs(gameDiff - guessScore)\n        }\n        gameDiffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg04k4mem.scala:24)\n\tat Problem.main(tmpg04k4mem.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013719
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // your code here\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach{case (score, index) => gameScoreList += score}\n        guessScoreMap.foreach{case (score, index) => guessScoreList += score}\n        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach{case (score, index) => gameScoreList += score}\n        guessScoreMap.foreach{case (score, index) => guessScoreList += score}\n        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach{case (score, index) => gameScoreList += score}\n        guessScoreMap.foreach{case (score, index) => guessScoreList += score}\n        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach{case (score, index) => gameScoreList += score}\n        guessScoreMap.foreach{case (score, index) => guessScoreList += score}\n        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp_gggwcpr.scala:51:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_gggwcpr.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScoreList.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_gggwcpr.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScores\u001b[0m = guessScoreList.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_gggwcpr.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_gggwcpr.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp_gggwcpr.scala:26:12 ----------",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n        val diffs = gameScores zip guessScores\n        diffs.map(x => if (x._1 == x._2) 0 else x._1 - x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013719
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessesScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach { case (score, index) =>\n            val guess = guessesScoreMap(index)\n            val difference = if (guess == score) 0 else abs(guess - score)\n            gameScoreList += difference\n            guessesScoreList += difference\n        }\n        gameScoreList.take(guessesScoreList.size)\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy9qb_c1k.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy9qb_c1k.scala:18:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreList\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013713
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.map(x => Math.abs(x - game(x)))\n        guesses.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2bnbsdy.scala:13:55 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguesses\u001b[0m = guess.map(\u001b[36mx\u001b[0m => Math.abs(x - game(x)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val result: List[Long] = guesses.map(guess => {\n            val score = scores.get(guess)\n            if (score == -1L) -1L\n            else Math.abs(score - guess)\n        }).toList\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3dppw589.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mscore\u001b[0m = scores.get(guess)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of Set[Long] - did you mean scores.seq?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val diffs = mutable.ArrayBuffer.empty[Long]\n        for(score <- scores) {\n            val guess = guesses.find(_ == score)\n            if(guess == None) diffs += abs(score - score)\n            else diffs += abs(guess - score)\n        }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk07b749p.scala:15:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiffs\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013712
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.map(x => Math.abs(x - game))\n        val correct = game.zip(guesses).map(x => if (x._1 == x._2) 0 else x._1 - x._2)\n        correct.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpnpofifin.scala:13:48 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguesses\u001b[0m = guess.map(\u001b[36mx\u001b[0m => Math.abs(x - game))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments ((game : List[Long]))\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmpnpofifin.scala:14:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcorrect\u001b[0m = game.zip(guesses).map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._1 == x._2) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m x._1 - x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m==\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0m (x$0: Any): Boolean\n\u001b[31m   |\u001b[0mall match arguments ((x._2 : => Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmpnpofifin.scala:14:79 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcorrect\u001b[0m = game.zip(guesses).map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._1 == x._2) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m x._1 - x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                          ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: D",
      "stdout": "",
      "timestamp": 1660013717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesWithScores = guessesScores.map { case (score, index) => index -> score }.toMap\n        val guessesWithIndexes = guessesScores.map { case (score, index) => index -> index }.toMap\n        val guessesWithIndexesWithScores = guessesWithIndexes.map { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexes = guessesWithIndexes.map { case (score, index) => index -> index }.toMap\n        val guessesWithIndexesWithIndexesWithScores = guessesWithIndexesWithIndexes.map { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithScores = guessesWithIndexesWithIndexesWithIndexes.map { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithScores = guessesWithIndexesWithIndexesWithIndexesWithIndexes.map { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes.map { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes.map { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes.map { case (score, index) => index -> score }.toMap\n        val guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpah00294z.scala:20:65 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithIndexesWithIndexesWithIndexesWithScores\u001b[0m = guessesWithIndexesWithIndexesWithIndexes.map { \u001b[33mcase\u001b[0m (score, index) => index -> score }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: guessesWithIndexesWithIndexesWithIndexes\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpah00294z.scala:21:76 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithIndexesWithIndexesWithIndexesWithIndexesWithScores\u001b[0m = guessesWithIndexesWithIndexesWithIndexesWithIndexes.map { \u001b[33mcase\u001b[0m (score, index) => index -> score }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Not found: guessesWithIndexesWithIndexesWithIndexesWithIndexes\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpah00294z.scala:22:87 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexesWithScores\u001b[0m = guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes.map { \u001b[33mcase\u001b[0m (score, index) => index -> score }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNot found: guessesWithIndexesWithIndexesWithIndexesWithIndexesWithIndexes\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpah00294z.scala:23:98 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m      ",
      "stdout": "",
      "timestamp": 1660013717
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val differences = guessScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        val difference = differences.sum\n        differences.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013719
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new Array[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val difference = abs(guess - score)\n            result(i) = difference\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptkvd4wtv.scala:26:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreSetMap = gameScores.toSetMap\n        val guessScoreSetMap = guessScores.toSetMap\n        val gameScoreSetSet = gameScores.toSetSet\n        val guessScoreSetSet = guessScores.toSetSet\n        val gameScoreSetList = gameScores.toSetList\n        val guessScoreSetList = guessScores.toSetList\n        val gameScoreSetMap = gameScores.toSetMap\n        val guessScoreSetMap = guessScores.toSetMap\n        val gameScoreSetSetMap = gameScores.toSetSetMap\n        val guessScoreSetSetMap = guessScores.toSetSetMap\n        val gameScoreSetSetSetMap = gameScores.toSetSetSetMap\n        val guessScoreSetSetSetMap = guessScores.toSetSetSetMap\n        val gameScoreSetSetSetSetMap = gameScores.toSetSetSetSetMap\n        val guessScoreSetSetSetSetMap = guessScores.toSetSetSetSetMap\n        val gameScoreSetSetSetSetSetMap = gameScores.toSetSetSetSetSetMap\n        val guessScoreSetSetSetSetSetMap = guessScores.toSetSetSetSetSetMap\n        val gameScoreSetSetSetSetSetSetMap = gameScores.toSetSetSetSetSetSetMap\n        val guessScoreSetSetSetSetSetSetMap = guessScores.toSetSetSetSetSetSetMap\n        val gameScoreSetSetSetSetSetSetSetMap = gameScores.toSetSetSetSetSetSetSetMap\n        val guessScoreSetSetSetSetSetSetSetMap = guessScores.toSetSetSetSetSetSetSetMap\n        val gameScoreSetSetSetSetSetSetSetSetMap = gameScores.toSetSetSetSetSetSetSetSetMap\n        val guessScoreSetSetSetSetSetSetSetSetMap = guessScores.toSetSetSetSetSetSetSetSetMap\n        val game\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmph2pt8kh4.scala:44:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph2pt8kh4.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSetMap\u001b[0m = gameScores.toSetMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreSetMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreSetMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph2pt8kh4.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreSetMap\u001b[0m = guessScores.toSetMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreSetMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreSetMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmph2pt8kh4.scala:13:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = game.zipWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => score }\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue zipWithIndex is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitCon",
      "stdout": "",
      "timestamp": 1660013720
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guessesWithScore = game.zip(guess)\n        val guessesWithScoreSortedByScore = guessesWithScore.sortBy(_._1)\n        val guessesWithScoreSortedByGuess = guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_._1 - _._2)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_ > 0)\n        val guessesWithScoreSortedByGuess = guessesWith\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcy0xjoza.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.map(_._1 - _._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcy0xjoza.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.filter(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcy0xjoza.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.map(_ / guessesWithScoreSortedByGuess.size)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcy0xjoza.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.filter(_ > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val gameScoreMap = gameScores.toSeq.sortBy(_._1).reverse.map { case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.toSeq.sortBy(_._1).reverse.map { case (score, index) => index -> score }.toMap\n        val gameScoreArray = gameScoreMap.values\n        val guessScoreArray = guessScoreMap.values\n        val gameScoreArrayLength = gameScoreArray.length\n        val guessScoreArrayLength = guessScoreArray.length\n        val gameScoreArrayCopy = gameScoreArray.clone()\n        val guessScoreArrayCopy = guessScoreArray.clone()\n        val gameScoreArrayCopyLength = gameScoreArrayCopy.length\n        val guessScoreArrayCopyLength = guessScoreArrayCopy.length\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopyLength = guessScoreArrayCopyLength\n        val gameScoreArrayCopyLength = gameScoreArrayCopyLength\n        val guessScoreArrayCopy\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp75kadk8f.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp75kadk8f.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreArrayCopyLength\u001b[0m = gameScoreArrayCopyLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreArrayCopyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreArrayCopyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp75kadk8f.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreArrayCopyLength\u001b[0m = guessScoreArrayCopyLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreArrayCopyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreArrayCopyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp75kadk8f.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreArrayCopyLength\u001b[0m = gameScoreArrayCopyLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreArrayCopyLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreArrayCopyLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp75kadk8f.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreArrayCopyLength\u001b[0m = guessScoreArrayCopyLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreArrayCopyLength is alre",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case (score, index) => score}\n        val guessScores = guessScoreList.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case (score, index) => score}\n        val guessScores = guessScoreList.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case (score, index) => score}\n        val guessScores = guessScoreList.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case (score, index) => score}\n        val guessScores = guessScoreList.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case (score, index) => score}\n        val guessScores = guessScoreList.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScores = gameScoreList.map{case (score, index) => score}\n        val guessScores = guessScoreList.map\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv75mvhhi.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScoreList.map{\u001b[33mcase\u001b[0m (score, index) => score}\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv75mvhhi.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScores\u001b[0m = guessScoreList.map{\u001b[33mcase\u001b[0m (score, index) => score}\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv75mvhhi.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv75mvhhi.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv75mvhhi.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36m",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreKeySetSize = gameScore\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySetSize\u001b[0m = gameScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySetSize\u001b[0m = guessScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySetSize\u001b[0m = gameScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySetSize\u001b[0m = guessScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp6bmt8wx7.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        ",
      "stdout": "",
      "timestamp": 1660013726
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new mutable.ListBuffer[Long]()\n        var i = 0\n        while(i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val diff = Math.abs(guess - score)\n            result.add(diff)\n            i += 1\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpk10dnqws.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013722
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameSet = game.distinct\n        val guessSet = guess.distinct\n        val result = gameSet.zip(guessSet).map { case (game, guess) => Math.abs(guess - game) }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp6gf83l64.scala:19)\n\tat Problem.main(tmp6gf83l64.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013730
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score, index) => score }.toList\n        val guessScores = guess.zipWithIndex.map{ case (score, index) => score }.toList\n        val gameScoreMap = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap2 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap2 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap3 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap3 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap4 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap4 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap5 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap5 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap6 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap6 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap7 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap7 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap8 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap8 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap9 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap9 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap10 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap10 = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMap11 = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap11 = guess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:15:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:15:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:16:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:16:72 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:17:49 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap2\u001b[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcz9a63ug.scala:17:71 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap2\u001b[0m = gameScores.group",
      "stdout": "",
      "timestamp": 1660013733
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mcompare\u001b[0m(\u001b[36mgame\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m], \u001b[36mguess\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    Unit\n\u001b[31m   |\u001b[0m                                                    Required: List[Long]\n\u001b[31m13 |\u001b[0m        \u001b[34m// Your code here\u001b[0m\n\u001b[31m14 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.map(x => if (x == -1) 0 else x)\n        val guessScores = guess.map(x => if (x == -1) 0 else x)\n        val diffs = gameScores zip guessScores\n        val diffsSorted = diffs.sortBy(_._1).reverse\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffsSortedWithZeros = diffsSorted.map(x => (x._1 - x._2, x._2))\n        val diffs\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuc8c5oc1.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuc8c5oc1.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiffsSortedWithZeros\u001b[0m = diffsSorted.map(\u001b[36mx\u001b[0m => (x._1 - x._2, x._2))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mdiffsSortedWithZeros is already defined as \u001b[33mvalue\u001b[0m \u001b[35mdiffsSortedWithZeros\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuc8c5oc1.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiffsSortedWithZeros\u001b[0m = diffsSorted.map(\u001b[36mx\u001b[0m => (x._1 - x._2, x._2))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mdiffsSortedWithZeros is already defined as \u001b[33mvalue\u001b[0m \u001b[35mdiffsSortedWithZeros\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuc8c5oc1.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiffsSortedWithZeros\u001b[0m = diffsSorted.map(\u001b[36mx\u001b[0m => (x._1 - x._2, x._2))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mdiffsSortedWithZeros is already defined as \u001b[33mvalue\u001b[0m \u001b[35mdiffsSortedWithZeros\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpuc8c5oc1.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiffsSortedWithZeros\u001b[0m = diffsSorted.map(\u001b[36mx\u001b[0m => (x._1 - x._2, x._2))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660013728
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}\n        val guessesScores = guess.zipWithIndex.map{case (score, index) => score}\n        val guessesDiff = guessesScores.zip(gameScores).map{case (guess, score) => Math.abs(guess - score)}\n        guessesDiff.map{case (guess, score) => if (guess == score) 0 else Math.abs(guess - score)}\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9c2nyhke.scala:16:89 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        guessesDiff.map{\u001b[33mcase\u001b[0m (guess, score) => \u001b[33mif\u001b[0m (guess == score) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m Math.abs(guess - score)}\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013730
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // TODO: Implement this function\n        val game = game.sorted\n        val guess = guess.sorted\n        val diffs = mutable.ArrayBuffer.empty[Long]\n        val gameSize = game.size\n        val guessSize = guess.size\n        val gameIndex = 0\n        val guessIndex = 0\n        while (gameIndex < gameSize && guessIndex < guessSize) {\n            if (game(gameIndex) == guess(guessIndex)) {\n                diffs += abs(game(gameIndex) - guess(guessIndex))\n                gameIndex += 1\n                guessIndex += 1\n            } else if (game(gameIndex) < guess(guessIndex)) {\n                gameIndex += 1\n            } else {\n                guessIndex += 1\n            }\n        }\n        diffs\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxad35qbk.scala:14:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgame\u001b[0m = game.sorted\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   Recursive \u001b[33mvalue\u001b[0m \u001b[35mgame\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxad35qbk.scala:15:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguess\u001b[0m = guess.sorted\n\u001b[31m\u001b[31m   |\u001b[0m                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                    Recursive \u001b[33mvalue\u001b[0m \u001b[35mguess\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpxad35qbk.scala:16:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiffs\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxad35qbk.scala:24:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                gameIndex += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean gameIndex.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxad35qbk.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                guessIndex += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value += is not a member of Int - did you mean guessIndex.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxad35qbk.scala:27:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                gameIndex += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean gameIndex.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp",
      "stdout": "",
      "timestamp": 1660013729
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, score) => (guess - score) }\n        guessesDiff.zipWithIndex.map { case (guess, index) => (if (guess == 0) 0 else abs(guess - game(index)) ) }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpy0m1wq_o.scala:19)\n\tat Problem.main(tmpy0m1wq_o.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013730
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val differences = gameScores zip guessScores\n        differences.map { case (guess, score) =>\n            if (guess == score) 0 else Math.abs(guess - score)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val result = guesses.zip(scores).map { case (guess, score) =>\n            if (guess == score) {\n                0\n            } else {\n                Math.abs(guess - score)\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013730
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n        val diffs = guessScores.zip(gameScores).map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013730
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new Array[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val diff = Math.abs(guess - score)\n            result(i) = diff\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjq0bipzl.scala:26:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013729
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score, index) => score }.toList\n        val guessesScores = guess.zipWithIndex.map{ case (score, index) => score }.toList\n        val gameScore = gameScores.sum\n        val guessesScore = guessesScores.sum\n        val diffs = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}.toList\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val diffs = guessScores.zip(gameScores).map{case (guess, game) => math.abs(guess - game)}\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new Array[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            var j = 0\n            while (j < scoresCount) {\n                if (guesses(i) == scores(j)) {\n                    result(i) = guesses(i) - scores(j)\n                    j++\n                }\n                else {\n                    result(i) = abs(guesses(i) - scores(j))\n                }\n                j++\n            }\n            i++\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpb4rlnumg.scala:24:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    j++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpb4rlnumg.scala:29:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpb4rlnumg.scala:31:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            i++\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb4rlnumg.scala:33:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660013729
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guessesCount = guess.size\n        val gameCount = game.size\n        val result = new Array[Long](guessesCount)\n        val gameScores = game.zipWithIndex.map(_._2)\n        val guessesScores = guess.zipWithIndex.map(_._2)\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        guessesScoreMap.foreach {\n            case (guess, score) =>\n                val gameScore = gameScoreMap.get(guess)\n                if (gameScore == score) {\n                    result(0)\n                } else {\n                    val diff = abs(gameScore - score)\n                    result(diff)\n                }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpj26c2fuz.scala:18:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Cannot prove that Int <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                        where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                  V is a type variable\n\u001b[31m   |\u001b[0m                                        .\n\u001b[31m\u001b[31m-- Error: /tmp/tmpj26c2fuz.scala:19:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreMap\u001b[0m = guessesScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Cannot prove that Int <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                        where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                  V is a type variable\n\u001b[31m   |\u001b[0m                                        .\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpj26c2fuz.scala:30:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660013730
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new Array[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val difference = guess - score\n            result(i) = difference\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzig84gbc.scala:26:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013729
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpzptrsuc0.scala:51:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSize\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySetSize\u001b[0m = gameScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySetSize\u001b[0m = guessScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSize\u001b[0m = gameScoreValueSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSetSize\u001b[0m = guessScoreValueSet.si",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n        val diffs = gameScores zip guessScores\n        diffs.map(x => if (x._1 == 0) 0 else x._1 - x._2)\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}.toList\n        val guessesScores = guess.zipWithIndex.map{case (score, index) => score}.toList\n        val diffs = guessesScores.zip(gameScores).map{case (guess, game) => math.abs(guess - game)}\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guessesWithScore = game.zip(guess)\n        val guessesWithScoreSortedByScore = guessesWithScore.sortBy(_._1)\n        val guessesWithScoreSortedByGuess = guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.to\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.map(\u001b[36mx\u001b[0m => (x._1, x._2))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.map(\u001b[36mx\u001b[0m => (x._1, x._2))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.map(x => abs(x - game))\n        val correct = guesses.filter(x => x == 0)\n        val wrong = guesses.filter(x => x != 0)\n        correct.toList ++ wrong.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpdebmcjeh.scala:13:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguesses\u001b[0m = guess.map(\u001b[36mx\u001b[0m => abs(x - game))\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments ((game : List[Long]))\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013729
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score -> index }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val game\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbrn4bkur.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbrn4bkur.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySetSize\u001b[0m = gameScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbrn4bkur.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySetSize\u001b[0m = guessScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbrn4bkur.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSize\u001b[0m = gameScoreValueSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbrn4bkur.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSetSize\u001b[0m = guessScoreValueSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValueSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValueSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |",
      "stdout": "",
      "timestamp": 1660013733
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val result: List[Long] = guesses.map(x => if (scores.contains(x)) 0 else abs(x - scores.head))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3qm7pp7q.scala:15:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = guesses.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (scores.contains(x)) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m abs(x - scores.head))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    \u001b[1m\u001b[31mSet\u001b[0m[Long]\n\u001b[31m   |\u001b[0m                                 Required: \u001b[1m\u001b[32mList\u001b[0m[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013733
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val result = guesses.zip(scores).map {\n            case (guess, score) => if (guess == score) 0 else abs(guess - score)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013739
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, game) => guess - game }\n        guessesDiff.map { case (guess, game) => guess }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjmpetp1h.scala:16:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        guessesDiff.map { \u001b[33mcase\u001b[0m (guess, game) => guess }\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    (guess : Any)\n\u001b[31m   |\u001b[0m                                                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013739
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val diffs = guessScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013742
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSorted = guessesWithScores.sortBy(_._1).reverse\n        val guessesWithScoresSortedWithCorrect = guessesWithScoresSorted.filter(_._2 == 0)\n        val guessesWithScoresSortedWithIncorrect = guessesWithScoresSorted.filter(_._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndIncorrect = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrect = guessesWithScoresSorted.filter(_._2 == 0 && _._2 == 0)\n        val guessesWithScoresSortedWithCorrectAndIncorrectAndCorrect = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0)\n        val guessesWithScoresSortedWithCorrectAndIncorrectAndIncorrect = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndIncorrect = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndCorrectAndIncorrect = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2 != 0 && _._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndIncorrectAndCorrect = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2 != 0 && _._2 != 0 && _._2 == 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndIncorrectAndIncorrectAndCorrect = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2 != 0 && _._2 != 0 && _._2 != 0 && _._2 == 0 && _._2 != 0)\n        val guessesWithScoresSortedWithCorrectAndCorrectAndCorrectAndIncorrectAndIncorrect = guessesWithScoresSorted.filter(_._2 == 0 && _._2 != 0 && _._2 == 0 && _._2 != 0 && _._2 != 0 && _._2 != 0 && \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpuucj8zef.scala:27:201 --------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedWithCorrectAndCorrectAndCorrectAndIncorrectAndIncorrect\u001b[0m = guessesWithScoresSorted.filter(_._2 == \u001b[31m0\u001b[0m && _._2 != \u001b[31m0\u001b[0m && _._2 == \u001b[31m0\u001b[0m && _._2 != \u001b[31m0\u001b[0m && _._2 != \u001b[31m0\u001b[0m && _._2 != \u001b[31m0\u001b[0m && \n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuucj8zef.scala:19:94 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedWithCorrectAndIncorrect\u001b[0m = guessesWithScoresSorted.filter(_._2 == \u001b[31m0\u001b[0m && _._2 != \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuucj8zef.scala:20:92 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedWithCorrectAndCorrect\u001b[0m = guessesWithScoresSorted.filter(_._2 == \u001b[31m0\u001b[0m && _._2 == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpuucj8zef.scala:21:102 --------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedWithCorrectAndIncorrectAndCorrect\u001b[0m = guessesWithScoresSorted.filter(_._2 == \u001b[31m0\u001b[0m && _._2 != \u001b[31m0\u001b[0m && _._2 == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m     ",
      "stdout": "",
      "timestamp": 1660013741
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map { case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map { case (guess, index) => guess }\n        val guessesWithScores : List[(Long, Long)] = guesses.zipWithIndex.map { case (guess, index) => (guess, scores(index)) }\n        val guessesWithScoresWithIndices : List[(Long, Long, Int)] = guessesWithScores.zipWithIndex.map { case (guess, score, index) => (guess, score, index) }\n        val guessesWithScoresWithIndicesAndIndices : List[(Long, Long, Int, Int)] = guessesWithScoresWithIndices.zipWithIndex.map { case (guess, score, index, index2) => (guess, score, index, index2) }\n        val guessesWithScoresWithIndicesAndIndicesAndIndices : List[(Long, Long, Int, Int, Int)] = guessesWithScoresWithIndicesAndIndices.zipWithIndex.map { case (guess, score, index, index2, index3) => (guess, score, index, index2, index3) }\n        val guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndices : List[(Long, Long, Int, Int, Int, Int)] = guessesWithScoresWithIndicesAndIndicesAndIndices.zipWithIndex.map { case (guess, score, index, index2, index3, index4) => (guess, score, index, index2, index3, index4) }\n        val guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndicesAndIndicesAndIndices : List[(Long, Long, Int, Int, Int, Int, Int)] = guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndices.zipWithIndex.map { case (guess, score, index, index2, index3, index4, index5) => (guess, score, index, index2, index3, index4, index5) }\n        val guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndicesAndIndicesAndIndicesAndIndices : List[(Long, Long, Int, Int, Int, Int, Int, Int)] = guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndicesAndIndices.zipWithIndex.map { case (guess, score, index, index2, index3, index4, index5, index6) => (guess, score, index, index2, index3, index4, index5, index6) }\n        val guessesWithScoresWithIndicesAndIndicesAndIndicesAndIndices\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpu8r8jzhy.scala:23:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu8r8jzhy.scala:16:137 -------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresWithIndices\u001b[0m : \u001b[35mList\u001b[0m[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m)] = guessesWithScores.zipWithIndex.map { \u001b[33mcase\u001b[0m (guess, score, index) => (guess, score, index) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                         ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Found:    (guess : Any)\n\u001b[31m   |\u001b[0m                                                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu8r8jzhy.scala:16:144 -------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresWithIndices\u001b[0m : \u001b[35mList\u001b[0m[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m)] = guessesWithScores.zipWithIndex.map { \u001b[33mcase\u001b[0m (guess, score, index) => (guess, score, index) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Found:    (score : Any)\n\u001b[31m   |\u001b[0m                                                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu8r8jzhy.scala:16:151 -------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresWithIndices\u001b[0m : \u001b[35mList\u001b[0m[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m)] = guessesWithScores.zipWithIndex.map { \u001b[33mcase\u001b[0m (guess, score, index) => (guess, score, index) }\n\u001b[31m\u001b[31m   ",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score, index) => score }.toList\n        val guessScores = guess.zipWithIndex.map{ case (score, index) => score }.toList\n        val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toList\n        val guessScoreList = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toList\n        val gameScoreSet = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toSet\n        val guessScoreSet = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toSet\n        val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toList\n        val guessScoreList = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toList\n        val gameScoreSet = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toSet\n        val guessScoreSet = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toSet\n        val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toList\n        val guessScoreList = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toList\n        val gameScoreSet = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toSet\n        val guessScoreSet = guessScores.zipWithIndex.map{ case (score, index) => \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1__kj3in.scala:42:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1__kj3in.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.zipWithIndex.map{ \u001b[33mcase\u001b[0m (score, index) => index -> score }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1__kj3in.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.zipWithIndex.map{ \u001b[33mcase\u001b[0m (score, index) => index -> score }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1__kj3in.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.zipWithIndex.map{ \u001b[33mcase\u001b[0m (score, index) => index -> score }.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1__kj3in.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[",
      "stdout": "",
      "timestamp": 1660013741
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameSet = game.distinct\n        val guessSet = guess.distinct\n        val gameSetSize = gameSet.size\n        val guessSetSize = guessSet.size\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSetSize = guessSetSize.toLong\n        val gameSetSize = gameSetSize.toLong\n        val guessSet\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8wwzfbyx.scala:61:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m61 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8wwzfbyx.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameSetSize\u001b[0m = gameSetSize.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8wwzfbyx.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessSetSize\u001b[0m = guessSetSize.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8wwzfbyx.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameSetSize\u001b[0m = gameSetSize.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8wwzfbyx.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessSetSize\u001b[0m = guessSetSize.toLong\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp8wwzfbyx.scala:21:12 ----------",
      "stdout": "",
      "timestamp": 1660013740
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val differences = guessScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        differences.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpzptrsuc0.scala:51:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSize\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySetSize\u001b[0m = gameScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySetSize\u001b[0m = guessScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSize\u001b[0m = gameScoreValueSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSetSize\u001b[0m = guessScoreValueSet.si",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreCount = gameScores.count\n        val guessesScoreCount = guessesScores.count\n        val gameScoreDiff = gameScoreCount - guessesScoreCount\n        val guessesScoreDiff = guessesScoreCount - gameScoreCount\n        val gameScoreDiffList = gameScoreDiff.toList.map(x => gameScoreDiff.minus(x))\n        val guessesScoreDiffList = guessesScoreDiff.toList.map(x => guessesScoreDiff.minus(x))\n        val gameScoreDiffSum = gameScoreDiffList.sum\n        val guessesScoreDiffSum = guessesScoreDiffList.sum\n        val gameScoreDiffSumAbs = gameScoreDiffSum.abs\n        val guessesScoreDiffSumAbs = guessesScoreDiffSum.abs\n        val gameScoreDiffSumAbsArray = gameScoreDiffSumAbs.toArray\n        val guessesScoreDiffSumAbsArray = guessesScoreDiffSumAbs.toArray\n        val gameScoreDiffSumAbsArrayLength = gameScoreDiffSumAbsArray.length\n        val guessesScoreDiffSumAbsArrayLength = guessesScoreDiffSumAbsArray.length\n        val gameScoreDiffSumAbsArrayLength = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength = guessesScoreDiffSumAbsArrayLength\n        val gameScoreDiffSumAbsArrayLength = gameScoreDiffSumAbsArrayLength\n        val guessesScoreDiffSumAbsArrayLength = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpoo5cd4x4.scala:40:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreDiffSumAbsArrayLength\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoo5cd4x4.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffSumAbsArrayLength\u001b[0m = gameScoreDiffSumAbsArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreDiffSumAbsArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffSumAbsArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoo5cd4x4.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreDiffSumAbsArrayLength\u001b[0m = guessesScoreDiffSumAbsArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreDiffSumAbsArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreDiffSumAbsArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpoo5cd4x4.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffSumAbsArrayLength\u001b[0m = gameScoreDiffSumAbsArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreDiffSumAbsArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffSumAbsArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the sam",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val diffs = guessScores.zip(gameScores).map(x => if (x._1 == 0) 0 else x._1 - x._2)\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2vbjskoi.scala:21)\n\tat Problem.main(tmp2vbjskoi.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreSetMap = gameScores.toMap.toSet\n        val guessesScoreSetMap = guessesScores.toMap.toSet\n        val gameScoreSetMapList = gameScores.toMap.toList.toSet\n        val guessesScoreSetMapList = guessesScores.toMap.toList.toSet\n        val gameScoreSetMapMap = gameScores.toMap.toMap.toSet\n        val guessesScoreSetMapMap = guessesScores.toMap.toMap.toSet\n        val gameScoreSetMapMapList = gameScores.toMap.toMap.toList.toSet\n        val guessesScoreSetMapMapList = guessesScores.toMap.toMap.toList.toSet\n        val gameScoreSetMapMapMap = gameScores.toMap.toMap.toMap.toSet\n        val guessesScoreSetMapMapMap = guessesScores.toMap.toMap.toMap.toSet\n        val gameScoreSetMapMapMapList = gameScores.toMap.toMap.toMap.toList.toSet\n        val guessesScoreSetMapMapMapList = guessesScores.toMap.toMap.toMap.toList.toSet\n        val gameScoreSetMapMapMapMap = gameScores.toMap.toMap.toMap.toMap.toSet\n        val guessesScoreSetMapMapMapMap = guessesScores.toMap.toMap.toMap.toMap.toSet\n        val gameScoreSetMapMapMapMapList = gameScores.toMap.toMap.toMap.toMap.toList.toSet\n        val guessesScoreSetMapMapMapMapList = guessesScores.toMap.toMap.toMap.toMap.toList.toSet\n        val gameScoreSetMapMapMapMapMap = gameScores.toMap.toMap.toMap.toMap.toMap.toSet\n        val guessesScoreSetMapMapMapMapMapList = guessesScores.toMap.toMap.toMap.toMap.toList.toSet\n        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq30b8f61.scala:40:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013742
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        guessesDiff.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013744
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, gameScore) => math.abs(guess - gameScore) }\n        guessesDiff.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSet\u001b[0m = gameScores.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.map(x => math.abs(x - _))\n        val guessesScores = guess.map(x => math.abs(x - _))\n        val guessesCorrect = guessesScores.zip(gameScores).filter(_._1 == 0).map(_._2)\n        val guessesWrong = guessesScores.zip(gameScores).filter(_._1 == 0).map(_._1)\n        guessesCorrect ++ guessesWrong\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp31jvbaoj.scala:13:44 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = game.map(\u001b[36mx\u001b[0m => math.abs(x - _))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments (<?> => <?>)\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp31jvbaoj.scala:14:48 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScores\u001b[0m = guess.map(\u001b[36mx\u001b[0m => math.abs(x - _))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments (<?> => <?>)\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013739
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val diffs = guesses.map { guess =>\n            val score = scores.get(guess)\n            if (score == null) 0 else abs(guess - score)\n        }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpol11ljzh.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mscore\u001b[0m = scores.get(guess)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of Set[Long] - did you mean scores.seq?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpol11ljzh.scala:19:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        diffs.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    List[\u001b[1m\u001b[31mInt\u001b[0m]\n\u001b[31m   |\u001b[0m        Required: List[\u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val guessesWithScore = guesses.map(x => (x, scores(x)))\n        val guessesWithScoreSortedByScore = guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByScoreReversed = guessesWithScoreSortedByScore.reverse\n        val guessesWithScoreSortedByScoreReversedWithCorrect = guessesWithScoreSortedByScoreReversed.filter(_._1 == 0)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversed = guessesWithScoreSortedByScoreReversedWithCorrect.map(x => x._1)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScore = guessesWithScoreSortedByScoreReversedWithCorrectReversed.sortBy(_._2)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversed = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScore.reverse\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversed.filter(_._1 == 0)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversed = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect.map(x => x._1)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScore = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversed.sortBy(_._2)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversed = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScore.reverse\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect.map(x => x._1)\n        val guessesWithScoreSortedByScoreReversedWithCorrectReversed\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpeikc157y.scala:28:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpeikc157y.scala:16:61 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByScore\u001b[0m = guessesWithScore.sortBy(_._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value sortBy is not a member of Set[(Long, Boolean)]\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpeikc157y.scala:26:143 --------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect\u001b[0m = guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect.map(\u001b[36mx\u001b[0m => x._1)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  guessesWithScoreSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrectReversedSortedByScoreReversedWithCorrect\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpeikc157y.scala:28:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map { case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map { case (guess, index) => guess }\n        val guessesCorrect : List[Long] = guesses.filter(x => x == game(index))\n        val guessesIncorrect : List[Long] = guesses.filter(x => x != game(index))\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorrect : Long = guessesCorrect.length\n        val guessesIncorrect : Long = guessesIncorrect.length\n        val guessesCorre\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmps_tkk21c.scala:46:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m46 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps_tkk21c.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesCorrect\u001b[0m : \u001b[35mLong\u001b[0m = guessesCorrect.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesCorrect is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesCorrect\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps_tkk21c.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesIncorrect\u001b[0m : \u001b[35mLong\u001b[0m = guessesIncorrect.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesIncorrect is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesIncorrect\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps_tkk21c.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesCorrect\u001b[0m : \u001b[35mLong\u001b[0m = guessesCorrect.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesCorrect is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesCorrect\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps_tkk21c.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesIncorrect\u001b[0m : \u001b[35mLong\u001b[0m = guessesIncorrect.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesIncorrect is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesIncorrect\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val diffs = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013744
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val result = guesses.zip(scores).map { case (guess, score) =>\n            if (guess == score) 0\n            else Math.abs(guess - score)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013744
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val result = guesses.zip(scores).map {\n            case (guess, score) => (guess - score)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpm0sqitnv.scala:21)\n\tat Problem.main(tmpm0sqitnv.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013746
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val diffs = guessScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013746
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}.toList\n        val diffs = gameScores diff guessScores\n        diffs.zipWithIndex.map{case (diff, index) => diff}.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp5j6rc8ne.scala:19)\n\tat Problem.main(tmp5j6rc8ne.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013747
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guessesWithScore = game.zip(guess)\n        val guessesWithScoreSortedByScore = guessesWithScore.sortBy(_._1)\n        val guessesWithScoreSortedByGuess = guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.toList\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.to\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.map(\u001b[36mx\u001b[0m => (x._1, x._2))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.map(\u001b[36mx\u001b[0m => (x._1, x._2))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpxbs1sj5r.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesWithScores = guess.zip(game).map { case (guess, score) => guess -> score }.toMap\n        val guessesWithIndexes = guess.zipWithIndex.map { case (guess, index) => guess -> index }.toMap\n        val guessesWithScoreAndIndex = guess.zip(game).map { case (guess, score) => guess -> score -> index }.toMap\n        val guessesWithScoreAndIndexAndScore = guess.zip(game).map { case (guess, score, index) => guess -> score -> index -> score }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuess = guess.zip(game).map { case (guess, score, index, guess) => guess -> score -> index -> score -> guess }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuessAndGuess = guess.zip(game).map { case (guess, score, index, guess) => guess -> score -> index -> score -> guess -> guess }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuessAndGuessAndGuess = guess.zip(game).map { case (guess, score, index, guess) => guess -> score -> index -> score -> guess -> guess -> guess }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuessAndGuessAndGuessAndGuess = guess.zip(game).map { case (guess, score, index, guess) => guess -> score -> index -> score -> guess -> guess -> guess -> guess }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuessAndGuessAndGuessAndGuessAndGuess = guess.zip(game).map { case (guess, score, index, guess) => guess -> score -> index -> score -> guess -> guess -> guess -> guess -> guess }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuessAndGuessAndGuessAndGuessAndGuessAndGuess = guess.zip(game).map { case (guess, score, index, guess) => guess -> score -> index -> score -> guess -> guess -> guess -> guess -> guess -> guess -> guess }.toMap\n        val guessesWithScoreAndIndexAndScoreAndGuess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpf9mskc85.scala:26:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpf9mskc85.scala:17:102 -----------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndex\u001b[0m = guess.zip(game).map { \u001b[33mcase\u001b[0m (guess, score) => guess -> score -> index }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                      ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Not found: index\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E005] Naming Error: /tmp/tmpf9mskc85.scala:19:104 --------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexAndScoreAndGuess\u001b[0m = guess.zip(game).map { \u001b[33mcase\u001b[0m (guess, score, index, guess) => guess -> score -> index -> score -> guess }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       duplicate pattern variable: guess\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E005] Naming Error: /tmp/tmpf9mskc85.scala:20:112 --------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexAndScoreAndGuessAndGuess\u001b[0m = guess.zip(game).map { \u001b[33mcase\u001b[0m (guess, score, index, guess) => guess -> score -> index -> score -> guess -> guess }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       duplicate pattern variable: guess\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E005] Naming Error: /tmp/tmpf9mskc85.scal",
      "stdout": "",
      "timestamp": 1660013752
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues = gameScoreMap.values\n        val guessScoreValues = guessScoreMap.values\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2m8whb9p.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySet\u001b[0m = gameScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2m8whb9p.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySet\u001b[0m = guessScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2m8whb9p.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSet\u001b[0m = gameScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2m8whb9p.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSet\u001b[0m = guessScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2m8whb9p.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySet\u001b[0m = gameScor",
      "stdout": "",
      "timestamp": 1660013752
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new mutable.ListBuffer[Long]()\n        val guessesRemaining = guessesCount - 1\n        val scoresRemaining = scoresCount - 1\n        val guessesRemainingIndex = guessesRemaining - 1\n        val scoresRemainingIndex = scoresRemaining - 1\n        val guessesRemainingScore = scores.get(guessesRemainingIndex)\n        val scoresRemainingScore = scores.get(scoresRemainingIndex)\n        val guessesRemainingGuess = guesses.get(guessesRemainingIndex)\n        val scoresRemainingGuess = guesses.get(scoresRemainingIndex)\n        val guessesRemainingGuessIndex = guessesRemainingIndex - 1\n        val scoresRemainingGuessIndex = scoresRemainingIndex - 1\n        val guessesRemainingGuessScore = scores.get(guessesRemainingGuessIndex)\n        val scoresRemainingGuessScore = scores.get(scoresRemainingGuessIndex)\n        val guessesRemainingGuessGuess = guesses.get(guessesRemainingGuessIndex)\n        val scoresRemainingGuessGuess = guesses.get(scoresRemainingGuessIndex)\n        val guessesRemainingGuessGuessIndex = guessesRemainingGuessIndex - 1\n        val scoresRemainingGuessGuessIndex = scoresRemainingGuessIndex - 1\n        val guessesRemainingGuessGuessScore = scores.get(guessesRemainingGuessGuessIndex)\n        val scoresRemainingGuessGuessScore = scores.get(scoresRemainingGuessGuessIndex)\n        val guessesRemainingGuessGuessGuess = guesses.get(guessesRemainingGuessGuessIndex)\n        val scoresRemainingGuessGuessGuess = guesses.get(scoresRemainingGuessGuessIndex)\n        val guessesRemainingGuessGuessGuessIndex = guessesRemainingGuessGuessIndex - 1\n        val scoresRemainingGuessGuessGuessIndex = scoresRemainingGuessGuessGuessIndex - 1\n        val guessesRemainingGuessGuessGuessScore = scores.get(guessesRemainingGuessGuessGuessIndex)\n        val scoresRemainingGuessGuessGuessScore = scores.get(scoresRemainingGuessGuessGuessIndex)\n        val guessesRemainingGuessGuessGuess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp741qan66.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp741qan66.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp741qan66.scala:22:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesRemainingScore\u001b[0m = scores.get(guessesRemainingIndex)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value get is not a member of List[Long] - did you mean scores.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp741qan66.scala:23:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mscoresRemainingScore\u001b[0m = scores.get(scoresRemainingIndex)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp741qan66.scala:24:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesRemainingGuess\u001b[0m = guesses.get(guessesRemainingIndex)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue get is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |",
      "stdout": "",
      "timestamp": 1660013755
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guessesCount = guess.size\n        val gameCount = game.size\n        val result = new Array[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guess(i)\n            val game = game(i)\n            val diff = abs(guess - game)\n            result(i) = diff\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpju99f8k0.scala:18:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mguess\u001b[0m = guess(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        Recursive \u001b[33mvalue\u001b[0m \u001b[35mguess\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpju99f8k0.scala:19:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mgame\u001b[0m = game(i)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       Recursive \u001b[33mvalue\u001b[0m \u001b[35mgame\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpju99f8k0.scala:24:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660013751
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val guessesToScores = guesses.zip(scores)\n        val scoresToGuesses = scores.zip(guesses)\n        val guessesToGuesses = guesses.zip(guesses)\n        val guessesToGuessesCount = guessesToGuesses.size\n        val scoresToGuessesCount = scoresToGuesses.size\n        val guessesToGuessesToScores = guessesToGuesses.zip(scoresToGuesses)\n        val scoresToGuessesToGuesses = scoresToGuesses.zip(guessesToGuesses)\n        val guessesToGuessesToGuessesCount = guessesToGuessesToScores.size\n        val scoresToGuessesToGuessesCount = scoresToGuessesToGuesses.size\n        val guessesToGuessesToGuessesToScores = guessesToGuessesToGuesses.zip(scoresToGuessesToGuesses)\n        val scoresToGuessesToGuessesToGuesses = scoresToGuessesToGuesses.zip(guessesToGuessesToGuesses)\n        val guessesToGuessesToGuessesToGuessesCount = guessesToGuessesToGuessesToScores.size\n        val scoresToGuessesToGuessesToGuessesCount = scoresToGuessesToGuessesToGuesses.size\n        val guessesToGuessesToGuessesToGuessesToScores = guessesToGuessesToGuessesToGuesses.zip(scoresToGuessesToGuessesToGuesses)\n        val scoresToGuessesToGuessesToGuessesToGuessesCount = scoresToGuessesToGuessesToGuessesToGuesses.size\n        val guessesToGuessesToGuessesToGuessesToGuessesCount = guessesToGuessesToGuessesToGuessesToScores.size\n        val guessesToGuessesToGuessesToGuessesToGuessesToScores = guessesToGuessesToGuessesToGuesses\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp010sznjo.scala:26:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesToGuessesToGuessesToScores\u001b[0m = guessesToGuessesToGuesses.zip(scoresToGuessesToGuesses)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: guessesToGuessesToGuesses\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp010sznjo.scala:27:77 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mscoresToGuessesToGuessesToGuesses\u001b[0m = scoresToGuessesToGuesses.zip(guessesToGuessesToGuesses)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Not found: guessesToGuessesToGuesses\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp010sznjo.scala:30:57 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesToGuessesToGuessesToGuessesToScores\u001b[0m = guessesToGuessesToGuessesToGuesses.zip(scoresToGuessesToGuessesToGuesses)\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: guessesToGuessesToGuessesToGuesses\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp010sznjo.scala:31:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mscoresToGuessesToGuessesToGuessesToGuessesCount\u001b[0m = scoresToGuessesToGuessesToGuessesToGuesses.size\n\u001b[31m\u001b[31m   |\u001b[0m                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: scoresToGuessesToGuessesToGuessesToGuesses\n\u001b[31m   |",
      "stdout": "",
      "timestamp": 1660013752
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessScoreList = guessScoreMap.values.toList\n        val gameScoreSet = gameScoreList.distinct\n        val guessScoreSet = guessScoreList.distinct\n        val gameScoreList = gameScoreSet.map { score => gameScoreMap.getOrElse(score,0) }\n        val guessScoreList = guessScoreSet.map { score => guessScoreMap.getOrElse(score,0) }\n        val gameScoreList = gameScoreList.sortBy(-_)\n        val guessScoreList = guessScoreList.sortBy(-_)\n        val gameScoreList = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessScoreList = guessScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreList = gameScoreList.zipWithIndex.map { case (score, \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpu92o011b.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpu92o011b.scala:49:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpu92o011b.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScoreSet.map { \u001b[36mscore\u001b[0m => gameScoreMap.getOrElse(score,\u001b[31m0\u001b[0m) }\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpu92o011b.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScoreSet.map { \u001b[36mscore\u001b[0m => guessScoreMap.getOrElse(score,\u001b[31m0\u001b[0m) }\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpu92o011b.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScoreList.sortBy(-_)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpu92o011b.scala:24:12 ---------------------------\u001b[0m\u001b[0m",
      "stdout": "",
      "timestamp": 1660013755
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.map(x => math.abs(x - _))\n        val guessesScores = guess.map(x => math.abs(x - _))\n        val guessesCorrect = guessesScores.zip(gameScores).filter(_._1 == 0).map(_._2)\n        val guessesWrong = guessesScores.zip(gameScores).filter(_._1 == 0).map(_._1)\n        guessesCorrect ++ guessesWrong\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp31jvbaoj.scala:13:44 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = game.map(\u001b[36mx\u001b[0m => math.abs(x - _))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments (<?> => <?>)\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp31jvbaoj.scala:14:48 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScores\u001b[0m = guess.map(\u001b[36mx\u001b[0m => math.abs(x - _))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mabs\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments (<?> => <?>)\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013739
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guessesWithScore = game.zip(guess)\n        val guessesWithScoreWithCorrect = guessesWithScore\n            .filter(x => x._2 == x._1)\n            .map(x => (x._2, x._1))\n        val guessesWithScoreWithIncorrect = guessesWithScore\n            .filter(x => x._2 != x._1)\n            .map(x => (x._2, x._1))\n        val guessesWithScoreWithCorrectAndIncorrect = guessesWithScoreWithCorrect ++ guessesWithScoreWithIncorrect\n        val guessesWithScoreWithCorrectAndCorrect = guessesWithScoreWithCorrect ++ guessesWithScoreWithCorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndCorrect = guessesWithScoreWithCorrectAndIncorrect ++ guessesWithScoreWithCorrectAndCorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndIncorrect = guessesWithScoreWithCorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndCorrect = guessesWithScoreWithCorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithCorrectAndIncorrectAndCorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect = guessesWithScoreWithCorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndCorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrectAndIncorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\n        val guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrectAndIncorrect\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzm3bgczj.scala:23:109 -----------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreWithCorrectAndIncorrectAndIncorrect\u001b[0m = guessesWithScoreWithCorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrect\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: guessesWithScoreWithIncorrectAndIncorrect\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzm3bgczj.scala:25:133 -----------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect\u001b[0m = guessesWithScoreWithCorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrect\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: guessesWithScoreWithIncorrectAndIncorrectAndIncorrect\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzm3bgczj.scala:27:157 -----------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\u001b[0m = guessesWithScoreWithCorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoreWithIncorrectAndIncorrectAndIncorrectAndIncorrect\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNot found: guessesWithScoreWithIncorrectAndIncorrectAndIncorrectAndIncorrect\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m long",
      "stdout": "",
      "timestamp": 1660013752
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val result = guesses.zip(scores).map { case (guess, score) =>\n            if (guess == score) 0 else Math.abs(guess - score)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013756
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameLen = game.length\n        val guessLen = guess.length\n        val result = new Array[Long](guessLen)\n        val gameScores = game.zipWithIndex.filter(_._1 == 1).map(_._2)\n        val guessScores = guess.zipWithIndex.filter(_._1 == 1).map(_._2)\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        guessScoreMap.foreach { case (guess, score) =>\n            val gameScore = gameScoreMap.get(guess)\n            if (gameScore == null) {\n                result(guess) = 0\n            } else {\n                result(guess) = math.abs(guess - gameScore)\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp6n2_yqa4.scala:18:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Cannot prove that Int <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                        where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                  V is a type variable\n\u001b[31m   |\u001b[0m                                        .\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6n2_yqa4.scala:19:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Cannot prove that Int <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                        where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                  V is a type variable\n\u001b[31m   |\u001b[0m                                        .\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6n2_yqa4.scala:28:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660013755
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // your code here\n        val gameArray = game.toArray\n        val guessArray = guess.toArray\n        val gameLength = gameArray.length\n        val guessLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = gameArray.length\n        val guessArrayLength = guessArray.length\n        val gameArrayLength = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpyz_qpqb2.scala:70:29 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m70 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameArrayLength\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyz_qpqb2.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameArrayLength\u001b[0m = gameArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyz_qpqb2.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessArrayLength\u001b[0m = guessArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyz_qpqb2.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameArrayLength\u001b[0m = gameArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpyz_qpqb2.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessArrayLength\u001b[0m = guessArray.length\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessArrayLength is already",
      "stdout": "",
      "timestamp": 1660013755
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSorted = guessesWithScores.sortBy(_._1)\n        val guessesWithScoresSortedReversed = guessesWithScoresSorted.reverse\n        val guessesWithScoresSortedReversedWithCorrect = guessesWithScoresSortedReversed.takeWhile(_._2 == 0).reverse\n        val guessesWithScoresSortedReversedWithCorrectWithIndex = guessesWithScoresSortedReversedWithCorrect.zipWithIndex\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSorted = guessesWithScoresSortedReversedWithCorrectWithIndex.sortBy(_._1)\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrect = guessesWithScoresSortedReversedWithCorrectWithIndexSorted.takeWhile(_._2 == 1).reverse\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndex = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrect.zipWithIndex\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSorted = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndex.sortBy(_._1)\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.takeWhile(_._2 == 2).reverse\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndex = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.zipWithIndex\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSorted = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndex.sortBy(_._1)\n        val guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.takeWhile(_._2 == 3).reverse\n        val guessesWithScoresSorted\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi0z9se_2.scala:29:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpi0z9se_2.scala:24:109 --------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\u001b[0m = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.takeWhile(_._2 == \u001b[31m2\u001b[0m).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpi0z9se_2.scala:27:135 --------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\u001b[0m = guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect.takeWhile(_._2 == \u001b[31m3\u001b[0m).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  guessesWithScoresSortedReversedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrectWithIndexSortedWithCorrect\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpi0z9se_2.scala:29:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Req",
      "stdout": "",
      "timestamp": 1660013755
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val results = new mutable.ArrayList[Long]()\n        for(score <- scores) {\n            val guess = guesses.find(_ == score)\n            if(guess == None) results += abs(score - game(0))\n            else results += abs(guess - score)\n        }\n        results\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdy9bzq3i.scala:15:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresults\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013750
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.map(x => if (x == 0) 0 else x)\n        val guessScores = guess.map(x => if (x == 0) 0 else x)\n        val diffs = guessScores.zip(gameScores).map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013730
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map { case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map { case (guess, index) => guess }\n        val guessesWithScores : List[(Long, Long)] = guesses.zipWithIndex.map { case (guess, index) => (score, guess) }\n        val guessesWithScoreAndIndex : List[(Long, Long, Int)] = guessesWithScores.zipWithIndex.map { case (score, guess, index) => (score, guess, index) }\n        val guessesWithScoreAndIndexAndGuessed : List[(Long, Long, Int, Boolean)] = guessesWithScoreAndIndex.map { case (score, guess, index, guessed) => (score, guess, index, guessed) }\n        val guessesWithScoreAndIndexAndGuessedAndGame : List[(Long, Long, Int, Boolean, List[Long])] = guessesWithScoreAndIndexAndGuessed.map { case (score, guess, index, guessed, game) => (score, guess, index, guessed, game) }\n        val guessesWithScoreAndIndexAndGuessedAndGameAndGuessed : List[(Long, Long, Int, Boolean, List[Long], List[Long])] = guessesWithScoreAndIndexAndGuessed.map { case (score, guess, index, guessed, game, guessed) => (score, guess, index, guessed, game, guessed) }\n        guessesWithScoreAndIndexAndGuessedAndGameAndGuessed.map { case (score, guess, index, guessed, game, guessed, guessesWithScoreAndIndexAndGuessedAndGameAndGuessed) =>\n            val guessesWithScoreAndIndexAndGuessedAndGameAndGuessedAndGuessedAndGuessedAndGuessed : List[(Long, Long, Int, Boolean, List[Long], List[Long], List[Long], List[Long])] = guessesWithScoreAndIndexAndGuessedAndGameAndGuessed.map { case (score, guess, index, guessed, game, guessed, guessesWithScoreAndIndexAndGuessedAndGameAndGuessedAndGuessed) =>\n                val guessesWithScoreAndIndexAndGuessedAndGameAndGuessedAndGuessedAndGuessedAndGuessedAndGuessed : List[(Long, Long, Int, Boolean, List[Long\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm783k5nv.scala:23:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ']' expected, but '}' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpm783k5nv.scala:32:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpm783k5nv.scala:15:104 -----------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScores\u001b[0m : \u001b[35mList\u001b[0m[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m)] = guesses.zipWithIndex.map { \u001b[33mcase\u001b[0m (guess, index) => (score, guess) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Not found: score\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm783k5nv.scala:16:133 -------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndex\u001b[0m : \u001b[35mList\u001b[0m[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m)] = guessesWithScores.zipWithIndex.map { \u001b[33mcase\u001b[0m (score, guess, index) => (score, guess, index) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                     ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Found:    (score : Any)\n\u001b[31m   |\u001b[0m                                                 Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm783k5nv.scala:16:140 -------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndex\u001b[0m : \u001b[35mList\u001b[0m[(\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m)] = guessesWithScores.zipWithIndex.map { \u001b[33mcase\u001b[0m (score, guess, index) => (score, guess, index) }\n\u001b[31m\u001b[31m   ",
      "stdout": "",
      "timestamp": 1660013758
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mcompare\u001b[0m(\u001b[36mgame\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m], \u001b[36mguess\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    Unit\n\u001b[31m   |\u001b[0m                                                    Required: List[Long]\n\u001b[31m13 |\u001b[0m        \u001b[34m// Your code here\u001b[0m\n\u001b[31m14 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n        val gameScore = game.zipWithIndex.filter(_._1 == 1).map(_._2)\n        val guessScore = guess.zipWithIndex.filter(_._1 == 1).map(_._2)\n        val gameScoreList = gameScore.toList\n        val guessScoreList = guessScore.toList\n        val gameScoreMap = gameScoreList.zipWithIndex.toMap\n        val guessScoreMap = guessScoreList.zipWithIndex.toMap\n        val gameScoreSet = gameScoreList.map(x => gameScoreMap.get(x))\n        val guessScoreSet = guessScoreList.map(x => guessScoreMap.get(x))\n        val gameScoreSetSet = gameScoreSet.union(guessScoreSet)\n        val gameScoreSetSetSet = gameScoreSetSet.toSet\n        val gameScoreSetSetSetSet = gameScoreSetSetSet.toSet\n        val gameScoreSetSetSetSetSet = gameScoreSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSet = gameScoreSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSetSetSet.toSet\n        val gameScoreSetSetSetSetSetSetSetSetSetSetSetSet = gameScoreSetSetSetSetSetSetSetSetSetSetSet\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpw55gfcwk.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSetSetSetSetSetSetSetSet\u001b[0m = gameScoreSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpw55gfcwk.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSetSetSetSetSetSetSetSetSetSet\u001b[0m = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreSetSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreSetSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpw55gfcwk.scala:34:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSetSetSetSetSetSetSetSetSetSetSet\u001b[0m = gameScoreSetSetSetSetSetSetSetSetSetSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreSetSetSetSetSetSetSetSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreSetSetSetSetSetSetSetSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpw55gfcwk.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSetSetSetSetSetSetSetSetSetSetSetSet\u001b[0m = gameScoreSetSetSetSetSetSetSetSetSetSetSet\n",
      "stdout": "",
      "timestamp": 1660013755
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val guessesPerScore = guessesCount / scoresCount\n        val guessesPerGame = guessesCount / gameCount\n        val guessesPerGameAbs = guessesPerGame - guessesPerScore\n        val guessesPerScoreAbs = guessesPerScore - guessesPerGame\n        val guessesPerGameAbsDiff = guessesPerGameAbs.toList\n        val guessesPerScoreAbsDiff = guessesPerScoreAbs.toList\n        val guessesPerGameAbsDiffDiff = guessesPerGameAbsDiff.zip(guessesPerScoreAbsDiff).map {\n            case (diff, diff2) => diff - diff2\n        }\n        val guessesPerScoreAbsDiffDiff = guessesPerScoreAbsDiff.zip(guessesPerGameAbsDiff).map {\n            case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n            case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n            case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n            case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n            case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n            case (diff, diff2) => diff - diff2\n        }\n        val guessesPerGameAbsDiffDiffDiff = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n            case (diff, diff2) => diff - diff2\n\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0b1i3mxn.scala:56:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m56 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0b1i3mxn.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesPerGameAbsDiffDiffDiff\u001b[0m = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mguessesPerGameAbsDiffDiffDiff is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesPerGameAbsDiffDiffDiff\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m33 |\u001b[0m            \u001b[33mcase\u001b[0m (diff, diff2) => diff - diff2\n\u001b[31m34 |\u001b[0m        }\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0b1i3mxn.scala:35:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesPerGameAbsDiffDiffDiff\u001b[0m = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mguessesPerGameAbsDiffDiffDiff is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesPerGameAbsDiffDiffDiff\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m36 |\u001b[0m            \u001b[33mcase\u001b[0m (diff, diff2) => diff - diff2\n\u001b[31m37 |\u001b[0m        }\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0b1i3mxn.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesPerGameAbsDiffDiffDiff\u001b[0m = guessesPerGameAbsDiffDiff.zip(guessesPerScoreAbsDiffDiff).map {\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0mguessesPerGameAbsDiffDiffDiff is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesPerGameAbsDiffDiffDiff\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m39 |\u001b[0m            \u001b[33mcase\u001b[0m (diff, diff2) => diff - diff2\n\u001b[31m40 |\u001b[0m        }\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp0b1i3mxn.scala:41:12 ----------",
      "stdout": "",
      "timestamp": 1660013755
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guessesScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guessesScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guessesScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guessesScoreList.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores = gameScoreList.zipWithIndex.map { case (score, index) => score }\n        val guesses\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpl0p0x1_x.scala:45:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl0p0x1_x.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScoreList.zipWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => score }\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl0p0x1_x.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScores\u001b[0m = guessesScoreList.zipWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => score }\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl0p0x1_x.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpl0p0x1_x.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreMap\u001b[0m = guessesScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[",
      "stdout": "",
      "timestamp": 1660013755
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.foldLeft(0)(_ + _)\n        val guessScore = guessScores.foldLeft(0)(_ + _)\n        val difference = guessScore - gameScore\n        val differences = guessScores.zip(gameScores).map { case (guess, game) => guess - game }\n        differences.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjsccwusb.scala:15:47 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScore\u001b[0m = gameScores.foldLeft(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Found:    Long\n\u001b[31m   |\u001b[0m                                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjsccwusb.scala:16:49 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScore\u001b[0m = guessScores.foldLeft(\u001b[31m0\u001b[0m)(_ + _)\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 Found:    Long\n\u001b[31m   |\u001b[0m                                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013755
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val difference = guessScore - gameScore\n        val differences = guessScores.zip(gameScores).map { case (guess, game) =>\n            if (guess == game) {\n                0\n            } else {\n                Math.abs(guess - game)\n            }\n        }\n        differences.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013757
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val results = new mutable.ArrayList[Long]()\n        for(score <- scores) {\n            val guess = guesses.find(_ == score)\n            if(guess == None) results += Math.abs(score - game(0))\n            else results += Math.abs(guess - score)\n        }\n        results\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaob12tyh.scala:15:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresults\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013752
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreDiff = gameScores.toList.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet = gameScoreDiff.toSet\n        val gameScoreDiffSet2 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet3 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet4 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet5 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet6 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet7 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet8 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet9 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet10 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet11 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet12 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet13 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet14 = gameScoreDiff.zip(guessScores).map { case (score, guess) => abs(guess - score) }\n        val gameScoreDiffSet15 = gameScoreDiff.\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqysmytgt.scala:33:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqysmytgt.scala:33:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013756
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map(x => x._2)\n        val guessScores = guess.zipWithIndex.map(x => x._2)\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptwvd9e32.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptwvd9e32.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptwvd9e32.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptwvd9e32.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmptwvd9e32.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSet\u001b[0m = gameScores.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660013760
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mcompare\u001b[0m(\u001b[36mgame\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m], \u001b[36mguess\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    Unit\n\u001b[31m   |\u001b[0m                                                    Required: List[Long]\n\u001b[31m13 |\u001b[0m        \u001b[34m// Your code here\u001b[0m\n\u001b[31m14 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mcompare\u001b[0m(\u001b[36mgame\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m], \u001b[36mguess\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    Unit\n\u001b[31m   |\u001b[0m                                                    Required: List[Long]\n\u001b[31m13 |\u001b[0m        \u001b[34m// Your code here\u001b[0m\n\u001b[31m14 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new Array[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val difference = guess - score\n            result(i) = difference\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzig84gbc.scala:26:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013729
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val gameScoreDiff = gameScore - guessScore\n        val gameScoreDiffs = gameScoreDiff.zipWithIndex.map { case (diff, index) => diff }\n        val gameScoreDiffsSum = gameScoreDiffs.sum\n        val gameScoreDiffsSumAbs = gameScoreDiffsSum.abs\n        val gameScoreDiffsSumAbsArray = gameScoreDiffsSumAbs.toArray\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArray.length\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiffsSumAbsArrayLength = gameScoreDiffsSumAbsArrayLength\n        val gameScoreDiff\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp62r_nzel.scala:40:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp62r_nzel.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffsSumAbsArrayLength\u001b[0m = gameScoreDiffsSumAbsArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreDiffsSumAbsArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffsSumAbsArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp62r_nzel.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffsSumAbsArrayLength\u001b[0m = gameScoreDiffsSumAbsArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreDiffsSumAbsArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffsSumAbsArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp62r_nzel.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffsSumAbsArrayLength\u001b[0m = gameScoreDiffsSumAbsArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreDiffsSumAbsArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffsSumAbsArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp62r_nzel.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffsSumAbsArrayLength\u001b[0m = gameScoreDiffsSumAbsArrayLength\n\u001b[",
      "stdout": "",
      "timestamp": 1660013760
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map{ case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp83i3aoxc.scala:51:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSize\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp83i3aoxc.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySetSize\u001b[0m = gameScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp83i3aoxc.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySetSize\u001b[0m = guessScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp83i3aoxc.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSize\u001b[0m = gameScoreValueSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp83i3aoxc.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSetSize\u001b[0m = guessScoreValueSet.si",
      "stdout": "",
      "timestamp": 1660013762
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameLength = game.size\n        val guessLength = guess.size\n        val result = new Array[Long](guessLength)\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreSet = gameScores.toSet\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpaykluvmy.scala:57:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m57 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaykluvmy.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaykluvmy.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaykluvmy.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSet\u001b[0m = gameScores.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaykluvmy.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreSet\u001b[0m = guessScores.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the s",
      "stdout": "",
      "timestamp": 1660013765
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesWithScores = guessesScores.map { case (score, index) => gameScores(index) -> score }\n        val guessesWithIndexes = guessesWithScores.map { case (score, index) => index -> score }\n        val guessesWithScoreAndIndex = guessesWithIndexes.map { case (score, index) => score -> index }\n        val guessesWithScoreAndIndexSorted = guessesWithScoreAndIndex.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversed = guessesWithScoreAndIndexSorted.reverse\n        val guessesWithScoreAndIndexSortedReversedSorted = guessesWithScoreAndIndexSortedReversed.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndex = guessesWithScoreAndIndexSortedReversedSorted.map { case (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSorted = guessesWithScoreAndIndexSortedReversedSortedWithIndex.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex.map { case (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.map { case (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.map { case (score, index) => index -> score }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpxn54n9k1.scala:18:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSorted\u001b[0m = guessesWithScoreAndIndex.sortBy(_._1)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value sortBy is not a member of Map[Long, Int]\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxn54n9k1.scala:23:83 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex\u001b[0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => index -> score }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxn54n9k1.scala:24:89 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\u001b[0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted.sortBy(_._1)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpxn54n9k1.scala:25:98 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex\u001b[0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => ",
      "stdout": "",
      "timestamp": 1660013765
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesWithScores = guessesScores.map { case (score, index) => index -> score }\n        val guessesWithIndexes = guessesWithScores.map { case (score, index) => index -> guess }\n        val guessesWithIndexesWithScores = guessesWithIndexes.map { case (score, index) => index -> gameScores(index) }\n        val guessesWithIndexesWithScoresWithIndex = guessesWithIndexesWithScores.map { case (score, index, gameScore) => index -> gameScore }\n        val guessesWithIndexesWithScoresWithIndexAndScore = guessesWithIndexesWithScoresWithIndex.map { case (score, index, gameScore) => index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndex = guessesWithIndexesWithScoresWithIndexAndScore.map { case (score, index, gameScore) => index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScore = guessesWithIndexesWithScoresWithIndexAndScoreWithIndex.map { case (score, index, gameScore) => index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndex = guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScore.map { case (score, index, gameScore) => index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScore = guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndex.map { case (score, index, gameScore) => index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScoreWithIndex = guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScore.map { case (score, index, gameScore) => index -> gameScore(index) }\n        val guessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScoreWithIndexAndScore = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpt6q2nop9.scala:25:110 --------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithIndexesWithScoresWithIndexAndScoreWithIndexAndScoreWithIndexAndScoreWithIndexAndScore\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt6q2nop9.scala:17:111 -------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithIndexesWithScores\u001b[0m = guessesWithIndexes.map { \u001b[33mcase\u001b[0m (score, index) => index -> gameScores(index) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                          Found:    (index : List[Long])\n\u001b[31m   |\u001b[0m                                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpt6q2nop9.scala:19:147 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithIndexesWithScoresWithIndexAndScore\u001b[0m = guessesWithIndexesWithScoresWithIndex.map { \u001b[33mcase\u001b[0m (score, index, gameScore) => index -> gameScore(index) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                   ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                \u001b[33mvalue\u001b[0m \u001b[35mgameScore\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpt6q2nop9.scala:20:164 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithIndexesWithScoresWithI",
      "stdout": "",
      "timestamp": 1660013766
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new Array[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val difference = abs(guess - score)\n            result(i) = difference\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptkvd4wtv.scala:26:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013717
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val diffs = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013744
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}\n        val guessesScores = guess.zipWithIndex.map{case (score, index) => score}\n        val gameScore = gameScores.sum\n        val guessesScore = guessesScores.sum\n        val differences = guessesScores.zip(gameScores).map{case (guess, game) => math.abs(guess - game)}\n        differences.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013767
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val diffs = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013744
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val differences = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        differences.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013767
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesWithScores = guessesScores.map { case (score, index) => gameScores(index) -> score }\n        val guessesWithIndexes = guessesWithScores.map { case (score, index) => index -> score }\n        val guessesWithScoreAndIndex = guessesWithIndexes.map { case (score, index) => (score, index) }\n        val guessesWithScoreAndIndexSorted = guessesWithScoreAndIndex.sortBy(_._1).reverse\n        val guessesWithScoreAndIndexSortedWithIndex = guessesWithScoreAndIndexSorted.map { case (score, index) => (score, index._2) }\n        val guessesWithScoreAndIndexSortedWithIndexSorted = guessesWithScoreAndIndexSortedWithIndex.sortBy(_._1).reverse\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedWithIndexSortedWithIndex.map { case (score, index) => (score, index._2) }\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSorted = guessesWithScoreAndIndexSortedWithIndexSortedWithIndex.sortBy(_._1).reverse\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex.map { case (score, index) => (score, index._2) }\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortBy(_._1).reverse\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.map { case (score, index) => (score, index._2) }\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.sortBy(_._1).reverse\n        val guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex = guessesWithScore\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv65r_06s.scala:18:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSorted\u001b[0m = guessesWithScoreAndIndex.sortBy(_._1).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value sortBy is not a member of Map[Long, Int]\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpv65r_06s.scala:21:69 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSortedWithIndexSortedWithIndex\u001b[0m = guessesWithScoreAndIndexSortedWithIndexSortedWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => (score, index._2) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreAndIndexSortedWithIndexSortedWithIndex\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpv65r_06s.scala:23:84 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex\u001b[0m = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => (score, index._2) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndex\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpv65r_06s.scala:24:90 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted\u001b[0m = guessesWithScoreAndIndexSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortBy(_._1).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                   ",
      "stdout": "",
      "timestamp": 1660013765
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSorted = guessesWithScores.sortBy(_._1)\n        val guessesWithScoresSortedReversed = guessesWithScoresSorted.reverse\n        val guessesWithScoresSortedReversedWithCorrect = guessesWithScoresSortedReversed.filter(_._2 == 0)\n        val guessesWithScoresSortedReversedWithIncorrect = guessesWithScoresSortedReversed.filter(_._2 != 0)\n        val guessesWithScoresSortedReversedWithCorrectAndIncorrect = guessesWithScoresSortedReversedWithCorrect ++ guessesWithScoresSortedReversedWithIncorrect\n        val guessesWithScoresSortedReversedWithCorrectAndCorrect = guessesWithScoresSortedReversedWithCorrect ++ guessesWithScoresSortedReversedWithCorrect\n        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndCorrect = guessesWithScoresSortedReversedWithCorrectAndIncorrect ++ guessesWithScoresSortedReversedWithCorrectAndCorrect\n        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect\n        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\n        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\n        val guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect\n        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp96rjq9ke.scala:23:149 --------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect\u001b[0m = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndCorrect ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrect\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp96rjq9ke.scala:24:93 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\u001b[0m = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrect\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp96rjq9ke.scala:25:103 -----------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\u001b[0m = guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrect ++ guessesWithScoresSortedReversedWithCorrectAndIncorrectAndIncorrectAndIncorrectAndIncorrectAndCorrect\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                       ^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1660013765
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesCorrect = guessesScores.zip(gameScores).map { case (guess, score) =>\n            if (guess == score) 0 else Math.abs(guess - score)\n        }\n        guessesCorrect.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013769
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n        val gameScoreMapKeys = gameScoreMap.keySet\n        val guessScoreMapKeys = guessScoreMap.keySet\n        gameScoreMapKeys.foreach(gameScoreList.+=)\n        guessScoreMapKeys.foreach(guessScoreList.+=)\n        val gameScoreMapValues = gameScoreMap.values.toList\n        val guessScoreMapValues = guessScoreMap.values.toList\n        val gameScoreMapValuesMap = gameScoreMapValues.toMap\n        val guessScoreMapValuesMap = guessScoreMapValues.toMap\n        val gameScoreMapValuesMapKeys = gameScoreMapValuesMap.keySet\n        val guessScoreMapValuesMapKeys = guessScoreMapValuesMap.keySet\n        gameScoreMapValuesMapKeys.foreach(gameScoreMapValuesList.+=)\n        guessScoreMapValuesMapKeys.foreach(guessScoreMapValuesList.+=)\n        val gameScoreMapValuesMapValues = gameScoreMapValuesMap.values.toList\n        val guessScoreMapValuesMapValues = guessScoreMapValuesMap.values.toList\n        val gameScoreMapValuesMapValuesMap = gameScoreMapValuesMapValues.toMap\n        val guessScoreMapValuesMapValuesMap = guessScoreMapValuesMapValues.toMap\n        val gameScoreMapValuesMapValuesMapKeys = gameScoreMapValuesMapValuesMap.keySet\n        val guessScoreMapValuesMapValuesMapKeys = guessScoreMapValuesMapValuesMap.keySet\n        gameScoreMapValuesMapValuesMapKeys.foreach(gameScoreMapValuesMapValuesList.+=)\n        guessScoreMapValuesMapValuesMapKeys.foreach(guessScoreMapValuesMapValuesList.+=)\n        val gameScoreMapValuesMapValuesMapValues = gameScoreMapValuesMapValuesMap.values.toList\n        val guessScoreMapValuesMapValuesMapValues = guessScoreMapValuesMapValuesMap.values.toList\n        val gameScoreMapValuesMapValuesMapValuesMap = gameScoreMapValuesMapValuesMapValues.toMap\n        val guessScoreMapValuesMapValuesMapValues\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp27t8dsvy.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmp27t8dsvy.scala:15:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Cannot prove that Long <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                       where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                 V is a type variable\n\u001b[31m   |\u001b[0m                                       .\n\u001b[31m\u001b[31m-- Error: /tmp/tmp27t8dsvy.scala:16:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Cannot prove that Long <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                       where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                 V is a type variable\n\u001b[31m   |\u001b[0m                                       .\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp27t8dsvy.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp27t8dsvy.scala:18:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          ",
      "stdout": "",
      "timestamp": 1660013769
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}.toList\n        val guessesScores = guess.zipWithIndex.map{case (score, index) => score}.toList\n        val gameScoreMap = gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toMap\n        val guessesScoreMap = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toMap\n        val gameScoreArray = gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toArray\n        val guessesScoreArray = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toArray\n        val gameScoreSet = gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toSet\n        val guessesScoreSet = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toSet\n        val gameScoreMap = gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toMap\n        val guessesScoreMap = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toMap\n        val gameScoreArray = gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toArray\n        val guessesScoreArray = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toArray\n        val gameScoreSet = gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toSet\n        val guessesScoreSet = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toSet\n        val gameScoreMap = gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toMap\n        val guessesScoreMap = guessesScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toMap\n        val gameScoreArray = gameScores.zipWithIndex.map{case (score, index) => index.toLong -> score}.toArray\n        val guessesScoreArray = guessesScores.zipWithIndex.map{case (score, index) => index\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpe54p3y27.scala:40:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe54p3y27.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.zipWithIndex.map{\u001b[33mcase\u001b[0m (score, index) => index.toLong -> score}.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe54p3y27.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreMap\u001b[0m = guessesScores.zipWithIndex.map{\u001b[33mcase\u001b[0m (score, index) => index.toLong -> score}.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe54p3y27.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreArray\u001b[0m = gameScores.zipWithIndex.map{\u001b[33mcase\u001b[0m (score, index) => index.toLong -> score}.toArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreArray is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreArray\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpe54p3y27.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24",
      "stdout": "",
      "timestamp": 1660013768
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n        val gameScores = game.zipWithIndex.map { case (score, index) => index -> score }.toMap\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => index -> score }.toMap\n        val gameScore = gameScores.map { case (index, score) => score }.toList\n        val guessesScore = guessesScores.map { case (index, score) => score }.toList\n        val gameScoreDiff = gameScore zip guessesScore map { case (gameScore, guessesScore) => Math.abs(gameScore - guessesScore) }\n        gameScoreDiff.map { case (gameScoreDiff, index) => gameScoreDiff -> index }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmgtei84r.scala:19:84 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        gameScoreDiff.map { \u001b[33mcase\u001b[0m (gameScoreDiff, index) => gameScoreDiff -> index }.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    List[(Any, Any)]\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013767
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map{ case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpfye81tef.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSet\u001b[0m = gameScores.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val result: List[Long] = guesses.map{g => if (scores.contains(g)) 0 else abs(g - scores.head)}\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmprtdt5c46.scala:15:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = guesses.map{\u001b[36mg\u001b[0m => \u001b[33mif\u001b[0m (scores.contains(g)) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m abs(g - scores.head)}\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    \u001b[1m\u001b[31mSet\u001b[0m[Long]\n\u001b[31m   |\u001b[0m                                 Required: \u001b[1m\u001b[32mList\u001b[0m[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013767
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmppr_z980i.scala:53:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppr_z980i.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppr_z980i.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreMap\u001b[0m = guessesScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppr_z980i.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppr_z980i.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreList\u001b[0m = guessesScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded ",
      "stdout": "",
      "timestamp": 1660013769
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesCorrect = guessesScores.zip(gameScores).map { case (guess, game) => guess == game }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, game) => Math.abs(guess - game) }\n        guessesCorrect ++ guessesDiff\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppau4va0u.scala:17:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        guessesCorrect ++ guessesDiff\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    List[\u001b[1m\u001b[31mAnyVal\u001b[0m]\n\u001b[31m   |\u001b[0m        Required: List[\u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013767
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val result: List[Long] = guesses.map(guess => if (scores.contains(guess)) 0 else abs(guess - scores.head))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6p6k1pru.scala:15:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = guesses.map(\u001b[36mguess\u001b[0m => \u001b[33mif\u001b[0m (scores.contains(guess)) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m abs(guess - scores.head))\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    \u001b[1m\u001b[31mSet\u001b[0m[Long]\n\u001b[31m   |\u001b[0m                                 Required: \u001b[1m\u001b[32mList\u001b[0m[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013767
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val result = guesses.zip(scores).map { case (guess, score) =>\n            if (guess == score) {\n                0\n            } else {\n                Math.abs(guess - score)\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013769
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val result = guesses.zip(scores).map {\n            case (guess, score) => if (guess == score) 0 else abs(guess - score)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013739
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guessesWithScores = game.zip(guess)\n        val guessesWithScoresSortedByScore = guessesWithScores.sortBy(_._1)\n        val guessesWithScoresSortedByGuess = guessesWithScoresSortedByScore.sortBy(_._2)\n        val guessesWithScoresSortedByGuessWithCorrect = guessesWithScoresSortedByGuess.filter(_._1 == _._2)\n        val guessesWithScoresSortedByGuessWithCorrectWithCorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithCorrectWithIncorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == _._2)\n        val guessesWithScoresSortedByGuessWithIncorrectWithCorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithIncorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == _._2)\n        val guessesWithScoresSortedByGuessWithCorrectWithIncorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithCorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithCorrectWithCorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithIncorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithCorrectWithCorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithIncorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithCorrectWithCorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == 0)\n        val guessesWithScoresSortedByGuessWithIncorrectWithIncorrect = guessesWithScoresSortedByGuessWithCorrect.filter(_\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmplcv1k55d.scala:29:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplcv1k55d.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedByGuessWithCorrectWithIncorrect\u001b[0m = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoresSortedByGuessWithCorrectWithIncorrect is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoresSortedByGuessWithCorrectWithIncorrect\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplcv1k55d.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedByGuessWithIncorrectWithCorrect\u001b[0m = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoresSortedByGuessWithIncorrectWithCorrect is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoresSortedByGuessWithIncorrectWithCorrect\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmplcv1k55d.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedByGuessWithCorrectWithCorrect\u001b[0m = guessesWithScoresSortedByGuessWithCorrect.filter(_._1 == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScores",
      "stdout": "",
      "timestamp": 1660013769
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val differences = guessScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        val correct = differences.filter(_ == 0).length\n        val wrong = differences.filter(_ != 0).length\n        val result = (correct + wrong).toList\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfsfba9iw.scala:20:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = (correct + wrong).toList\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value toList is not a member of Int - did you mean Int.toInt?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013769
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet = gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n        val gameScoreList = gameScoreList.filter(gameScoreSet.contains)\n        val guessScoreList = guessScoreList.filter(guessScoreSet.contains)\n        val gameScoreList = gameScoreList.map(gameScoreMap(_))\n        val guessScoreList = guessScoreList.map(guessScoreMap(_))\n        val gameScoreList = gameScoreList.zipWithIndex.map{case (score, index) => score}.toList\n        val guessScoreList = guessScoreList.zipWithIndex.map{case (score, index) => score}.toList\n        val gameScoreList = gameScoreList.zipWithIndex.filter(_._2 % 2 == 0).map{case (score, index) => score}.toList\n        val guessScoreList = guessScoreList.zipWithIndex.filter(_._2 % 2 == 0).map{case (score, index) => score}.toList\n        val gameScoreList = gameScoreList.zipWithIndex.filter(_._2 % 2 == 1).map{case (score, index) => score}.toList\n        val guessScoreList = guessScoreList.zipWithIndex.filter(_._2 % 2 == 1).map{case (score, index) => score}.toList\n        val gameScoreList = gameScoreList.zipWithIndex.filter(_._2 % 2 == 0).filter(_._2 % 2 == 1).map{case (score, index) => score}.toList\n        val guessScoreList = guessScoreList.zipWithIndex.filter(_._2 % 2 == 0).filter(_._2 % 2 == 1).map{case (score, index) => score}.toList\n        val gameScoreList = gameScoreList.zipWithIndex.filter(_._2 % 2 == 1).filter(_._2 % 2 == 0).map{case (score, index) => score}.toList\n        val guessScoreList = guessScoreList.zipWithIndex.filter(_._2 % 2 == 1).filter(_._2 % 2 == 0).map{case (score, index) => score}.toList\n        val gameScoreList = gameScoreList.zipWithIndex.filter(_._\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbz2hop8a.scala:35:64 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScoreList.zipWithIndex.filter(_._\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   an identifier expected, but '_' found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbz2hop8a.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScoreList.filter(gameScoreSet.contains)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbz2hop8a.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScoreList.filter(guessScoreSet.contains)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbz2hop8a.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScoreList.map(gameScoreMap(_))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbz2hop8a.scala:24:12 ---------------------------\u001b[0m\u001b[0",
      "stdout": "",
      "timestamp": 1660013772
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new Array[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val diff = Math.abs(guess - score)\n            result(i) = diff\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjq0bipzl.scala:26:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013729
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // your code here\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppgttl6qo.scala:12:70 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mcompare\u001b[0m(\u001b[36mgame\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m], \u001b[36mguess\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    Unit\n\u001b[31m   |\u001b[0m                                                    Required: List[Long]\n\u001b[31m13 |\u001b[0m        \u001b[34m// your code here\u001b[0m\n\u001b[31m14 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013771
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guessesScores.filter(_._2 > gameScores.size)\n        val guessesScores = guessesScores.map { case (score, index) => (gameScores(score) - gameScores(index)) }\n        guessesScores.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpswe2btee.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScores\u001b[0m = guessesScores.filter(_._2 > gameScores.size)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpswe2btee.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScores\u001b[0m = guessesScores.map { \u001b[33mcase\u001b[0m (score, index) => (gameScores(score) - gameScores(index)) }\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpswe2btee.scala:17:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        guessesScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    List[\u001b[1m\u001b[31m(\u001b[0mLong\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mInt\u001b[0m\u001b[1m\u001b[31m)\u001b[0m]\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660013772
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpet_5gz59.scala:51:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpet_5gz59.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySet\u001b[0m = gameScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpet_5gz59.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySet\u001b[0m = guessScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpet_5gz59.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSet\u001b[0m = gameScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpet_5gz59.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSet\u001b[0m = guessScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group o",
      "stdout": "",
      "timestamp": 1660013774
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val differences = guessScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        val correct = differences.filter(x => x == 0).length\n        val wrong = differences.filter(x => x != 0).length\n        val result = if (correct == guessScore) 0 else wrong\n        gameScores.zip(guesses).map { case (score, guess) => math.abs(guess - score) }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzn7usman.scala:21:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        gameScores.zip(guesses).map { \u001b[33mcase\u001b[0m (score, guess) => math.abs(guess - score) }\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: guesses\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzn7usman.scala:21:76 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        gameScores.zip(guesses).map { \u001b[33mcase\u001b[0m (score, guess) => math.abs(guess - score) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Byte.byte2double\n\u001b[31m   |\u001b[0m  import Byte.byte2float\n\u001b[31m   |\u001b[0m  import Byte.byte2int\n\u001b[31m   |\u001b[0m  import Byte.byte2long\n\u001b[31m   |\u001b[0m  import Byte.byte2short\n\u001b[31m   |\u001b[0m  import Char.char2double\n\u001b[31m   |\u001b[0m  import Char.char2float\n\u001b[31m   |\u001b[0m  import Char.char2int\n\u001b[31m   |\u001b[0m  import Char.char2long\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013775
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val differences = gameScores zip guessScores\n        val correct = differences.filter(_._1 == 0)\n        val wrong = differences.filter(_._1 == 1)\n        val result = correct.map(_._2).zip(wrong.map(_._2)).map { case (correct, wrong) => Math.abs(correct - wrong) }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpj1zt6_qe.scala:22)\n\tat Problem.main(tmpj1zt6_qe.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013780
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val diffs = guesses.map { guess =>\n            val score = scores.get(guess)\n            if (score == None) 0 else abs(guess - score)\n        }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz0nfgcr6.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mscore\u001b[0m = scores.get(guess)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of Set[Long] - did you mean scores.seq?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz0nfgcr6.scala:19:14 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        diffs.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    List[\u001b[1m\u001b[31mInt\u001b[0m]\n\u001b[31m   |\u001b[0m        Required: List[\u001b[1m\u001b[32mLong\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013778
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val result = guesses.zip(scores).map { case (guess, score) =>\n            if (guess == score) {\n                0\n            } else {\n                Math.abs(guess - score)\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013769
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val scores = new mutable.HashMap[Int, Long]()\n        val guesses = new mutable.HashMap[Int, Long]()\n        val scoreDiff = new mutable.HashMap[Int, Long]()\n        val guesseDiff = new mutable.HashMap[Int, Long]()\n        val scoreDiff2 = new mutable.HashMap[Int, Long]()\n        val guesseDiff2 = new mutable.HashMap[Int, Long]()\n        val scoreDiff3 = new mutable.HashMap[Int, Long]()\n        val guesseDiff3 = new mutable.HashMap[Int, Long]()\n        val scoreDiff4 = new mutable.HashMap[Int, Long]()\n        val guesseDiff4 = new mutable.HashMap[Int, Long]()\n        val scoreDiff5 = new mutable.HashMap[Int, Long]()\n        val guesseDiff5 = new mutable.HashMap[Int, Long]()\n        val scoreDiff6 = new mutable.HashMap[Int, Long]()\n        val guesseDiff6 = new mutable.HashMap[Int, Long]()\n        val scoreDiff7 = new mutable.HashMap[Int, Long]()\n        val guesseDiff7 = new mutable.HashMap[Int, Long]()\n        val scoreDiff8 = new mutable.HashMap[Int, Long]()\n        val guesseDiff8 = new mutable.HashMap[Int, Long]()\n        val scoreDiff9 = new mutable.HashMap[Int, Long]()\n        val guesseDiff9 = new mutable.HashMap[Int, Long]()\n        val scoreDiff10 = new mutable.HashMap[Int, Long]()\n        val guesseDiff10 = new mutable.HashMap[Int, Long]()\n        val scoreDiff11 = new mutable.HashMap[Int, Long]()\n        val guesseDiff11 = new mutable.HashMap[Int, Long]()\n        val scoreDiff12 = new mutable.HashMap[Int, Long]()\n        val guesseDiff12 = new mutable.HashMap[Int, Long]()\n        val scoreDiff13 = new mutable.HashMap[Int, Long]()\n        val guesseDiff13 = new mutable.HashMap[Int, Long]()\n        val scoreDiff14 = new mutable.HashMap[Int, Long]()\n        val guesseDiff14 = new mutable.HashMap[Int, Long]()\n        val scoreDiff15 = new mutable.HashMap[Int, Long]()\n        val guesseDiff15 = new \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpd_pa01ge.scala:45:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m45 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd_pa01ge.scala:13:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mscores\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd_pa01ge.scala:14:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguesses\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd_pa01ge.scala:15:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mscoreDiff\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd_pa01ge.scala:16:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguesseDiff\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd_pa01ge.scala:17:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mscoreDiff2\u001b[0m = \u001b[33mnew\u001b[0m mutable.Has",
      "stdout": "",
      "timestamp": 1660013777
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        guessesDiff.zipWithIndex.map { case (diff, index) => diff }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013780
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map { case (score, index) => score }.toList\n        val guessesScore = guessesScores.map { case (score, index) => score }.toList\n        val gameScores = gameScores.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guessesScores.map { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map { case (score, index) => score }.toList\n        val guessesScore = guessesScores.map { case (score, index) => score }.toList\n        val gameScores = gameScores.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guessesScores.map { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map { case (score, index) => score }.toList\n        val guessesScore = guessesScores.map { case (score, index) => score }.toList\n        val gameScores = gameScores.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guessesScores.map { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map { case (score, index) => score }.toList\n        val guessesScore = guessesScores.map { case (score, index) => score }.toList\n        val gameScores = gameScores.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guessesScores.map { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map { case (score, index) => score }.toList\n        val guessesScore = guessesScores.map { case (score, index) => score }.toList\n        val gameScores = gameScores.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guessesScores.map { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map { case (score, index) => score }.toList\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpv4tyrcxg.scala:36:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv4tyrcxg.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScores.map { \u001b[33mcase\u001b[0m (score, index) => score -> index }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv4tyrcxg.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScores\u001b[0m = guessesScores.map { \u001b[33mcase\u001b[0m (score, index) => score -> index }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv4tyrcxg.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScore\u001b[0m = gameScores.map { \u001b[33mcase\u001b[0m (score, index) => score }.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScore is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScore\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv4tyrcxg.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguesse",
      "stdout": "",
      "timestamp": 1660013779
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessesWithScores = guessesScores.map { case (score, index) => gameScores(index) -> score }\n        val guessesWithIndexes = guessesWithScores.map { case (score, index) => index -> score }\n        val guessesWithScoreAndIndex = guessesWithIndexes.map { case (score, index) => score -> index }\n        val guessesWithScoreAndIndexSorted = guessesWithScoreAndIndex.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversed = guessesWithScoreAndIndexSorted.reverse\n        val guessesWithScoreAndIndexSortedReversedSorted = guessesWithScoreAndIndexSortedReversed.sortBy(_._2)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndex = guessesWithScoreAndIndexSortedReversedSorted.map { case (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSorted = guessesWithScoreAndIndexSortedReversedSortedWithIndex.sortBy(_._1)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex.map { case (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted.sortBy(_._2)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.map { case (score, index) => index -> score }\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSorted.sortBy(_._2)\n        val guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndexSortedWithIndex.map { case (score, index) => index -> score }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb8wxs4jb.scala:18:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSorted\u001b[0m = guessesWithScoreAndIndex.sortBy(_._1)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value sortBy is not a member of Map[Long, Int]\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpb8wxs4jb.scala:23:83 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex\u001b[0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => index -> score }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndex\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpb8wxs4jb.scala:24:89 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\u001b[0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted.sortBy(_._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSorted\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpb8wxs4jb.scala:25:98 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex\u001b[0m = guessesWithScoreAndIndexSortedReversedSortedWithIndexSortedWithIndexSortedWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => ",
      "stdout": "",
      "timestamp": 1660013779
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new Array[Long](guessesCount)\n        val guessesIndex = 0\n        val scoresIndex = 0\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        while (guessesIndex < guessesCount && scoresIndex < scoresCount) {\n            if (guesses(guessesIndex) == scores(scoresIndex)) {\n                result(guessesIndex) = results(guessesIndex)\n                guessesIndex += 1\n                scoresIndex += 1\n            } else if (guesses(guessesIndex) < scores(scoresIndex)) {\n                result(guessesIndex) = results(guessesIndex) - abs(scores(scoresIndex) - guesses(guessesIndex))\n                guessesIndex += 1\n            } else {\n                result(guessesIndex) = abs(guesses(guessesIndex) - scores(scoresIndex))\n                scoresIndex += 1\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbk1_j5nu.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesCount\u001b[0m = guesses.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbk1_j5nu.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mscoresCount\u001b[0m = scores.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mscoresCount is already defined as \u001b[33mvalue\u001b[0m \u001b[35mscoresCount\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbk1_j5nu.scala:24:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result(guessesIndex) = results(guessesIndex)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Not found: results\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbk1_j5nu.scala:25:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                guessesIndex += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value += is not a member of Int - did you mean guessesIndex.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbk1_j5nu.scala:26:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                scoresIndex += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean scoresIndex.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbk1_j5nu.scala:28:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                result(guessesIndex) = results(guessesIndex) - abs(scores(scoresInd",
      "stdout": "",
      "timestamp": 1660013781
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x => x._2)\n        val guessScoreSet = guessScoreList.map(x => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap = gameScoreSet.zip(guessScoreSet).map(x => (x._1, x._2 - x._1)).toMap\n        val gameScoreList = gameScoreMap.toList\n        val gameScoreSet = gameScoreList.map(x => x._2)\n        val gameScoreMap = gameScoreSet.zip(guess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7hozn4mq.scala:43:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7hozn4mq.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScoreSet.zip(guessScoreSet).map(\u001b[36mx\u001b[0m => (x._1, x._2 - x._1)).toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7hozn4mq.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScoreMap.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7hozn4mq.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSet\u001b[0m = gameScoreList.map(\u001b[36mx\u001b[0m => x._2)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7hozn4mq.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScoreSet.zip(guessScoreSet).map(\u001b[36mx\u001b[0m => (x._1, x._2 - x._1)).toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreM",
      "stdout": "",
      "timestamp": 1660013780
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, score) =>\n            if (guess == score) 0 else math.abs(guess - score)\n        }\n        guessesDiff.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013781
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val results = new mutable.ArrayBuffer[Long]()\n        val correct = guesses.filter(x => x == scores(0))\n        val wrong = guesses.filter(x => x != scores(0))\n        val diff = wrong.map(x => Math.abs(x - scores(0))) \n        diff foreach { x => results += x }\n        correct foreach { x => results += 0 }\n        results\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4jkgcqir.scala:15:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresults\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013776
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameLen = game.size\n        val guessLen = guess.size\n        val result = new Array[Long](guessLen)\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScore\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9o1vhjhi.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9o1vhjhi.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySet\u001b[0m = gameScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9o1vhjhi.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySet\u001b[0m = guessScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9o1vhjhi.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSet\u001b[0m = gameScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9o1vhjhi.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSet\u001b[0m = guessScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group o",
      "stdout": "",
      "timestamp": 1660013781
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.map(x => Math.abs(x - game(x)))\n        guesses.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn2bnbsdy.scala:13:55 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguesses\u001b[0m = guess.map(\u001b[36mx\u001b[0m => Math.abs(x - game(x)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val results = new mutable.ArrayList[Long](guessesCount)\n        val guessesDiff = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiff = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount2 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount2 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount3 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount3 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount4 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount4 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount5 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount5 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount6 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount6 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount7 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount7 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount8 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount8 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount9 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount9 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount10 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount10 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount11 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount11 = new mutable.ArrayList[Long](scoresCount)\n        val guessesDiffCount12 = new mutable.ArrayList[Long](guessesCount)\n        val scoresDiffCount12 = new mutable.ArrayList[Long](scoresCount)\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmppmbrukrg.scala:44:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppmbrukrg.scala:17:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresults\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m](guessesCount)\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppmbrukrg.scala:18:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesDiff\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m](guessesCount)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppmbrukrg.scala:19:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mscoresDiff\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m](scoresCount)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppmbrukrg.scala:20:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesDiffCount\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m](guessesCount)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppm",
      "stdout": "",
      "timestamp": 1660013781
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9la7r8y5.scala:51:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9la7r8y5.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySet\u001b[0m = gameScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9la7r8y5.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySet\u001b[0m = guessScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9la7r8y5.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSet\u001b[0m = gameScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9la7r8y5.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSet\u001b[0m = guessScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group o",
      "stdout": "",
      "timestamp": 1660013782
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScores = gameScores.toList\n        val guessScores = guessScores.toList\n        val gameScores = gameScores.sortBy(_._1)\n        val guessScores = guessScores.sortBy(_._1)\n        val gameScores = gameScores.reverse\n        val guessScores = guessScores.reverse\n        val gameScores = gameScores.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guessScores.zipWithIndex.map { case (score, index) => score }\n        val gameScores = gameScores.toList\n        val guessScores = guessScores.toList\n        val gameScores = gameScores.sortBy(_._1)\n        val guessScores = guessScores.sortBy(_._1)\n        val gameScores = gameScores.reverse\n        val guessScores = guessScores.reverse\n        val gameScores = gameScores.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guessScores.zipWithIndex.map { case (score, index) => score }\n        val gameScores = gameScores.toList\n        val guessScores = guessScores.toList\n        val gameScores = gameScores.sortBy(_._1)\n        val guessScores = guessScores.sortBy(_._1)\n        val gameScores = gameScores.reverse\n        val guessScores = guessScores.reverse\n        val gameScores = gameScores.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guessScores.zipWithIndex.map { case (score, index) => score }\n        val gameScores = gameScores.toList\n        val guessScores = guessScores.toList\n        val gameScores = gameScores.sortBy(_._1)\n        val guessScores = guessScores.sortBy(_._1)\n        val gameScores = gameScores.reverse\n        val guessScores = guessScores.reverse\n        val gameScores = gameScores.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guessScores.zipWithIndex.map { case (score, index) => score }\n        val gameScores = gameScores.toList\n        val guessScore\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpisn0of2m.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpisn0of2m.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpisn0of2m.scala:16:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScores\u001b[0m = guessScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpisn0of2m.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScores.sortBy(_._1)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpisn0of2m.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScores\u001b[0m = guessScores.sortBy(_._1)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpisn0of2m.scala:19:12 ----------",
      "stdout": "",
      "timestamp": 1660013781
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.map(_.toInt)\n        val guessScores = guess.map(_.toInt)\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpnpgb_d4n.scala:52:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpnpgb_d4n.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySet\u001b[0m = gameScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpnpgb_d4n.scala:26:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySet\u001b[0m = guessScoreKeys.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpnpgb_d4n.scala:27:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSet\u001b[0m = gameScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpnpgb_d4n.scala:28:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSet\u001b[0m = guessScoreValues.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValueSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValueSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the sa",
      "stdout": "",
      "timestamp": 1660013782
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}.toList\n        val guessesScores = guess.zipWithIndex.map{case (score, index) => score}.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val guessesScoreMap = guessesScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val gameScoreArray = gameScoreMap.values\n        val guessesScoreArray = guessesScoreMap.values\n        val gameScoreArrayLength = gameScoreArray.length\n        val guessesScoreArrayLength = guessesScoreArray.length\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n        val guessesScoreArrayLength = guessesScoreArrayLength\n        val gameScoreArrayLength = gameScoreArrayLength\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreArrayLength\u001b[0m = gameScoreArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreArrayLength\u001b[0m = guessesScoreArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreArrayLength\u001b[0m = gameScoreArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreArrayLength\u001b[0m = guessesScoreArrayLength\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreArrayLength is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreArrayLength\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmph7ikpptd.scala:25:12 -----------------",
      "stdout": "",
      "timestamp": 1660013784
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score -> index }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n        val guessesScoreKeys = guessesScoreMap.keys\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessesScoreValues = guessesScoreMap.values.toList\n        val gameScoreKeysSet = gameScoreKeys.toSet\n        val guessesScoreKeysSet = guessesScoreKeys.toSet\n        val gameScoreValuesSet = gameScoreValues.toSet\n        val guessesScoreValuesSet = guessesScoreValues.toSet\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize = guessesScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessesScoreValuesSetSize = guessesScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessesScoreKeysSetSize = guessesScoreKey\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz2uh075q.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeysSetSize\u001b[0m = gameScoreKeysSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeysSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeysSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz2uh075q.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreKeysSetSize\u001b[0m = guessesScoreKeysSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreKeysSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreKeysSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz2uh075q.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValuesSetSize\u001b[0m = gameScoreValuesSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValuesSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValuesSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz2uh075q.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreValuesSetSize\u001b[0m = guessesScoreValuesSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreValuesSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreValuesSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpz2uh07",
      "stdout": "",
      "timestamp": 1660013781
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val guessesWithScore = guesses.map(x => (x, scores(x)))\n        val guessesWithScoreSorted = guessesWithScore.sortBy(_._1)\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSorted.sortBy(_._2)\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => x._1)\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._2))\n        val guessesWithScoreSortedSortedByGuess = guessesWithScoreSortedSortedByGuess.map(x => (x, x._1))\n        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp70su5jqn.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedSortedByGuess\u001b[0m = guessesWithScoreSortedSortedByGuess.map(\u001b[36mx\u001b[0m => x._1)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp70su5jqn.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedSortedByGuess\u001b[0m = guessesWithScoreSortedSortedByGuess.map(\u001b[36mx\u001b[0m => (x, x._2))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp70su5jqn.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedSortedByGuess\u001b[0m = guessesWithScoreSortedSortedByGuess.map(\u001b[36mx\u001b[0m => (x, x._1))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp70su5jqn.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedSortedByGuess\u001b[0m = guessesWithS",
      "stdout": "",
      "timestamp": 1660013783
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map(x => x._2)\n        val guessesScores = guess.zipWithIndex.map(x => x._2)\n        val guessesCorrect = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff2 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff3 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff4 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff5 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff6 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff7 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff8 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff9 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff10 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff11 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff12 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff13 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff14 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff15 = guessesScores.map(x => if (x._1 == x._2) 0 else abs(x._1 - x._2))\n        val guessesDiff16 = guesses\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgzvdfub2.scala:15:58 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesCorrect\u001b[0m = guessesScores.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._1 == x._2) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m abs(x._1 - x._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         value _1 is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgzvdfub2.scala:15:83 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesCorrect\u001b[0m = guessesScores.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._1 == x._2) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m abs(x._1 - x._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         value _1 is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgzvdfub2.scala:16:55 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesDiff\u001b[0m = guessesScores.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._1 == x._2) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m abs(x._1 - x._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         value _1 is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgzvdfub2.scala:16:80 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesDiff\u001b[0m = guessesScores.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._1 == x._2) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m abs(x._1 - x._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         value _1 is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgzvdfub2.scala:17:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesDiff2\u001b[0m = guessesScores.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._1 == x._2) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m abs(x._1 - x._2))\n\u001b[31m\u001b[31m   |\u001b[0m             ",
      "stdout": "",
      "timestamp": 1660013788
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keys\n        val guessScoreKeys = guessScoreMap.keys\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = gameScoreValueSet.size\n        val guessScoreValueSetSize = guessScoreValueSet.size\n        val gameScoreKeySetSize = gameScoreKeySet.size\n        val guessScoreKeySetSize = guessScoreKeySet.size\n        val gameScoreValueSetSize = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpzptrsuc0.scala:51:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSize\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeySetSize\u001b[0m = gameScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySetSize\u001b[0m = guessScoreKeySet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSize\u001b[0m = gameScoreValueSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpzptrsuc0.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSetSize\u001b[0m = guessScoreValueSet.si",
      "stdout": "",
      "timestamp": 1660013731
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        guessesDiff.zipWithIndex.map { case (diff, index) => diff }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013780
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreArray = gameScores.toArray\n        val guessesScoreArray = guessesScores.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.toMap.toArray\n        val gameScoreArrayMap = gameScores.toMap.toArray\n        val guessesScoreArrayMap = guessesScores.\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp86jznm8c.scala:48:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86jznm8c.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreArrayMap\u001b[0m = gameScores.toMap.toArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreArrayMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreArrayMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86jznm8c.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreArrayMap\u001b[0m = guessesScores.toMap.toArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreArrayMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreArrayMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86jznm8c.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreArrayMap\u001b[0m = gameScores.toMap.toArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreArrayMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreArrayMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp86jznm8c.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreArrayMap\u001b[0m = guessesScores.toMap.toArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreArrayMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreArrayMap\u001b[0m\n\u001b[31m   |\u001b[0m",
      "stdout": "",
      "timestamp": 1660013787
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}.toList\n        val gameScoreMap = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreMapWithIndex = gameScoreMap.zipWithIndex\n        val guessScoreMapWithIndex = guessScoreMap.zipWithIndex\n        val gameScoreMapWithIndexAndGuess = gameScoreMapWithIndex.zip(guessScoreMapWithIndex)\n        val gameScoreMapWithIndexAndGuessAndScore = gameScoreMapWithIndexAndGuess.map{case (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val gameScoreMapWithIndexAndGuessAndScoreAndGuess = gameScoreMapWithIndexAndGuessAndScore.map{case (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScore = gameScoreMapWithIndexAndGuessAndScoreAndGuess.map{case (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuess = gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScore.map{case (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScore = gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuess.map{case (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScoreAndGuess = gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScore.map{case (gameScore, guessScore, index) => (gameScore, guessScore, index)}\n        val gameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScoreAndGuessAndScore = gameScoreMapWithIndexAndGuessAnd\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuou6gwgs.scala:15:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuou6gwgs.scala:15:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuou6gwgs.scala:16:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuou6gwgs.scala:16:72 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuou6gwgs.scala:26:100 -----------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMapWithIndexAndGuessAndScoreAndGuessAndScoreAndGuessAndScoreAndGuessAndScore\u001b[0m = gameScoreMapWithIndexAndGuessAnd\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: gameScoreMapWithIndexAndGuessAnd\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer e",
      "stdout": "",
      "timestamp": 1660013787
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val result = new mutable.ArrayList[Long]()\n        for(i <- 0 until guess.size) {\n            val score = scores.get(i)\n            val guess = guesses.get(i)\n            val diff = abs(guess - score)\n            if(guess == score) {\n                result.add(0)\n            } else {\n                result.add(diff)\n            }\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz62iian2.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz62iian2.scala:17:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mscore\u001b[0m = scores.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value get is not a member of Set[Long] - did you mean scores.seq?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz62iian2.scala:18:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mguess\u001b[0m = guesses.get(i)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value get is not a member of Set[Long] - did you mean guesses.seq?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660013788
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameLen = game.length\n        val guessLen = guess.length\n        val result = new Array[Long](guessLen)\n        val gameScores = game.zipWithIndex.filter(_._2 != 0).map(_._1)\n        val guessScores = guess.zipWithIndex.filter(_._2 != 0).map(_._1)\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        guessScoreMap.foreach { case (score, index) =>\n            val guess = guessScoreMap(index)\n            if (gameScoreMap(index) == score) {\n                result(index) = guess\n            } else {\n                result(index) = abs(guess - score)\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp57ii_dz2.scala:18:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Cannot prove that Long <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                       where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                 V is a type variable\n\u001b[31m   |\u001b[0m                                       .\n\u001b[31m\u001b[31m-- Error: /tmp/tmp57ii_dz2.scala:19:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Cannot prove that Long <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                       where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                 V is a type variable\n\u001b[31m   |\u001b[0m                                       .\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp57ii_dz2.scala:28:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660013788
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val result = guesses.map(x => if (x == scores(0)) 0 else abs(x - scores(0)))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpi8bp86br.scala:19)\n\tat Problem.main(tmpi8bp86br.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013792
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet = gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n        val gameScoreMap = gameScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n        val guessScoreMap = guessScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet = gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n        val gameScoreMap = gameScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n        val guessScoreMap = guessScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet = gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n        val gameScoreMap = gameScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n        val guessScoreMap = guessScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet = gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n        val gameScoreMap = gameScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n        val guessScoreMap = guessScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n        val gameScoreList = gameScoreMap.toList\n        val guessScoreList = guessScoreMap.toList\n        val gameScoreSet = gameScoreList.toSet\n        val guessScoreSet = guessScoreList.toSet\n        val gameScoreMap = gameScoreList.zipWithIndex.map{case (score, index) => score}.toMap\n        val guess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmppn6kwwe4.scala:47:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m47 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppn6kwwe4.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScoreList.zipWithIndex.map{\u001b[33mcase\u001b[0m (score, index) => score}.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppn6kwwe4.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScoreList.zipWithIndex.map{\u001b[33mcase\u001b[0m (score, index) => score}.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppn6kwwe4.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScoreMap.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmppn6kwwe4.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScoreMap.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already def",
      "stdout": "",
      "timestamp": 1660013792
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{ case (score, index) => score }.toList\n        val guessScores = guess.zipWithIndex.map{ case (score, index) => score }.toList\n        val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val gameScoreArray = gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n        val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val gameScoreArray = gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n        val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val gameScoreArray = gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n        val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val gameScoreArray = gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n        val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val gameScoreArray = gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n        val gameScoreMap = gameScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val guessScoreMap = guessScores.zipWithIndex.map{ case (score, index) => index -> score }.toMap\n        val gameScoreArray = gameScores.toArray\n        val guessScoreArray = guessScores.toArray\n        val gameScoreMap = gameScores.zipWithIndex\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaqn85pz3.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.zipWithIndex.map{ \u001b[33mcase\u001b[0m (score, index) => index -> score }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaqn85pz3.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.zipWithIndex.map{ \u001b[33mcase\u001b[0m (score, index) => index -> score }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaqn85pz3.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreArray\u001b[0m = gameScores.toArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreArray is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreArray\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpaqn85pz3.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreArray\u001b[0m = guessScores.toArray\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreArray is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreArray\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel de",
      "stdout": "",
      "timestamp": 1660013791
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val result = new mutable.ArrayBuffer[Long]()\n        for(i <- 0 until guess.size) {\n            val score = scores(i)\n            val guess = guesses(i)\n            val difference = guess - score\n            if(guess == score) {\n                result.push(0)\n            } else {\n                result.push(difference)\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb525p5qr.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb525p5qr.scala:19:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mdifference\u001b[0m = guess - score\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Boolean, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013792
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeySet = gameScoreKeys.toSet\n        val guessScoreKeySet = guessScoreKeys.toSet\n        val gameScoreValueSet = gameScoreValues.toSet\n        val guessScoreValueSet = guessScoreValues.toSet\n        val gameScoreKeySetSet = gameScoreKeySet.toSet\n        val guessScoreKeySetSet = guessScoreKeySet.toSet\n        val gameScoreValueSetSet = gameScoreValueSet.toSet\n        val guessScoreValueSetSet = guessScoreValueSet.toSet\n        val gameScoreKeySetSetSet = gameScoreKeySetSet.toSet\n        val guessScoreKeySetSetSet = guessScoreKeySetSet.toSet\n        val gameScoreValueSetSetSet = gameScoreValueSetSet.toSet\n        val guessScoreValueSetSetSet = guessScoreValueSetSet.toSet\n        val gameScoreKeySetSetSetSet = gameScoreKeySetSetSet.toSet\n        val guessScoreKeySetSetSetSet = guessScoreKeySetSetSet.toSet\n        val gameScoreValueSetSetSetSet = gameScoreValueSetSetSet.toSet\n        val guessScoreValueSetSetSet = guessScoreValueSetSet.toSet\n        val gameScoreKeySetSetSetSetSet = gameScoreKeySetSetSet.toSet\n        val guessScoreKeySetSetSetSet = guessScoreKeySetSet.toSet\n        val gameScoreValueSetSetSetSet = gameScoreValueSetSet.toSet\n        val guessScoreValueSetSetSet = guessScoreValueSetSet.toSet\n        val gameScoreKeySetSetSetSetSet = gameScoreKeySetSetSet.toSet\n        val guessScoreKeySetSetSetSet = guessScoreKeySetSet.toSet\n        val gameScoreValueSetSetSetSet = gameScoreValueSetSet.toSet\n        val guessScoreValueSetSetSet = guessScoreValue\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3_0_2uhf.scala:36:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSetSetSet\u001b[0m = guessScoreValueSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValueSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValueSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3_0_2uhf.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeySetSetSetSet\u001b[0m = guessScoreKeySetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeySetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeySetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3_0_2uhf.scala:39:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValueSetSetSetSet\u001b[0m = gameScoreValueSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValueSetSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValueSetSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3_0_2uhf.scala:40:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValueSetSetSet\u001b[0m = guessScoreValueSetSet.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValueSetSetSet is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValueSetSetSet\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel de",
      "stdout": "",
      "timestamp": 1660013794
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}\n        val guessesScores = guess.zipWithIndex.map{case (score, index) => score}\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessesScoreList = guessesScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessesScoreSet = guessesScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpcmzhzfao.scala:53:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcmzhzfao.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcmzhzfao.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreMap\u001b[0m = guessesScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcmzhzfao.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpcmzhzfao.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreList\u001b[0m = guessesScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded ",
      "stdout": "",
      "timestamp": 1660013794
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val diffs = guessScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013742
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val difference = abs(guess - score)\n            if (difference < score) {\n                result.clear()\n                result.add(difference)\n            } else {\n                result.add(0)\n            }\n            i += 1\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp83cf57gp.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013790
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScores = gameScoreList.zip(guessesScoreList).map { case (gameScore, guessesScore) => Math.abs(gameScore - guessesScore) }\n        gameScores\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp2aa4t3zx.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScoreList.zip(guessesScoreList).map { \u001b[33mcase\u001b[0m (gameScore, guessesScore) => Math.abs(gameScore - guessesScore) }\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- Error: /tmp/tmp2aa4t3zx.scala:15:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Cannot prove that Long <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                       where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                 V is a type variable\n\u001b[31m   |\u001b[0m                                       .\n\u001b[31m\u001b[31m-- Error: /tmp/tmp2aa4t3zx.scala:16:49 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreMap\u001b[0m = guessesScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Cannot prove that Long <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                       where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                 V is a type variable\n\u001b[31m   |\u001b[0m                                       .\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660013793
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val result = new mutable.ArrayList[Long]()\n        val guessesWithScore = scores.map(x => (x, game(x)))\n        val guessesWithScoreSortedByScore = guessesWithScore.sortBy(_._2)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByScore.map(x => (x._1, x._2))\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val guessesWithScoreSortedByGuess = guessesWithScoreSortedByGuess.filter(_._2 > 0)\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpv_dj0s_j.scala:35:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv_dj0s_j.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.filter(_._2 > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv_dj0s_j.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.filter(_._2 > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpv_dj0s_j.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreSortedByGuess\u001b[0m = guessesWithScoreSortedByGuess.filter(_._2 > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreSortedByGuess is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreSortedByGuess\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m",
      "stdout": "",
      "timestamp": 1660013794
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}.toList\n        val gameScoreMap = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n        val guessScoreMap = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n        val gameScoreList: List[Long] = gameScoreMap.map(_._2).flatten.toList\n        val guessScoreList: List[Long] = guessScoreMap.map(_._2).flatten.toList\n        val gameScoreDiff = gameScoreList.zip(guessScoreList).map{case (gameScore, guessScore) => Math.abs(gameScore - guessScore)}\n        gameScoreDiff.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpatsgys6z.scala:15:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpatsgys6z.scala:15:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpatsgys6z.scala:16:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpatsgys6z.scala:16:72 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.groupBy(_._1).mapValues(_.map(_._2))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660013795
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map { case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map { case (guess, index) => guess }\n        val diffs : List[Long] = guesses.zip(scores).map { case (guess, score) =>\n            val diff = guess - score\n            if (diff < 0) diff else diff\n        }\n        diffs\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmplhtue0ke.scala:22)\n\tat Problem.main(tmplhtue0ke.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013797
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val results = new mutable.ArrayList[Long]()\n        val guessesWithScore = guess.zip(game)\n        val scoresWithGuesses = scores.zip(guesses)\n        guessesWithScore.foreach { case (guess, score) =>\n            if (score == guess) {\n                results.add(0)\n            } else {\n                val difference = guess - score\n                results.add(difference)\n            }\n        }\n        results.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4spmmyh9.scala:15:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresults\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013790
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreCount = gameScores.count\n        val guessScoreCount = guessScores.count\n        val gameScoreDiff = gameScoreCount - guessScoreCount\n        val guessScoreDiff = guessScoreCount - gameScoreCount\n        val gameScoreDiffs = gameScores.zip(guessScores).map { case (gameScore, guessScore) =>\n            val gameScoreDiff = gameScore - guessScore\n            if (gameScoreDiff < 0)\n                gameScoreDiff\n            else\n                gameScoreDiff + gameScoreDiff\n        }\n        val guessScoreDiffs = guessScores.zip(gameScores).map { case (guessScore, gameScore) =>\n            val guessScoreDiff = guessScore - gameScore\n            if (guessScoreDiff < 0)\n                guessScoreDiff\n            else\n                guessScoreDiff + guessScoreDiff\n        }\n        gameScoreDiffs.zip(guessScoreDiffs).map { case (gameScoreDiff, guessScoreDiff) =>\n            if (gameScoreDiff < 0)\n                guessScoreDiff\n            else\n                gameScoreDiff + guessScoreDiff\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj30v_0sn.scala:17:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiff\u001b[0m = gameScoreCount - guessScoreCount\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of (Long => Boolean) => Int, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj30v_0sn.scala:18:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreDiff\u001b[0m = guessScoreCount - gameScoreCount\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of (Long => Boolean) => Int, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660013796
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val scores : List[Long] = game.zipWithIndex.map { case (score, index) => score }\n        val guesses : List[Long] = guess.zipWithIndex.map { case (guess, index) => guess }\n        val guessesWithScores : List[(Long, Long)] = guesses.zipWithIndex.map { case (guess, index) => (guess, scores(index)) }\n        val guessesWithScoreAndIndex : List[(Long, Long, Int)] = guessesWithScores.zipWithIndex.map { case (guess, score, index) => (guess, score, index) }\n        val guessesWithScoreAndIndexAndGuessed : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAndGuessed : Set[Long] = guessesWithScoreAndIndex.map { case (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n        val guessesWithScoreAndIndexAnd\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp1dm6oec0.scala:26:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1dm6oec0.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexAndGuessed\u001b[0m : \u001b[35mSet\u001b[0m[\u001b[35mLong\u001b[0m] = guessesWithScoreAndIndex.map { \u001b[33mcase\u001b[0m (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreAndIndexAndGuessed is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreAndIndexAndGuessed\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1dm6oec0.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexAndGuessed\u001b[0m : \u001b[35mSet\u001b[0m[\u001b[35mLong\u001b[0m] = guessesWithScoreAndIndex.map { \u001b[33mcase\u001b[0m (guess, score, index, guessed) => (guess, score, index, guessed) }.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesWithScoreAndIndexAndGuessed is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesWithScoreAndIndexAndGuessed\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp1dm6oec0.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoreAndIndexAndGuessed\u001b[0m : \u001b[35mSet\u001b[0m[\u001b[35mLong\u001b[0m] = guessesWithScoreAndIndex.map { \u001b[33mcase\u001b[0m (guess, score, index, guessed) => (guess, score, index, guessed) }.toSe",
      "stdout": "",
      "timestamp": 1660013796
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreSetMap = gameScores.toMap.toSet\n        val guessScoreSetMap = guessScores.toMap.toSet\n        val gameScoreSetSetMap = gameScores.toMap.toSet.toSet\n        val guessScoreSetSetMap = guessScores.toMap.toSet.toSet\n        val gameScoreSetListMap = gameScores.toMap.toSet.toList\n        val guessScoreSetListMap = guessScores.toMap.toSet.toList\n        val gameScoreSetMapMap = gameScores.toMap.toSet.toMap\n        val guessScoreSetMapMap = guessScores.toMap.toSet.toMap\n        val gameScoreSetSetMapMap = gameScores.toMap.toSet.toMap.toMap\n        val guessScoreSetSetMapMap = guessScores.toMap.toSet.toMap.toMap\n        val gameScoreSetListMapMap = gameScores.toMap.toSet.toList.toMap\n        val guessScoreSetListMapMap = guessScores.toMap.toSet.toList.toMap\n        val gameScoreSetMapMapMap = gameScores.toMap.toSet.toMap.toMap\n        val guessScoreSetMapMapMap = guessScores.toMap.toSet.toMap.toMap\n        val gameScoreSetSetMapMapMap = gameScores.toMap.toSet.toMap.toMap.toMap\n        val guessScoreSetSetMapMapMap = guessScores.toMap.toSet.toMap.toMap.toMap\n        val gameScoreSetListMapMap = gameScores.toMap.toSet.toList.toMap.toMap\n        val guessScoreSetListMapMap = guessScores.toMap.toSet.toList.toMap.toMap\n        val gameScoreSetMapMapMapMap = gameScores.toMap.toSet.toMap.toMap.toMap\n        val guessScoreSetMapMapMapMap = guessScores.toMap.toSet.toMap.toMap.toMap\n        val gameScoreSetSetMapMapMapMap = gameScores.toMap.toSet\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmphahv2j41.scala:37:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSetListMapMap\u001b[0m = gameScores.toMap.toSet.toList.toMap.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreSetListMapMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreSetListMapMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmphahv2j41.scala:38:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreSetListMapMap\u001b[0m = guessScores.toMap.toSet.toList.toMap.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreSetListMapMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreSetListMapMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- Error: /tmp/tmphahv2j41.scala:19:43 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Cannot prove that Long <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                       where:    K is a type variable\n\u001b[31m   |\u001b[0m                                                 V is a type variable\n\u001b[31m   |\u001b[0m                                       .\n\u001b[31m\u001b[31m-- Error: /tmp/tmphahv2j41.scala:20:45 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Cannot prove that Long <:< (K, V)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                       where:    K is a t",
      "stdout": "",
      "timestamp": 1660013797
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSetList = gameScores.toList\n        val guessScoreSetList = guessScores.toList\n        val gameScoreSetSet = gameScores.toSet.toSet\n        val guessScoreSetSet = guessScores.toSet.toSet\n        val gameScoreSetList = gameScores.toList.toList\n        val guessScoreSetList = guessScores.toList.toList\n        val gameScoreSetSetList = gameScores.toSet.toList.toList\n        val guessScoreSetSetList = guessScores.toSet.toList.toList\n        val gameScoreSetSetSet = gameScores.toSet.toSet.toSet\n        val guessScoreSetSetSet = guessScores.toSet.toSet.toSet\n        val gameScoreSetSetList = gameScores.toSet.toList.toList\n        val guessScoreSetSetList = guessScores.toSet.toList.toList\n        val gameScoreSetSetSet = gameScores.toSet.toSet.toSet\n        val guessScoreSetSetSet = guessScores.toSet.toSet.toSet\n        val gameScoreSetSetSetList = gameScores.toSet.toList.toList.toList\n        val guessScoreSetSetSetList = guessScores.toSet.toList.toList.toList\n        val gameScoreSetSetSetSet = gameScores.toSet.toSet.toSet.toSet\n        val guessScoreSetSetSetSet = guessScores.toSet.toSet.toSet.toSet\n        val gameScoreSetSetSetSetList = gameScores.toSet.toSet.toList.toList.toList\n        val guessScoreSetSetSetSetList = guessScores.toSet.toSet.toList.toList.toList\n        val gameScoreSetSetSetSetSet = gameScores.toSet.toSet.toSet.toSet.toSet\n        val guessScoreSetSetSetSetSet = guessScores.toSet.toSet.toSet.toSet.toSet\n        val gameScoreSetSetSetSetSetList = gameScores.toSet.toSet.toList.toList.toList.toList\n        \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSetList\u001b[0m = gameScores.toList.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreSetList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreSetList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreSetList\u001b[0m = guessScores.toList.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreSetList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreSetList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSetSetList\u001b[0m = gameScores.toSet.toList.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreSetSetList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreSetSetList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreSetSetList\u001b[0m = guessScores.toSet.toList.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreSetSetList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreSetSetList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp15f8y5qd.scala:31:12 -------------------------",
      "stdout": "",
      "timestamp": 1660013794
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val gameScoreDiff = gameScore - guessScore\n        val gameScoreDiffs = gameScoreDiff.zipWithIndex.map { case (score, index) => score }\n        val gameScoreDiffsSorted = gameScoreDiffs.sortWith(_ < _)\n        val gameScoreDiffsSortedIndex = gameScoreDiffsSorted.zipWithIndex.map { case (score, index) => index }\n        val gameScoreDiffsSortedIndexReversed = gameScoreDiffsSortedIndex.zipWithIndex.map { case (index, score) => score }\n        val gameScoreDiffsSortedIndexReversedSorted = gameScoreDiffsSortedIndexReversed.sortWith(_ < _)\n        val gameScoreDiffsSortedIndexReversedSortedIndex = gameScoreDiffsSortedIndexReversedSorted.zipWithIndex.map { case (score, index) => index }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversed = gameScoreDiffsSortedIndexReversedSortedIndex.zipWithIndex.map { case (index, score) => score }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversedSorted = gameScoreDiffsSortedIndexReversedSortedIndexReversed.sortWith(_ < _)\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex.zipWithIndex.map { case (score, index) => index }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed.zipWithIndex.map { case (index, score) => score }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversedSorted = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversedSorted.zipWithIndex.map { case (score, index) => index }\n        val gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversedSortedIndex = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversedSortedIndex.zipWithIndex.map { case (score, index) => index }\n        val \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmpiyxmj2cg.scala:30:11 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \n\u001b[31m\u001b[31m   |\u001b[0m           ^\u001b[0m\n\u001b[31m   |\u001b[0m           pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiyxmj2cg.scala:18:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffs\u001b[0m = gameScoreDiff.zipWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => score }\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value zipWithIndex is not a member of Long\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpiyxmj2cg.scala:26:78 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex\u001b[0m = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex.zipWithIndex.map { \u001b[33mcase\u001b[0m (score, index) => index }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                              ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndex\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpiyxmj2cg.scala:27:86 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed\u001b[0m = gameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed.zipWithIndex.map { \u001b[33mcase\u001b[0m (index, score) => score }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffsSortedIndexReversedSortedIndexReversedSortedIndexReversed\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tm",
      "stdout": "",
      "timestamp": 1660013797
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        guessesDiff.zipWithIndex.map { case (diff, index) => diff }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013780
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpnjwp6eo7.scala:12:70 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mcompare\u001b[0m(\u001b[36mgame\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m], \u001b[36mguess\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m]) : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    Unit\n\u001b[31m   |\u001b[0m                                                    Required: List[Long]\n\u001b[31m13 |\u001b[0m        \u001b[34m// Your code here\u001b[0m\n\u001b[31m14 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013718
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val results = new mutable.ArrayList[Long](guessesCount)\n        val guessesRemaining = guessesCount - 1\n        val scoresRemaining = scoresCount - 1\n        val guessesRemainingCount = guessesRemaining\n        val scoresRemainingCount = scoresRemaining\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n        var m = 0\n        var n = 0\n        var o = 0\n        var p = 0\n        var q = 0\n        var r = 0\n        var s = 0\n        var t = 0\n        var u = 0\n        var v = 0\n        var w = 0\n        var x = 0\n        var y = 0\n        var z = 0\n        var a = 0\n        var b = 0\n        var c = 0\n        var d = 0\n        var e = 0\n        var f = 0\n        var g = 0\n        var h = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        var l = 0\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:48:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m48 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mi is already defined as \u001b[33mvariable\u001b[0m \u001b[35mi\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:49:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mj\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mj is already defined as \u001b[33mvariable\u001b[0m \u001b[35mj\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:50:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mk\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mk is already defined as \u001b[33mvariable\u001b[0m \u001b[35mk\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:51:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m51 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ml\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml is already defined as \u001b[33mvariable\u001b[0m \u001b[35ml\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:52:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m52 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mm\u001b[0m = \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mm is already defined as \u001b[33mvariable\u001b[0m \u001b[35mm\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpev_d476v.scala:53:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m53 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mn\u001b[0m",
      "stdout": "",
      "timestamp": 1660013796
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, score) => (guess - score) }\n        guessesDiff.filter(x => x < 0).map(x => math.abs(x))\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpads6c7qg.scala:19)\n\tat Problem.main(tmpads6c7qg.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013800
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new Array[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val difference = abs(guess - score)\n            result(i) = difference\n            i += 1\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptkvd4wtv.scala:26:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        result\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (result : Array[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013717
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score -> index }.toMap\n        val gameScore = gameScores.map { case (score, index) => score }.toList\n        val guessScore = guessScores.map { case (score, index) => score }.toList\n        val gameScoreDiff = gameScore diff guessScore\n        val gameScoreDiffList = gameScoreDiff.map { case (score, index) => score -> index }.toMap\n        val gameScoreDiffListSorted = gameScoreDiffList.sortBy(_._1)\n        val gameScoreDiffListSortedReversed = gameScoreDiffListSorted.reverse\n        val gameScoreDiffListSortedReversedList = gameScoreDiffListSortedReversed.map { case (score, index) => index -> score }.toList\n        val gameScoreDiffListSortedReversedListSorted = gameScoreDiffListSortedReversedList.sortBy(_._1)\n        val gameScoreDiffListSortedReversedListSortedReversed = gameScoreDiffListSortedReversedListSorted.reverse\n        val gameScoreDiffListSortedReversedListSortedReversedList = gameScoreDiffListSortedReversedListSortedReversed.map { case (score, index) => index -> score }.toList\n        val gameScoreDiffListSortedReversedListSortedReversedListSorted = gameScoreDiffListSortedReversedListSortedReversedListSorted.sortBy(_._1)\n        val gameScoreDiffListSortedReversedListSortedReversedListSortedReversed = gameScoreDiffListSortedReversedListSortedReversedListSortedReversed.map { case (score, index) => index -> score }.toList\n        val gameScoreDiffListSortedReversedListSortedReversedListSortedReversedList = gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSorted.reverse\n        val gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSorted = gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSortedReversed.map { case (score, index) => index -> score }.toList\n        val gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSortedReversed = gameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSortedReversedListSorted.reverse\n        val gameScoreDiffListSortedReversedListSortedReversed\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpuk9qhajo.scala:31:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuk9qhajo.scala:19:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffListSorted\u001b[0m = gameScoreDiffList.sortBy(_._1)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value sortBy is not a member of Map[Any, Any]\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpuk9qhajo.scala:25:74 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffListSortedReversedListSortedReversedListSorted\u001b[0m = gameScoreDiffListSortedReversedListSortedReversedListSorted.sortBy(_._1)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                          ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffListSortedReversedListSortedReversedListSorted\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpuk9qhajo.scala:26:82 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffListSortedReversedListSortedReversedListSortedReversed\u001b[0m = gameScoreDiffListSortedReversedListSortedReversedListSortedReversed.map { \u001b[33mcase\u001b[0m (score, index) => index -> score }.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35mgameScoreDiffListSortedReversedListSortedReversedListSortedReversed\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpuk9qhajo.scala:29:100 -----------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffListSortedReversedListSortedReversedListSortedReversedListSortedReversed\u001b[0m = gameScoreDiffL",
      "stdout": "",
      "timestamp": 1660013800
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n        val gameScores = game.map(x => if (x == 0) 0 else x)\n        val guessesScores = guess.map(x => if (x == 0) 0 else x)\n        val diffs = guessesScores.zip(gameScores).map(x => if (x._1 == x._2) 0 else x._1 - x._2)\n        diffs\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpnxikx8o2.scala:20)\n\tat Problem.main(tmpnxikx8o2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013800
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSet\u001b[0m = gameScores.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessScore = guessScores.sum\n        val gameScoreDiff = gameScore - guessScore\n        val gameScoreDiffs = gameScoreDiff.zipWithIndex.map { case (diff, index) => diff }\n        val gameScoreDiffsSum = gameScoreDiffs.sum\n        val gameScoreDiffsSumAbs = gameScoreDiffsSum.abs\n        val guessScoreDiff = guessScore - gameScore\n        val guessScoreDiffs = guessScoreDiff.zipWithIndex.map { case (diff, index) => diff }\n        val guessScoreDiffsSum = guessScoreDiffs.sum\n        val guessScoreDiffsSumAbs = guessScoreDiffsSum.abs\n        val gameScoreDiffsSumAbsDiffs = gameScoreDiffsSumAbs.zipWithIndex.map { case (diff, index) => diff }\n        val gameScoreDiffsSumAbsDiffsSum = gameScoreDiffsSumAbsDiffs.sum\n        val gameScoreDiffsSumAbsDiffsSumAbs = gameScoreDiffsSumAbsDiffsSum.abs\n        val guessScoreDiffsSumAbsDiff = guessScoreDiffsSumAbs - gameScoreDiff\n        val guessScoreDiffsSumAbsDiffs = guessScoreDiffsSumAbsDiff.zipWithIndex.map { case (diff, index) => diff }\n        val guessScoreDiffsSumAbsDiffsSum = guessScoreDiffsSumAbsDiffsSum.sum\n        val guessScoreDiffsSumAbsDiffsSumAbs = guessScoreDiffsSumAbsDiffsSum.abs\n        val gameScoreDiffsSumAbsDiffsSumAbsDiffs = gameScoreDiffsSumAbsDiffsSumAbs.zipWithIndex.map { case (diff, index) => diff }\n        val gameScoreDiffsSumAbsDiffsSumAbsDiffsSum = gameScoreDiffsSumAbsDiffsSumAbsDiffs.sum\n        val gameScoreDiffsSumAbsDiffsSumAbsDiffsSumAbs = gameScoreDiffsSumAbsDiffsSumAbsDiffsSum.abs\n        val guessScoreDiffsSum\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpujqqhadx.scala:36:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpujqqhadx.scala:18:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreDiffs\u001b[0m = gameScoreDiff.zipWithIndex.map { \u001b[33mcase\u001b[0m (diff, index) => diff }\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value zipWithIndex is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpujqqhadx.scala:22:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreDiffs\u001b[0m = guessScoreDiff.zipWithIndex.map { \u001b[33mcase\u001b[0m (diff, index) => diff }\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value zipWithIndex is not a member of Long\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpujqqhadx.scala:30:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreDiffsSumAbsDiffsSum\u001b[0m = guessScoreDiffsSumAbsDiffsSum.sum\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mguessScoreDiffsSumAbsDiffsSum\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpujqqhadx.scala:36:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660013801
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val results = new mutable.ArrayBuffer[Long]()\n        for(score <- scores) {\n            val guess = guesses.find(_ == score)\n            if (guess == None) results += score\n            else results += abs(guess - score)\n        }\n        results\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6xpc28ql.scala:15:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresults\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013797
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val result = new mutable.ArrayList[Long](guessesCount)\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val difference = abs(guess - score)\n            if (difference == 0) {\n                result(i) = difference\n            } else {\n                result(i) = difference\n            }\n            i += 1\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmph39fl_9r.scala:17:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m](guessesCount)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013799
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesCount = guesses.size\n        val scoresCount = scores.size\n        val diffs = mutable.ArrayBuffer.empty[Long]\n        var i = 0\n        while (i < guessesCount) {\n            val guess = guesses(i)\n            val score = scores(i)\n            val diff = Math.abs(guess - score)\n            diffs += diff\n            i += 1\n        }\n        diffs\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4ltt6oqz.scala:17:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mdiffs\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013800
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScore = gameScores.sum\n        val guessesScore = guessesScores.sum\n        val diffs = guessesScores.zip(gameScores).map { case (guess, game) => math.abs(guess - game) }\n        diffs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660013803
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach { case (score, index) => gameScoreList.add(score) }\n        guessScoreMap.foreach { case (score, index) => guessScoreList.add(score) }\n        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach { case (score, index) => gameScoreList.add(score) }\n        guessScoreMap.foreach { case (score, index) => guessScoreList.add(score) }\n        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach { case (score, index) => gameScoreList.add(score) }\n        guessScoreMap.foreach { case (score, index) => guessScoreList.add(score) }\n        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = new mutable.ListBuffer[Long]()\n        val guessScoreList = new mutable.ListBuffer[Long]()\n        gameScoreMap.foreach { case (score, index) => gameScoreList.add(score) }\n        guessScoreMap.foreach { case (score, index) => guessScoreList.add(score) }\n        val gameScores = gameScoreList.toList\n        val guessScores = guessScoreList.toList\n        val gameScoreMap = gameScores.toMap\n        val guessScore\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3nfl9a5z.scala:49:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m49 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3nfl9a5z.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScoreList.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3nfl9a5z.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScores\u001b[0m = guessScoreList.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3nfl9a5z.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3nfl9a5z.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3nfl9a5z.scala:25:12 ----------",
      "stdout": "",
      "timestamp": 1660013803
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map { case (score, index) => score }\n        val guessesDiff = guessesScores.zip(gameScores).map { case (guess, score) => (guess - score) }\n        guessesDiff.map { case (guess, score) => (guess - score) }\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_50qp5r_.scala:16:56 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        guessesDiff.map { \u001b[33mcase\u001b[0m (guess, score) => (guess - score) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013803
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSet\u001b[0m = gameScores.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        // Your code here\n        val gameScores = game.zipWithIndex.map{ case (score, index) => score }\n        val guessesScores = guess.zipWithIndex.map{ case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessesScoreMap = guessesScores.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScoreSet = gameScoreList.distinct\n        val guessesScoreSet = guessesScoreList.distinct\n        val gameScoreMap = gameScoreSet.zip(gameScoreList).map{ case (score, index) => index -> score }.toMap\n        val guessesScoreMap = guessesScoreSet.zip(guessesScoreList).map{ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScoreSet = gameScoreList.distinct\n        val guessesScoreSet = guessesScoreList.distinct\n        val gameScoreMap = gameScoreSet.zip(gameScoreList).map{ case (score, index) => index -> score }.toMap\n        val guessesScoreMap = guessesScoreSet.zip(guessesScoreList).map{ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScoreSet = gameScoreList.distinct\n        val guessesScoreSet = guessesScoreList.distinct\n        val gameScoreMap = gameScoreSet.zip(gameScoreList).map{ case (score, index) => index -> score }.toMap\n        val guessesScoreMap = guessesScoreSet.zip(guessesScoreList).map{ case (score, index) => index -> score }.toMap\n        val gameScoreList = gameScoreMap.values.toList\n        val guessesScoreList = guessesScoreMap.values.toList\n        val gameScoreSet = gameScoreList.distinct\n        val guessesScoreSet = guessesScoreList.distinct\n        val gameScoreMap = gameScoreSet.zip(gameScoreList).map{ case (score, index) => index -> score }.toMap\n        val guessesScoreMap = guessesScoreSet.zip(guessesScoreList).map{ case (score, index) => index -> score }.toMap\n        val gameScoreList = \n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmphkbytu0_.scala:42:27 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = \n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmphkbytu0_.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScoreSet.zip(gameScoreList).map{ \u001b[33mcase\u001b[0m (score, index) => index -> score }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmphkbytu0_.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesScoreMap\u001b[0m = guessesScoreSet.zip(guessesScoreList).map{ \u001b[33mcase\u001b[0m (score, index) => index -> score }.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessesScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessesScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmphkbytu0_.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScoreMap.values.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[3",
      "stdout": "",
      "timestamp": 1660013803
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val games = game.toSet\n        val result = game.zip(guess).map { case (game, guess) =>\n            if (games.contains(guess))\n                0\n            else\n                Math.abs(guess - game)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp07sztydo.scala:24)\n\tat Problem.main(tmp07sztydo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660013803
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toSet\n        val scores = game.toSet\n        val result = new mutable.ListBuffer[Long]()\n        for(score <- scores) {\n            val guess = guesses.find(_ == score)\n            if(guess == None) result += score\n            else result += abs(guess - score)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwaztp0ph.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660013801
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreKeys = gameScoreMap.keySet\n        val guessScoreKeys = guessScoreMap.keySet\n        val gameScoreValues = gameScoreMap.values.toList\n        val guessScoreValues = guessScoreMap.values.toList\n        val gameScoreKeysSet = gameScoreKeys.toSet\n        val guessScoreKeysSet = guessScoreKeys.toSet\n        val gameScoreValuesSet = gameScoreValues.toSet\n        val guessScoreValuesSet = guessScoreValues.toSet\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessScoreKeysSetSize = guessScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessScoreValuesSetSize = guessScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessScoreKeysSetSize = guessScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessScoreValuesSetSize = guessScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessScoreKeysSetSize = guessScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessScoreValuesSetSize = guessScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessScoreKeysSetSize = guessScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessScoreValuesSetSize = guessScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessScoreKeysSetSize = guessScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessScoreValuesSetSize = guessScoreValuesSet.size\n        val gameScoreKeysSetSize = gameScoreKeysSet.size\n        val guessScoreKeysSetSize = guessScoreKeysSet.size\n        val gameScoreValuesSetSize = gameScoreValuesSet.size\n        val guessScoreValuesSetSize = guessScoreValuesSet.size\n        val gameScoreKey\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp3pr7n19s.scala:50:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m50 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3pr7n19s.scala:29:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreKeysSetSize\u001b[0m = gameScoreKeysSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreKeysSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreKeysSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3pr7n19s.scala:30:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreKeysSetSize\u001b[0m = guessScoreKeysSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreKeysSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreKeysSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3pr7n19s.scala:31:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreValuesSetSize\u001b[0m = gameScoreValuesSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreValuesSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreValuesSetSize\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp3pr7n19s.scala:32:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreValuesSetSize\u001b[0m = guessScoreValuesSet.size\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreValuesSetSize is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreValuesSetSize\u001b[0m",
      "stdout": "",
      "timestamp": 1660013803
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.toList\n        val scores = game.toList\n        val guessesWithScores = guesses.zip(scores)\n        val guessesWithScoresSortedByScore = guessesWithScores.sortBy(_._2)\n        val guessesWithScoresSortedByGuess = guessesWithScoresSortedByScore.map(x => x._1)\n        val guessesWithScoresSortedByGuessWithScores = guessesWithScoresSortedByGuess.zip(scores)\n        val guessesWithScoresSortedByGuessWithScoresSortedByScore = guessesWithScoresSortedByGuessWithScores.sortBy(_._2)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuess = guessesWithScoresSortedByGuessWithScoresSortedByScore.map(x => x._1)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScores = guessesWithScoresSortedByGuessWithScoresSortedByGuess.zip(scores)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(x => x._1)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScores = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuess.zip(scores)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(x => x._1)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScores = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(x => x._1)\n        val guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwbh_kfbf.scala:27:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '=' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwbh_kfbf.scala:22:91 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\u001b[0m = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(\u001b[36mx\u001b[0m => x._1)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                           ^\u001b[0m\n\u001b[31m   |\u001b[0mRecursive \u001b[33mvalue\u001b[0m \u001b[35m\n\u001b[31m   |\u001b[0m  guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\n\u001b[31m   |\u001b[0m\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwbh_kfbf.scala:23:101 -----------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScores\u001b[0m = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuess.zip(scores)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNot found: guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuess\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpwbh_kfbf.scala:24:114 --------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore\u001b[0m = guessesWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByGuessWithScoresSortedByScore.map(\u001b[36mx\u001b[0m => x._1)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ",
      "stdout": "",
      "timestamp": 1660013803
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val guesses = guess.map(x => Math.abs(x - game))\n        val correct = game.zip(guesses).map { case (x, y) => if (x == y) 0 else Math.abs(x - y) }\n        correct.toList\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp5erz9l6i.scala:13:48 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguesses\u001b[0m = guess.map(\u001b[36mx\u001b[0m => Math.abs(x - game))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Double\n\u001b[31m   |\u001b[0m (x: Float): Float\n\u001b[31m   |\u001b[0m (x: Long): Long\n\u001b[31m   |\u001b[0m (x: Int): Long\n\u001b[31m   |\u001b[0m (x: Char): Long\n\u001b[31m   |\u001b[0m (x: Short): Long\n\u001b[31m   |\u001b[0m (x: Byte): Long\n\u001b[31m   |\u001b[0mmatch arguments ((game : List[Long]))\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmp5erz9l6i.scala:14:67 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcorrect\u001b[0m = game.zip(guesses).map { \u001b[33mcase\u001b[0m (x, y) => \u001b[33mif\u001b[0m (x == y) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m Math.abs(x - y) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m==\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0m (x$0: Any): Boolean\n\u001b[31m   |\u001b[0mall match arguments ((y : Nothing))\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E051] Reference Error: /tmp/tmp5erz9l6i.scala:14:91 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcorrect\u001b[0m = game.zip(guesses).map { \u001b[33mcase\u001b[0m (x, y) => \u001b[33mif\u001b[0m (x == y) \u001b[31m0\u001b[0m \u001b[33melse\u001b[0m Math.abs(x - y) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0mAmbiguous overload. The overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m-\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLo",
      "stdout": "",
      "timestamp": 1660013803
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map { case (score, index) => score }\n        val guessScores = guess.zipWithIndex.map { case (score, index) => score }\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guessScores.toSet\n        val gameScoreMap = gameScores.toMap\n        val guessScoreMap = guessScores.toMap\n        val gameScoreList = gameScores.toList\n        val guessScoreList = guessScores.toList\n        val gameScoreSet = gameScores.toSet\n        val guessScoreSet = guess\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:21:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreMap\u001b[0m = gameScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:22:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreMap\u001b[0m = guessScores.toMap\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreMap is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreMap\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:23:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreList\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:24:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScoreList\u001b[0m = guessScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScoreList is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScoreList\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmps2vlxvc8.scala:25:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScoreSet\u001b[0m = gameScores.toSet\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1660013743
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // I think we all remember that feeling when the result of some long-awaited\n    // event is finally known. The feelings and thoughts you have at that moment are\n    // definitely worth noting down and comparing.\n    // Your task is to determine if a person correctly guessed the results of a number of matches.\n    // You are given two arrays of scores and guesses of equal length, where each index shows a match. \n    // Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    // the value is 0, and if not, the value is the absolute difference between the guess and the score.\n    // example:\n    def compare(game : List[Long], guess : List[Long]) : List[Long] = {\n        val gameScores = game.zipWithIndex.map{case (score, index) => score}.toList\n        val guessScores = guess.zipWithIndex.map{case (score, index) => score}.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val guessScoreMap = guessScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val gameScores = gameScoreMap.map{case (score, index) => gameScoreMap.getOrElse(index, score)}\n        val guessScores = guessScoreMap.map{case (score, index) => guessScoreMap.getOrElse(index, score)}\n        val gameScores = gameScores.toList\n        val guessScores = guessScores.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val guessScoreMap = guessScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val gameScores = gameScoreMap.map{case (score, index) => gameScoreMap.getOrElse(index, score)}\n        val guessScores = guessScoreMap.map{case (score, index) => guessScoreMap.getOrElse(index, score)}\n        val gameScores = gameScores.toList\n        val guessScores = guessScores.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val guessScoreMap = guessScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val gameScores = gameScoreMap.map{case (score, index) => gameScoreMap.getOrElse(index, score)}\n        val guessScores = guessScoreMap.map{case (score, index) => guessScoreMap.getOrElse(index, score)}\n        val gameScores = gameScores.toList\n        val guessScores = guessScores.toList\n        val gameScoreMap = gameScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val guessScoreMap = guessScores.groupBy(_._2).mapValues(_.map(_._1)).toMap\n        val gameScores = gameScoreMap.map{case (score, index) => gameScoreMap.getOrElse(index, score)}\n        val guessScores = guessScoreMap.map{case (score, index) => guessScoreMap.getOrElse(index, score)}\n        val gameScores = gameScores.to\n    }\n    def main(args: Array[String]) = {\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 5l.toLong, 1l.toLong)), (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong, -2l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 3l.toLong, 3l.toLong))));\n    assert(compare((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong)), (List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))).equals((List[Long](0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong, 0l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong)), (List[Long](-1l.toLong, -2l.toLong, -3l.toLong))).equals((List[Long](2l.toLong, 4l.toLong, 6l.toLong))));\n    assert(compare((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 5l.toLong)), (List[Long](-1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](2l.toLong, 0l.toLong, 0l.toLong, 1l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpabyebevl.scala:17:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScoreMap.map{\u001b[33mcase\u001b[0m (score, index) => gameScoreMap.getOrElse(index, score)}\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpabyebevl.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScores\u001b[0m = guessScoreMap.map{\u001b[33mcase\u001b[0m (score, index) => guessScoreMap.getOrElse(index, score)}\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpabyebevl.scala:19:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mgameScores\u001b[0m = gameScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mgameScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mgameScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpabyebevl.scala:20:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mguessScores\u001b[0m = guessScores.toList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mguessScores is already defined as \u001b[33mvalue\u001b[0m \u001b[35mguessScores\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming E",
      "stdout": "",
      "timestamp": 1660013804
    }
  ]
}