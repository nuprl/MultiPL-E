language: scala
name: HumanEval_119_match_parens
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    if(str == \"(\") {\n                stack += str\n            } else if(str\
    \ == \")\") {\n                val str = stack.pop()\n                if(str ==\
    \ \"\") {\n                    result += \"No\"\n                } else {\n  \
    \                  result += \"Yes\"\n                }\n            }\n     \
    \   }\n        result match {\n            case Nil => \"No\"\n            case\
    \ _ => \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp72zjnm1q.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp72zjnm1q.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val curr = stack.pop()\n            if(curr == \"(\") {\n            \
    \    result += \"(\"\n                stack += \")\"\n            } else if(curr\
    \ == \")\") {\n                result += \"(\"\n                stack += \")\"\
    \n            } else {\n                result += curr\n            }\n      \
    \  }\n        if(result.size == lst.length) result.mkString(\"\") else \"No\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqw0jhu91.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqw0jhu91.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop() match {\n                    case \")\" => result.append(\"Yes\"\
    )\n                    case \")(\"  => result.append(\"No\")\n               \
    \     case \")()\" => result.append(\"No\")\n                    case \")()()\"\
    \ => result.append(\"Yes\")\n                    case _ => result.append(\"No\"\
    )\n                }\n                case \")(\"  => stack.append(x)\n      \
    \          case \")()\" => stack.append(x)\n                case \")()()\" =>\
    \ stack.append(x)\n                case _ => stack.append(x)\n            }\n\
    \        })\n        result.last\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppwmha3fx.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppwmha3fx.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop\n                }\n                case\
    \ \")()\" => {\n                    stack.pop\n                    stack.pop\n\
    \                }\n                case \")(\" => {\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \  }\n                case \")()()\" => {\n                    stack.pop\n   \
    \                 stack.pop\n                    stack.pop\n                 \
    \   stack.pop\n                }\n                case \")()()()\" => {\n    \
    \                stack.pop\n                    stack.pop\n                  \
    \  stack.pop\n                    stack.pop\n                    stack.pop\n \
    \               }\n                case \")()()()()\" => {\n                 \
    \   stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \      stack.pop\n                }\n                case \")()()()()()\" => {\n\
    \                    stack.pop\n                    stack.pop\n              \
    \      stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \  }\n                case \")()()()()()()\" => {\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \      stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \  }\n                case \")()()()()()()()\" => {\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \      stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \      stack.pop\n                }\n                case \")()()()()()()()\"\
    \ => {\n                    stack.pop\n                    stack.pop\n       \
    \             stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \      stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                }\n                case \")()()()()()()()()\" => {\n        \
    \            stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \      stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \  }\n                case \")()()()()()()()()\" => {\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \      stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \      stack.pop\n                    stack.pop\n                }\n         \
    \       case \")()()()()()()()()()\" => {\n                    stack.pop\n   \
    \                 stack.pop\n                    stack.pop\n                 \
    \   stack.pop\n                    stack.pop\n                    stack.pop\n\
    \                    stack\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqig5lngk.scala:142:0 ---------------------------\e\
    [0m\e[0m\n\e[31m142 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqig5lngk.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqig5lngk.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqig5lngk.scala:16:19\
    \ --------------------\e[0m\e[0m\n\e[31m 16 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 17 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 18 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m => {\n\e[31m 19 |\e[0m                    stack.pop\n\e[31m 20\
    \ |\e[0m                }\n\e[31m 21 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")()\"\e[0m => {\n\e[31m 22 |\e[0m                    stack.pop\n\e[31m 23\
    \ |\e[0m                    stack.pop\n\e[31m 24 |\e[0m                }\n\e[31m\
    \ 25 |\e[0m                \e[33mcase\e[0m \e[31m\")(\"\e[0m => {\n\e[31m 26 |\e\
    [0m                    stack.pop\n\e[31m 27 |\e[0m                    stack.pop\n\
    \e[31m 28 |\e[0m                    stack.pop\n\e[31m 29 |\e[0m              \
    \  }\n\e[31m 30 |\e[0m                \e[33mcase\e[0m \e[31m\")()()\"\e[0m =>\
    \ {\n\e[31m 31 |\e[0m                    stack.pop\n\e[31m 32 |\e[0m         \
    \           stack.pop\n\e[31m 33 |\e[0m                    stack.pop\n\e[31m 34\
    \ |\e[0m                    stack.pop\n\e[31m 35 |\e[0m     "
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    stack.pop() match {\n                        case Some(\"\
    (\") => result += \"(\"\n                        case _ => result += \"(\"\n \
    \                   }\n                case \")(\" =>\n                    stack.pop()\
    \ match {\n                        case Some(\"(\") => result += \"(\"\n     \
    \                   case _ => result += \"(\"\n                    }\n       \
    \         case _ =>\n                    stack += x\n            }\n        })\n\
    \        if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7x2zf6ij.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7x2zf6ij.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val s = stack.pop()\n            val open = s.indexOf('(')\n         \
    \   val close = s.indexOf(')')\n            if(open < 0 || close < 0) {\n    \
    \            result += \"No\"\n            } else {\n                result +=\
    \ \"Yes\"\n            }\n            if(open < close) {\n                stack\
    \ += s.substring(open + 1, close)\n            }\n        }\n        result.mkString(\"\
    ,\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7jaefpx1.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7jaefpx1.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => x match {\n            case \")\" => stack.pop()\n \
    \           case \")(\"  => stack.append(x)\n            case _ => stack.append(x)\n\
    \        })\n        stack.foreach(x => result.append(x))\n        result.mkString(\"\
    (\", \", \", \")\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppnou3ota.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppnou3ota.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        for(i <- 0 until stackSize) {\n   \
    \         val str = lst(i)\n            if(str == \"(\") {\n                stack.push(str)\n\
    \            } else if(str == \")\") {\n                val s = stack.pop()\n\
    \                if(s == \"(\") {\n                    stack.push(s)\n       \
    \         } else {\n                    result += \"No\"\n                   \
    \ break\n                }\n            } else {\n                result += \"\
    No\"\n                break\n            }\n        }\n        if(result.size\
    \ == stackSize) {\n            result += \"Yes\"\n        } else {\n         \
    \   result += \"No\"\n        }\n        return result.toString()\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu8awb8mi.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpu8awb8mi.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpu8awb8mi.scala:27:20 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu8awb8mi.scala:31:16\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") stack.pop()\
    \ else stack += x)\n        stack.foreach(x => result += (x + \"(\")))\n     \
    \   if (result.size == lst.length) result.mkString(\"(\", \")\") else \"No\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj8_3lv4z.scala:17:47 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        stack.foreach(\e[36mx\e[0m => result += (x +\
    \ \e[31m\"(\"\e[0m)))\n\e[31m\e[31m   |\e[0m                                 \
    \              ^\e[0m\n\e[31m   |\e[0m                                       \
    \      '}' expected, but ')' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj8_3lv4z.scala:35:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m35 |\e[0m}\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0meof expected, but '}' found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpj8_3lv4z.scala:14:20 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpj8_3lv4z.scala:15:21 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpj8_3lv4z.scala:16:59 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) stack.pop() \e[33melse\e[0m stack += x)\n\e[31m\e[31m   |\e[0m     \
    \                                                      ^^\e[0m\n\e[31m   |\e[0m\
    \                                 value unary_! is not a member of String\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpj8_3lv4z.scala:18:12 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mif\e[0m (result.size == lst.length) result.mkString(\e\
    [31m\"(\"\e[0m, \e[31m\")\"\e[0m) \e[33melse\e[0m \e[31m\"No\"\e[0m\n\e[31m\e\
    [31m   |\e[0m            ^^^^^^\e[0m\n\e[31m   |\e[0m            Not found: result\n\
    \e[31m   |\e[0m\n\e[31m"
  stdout: ''
  timestamp: 1659979812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \"(\"\
    \ => open += x\n                case \")\" => close += x\n                case\
    \ _ => stack += x\n            }\n        })\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        val openCount2 = openCount + closeCount\n\
    \        val openCount3 = openCount + openCount2\n        val openCount4 = openCount\
    \ + openCount3\n        val openCount5 = openCount + openCount4\n        val openCount6\
    \ = openCount + openCount5\n        val openCount7 = openCount + openCount6\n\
    \        val openCount8 = openCount + openCount7\n        val openCount9 = openCount\
    \ + openCount8\n        val openCount10 = openCount + openCount9\n        val\
    \ openCount11 = openCount + openCount10\n        val openCount12 = openCount +\
    \ openCount11\n        val openCount13 = openCount + openCount12\n        val\
    \ openCount14 = openCount + openCount13\n        val openCount15 = openCount +\
    \ openCount14\n        val openCount16 = openCount + openCount15\n        val\
    \ openCount17 = openCount + openCount16\n        val openCount18 = openCount +\
    \ openCount17\n        val openCount19 = openCount + openCount18\n        val\
    \ openCount20 = openCount + openCount19\n        val openCount21 = openCount +\
    \ openCount20\n        val openCount22 = openCount + openCount21\n        val\
    \ openCount23 = openCount + openCount22\n        val openCount24 = openCount +\
    \ openCount23\n        val openCount25 = openCount + openCount24\n        val\
    \ openCount26 = openCount + openCount25\n        val openCount27 = openCount +\
    \ openCount26\n        val openCount28 = openCount + openCount27\n        val\
    \ openCount29 = openCount + openCount28\n        val openCount30 = openCount +\
    \ openCount29\n        val openCount31 = openCount + openCount30\n        val\
    \ openCount32 = openCount + openCount31\n        val openCount33 = openCount +\
    \ openCount32\n        val openCount34 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb1xkjdpg.scala:59:25 ---------------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m        \e[33mval\e[0m \e[36mopenCount34\e[0m = \n\e\
    [31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m          \
    \               expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpb1xkjdpg.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb1xkjdpg.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb1xkjdpg.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpb1xkjdpg.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpb1xkjdpg.scala:60:5 ---------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n"
  stdout: ''
  timestamp: 1659979812
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val s = stack.pop()\n            if(s.startsWith(\"(\")) {\n         \
    \       result += \"(\"\n                stack += \")\"\n            }\n     \
    \       else if(s.startsWith(\")\")) {\n                result += \")\"\n    \
    \            stack += \")\"\n            }\n            else {\n             \
    \   result += \"(\"\n                stack += \")\"\n            }\n        }\n\
    \        if(result.size == lst.length) result.mkString\n        else null\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnjtvpotc.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnjtvpotc.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.equals(\"(\") =>\
    \ stack.push(x)\n            case x if x.equals(\")\") => queue.push(x)\n    \
    \        case x => bad.add(x)\n        })\n        while(!queue.isEmpty && !stack.isEmpty)\
    \ {\n            val x = queue.poll\n            val y = stack.pop()\n       \
    \     if(!good.contains(x + y)) {\n                good.add(x + y)\n         \
    \       bad.add(x + y)\n            }\n        }\n        if(good.size == lst.length)\
    \ \"Yes\" else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjwxq1gyr.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjwxq1gyr.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpjwxq1gyr.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpjwxq1gyr.scala:17:18 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.ListBuffer[String]()\n\
    \        val bad = mutable.ListBuffer[String]()\n        lst.foreach { s =>\n\
    \            val open = s.indexOf(\"(\")\n            val close = s.indexOf(\"\
    )\")\n            if (open < 0 || close < 0) {\n                bad += s\n   \
    \         } else {\n                if (open > close) {\n                    bad\
    \ += s\n                } else {\n                    stack.push(s)\n        \
    \        }\n            }\n        }\n        val goodString = good.mkString(\"\
    (\", \",\", \")\")\n        val badString = bad.mkString(\"(\", \",\", \")\")\n\
    \        if (goodString.equals(badString)) {\n            \"Yes\"\n        } else\
    \ {\n            \"No\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfrvwiinh.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfrvwiinh.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpfrvwiinh.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val open = s.indexOf(\"(\")\n       \
    \     val close = s.indexOf(\")\")\n            if (open < 0 || close < 0) {\n\
    \                result += \"No\"\n            } else {\n                if (open\
    \ > close) {\n                    result += \"No\"\n                } else {\n\
    \                    stack += s\n                }\n            }\n        }\n\
    \        if (stack.size == 0) {\n            result += \"Yes\"\n        } else\
    \ {\n            result += \"No\"\n        }\n        result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbbuncq0w.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbbuncq0w.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => if (x == \"(\") stack.push(x) else stack.pop() match\
    \ {\n            case x if x == \")\" => result.add(\"Yes\")\n            case\
    \ _ => result.add(\"No\")\n        })\n        result.head\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfvb67r0v.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfvb67r0v.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n\
    \        val bad = mutable.Set[String]()\n        lst.foreach(x => {\n       \
    \     x match {\n                case \")\" => stack.pop()\n                case\
    \ \")(\"  => stack.pop()\n                case \")()\" => stack.pop()\n      \
    \          case \")()()\" => stack.pop()\n                case \")(\" => stack.pop()\n\
    \                case \")()\" => stack.pop()\n                case \")(\" => stack.pop()\n\
    \                case \")()()\" => stack.pop()\n                case \")(()\"\
    \ => stack.pop()\n                case \")(()()\" => stack.pop()\n           \
    \     case \")(()()()\" => stack.pop()\n                case \")(()()()()\" =>\
    \ stack.pop()\n                case \")(()()()()()\" => stack.pop()\n        \
    \        case \")(()()()()()()\" => stack.pop()\n                case \")(()()()()()()()\"\
    \ => stack.pop()\n                case \")(()()()()()()()()\" => stack.pop()\n\
    \                case \")(()()()()()()()()()\" => stack.pop()\n              \
    \  case \")(()()()()()()()()()()\" => stack.pop()\n                case \")(()()()()()()()()()()\"\
    \ => stack.pop()\n                case \")(()()()()()()()()()()\" => stack.pop()\n\
    \                case \")(()()()()()()()()()()()\" => stack.pop()\n          \
    \      case \")(()()()()()()()()()()()()\" => stack.pop()\n                case\
    \ \")(()()()()()()()()()()()()\" => stack.pop()\n                case \")(()()()()()()()()()()()()()\"\
    \ => stack.pop()\n                case \")(()()()()()()()()()()()()()\" => stack.pop()\n\
    \                case \")(()()()()()()()()()()()()()\" => stack.pop()\n      \
    \          case \")(()()()()()()()()()()()()()\" => stack.pop()\n            \
    \    case \")(()()()()()()()()()()()()()\" => stack.pop()\n                case\
    \ \")(()()()()()()()()()()()()()\" => stack.pop()\n                case \")(()()()()()()()()()()()()()\"\
    \ => stack.pop()\n                case \")(()()()()()()()()()()()()()\" => stack.pop()\n\
    \                case \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmppk5_smrd.scala:50:20 ---------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m                \e[33mcase\e[0m \n\e[31m\e[31m   |\e\
    [0m                    ^\e[0m\n\e[31m   |\e[0m                    pattern expected\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppk5_smrd.scala:68:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m68 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmppk5_smrd.scala:14:20 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmppk5_smrd.scala:15:19 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmppk5_smrd.scala:16:18 ------------------------\e[0m\e\
    [0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[33m\e[33m-- Warning:\
    \ /tmp/tmppk5_smrd.scala:52:4 ----------------------------------------\e[0m\e\
    [0m\n\e[33m52 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m\
    \    Line is indented too far to the left, or a `}` is missing\n1 warning found\n\
    5 errors found\n"
  stdout: ''
  timestamp: 1659979810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \"(\"\
    \ => stack.push(x)\n                case \")\" => stack.pop() match {\n      \
    \              case x if x == \")\" => result.add(x)\n                    case\
    \ x => result.add(x)\n                }\n            }\n        })\n        if\
    \ (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw1o94ibc.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpw1o94ibc.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stackMax = stackSize - 1\n        val resultMax = resultSize - 1\n     \
    \   val stackIndex = stackMax\n        val resultIndex = resultMax\n        val\
    \ stackElement = lst(stackIndex)\n        val resultElement = lst(resultIndex)\n\
    \        val stackOpen = stackElement.indexOf(\"(\")\n        val stackClose =\
    \ stackElement.indexOf(\")\")\n        val resultOpen = resultElement.indexOf(\"\
    (\")\n        val resultClose = resultElement.indexOf(\")\")\n        val stackOpenCount\
    \ = stackOpen + 1\n        val stackCloseCount = stackClose + 1\n        val resultOpenCount\
    \ = resultOpen + 1\n        val resultCloseCount = resultClose + 1\n        while(stackIndex\
    \ >= 0 && resultIndex >= 0) {\n            val stackElement = lst(stackIndex)\n\
    \            val resultElement = lst(resultIndex)\n            val stackOpen =\
    \ stackElement.indexOf(\"(\")\n            val stackClose = stackElement.indexOf(\"\
    )\")\n            val resultOpen = resultElement.indexOf(\"(\")\n            val\
    \ resultClose = resultElement.indexOf(\")\")\n            val stackOpenCount =\
    \ stackOpen + 1\n            val stackCloseCount = stackClose + 1\n          \
    \  val resultOpenCount = resultOpen + 1\n            val resultCloseCount = resultClose\
    \ + 1\n            if(stackOpenCount > stackCloseCount && resultOpenCount > resultCloseCount)\
    \ {\n                stackIndex -= 1\n                resultIndex -= 1\n     \
    \       } else if(stackOpenCount < stackCloseCount && resultOpenCount < resultCloseCount)\
    \ {\n                stackIndex += 1\n                resultIndex += 1\n     \
    \       } else if(stackOpenCount > stackCloseCount && resultOpenCount < resultCloseCount)\
    \ {\n                stackIndex -= 1\n                resultIndex += 1\n     \
    \       } else if(stackOpenCount < stackCloseCount && resultOpenCount > resultCloseCount)\
    \ {\n                stackIndex += 1\n                resultIndex -= 1\n     \
    \       }\n            stackElement = lst(stackIndex)\n            stackOpen =\
    \ stackElement.indexOf(\"(\")\n            stackClose = stackElement.indexOf(\"\
    )\")\n            resultElement = lst(resultIndex)\n            resultOpen = resultElement.indexOf(\"\
    (\")\n            resultClose = resultElement.indexOf(\")\")\n            stackOpenCount\
    \ = stackOpen + 1\n            stackCloseCount = stackClose + 1\n            resultOpenCount\
    \ = resultOpen + 1\n            resultCloseCount = resultClose + 1\n         \
    \   stackElement = lst(stackIndex)\n            stackOpen = stackElement.indexOf(\"\
    (\")\n            stackClose = stack\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpp2vfuizv.scala:86:0 ----------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp2vfuizv.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpp2vfuizv.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2vfuizv.scala:44:27\
    \ ------------------------\e[0m\e[0m\n\e[31m44 |\e[0m                stackIndex\
    \ -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0m           value -= is not a member of Int - did you mean stackIndex.!=?\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpp2vfuizv.scala:45:28 ------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m                resultIndex -= \e[31m1\e[0m\n\e[31m\e\
    [31m   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ -= is not a member of Int - did you mean resultIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpp2vfuizv.scala:47:27 ------------------------\e[0m\e\
    [0m\n\e[31m47 |\e[0m                stackIndex += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value +=\
    \ is not a member of Int - did you mean stackIndex.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpp2vfuizv.scala:48:28 ------------------------\e[0m\e\
    [0m\n\e[31m48 |\e[0m                resultIndex += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m          value\
    \ += is"
  stdout: ''
  timestamp: 1659979816
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val len = open - close\n            if(len > 0) {\n           \
    \     stack.push(str)\n                while(stack.nonEmpty) {\n             \
    \       val str = stack.pop()\n                    val open = str.indexOf(\"(\"\
    )\n                    val close = str.indexOf(\")\")\n                    val\
    \ len = open - close\n                    if(len > 0) {\n                    \
    \    stack.push(str)\n                    } else {\n                        if(stack.nonEmpty)\
    \ {\n                            val str = stack.pop()\n                     \
    \       val open = str.indexOf(\"(\")\n                            val close =\
    \ str.indexOf(\")\")\n                            val len = open - close\n   \
    \                         if(len > 0) {\n                                stack.push(str)\n\
    \                            } else {\n                                result.add(str\
    \ + lst(i))\n                            }\n                        } else {\n\
    \                            result.add(str + lst(i))\n                      \
    \  }\n                    }\n                }\n            } else {\n       \
    \         result.add(str + lst(i))\n            }\n        }\n        if(result.size\
    \ == lst.size) {\n            return \"Yes\"\n        } else {\n            return\
    \ \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpa72j3ltc.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpa72j3ltc.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n            } else if (x == \")\") {\n                close += x\n   \
    \         } else {\n                stack += x\n            }\n        })\n  \
    \      val openCount = open.size\n        val closeCount = close.size\n      \
    \  if (openCount == closeCount) {\n            val openSet = open.toSet\n    \
    \        val closeSet = close.toSet\n            val openStack = stack.toSet\n\
    \            val closeStack = stack.toSet\n            val openStackSize = openStack.size\n\
    \            val closeStackSize = closeStack.size\n            if (openStackSize\
    \ == closeStackSize) {\n                val openStackSet = openStack.toSet\n \
    \               val closeStackSet = closeStack.toSet\n                val openStackSetSize\
    \ = openStackSet.size\n                val closeStackSetSize = closeStackSet.size\n\
    \                if (openStackSetSize == closeStackSetSize) {\n              \
    \      val openStackSetIterator = openStackSet.iterator\n                    val\
    \ closeStackSetIterator = closeStackSet.iterator\n                    val openStackSetIteratorSize\
    \ = openStackSetIterator.size\n                    val closeStackSetIteratorSize\
    \ = closeStackSetIterator.size\n                    if (openStackSetIteratorSize\
    \ == closeStackSetIteratorSize) {\n                        val openStackSetIteratorIterator\
    \ = openStackSetIterator.iterator\n                        val closeStackSetIteratorIterator\
    \ = closeStackSetIterator.iterator\n                        val openStackSetIteratorIteratorSize\
    \ = openStackSetIteratorIterator.size\n                        val closeStackSetIteratorIteratorSize\
    \ = closeStackSetIteratorIterator.size\n                        if (openStackSetIteratorIteratorSize\
    \ == closeStackSetIteratorIteratorSize) {\n                            val openStackSetIteratorIteratorIterator\
    \ = openStackSetIteratorIterator.iterator\n                            val closeStackSetIteratorIteratorIterator\
    \ = closeStackSetIteratorIterator.iterator\n                            val openStackSetIteratorIteratorIteratorSize\
    \ = openStackSetIteratorIteratorIterator.size\n                            val\
    \ closeStackSetIteratorIteratorIteratorSize = closeStackSetIteratorIteratorIterator.size\n\
    \                            if (openStackSetIteratorIteratorIteratorSize == closeStackSetIteratorIteratorIteratorSize)\
    \ {\n                                val openStackSetIteratorIteratorIteratorIterator\
    \ = openStackSetIteratorIteratorIterator.iterator\n                          \
    \      val closeStackSetIteratorIteratorIteratorIterator = closeStackSetIteratorIteratorIterator.iterator\n\
    \                                val openStackSetIteratorIteratorIteratorIteratorSize\
    \ = openStack\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpt48zs0mg.scala:77:0 ----------------------------\e\
    [0m\e[0m\n\e[31m77 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt48zs0mg.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt48zs0mg.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt48zs0mg.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpt48zs0mg.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpt48zs0mg.scala:29:8\
    \ ---------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mif\e[0m (openCount\
    \ == closeCount) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Unit\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m \
    \       Maybe you are missing an else part for the conditional?\n\e[31m30 |\e\
    [0m            \e[33mval\e"
  stdout: ''
  timestamp: 1659979810
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop\n                }\n                case\
    \ \")(\"  => {\n                    stack.push(x)\n                }\n       \
    \         case \")()\" => {\n                    stack.push(x)\n             \
    \   }\n                case \")()()\" => {\n                    stack.push(x)\n\
    \                }\n                case _ => {\n                    result +=\
    \ (x + \"(\")\n                }\n            }\n        })\n        if (stack.size\
    \ == 0) {\n            \"No\"\n        } else {\n            \"Yes\"\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzs96km0b.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzs96km0b.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(elem) => result += elem\n   \
    \                         case None => result += \"No\"\n                    \
    \    }\n                    }\n                }\n                case \"(\" =>\
    \ {\n                    open.synchronized {\n                        stack +=\
    \ x\n                    }\n                }\n                case _ => {\n \
    \                   stack.synchronized {\n                        stack += x\n\
    \                    }\n                }\n            }\n        })\n       \
    \ stack.synchronized {\n            stack.toList match {\n                case\
    \ Nil => \"No\"\n                case x :: Nil => result += \"Yes\"\n        \
    \        case x :: y :: Nil => result += \"Yes\"\n                case x :: y\
    \ :: z :: Nil => result += \"Yes\"\n                case x :: y :: z :: t => {\n\
    \                    val newStack = stack.filterNot(_ == x)\n                \
    \    val newOpen = open.filterNot(_ == y)\n                    val newClose =\
    \ close.filterNot(_ == z)\n                    val newResult = result.filterNot(_\
    \ == t)\n                    val newStackSize = newStack.size + newOpen.size +\
    \ newClose.size\n                    val newResultSize = newResult.size + newStackSize\n\
    \                    if (newResultSize == newStackSize) {\n                  \
    \      newResult += \"Yes\"\n                    } else {\n                  \
    \      newResult += \"No\"\n                    }\n                }\n       \
    \     }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqnte1o66.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqnte1o66.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqnte1o66.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpqnte1o66.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => x match {\n            case \")\" => stack.pop() match\
    \ {\n                case \")\" => result += \"(\"\n                case \")()\"\
    \ => result += \"()\"\n                case \")(\" => result += \"()\"\n     \
    \           case \")()()\" => result += \"()()\"\n                case _ => result\
    \ += \"(\"\n            }\n            case \")()\" => stack.pop() match {\n \
    \               case \")\" => result += \"(\"\n                case \")()\" =>\
    \ result += \"()\"\n                case \")(\" => result += \"()\"\n        \
    \        case \")()()\" => result += \"()()\"\n                case _ => result\
    \ += \"(\"\n            }\n            case \")(\" => stack.pop() match {\n  \
    \              case \")\" => result += \"(\"\n                case \")()\" =>\
    \ result += \"()\"\n                case \")(\" => result += \"()\"\n        \
    \        case \")()()\" => result += \"()()\"\n                case _ => result\
    \ += \"(\"\n            }\n            case \")()()\" => stack.pop() match {\n\
    \                case \")\" => result += \"(\"\n                case \")()\" =>\
    \ result += \"()\"\n                case \")(\" => result += \"()\"\n        \
    \        case \")()()\" => result += \"()()\"\n                case _ => result\
    \ += \"(\"\n            }\n            case _ => stack += x\n        })\n    \
    \    if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3fuuqq0c.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3fuuqq0c.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979815
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(\")\") =>\n                 \
    \               result += \"(\" + stack.toList.reverse.mkString(\",\") + \")\"\
    \n                            case _ =>\n                        }\n         \
    \           }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(\"(\") =>\n                                result += \"(\" + stack.toList.reverse.mkString(\"\
    ,\") + \")\"\n                            case _ =>\n                        }\n\
    \                    }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(\"(\") =>\n                                result += \"(\" + stack.toList.reverse.mkString(\"\
    ,\") + \")\"\n                            case _ =>\n                        }\n\
    \                    }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(\"(\") =>\n                                result += \"(\" + stack.toList.reverse.mkString(\"\
    ,\") + \")\"\n                            case _ =>\n                        }\n\
    \                    }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(\"(\") =>\n                                result += \"(\" + stack.toList.reverse.mkString(\"\
    ,\") + \")\"\n                            case _ =>\n                        }\n\
    \                    }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(\"(\") =>\n                                result += \"(\" + stack.toList.reverse.mkString(\"\
    ,\") + \")\"\n                            case _ =>\n                        }\n\
    \                    }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(\"(\") =>\n                                result += \"(\" + stack.toList.reverse.mkString(\"\
    ,\") + \")\"\n                            case _ =>\n                        }\n\
    \                    }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(\"(\") =>\n                                result += \"(\" + stack.toList.reverse.mkString(\"\
    ,\") + \")\"\n                            case _ =>\n                        }\n\
    \                    }\n                case \")(\" =>\n                    open.synchronized\
    \ {\n                        stack.pop() match {\n                           \
    \ case Some(\"(\") =>\n                                \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpi6ddeizd.scala:106:0 ---------------------------\e\
    [0m\e[0m\n\e[31m106 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6ddeizd.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6ddeizd.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6ddeizd.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpi6ddeizd.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpi6ddeizd.scala:18:19\
    \ --------------------\e[0m\e[0m\n\e[31m 18 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 19 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 20 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m =>\n\e[31m 21 |\e"
  stdout: ''
  timestamp: 1659979818
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \                return result.toString\n            }\n            val openCount\
    \ = stack.length\n            val closeCount = stack.length\n            stack.push(str)\n\
    \            while(open > -1) {\n                val openCount = stack.length\n\
    \                val closeCount = stack.length\n                stack.push(str.substring(0,\
    \ open))\n                val str = str.substring(open + 1, close)\n         \
    \       val closeCount = stack.length\n                stack.push(str)\n     \
    \           open -= 1\n            }\n            while(close > -1) {\n      \
    \          val openCount = stack.length\n                val closeCount = stack.length\n\
    \                stack.push(str.substring(0, close))\n                val str\
    \ = str.substring(close + 1, str.length)\n                val closeCount = stack.length\n\
    \                stack.push(str)\n                close += 1\n            }\n\
    \            val openCount = stack.length\n            val closeCount = stack.length\n\
    \            val str = stack.mkString\n            result += \"Yes\"\n       \
    \ }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n \
    \   assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz3988qmw.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpz3988qmw.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpz3988qmw.scala:47:16 ---------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m            \e[33mval\e[0m \e[36mstr\e[0m = stack.mkString\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstr\
    \ is already defined as \e[33mvalue\e[0m \e[35mstr\e[0m\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpz3988qmw.scala:34:21\
    \ ------------------------\e[0m\e[0m\n\e[31m34 |\e[0m                open -= \e\
    [31m1\e[0m\n\e[31m\e[31m   |\e[0m                ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                value -= is not a member of Int - did you mean open.!=?\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpz3988qmw.scala:43:22 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                close += \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^\e[0m\n\e[31m   |\e[0m                value +=\
    \ is not a member of Int - did you mean close.!=?\n5 errors found\n"
  stdout: ''
  timestamp: 1659979820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop()\n                }\n                case\
    \ \")(\"  => {\n                    stack += x\n                }\n          \
    \      case \")()\" => {\n                    stack += x\n                   \
    \ stack.pop()\n                }\n                case \")()()\" => {\n      \
    \              stack += x\n                    stack += x\n                  \
    \  stack.pop()\n                }\n                case \")()()()\" => {\n   \
    \                 stack += x\n                    stack += x\n               \
    \     stack += x\n                    stack.pop()\n                }\n       \
    \         case \")()()()()\" => {\n                    stack += x\n          \
    \          stack += x\n                    stack += x\n                    stack\
    \ += x\n                    stack.pop()\n                }\n                case\
    \ \")()()()()()\" => {\n                    stack += x\n                    stack\
    \ += x\n                    stack += x\n                    stack += x\n     \
    \               stack += x\n                    stack.pop()\n                }\n\
    \                case \")()()()()()()\" => {\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack += x\n                    stack += x\n                    stack\
    \ += x\n                    stack.pop()\n                }\n                case\
    \ \")()()()()()()()\" => {\n                    stack += x\n                 \
    \   stack += x\n                    stack += x\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack += x\n                    stack.pop()\n                }\n    \
    \            case \")()()()()()()()()\" => {\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack += x\n                    stack += x\n                    stack\
    \ += x\n                    stack += x\n                    stack += x\n     \
    \               stack.pop()\n                }\n                case \")()()()()()()()()()\"\
    \ => {\n                    stack += x\n                    stack += x\n     \
    \               stack += x\n                    stack += x\n                 \
    \   stack += x\n                    stack += x\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack.pop()\n                }\n                case \")()()()()()()()()()\"\
    \ => {\n                    stack += x\n                    stack += x\n     \
    \               stack += x\n                    stack += x\n                 \
    \   stack += x\n                    stack += x\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack.pop()\n                }\n                case \")()()()()()()()()()()\"\
    \ => {\n                    stack += \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1me2xam3.scala:109:28 --------------------------\e\
    [0m\e[0m\n\e[31m109 |\e[0m                    stack += \n\e[31m\e[31m    |\e[0m\
    \                            ^\e[0m\n\e[31m    |\e[0m                        \
    \    expression expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m  \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp1me2xam3.scala:127:0 ---------------------------\e\
    [0m\e[0m\n\e[31m127 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1me2xam3.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1me2xam3.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp1me2xam3.scala:111:4\
    \ ---------------------------------------\e[0m\e[0m\n\e[33m111 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m    |\e[0m    ^\e[0m\n\e[33m    |\e[0m    Line is indented too far\
    \ to the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach {\n            s =>\n                val newStack = mutable.Stack[String]()\n\
    \                val newResult = mutable.ListBuffer[String]()\n              \
    \  val open = s.indexOf('(')\n                val close = s.lastIndexOf(')')\n\
    \                val openCount = stack.length\n                val closeCount\
    \ = stack.length\n                stack.push(s)\n                while (open !=\
    \ -1) {\n                    if (openCount == closeCount) {\n                \
    \        newStack.push(stack.pop())\n                        newResult.push(stack.pop())\n\
    \                        openCount = stack.length\n                        closeCount\
    \ = stack.length\n                    } else if (openCount < closeCount) {\n \
    \                       newStack.push(stack.pop())\n                        openCount\
    \ = stack.length\n                    } else {\n                        newStack.push(stack.pop())\n\
    \                        closeCount = stack.length\n                    }\n  \
    \                  open = s.indexOf('(', open + 1)\n                }\n      \
    \          stack.clear()\n                result.clear()\n                result.addAll(newResult)\n\
    \        }\n        if (result.size == 0) {\n            \"No\"\n        } else\
    \ {\n            \"Yes\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9fdt95tu.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9fdt95tu.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9fdt95tu.scala:18:31 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m                \e[33mval\e[0m \e[36mnewStack\e[0m =\
    \ mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9fdt95tu.scala:19:32\
    \ ------------------------\e[0m\e[0m\n\e[31m19 |\e[0m                \e[33mval\e\
    [0m \e[36mnewResult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \                          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp9fdt95tu.scala:29:34 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m                        openCount = stack.length\n\e\
    [31m\e[31m   |\e[0m                        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                        Reassignment to val openCount\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmp9fdt95tu.scala:30:35 --------------------------"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        open += s\n                stack.push(s)\n            } else if (s.startsWith(\"\
    )\")) {\n                close += s\n                val openCount = open.length\n\
    \                val closeCount = close.length\n                if (openCount\
    \ == closeCount) {\n                    result += (open.toList ++ close.toList)\n\
    \                }\n                stack.pop()\n            }\n        }\n  \
    \      if (result.size == 0) {\n            \"No\"\n        } else {\n       \
    \     \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw44ryyha.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpw44ryyha.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpw44ryyha.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpw44ryyha.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                result += \"Yes\"\n                stack.push(str)\n\
    \            }\n        }\n        if(stack.size == 0) {\n            result +=\
    \ \"No\"\n        } else {\n            result += \"Yes\"\n        }\n       \
    \ result + stack.toList.reverse.mkString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp3r5guxrq.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp3r5guxrq.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val open = s.indexOf('(')\n         \
    \   val close = s.lastIndexOf(')')\n            if (open < 0 || close < 0) return\n\
    \            if (open > close) return\n            val left = s.substring(0, open)\n\
    \            val right = s.substring(close + 1)\n            val newStack = stack\
    \ :+ left\n            val newResult = result :+ right\n            val newResult2\
    \ = newResult :+ right\n            val newResult3 = newResult :+ left\n     \
    \       val newResult4 = newResult :+ left\n            val newResult5 = newResult\
    \ :+ right\n            val newResult6 = newResult :+ left\n            val newResult7\
    \ = newResult :+ right\n            val newResult8 = newResult :+ left\n     \
    \       val newResult9 = newResult :+ left\n            val newResult10 = newResult\
    \ :+ right\n            val newResult11 = newResult :+ left\n            val newResult12\
    \ = newResult :+ left\n            val newResult13 = newResult :+ right\n    \
    \        val newResult14 = newResult :+ left\n            val newResult15 = newResult\
    \ :+ left\n            val newResult16 = newResult :+ right\n            val newResult17\
    \ = newResult :+ left\n            val newResult18 = newResult :+ left\n     \
    \       val newResult19 = newResult :+ right\n            val newResult20 = newResult\
    \ :+ left\n            val newResult21 = newResult :+ left\n            val newResult22\
    \ = newResult :+ right\n            val newResult23 = newResult :+ left\n    \
    \        val newResult24 = newResult :+ left\n            val newResult25 = newResult\
    \ :+ right\n            val newResult26 = newResult :+ left\n            val newResult27\
    \ = newResult :+ left\n            val newResult28 = newResult :+ right\n    \
    \        val newResult29 = newResult :+ left\n            val newResult30 = newResult\
    \ :+ left\n            val newResult31 = newResult :+ right\n            val newResult32\
    \ = newResult :+ left\n            val newResult33 = newResult :+ left\n     \
    \       val newResult34 = newResult :+ right\n            val newResult35 = newResult\
    \ :+ left\n            val newResult36 = newResult :+ left\n            val newResult37\
    \ = newResult :+ right\n            val newResult38 = newResult :+ left\n    \
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp82zqj7hy.scala:80:0 ----------------------------\e\
    [0m\e[0m\n\e[31m80 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp82zqj7hy.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp82zqj7hy.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp82zqj7hy.scala:19:39\
    \ --------------------\e[0m\e[0m\n\e[31m19 |\e[0m            \e[33mif\e[0m (open\
    \ < \e[31m0\e[0m || close < \e[31m0\e[0m) \e[33mreturn\e[0m\n\e[31m\e[31m   |\e\
    [0m                                       ^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \                                Found:    Unit\n\e[31m   |\e[0m             \
    \                          Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E007] Type Mismatch Error: /tmp/tmp82zqj7hy.scala:20:30 --------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m            \e[33mif\e[0m (open > close) \e[33mreturn\e\
    [0m\n\e[31m\e[31m   |\e[0m                              ^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                              Found:    Unit\n\e[31m   |\e[0m        \
    \                      Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp82zqj7hy.scala:79:1 ---------------------\e[0m\e\
    [0m\n\e[31m79 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:  \
    \  Unit\n\e[31m   |\e[0m Required: St"
  stdout: ''
  timestamp: 1659979819
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val x = stack.pop()\n            val y = stack.pop()\n            if(x\
    \ == \")\" && y == \")\") {\n                result += \"(\" + x + \")\"\n   \
    \         } else if(x == \"(\" && y == \")\") {\n                result += \"\
    (\" + y + \")\"\n            } else if(x == \"(\" && y == \"(\") {\n         \
    \       result += \"(\" + x + \")\"\n            } else if(y == \"(\" && x ==\
    \ \")\") {\n                result += \"(\" + y + \")\"\n            } else if(y\
    \ == \"(\" && x != \"(\") {\n                result += \"(\" + x + \")\"\n   \
    \         } else if(x != \"(\" && y == \"(\") {\n                result += \"\
    (\" + y + \")\"\n            } else if(x != \"(\" && y != \"(\") {\n         \
    \       result += \"(\" + x + \")\"\n            } else if(x != \"(\" && y !=\
    \ \"(\" && x != \")\") {\n                result += \"(\" + x + \")\"\n      \
    \      } else if(y != \"(\" && x != \"(\" && y != \")\") {\n                result\
    \ += \"(\" + y + \")\"\n            }\n        }\n        if(result.nonEmpty)\
    \ {\n            val str = result.toList\n            val len = str.size\n   \
    \         if(len == 1) {\n                return str(0)\n            }\n     \
    \       if(len == 2) {\n                return str(0) + str(1)\n            }\n\
    \            if(len == 3) {\n                return str(0) + str(1) + str(2)\n\
    \            }\n            if(len == 4) {\n                return str(0) + str(1)\
    \ + str(2) + str(3)\n            }\n            if(len == 5) {\n             \
    \   return str(0) + str(1) + str(2) + str(3) + str(4)\n            }\n       \
    \     if(len == 6) {\n                return str(0) + str(1) + str(2) + str(3)\
    \ + str(4) + str(5)\n            }\n            if(len == 7) {\n             \
    \   return str(0) + str(1) + str(2) + str(3) + str(4) + str(5) + str(6)\n    \
    \        }\n            if(len == 8) {\n                return str(0) + str(1)\
    \ + str(2) + str(3) + str(4) + str(5) + str(6) + str(7)\n            }\n     \
    \       if(len == 9) {\n                return str(0) + str(1) + str(2) + str(3)\
    \ + str(4) + str(5) + str(6) + str(7) + str(8)\n            }\n            if(len\
    \ == 10) {\n                return str(0) + str(1) + str(2) + str(3) + str(4)\
    \ + str(5) + str(6) + str(7) + str(8) + str(9)\n            }\n            if(len\
    \ == 11) {\n                return str(0) + str(1) + str(2) + str(3) + str(4)\
    \ + str(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp_onh8i9_.scala:74:72 ---------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m                \e[33mreturn\e[0m str(\e[31m0\e[0m) +\
    \ str(\e[31m1\e[0m) + str(\e[31m2\e[0m) + str(\e[31m3\e[0m) + str(\e[31m4\e[0m)\
    \ + str(\n\e[31m\e[31m   |\e[0m                                              \
    \                          ^\e[0m\n\e[31m   |\e[0m                           \
    \            expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp_onh8i9_.scala:92:0 ----------------------------\e\
    [0m\e[0m\n\e[31m92 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_onh8i9_.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_onh8i9_.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp_onh8i9_.scala:76:4\
    \ ----------------------------------------\e[0m\e[0m\n\e[33m76 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m   |\e[0m    Line is indented too far to\
    \ the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.length){\n            val str = lst(i)\n       \
    \     val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0){\n                return \"No\"\n   \
    \         }\n            val stackStr = str.substring(0,open)\n            val\
    \ stackStr2 = str.substring(open+1,close)\n            val stackStr3 = str.substring(close+1)\n\
    \            if(!stackStr.equals(stackStr2)){\n                return \"No\"\n\
    \            }\n            if(!stackStr.equals(stackStr3)){\n               \
    \ return \"No\"\n            }\n            stack.push(str)\n        }\n     \
    \   while(stack.nonEmpty){\n            val str = stack.pop()\n            val\
    \ open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n    \
    \        if(open < 0 || close < 0){\n                return \"No\"\n         \
    \   }\n            val stackStr = str.substring(0,open)\n            val stackStr2\
    \ = str.substring(open+1,close)\n            val stackStr3 = str.substring(close+1)\n\
    \            if(!stackStr.equals(stackStr2)){\n                return \"No\"\n\
    \            }\n            if(!stackStr.equals(stackStr3)){\n               \
    \ return \"No\"\n            }\n            result.add(str)\n        }\n     \
    \   if(result.length == 0){\n            return \"Yes\"\n        }\n        return\
    \ \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5o1y2dqi.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5o1y2dqi.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                open\
    \ += x\n                stack.push(x)\n            } else if (x == \")\") {\n\
    \                close += x\n                while (!stack.isEmpty && stack.peek().equals(x))\
    \ {\n                    result += stack.pop()\n                }\n          \
    \      stack.pop()\n            }\n        })\n        if (close.size == 0) {\n\
    \            return \"No\"\n        }\n        if (open.size == 0) {\n       \
    \     return \"Yes\"\n        }\n        return \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd9yni7em.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd9yni7em.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd9yni7em.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpd9yni7em.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\"\
    ) => stack.push(x)\n            case x if x.startsWith(\")\") => stack.pop() match\
    \ {\n                case x if x == \")\" => result.add(\"Yes\")\n           \
    \     case x => result.add(\"No\")\n            }\n            case x => result.add(\"\
    No\")\n        })\n        result.mkString(\",\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg9r3afhb.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpg9r3afhb.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach { x =>\n            x match {\n                case \")\"\
    \ =>\n                    close.push(x)\n                case \")(\" =>\n    \
    \                stack.push(x)\n                case \")(\" =>\n             \
    \       stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push(x)\n                case\
    \ \")(\" =>\n                    stack.push(x)\n                case \")(\" =>\n\
    \                    stack.push(x)\n                case \")(\" =>\n         \
    \           stack.push(x)\n                case \")(\" =>\n                  \
    \  stack.push(x)\n                case \")(\" =>\n                    stack.push(x)\n\
    \                case \")(\" =>\n                    stack.push(x)\n         \
    \       case \")(\" =>\n                    stack.push\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfe_dagiq.scala:119:0 ---------------------------\e\
    [0m\e[0m\n\e[31m119 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfe_dagiq.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfe_dagiq.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfe_dagiq.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfe_dagiq.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfe_dagiq.scala:18:20\
    \ --------------------\e[0m\e[0m\n\e[31m 18 |\e[0m        lst.foreach { \e[36mx\e\
    [0m =>\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found: \
    \   Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 19 |\e[0m         \
    \   x \e[33mmatch\e[0m {\n\e[31m 20 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )\"\e[0m "
  stdout: ''
  timestamp: 1659979820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val x = stack.pop()\n            val y = stack.pop()\n            val\
    \ z = (x + \"(\" + y + \")\")\n            result += z\n            stack.push(z)\n\
    \        }\n        if(result.size == lst.length)\n            \"Yes\"\n     \
    \   else\n            \"No\"\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n \
    \   assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp08caaioe.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp08caaioe.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n\
    \        val bad = mutable.Set[String]()\n        lst.foreach(x => {\n       \
    \     if (x == \"(\") {\n                stack.push(x)\n            } else if\
    \ (x == \")\") {\n                val top = stack.pop()\n                if (top\
    \ == \"(\") {\n                    good.add(x)\n                } else {\n   \
    \                 bad.add(x)\n                }\n            }\n        })\n \
    \       if (good.size == lst.size) {\n            return \"Yes\"\n        } else\
    \ {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5fo3qihj.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp5fo3qihj.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp5fo3qihj.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979818
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \            } else {\n                val openParen = str.substring(0, open)\n\
    \                val closeParen = str.substring(close+1, str.length)\n       \
    \         val newStack = stack.dropRight(1)\n                val newResult = result.dropRight(1)\n\
    \                val newOpen = openParen.indexOf(\"(\")\n                val newClose\
    \ = closeParen.indexOf(\")\")\n                if(newOpen < 0 || newClose < 0)\
    \ {\n                    newResult += \"No\"\n                } else {\n     \
    \               val newOpenParen = openParen.substring(0, newOpen)\n         \
    \           val newCloseParen = closeParen.substring(newClose+1, closeParen.length)\n\
    \                    val newStack = stack.dropRight(1)\n                    val\
    \ newResult = result.dropRight(1)\n                    val newOpenParen2 = newOpenParen.substring(0,\
    \ newOpenParen.indexOf(\"(\"))\n                    val newCloseParen2 = newCloseParen.substring(newCloseParen.indexOf(\"\
    )\"), newCloseParen.length)\n                    val newStack2 = newStack.dropRight(1)\n\
    \                    val newResult2 = newResult.dropRight(1)\n               \
    \     val newOpenParen3 = newOpenParen2.substring(0, newOpenParen2.indexOf(\"\
    (\"))\n                    val newCloseParen3 = newCloseParen2.substring(newCloseParen2.indexOf(\"\
    )\"), newCloseParen2.length)\n                    val newStack3 = newStack2.dropRight(1)\n\
    \                    val newResult3 = newResult2.dropRight(1)\n              \
    \      val newOpenParen4 = newOpenParen3.substring(0, newOpenParen3.indexOf(\"\
    (\"))\n                    val newCloseParen4 = newCloseParen3.substring(newCloseParen3.indexOf(\"\
    )\"), newCloseParen3.length)\n                    val newStack4 = newStack3.dropRight(1)\n\
    \                    val newResult4 = newResult3.dropRight(1)\n              \
    \      val newOpenParen5 = newOpenParen4.substring(0, newOpenParen4.indexOf(\"\
    (\"))\n                    val newCloseParen5 = newCloseParen4.substring(newCloseParen4.indexOf(\"\
    )\"), newCloseParen4.length)\n                    val newStack5 = newStack4.dropRight(1)\n\
    \                    val newResult5 = newResult4.dropRight(1)\n              \
    \      val newOpenParen6 = newOpenParen5.substring(0, newOpenParen5.indexOf(\"\
    (\"))\n                    val newCloseParen\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwh3w225d.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpwh3w225d.scala:71:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m71 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpwh3w225d.scala:14:20 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpwh3w225d.scala:15:21 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpwh3w225d.scala:55:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m55 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979818
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            if (s.contains(\"(\")) {\n          \
    \      open += s\n                stack.push(s)\n            }\n            if\
    \ (s.contains(\")\")) {\n                close += s\n                while (!stack.isEmpty\
    \ && stack.peek().contains(\"(\")) {\n                    result += (stack.peek()\
    \ + s)\n                    stack.pop()\n                }\n                stack.pop()\n\
    \            }\n        }\n        if (close.isEmpty) result.toList(\"Yes\")\n\
    \        else result.toList(\"No\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwg54k15u.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwg54k15u.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwg54k15u.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpwg54k15u.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979818
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach {\n            s =>\n                if (s.startsWith(\"\
    (\")) {\n                    stack.push(s)\n                } else if (s.startsWith(\"\
    )\")) {\n                    val top = stack.pop()\n                    if (top.length\
    \ == 1) {\n                        result += \"(\" + top + \")\"\n           \
    \         } else {\n                        result += \"(\" + top + \")\"\n  \
    \                  }\n                }\n        }\n        if (result.length\
    \ == lst.length) {\n            return \"Yes\"\n        } else {\n           \
    \ return \"No\"\n        }\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n   \
    \ assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0s0jowdk.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0s0jowdk.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979818
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \"(\"\
    \ => stack.push(x)\n                case \")\" => stack.pop() match {\n      \
    \              case x if x == \")\" => result.add(x)\n                    case\
    \ x => result.add(x)\n                }\n            }\n        })\n        if\
    \ (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw1o94ibc.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpw1o94ibc.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979809
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val cur = lst(i)\n        \
    \    val open = cur match {\n                case '(': stack += '('\n        \
    \        case ')': stack += ')'\n                case _: String => throw new Exception(\"\
    Invalid parentheses\")\n            }\n            val close = cur match {\n \
    \               case ')': stack -= ')'\n                case _: String => throw\
    \ new Exception(\"Invalid parentheses\")\n            }\n            if(open !=\
    \ close) {\n                result += \"No\"\n                return result.toString\n\
    \            }\n        }\n        result += \"Yes\"\n        return result.toString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppmv584nz.scala:19:32 ---------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m \e[31m'('\e[0m: stack\
    \ += \e[31m'('\e[0m\n\e[31m\e[31m   |\e[0m                                ^^\e\
    [0m\n\e[31m   |\e[0m                                '=>' expected, but identifier\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppmv584nz.scala:20:32 ---------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e[0m \e[31m')'\e[0m: stack\
    \ += \e[31m')'\e[0m\n\e[31m\e[31m   |\e[0m                                ^^\e\
    [0m\n\e[31m   |\e[0m                                '=>' expected, but identifier\
    \ found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppmv584nz.scala:24:32 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m                \e[33mcase\e[0m \e[31m')'\e[0m: stack\
    \ -= \e[31m')'\e[0m\n\e[31m\e[31m   |\e[0m                                ^^\e\
    [0m\n\e[31m   |\e[0m                                '=>' expected, but identifier\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppmv584nz.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppmv584nz.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmppmv584nz.scala:19:26 ------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m \e[31m'('\e[0m: stack\
    \ += \e[31m'('\e[0m\n\e[31m\e[31m   |\e[0m                          ^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: type stack\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation av"
  stdout: ''
  timestamp: 1659979820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \"(\"\
    \ => open += s\n                case \")\" => close += s\n                case\
    \ _ => stack += s\n            }\n        }\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        val openParen = openCount - closeCount\n\
    \        val closeParen = closeCount - openCount\n        val openParenCount =\
    \ openParen\n        val closeParenCount = closeParen\n        val openParenIndex\
    \ = stack.indexOf(\"(\")\n        val closeParenIndex = stack.indexOf(\")\")\n\
    \        val openParenCount = stack.size\n        val closeParenCount = stack.size\n\
    \        val openParenIndex = stack.indexOf(\"(\")\n        val closeParenIndex\
    \ = stack.indexOf(\")\")\n        val openParenCount = stack.size\n        val\
    \ closeParenCount = stack.size\n        if (openParenCount > closeParenCount &&\
    \ openParenCount > openParenIndex && closeParenCount > closeParenIndex) {\n  \
    \          val openParen = stack.take(openParenIndex).reverse\n            val\
    \ closeParen = stack.drop(closeParenIndex).reverse\n            val openParenCount\
    \ = openParen.size\n            val closeParenCount = closeParen.size\n      \
    \      val openParenIndex = stack.indexOf(\"(\")\n            val closeParenIndex\
    \ = stack.indexOf(\")\")\n            val openParenCount = stack.size\n      \
    \      val closeParenCount = stack.size\n            val openParenIndex = stack.indexOf(\"\
    (\")\n            val closeParenIndex = stack.indexOf(\")\")\n            val\
    \ openParenCount = stack.size\n            val closeParenCount = stack.size\n\
    \            val openParen = stack.take(openParenIndex).reverse\n            val\
    \ closeParen = stack.drop(closeParenIndex).reverse\n            val openParenCount\
    \ = openParen.size\n            val closeParenCount = closeParen.size\n      \
    \      val openParenIndex = stack.indexOf(\"(\")\n            val closeParenIndex\
    \ = stack.indexOf(\")\")\n            val openParenCount = stack.size\n      \
    \      val closeParenCount = stack.size\n            val openParen = stack.take(openParenIndex).reverse\n\
    \            val closeParen = stack.drop(closeParenIndex).reverse\n          \
    \  val openParenCount = openParen.size\n            val closeParenCount = closeParen.size\n\
    \            val openParenIndex = stack.indexOf(\"(\")\n            val closeParenIndex\
    \ = stack.indexOf(\")\")\n            val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmph0myhg8u.scala:66:15 ---------------------------\e\
    [0m\e[0m\n\e[31m66 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph0myhg8u.scala:84:0 ----------------------------\e\
    [0m\e[0m\n\e[31m84 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph0myhg8u.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopenParenCount\e[0m = stack.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenParenCount is already defined as \e[33mvalue\e[0m \e[35mopenParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph0myhg8u.scala:34:12 ---------------------------\e[0m\e[0m\n\e\
    [31m34 |\e[0m        \e[33mval\e[0m \e[36mcloseParenCount\e[0m = stack.size\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mcloseParenCount is already defined as \e[33mvalue\e[0m \e[35mcloseParenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph0myhg8u.scala:35:12 ---------------------------\e[0m\e[0m\n\e\
    [31m35 |\e[0m        \e[33mval\e[0m \e[36mopenParenIndex\e[0m = stack.indexOf(\e\
    [31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenParenIndex is already defined as \e[33mvalue\e[0m \e[35mopenParenIndex\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmph0myhg8u.scala:36:12 ---------------------------\e[0m\e[0m\n\e\
    [31m36 |\e[0m        \e[33mval\e[0m \e[36mcloseParenIndex\e[0m = stack.indexOf(\e\
    [31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m        "
  stdout: ''
  timestamp: 1659979823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(s => {\n            if (s.startsWith(\"(\")) {\n        \
    \        stack.push(s)\n            } else if (s.startsWith(\")\")) {\n      \
    \          val s = stack.pop()\n                if (s.startsWith(\"(\")) {\n \
    \                   stack.push(s)\n                } else {\n                \
    \    result += (s + \"(\" + s + \")\")\n                }\n            }\n   \
    \     })\n        if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp04y455zz.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp04y455zz.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979820
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStr = str.substring(open + 1, close)\n            val newStack\
    \ = stack.filterNot(x => x == newStr)\n            val newResult = result.filterNot(x\
    \ => x == newStr)\n            if(newStack.isEmpty) {\n                result\
    \ += newStr\n            }\n            else if(newResult.isEmpty) {\n       \
    \         stack += newStr\n            }\n            else {\n               \
    \ val newStackStr = newStack.mkString(\"(\", \")\")\n                val newResultStr\
    \ = newResult.mkString(\"(\", \")\")\n                if(newStackStr == newResultStr)\
    \ {\n                    result += newStr\n                }\n               \
    \ else {\n                    stack += newStr\n                }\n           \
    \ }\n        }\n        if(result.size == lst.size) {\n            return \"Yes\"\
    \n        }\n        else {\n            return \"No\"\n        }\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4k1sc6ul.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4k1sc6ul.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979822
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        val open = stack.takeWhile(x =>\
    \ x != \"(\").length\n        val close = stack.takeWhile(x => x != \")\").length\n\
    \        if (open != close)\n            return \"No\"\n        val stack2 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(1)\n        val stack3 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(2)\n        val stack4 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(3)\n        val stack5 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(4)\n        val stack6 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(5)\n        val stack7 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(6)\n        val stack8 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(7)\n        val stack9 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(8)\n        val stack10 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(9)\n        val stack11 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(10)\n        val stack12 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(11)\n        val stack13 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(12)\n        val stack14 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(13)\n        val stack15 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(14)\n        val stack16 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(15)\n        val stack17 = stack.dropWhile(x\
    \ => x != \"(\").dropWhile(x => x != \")\").drop(16)\n        val stack18\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp5q4ztond.scala:38:4 ----------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5q4ztond.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5q4ztond.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp5q4ztond.scala:38:5\
    \ ---------------------\e[0m\e[0m\n\e[31m38 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ String\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue\
    \ += x else if (!x == \")\") bad += x))\n        val goodString = stack.toList\
    \ ++ queue.toList\n        val goodString = goodString.filter(x => !bad.contains(x))\n\
    \        val goodString = goodString.filter(x => !good.contains(x))\n        val\
    \ goodString = goodString.filter(x => !stack.toList.contains(x))\n        val\
    \ goodString = goodString.filter(x => !queue.toList.contains(x))\n        if (goodString.size\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf0xio3jv.scala:18:110 --------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) bad\
    \ += x))\n\e[31m\e[31m   |\e[0m                                              \
    \                                                                ^\e[0m\n\e[31m\
    \   |\e[0m                                             '}' expected, but ')' found\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpf0xio3jv.scala:41:0 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m}\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0meof expected,\
    \ but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0xio3jv.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0xio3jv.scala:15:20\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0xio3jv.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpf0xio3jv.scala:17:18\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[3"
  stdout: ''
  timestamp: 1659979828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        stack.push(s)\n            } else if (s.startsWith(\")\")) {\n      \
    \          val s = stack.pop()\n                if (s.startsWith(\"(\")) {\n \
    \                   stack.push(s)\n                } else {\n                \
    \    result += \"No\"\n                }\n            }\n        }\n        if\
    \ (stack.size == 0) {\n            result += \"Yes\"\n        } else {\n     \
    \       result += \"No\"\n        }\n        return result.toString\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmponbc0glx.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmponbc0glx.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979823
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val len = lst.size\n        for(i <- 0 until len) {\n            val\
    \ str = lst(i)\n            if(str == \"(\") {\n                stack.push(str)\n\
    \            } else if(str == \")\") {\n                val top = stack.pop()\n\
    \                if(top == \"(\") {\n                    result += \"(\" + top\
    \ + \")\"\n                } else {\n                    result += \"(\" + top\
    \ + \")\"\n                }\n            } else {\n                result +=\
    \ \"(\" + str + \")\"\n            }\n        }\n        if(result.size == len)\
    \ {\n            return \"Yes\"\n        } else {\n            return \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp4tr1oui0.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp4tr1oui0.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => if (x == \"(\") stack.push(x) else stack.pop())\n  \
    \      val stackSize = stack.size\n        if (stackSize == 0) \"No\" else \"\
    Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1j_v_g68.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1j_v_g68.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val openCount = open + 1\n            val closeCount = close +\
    \ 1\n            val openParens = openCount - closeCount\n            if(openParens\
    \ == 0) {\n                stack += str\n            }\n            else if(openParens\
    \ > 0) {\n                stack += str.substring(0, open)\n            }\n   \
    \         else if(closeParens > 0) {\n                val popped = stack.pop()\n\
    \                result += popped\n            }\n        }\n        if(stack.size\
    \ == 0) {\n            return \"No\"\n        }\n        else if(stack.size ==\
    \ 1) {\n            return \"Yes\"\n        }\n        else {\n            return\
    \ \"Yes\"\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp7t0wlgu0.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7t0wlgu0.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp7t0wlgu0.scala:29:20 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            \e[33melse\e[0m \e[33mif\e[0m(closeParens\
    \ > \e[31m0\e[0m) {\n\e[31m\e[31m   |\e[0m                    ^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                    Not found: closeParens\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \")()\" => close.push(x)\n            case x if x\
    \ == \"(\" => open.push(x)\n            case x if x == \")(\" => open.push(x)\n\
    \            case x if x == \")()()\" => close.push(x)\n            case x if\
    \ x == \")(())\" => close.push(x)\n            case x if x == \")(()())\" => close.push(x)\n\
    \            case x if x == \")(())()\" => close.push(x)\n            case x if\
    \ x == \")(()())()\" => close.push(x)\n            case x if x == \")(())(())\"\
    \ => close.push(x)\n            case x if x == \")(())(()())\" => close.push(x)\n\
    \            case x if x == \")(())(()())()\" => close.push(x)\n            case\
    \ x if x == \")(())(())(())\" => close.push(x)\n            case x if x == \"\
    )(())(())(()())\" => close.push(x)\n            case x if x == \")(())(())(()())()\"\
    \ => close.push(x)\n            case x if x == \")(())(())(()())(())\" => close.push(x)\n\
    \            case x if x == \")(())(())(()())(()())\" => close.push(x)\n     \
    \       case x if x == \")(())(())(()())(()())()\" => close.push(x)\n        \
    \    case x if x == \")(())(())(()())(()())(())\" => close.push(x)\n         \
    \   case x if x == \")(())(())(()())(()())(()())\" => close.push(x)\n        \
    \    case x if x == \")(())(())(()())(()())(()())()\" => close.push(x)\n     \
    \       case x if x == \")(())(())(()())(()())(()())(())\" => close.push(x)\n\
    \            case x if x == \")(())(())(()())(()())(()())(()())\" => close.push(x)\n\
    \            case x if x == \")(())(())(()())(()())(()())(()())()\" => close.push\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpv8avql4l.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpv8avql4l.scala:60:0 ----------------------------\e[0m\e[0m\n\e[31m60\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv8avql4l.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpv8avql4l.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpv8avql4l.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpv8avql4l.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n6 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.ListBuffer[String]()\n\
    \        val bad = mutable.ListBuffer[String]()\n        lst.foreach(x => x match\
    \ {\n            case \")\" => stack.pop() match {\n                case \")\"\
    \ => good.toList match {\n                    case Nil => bad.toList match {\n\
    \                        case Nil => \"No\"\n                        case x =>\
    \ x match {\n                            case x => good = good.toList ++ List(x)\n\
    \                            case Nil => \"Yes\"\n                        }\n\
    \                    }\n                    case x => x match {\n            \
    \            case x => good = good.toList ++ List(x)\n                       \
    \ case Nil => \"Yes\"\n                    }\n                }\n            \
    \    case \")\" => bad.toList match {\n                    case Nil => \"No\"\n\
    \                    case x => x match {\n                        case x => good\
    \ = good.toList ++ List(x)\n                        case Nil => \"Yes\"\n    \
    \                }\n                }\n            }\n            case \")\" =>\
    \ stack.append(x)\n            case x => stack.append(x)\n        })\n       \
    \ good.toList match {\n            case Nil => \"No\"\n            case x => x\
    \ match {\n                case x => good = good.toList ++ List(x)\n         \
    \       case Nil => \"Yes\"\n            }\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0ugaduae.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0ugaduae.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp0ugaduae.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp0ugaduae.scala:23:43 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                            \e[33mcase\e[0m x => good\
    \ = good.toList ++ List(x)\n\e[31m\e[31m   |\e[0m                            \
    \          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \                       Reassignment to val good\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmp0ugaduae.scala:28:39 -----------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                        \e[33mcase\e[0m x => good = good.toList\
    \ ++ List(x)\n\e[31m\e[31m   |\e[0m                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                  Reassignment to val good\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmp0ugaduae.scala"
  stdout: ''
  timestamp: 1659979825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") stack += x\n        \
    \    if (x == \")\") stack -= x\n            if (stack.size == 0) good += x\n\
    \        })\n        if (good.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmy03zdk9.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmy03zdk9.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\"\
    ) => stack.push(x)\n            case x if x.startsWith(\")\") => stack.pop() match\
    \ {\n                case x if x == \")\" => result.add(x)\n                case\
    \ x => result.add(x)\n            }\n            case x => result.add(x)\n   \
    \     })\n        if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb2cfxbxe.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb2cfxbxe.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979825
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n\
    \        val bad = mutable.Set[String]()\n        lst.foreach(x => if (x == \"\
    (\") stack += x else if (!x == \"(\") stack.pop() else if (!x == \")\") stack.pop()\
    \ else if (!stack.isEmpty && stack.last == \"(\") stack += x else if (!stack.isEmpty\
    \ && stack.last == \")\") stack.pop() else if (!stack.isEmpty && stack.last ==\
    \ \"(\") stack += x else if (!stack.isEmpty && stack.last == \")\") stack.pop()\
    \ else if (!stack.isEmpty && stack.last == \"(\") stack += x else if (!stack.isEmpty\
    \ && stack.last == \")\") stack.pop() else if (!stack.isEmpty && stack.last ==\
    \ \"(\") stack += x else if (!stack.isEmpty && stack.last == \")\") stack.pop()\
    \ else if (!stack.isEmpty && stack.last == \"(\") stack += x else if (!stack.isEmpty\
    \ && stack.last == \")\") stack.pop() else if (!stack.isEmpty && stack.last ==\
    \ \"(\") stack += x else if (!stack.isEmpty && stack.last == \")\") stack.pop()\
    \ else if (!stack.isEmpty && stack.last == \"(\") stack += x else if (!stack.isEmpty\
    \ && stack.last == \")\") stack.pop() else if (!stack.isEmpty && stack.last ==\
    \ \"(\") stack += x else if (!stack.isEmpty && stack.last == \")\") stack.pop()\
    \ else if (!stack.isEmpty && stack.last == \"(\") stack += x else if (!stack.isEmpty\
    \ && stack.last == \")\") stack.pop() else if (!stack.isEmpty && stack.last ==\
    \ \"(\") stack += x else if (!stack.isEmpty && stack.last == \")\") stack.pop()\
    \ else if (!stack.isEmpty && stack.last == \"(\") stack += x else if (!stack.isEmpty\
    \ && stack.last == \")\") stack.pop() else if (!stack.isEmpty && stack.last ==\
    \ \"(\") stack += x else if (!stack.isEmpty && stack.last == \")\") stack.pop()\
    \ else if (!stack.isEmpty && stack.last == \"(\") stack += x else if (!stack.isEmpty\
    \ && stack.last == \")\") stack.pop() else if (!stack.isEmpty && stack.last ==\
    \ \"(\") stack += x else if (!stack.isEmpty && stack.last == \")\") stack.pop()\
    \ else if (!stack.isEmpty && stack.last == \"(\") stack += x else if (!stack.isEmpty\
    \ && stack.last == \")\") stack.pop() else if (!stack.isEmpty && stack.last ==\
    \ \"(\") stack += x else if (!stack.isEmpty && stack.last == \")\") \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzh5ihlfz.scala:18:4 ----------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    'then' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzh5ihlfz.scala:14:20 ------------------------\e[0m\e[0m\n\e[31m14 |\e\
    [0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzh5ihlfz.scala:15:19 ------------------------\e[0m\e[0m\n\e[31m15 |\e\
    [0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpzh5ihlfz.scala:16:18 ------------------------\e[0m\e[0m\n\e[31m16 |\e\
    [0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e\
    [31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m   |\e[0m           \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error:\
    \ /tmp/tmpzh5ihlfz.scala:17:59 ------------------------\e[0m\e[0m\n\e[31m17 |\e\
    [0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x == \e[31m\"(\"\e[0m) stack\
    \ += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"(\"\e[0m) stack.pop() \e[33melse\e\
    [0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e\
    [0m (!stack.isEmpty && stack.last == \e[31m\"(\"\e[0m) stack += x \e[33melse\e\
    [0m \e[33mif\e[0m (!stack.isEmpty && stack.last == \e[31m\")\"\e[0m) stack.pop()\
    \ \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty && stack.last == \e[31m\"(\"\e\
    [0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty && stack.last ==\
    \ \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && stack.last == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33m"
  stdout: ''
  timestamp: 1659979828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            if (s == \"(\") {\n                stack.push(s)\n\
    \            } else if (s == \")\") {\n                if (stack.isEmpty) {\n\
    \                    result += \"No\"\n                } else {\n            \
    \        result += \"Yes\"\n                }\n                stack.pop()\n \
    \           }\n        }\n        if (result.isEmpty) {\n            result +=\
    \ \"No\"\n        } else {\n            result += \"Yes\"\n        }\n       \
    \ return result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxmmlzpdq.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxmmlzpdq.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979824
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openCount = stack.length\n      \
    \          val closeCount = stack.length\n                while(openCount > 0)\
    \ {\n                    stack.pop()\n                    openCount -= 1\n   \
    \             }\n                while(closeCount > 0) {\n                   \
    \ stack.pop()\n                    closeCount -= 1\n                }\n      \
    \          val newStack = stack.mkString(\"(\", \", \", \")\")\n             \
    \   result.append(\"Yes\")\n            }\n        }\n        result.mkString(\"\
    , \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmk8j1rhh.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmk8j1rhh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")(\" => open.push(x)\n                case \")()\" =>\
    \ open.push(x)\n                case _ => stack.push(x)\n            }\n     \
    \   })\n        val openCount = open.size\n        val closeCount = close.size\n\
    \        if (openCount == 0 && closeCount == 0) \"No\"\n        else if (openCount\
    \ == 0 && closeCount > 0) \"Yes\"\n        else if (openCount > 0 && closeCount\
    \ == 0) \"Yes\"\n        else if (openCount > 0 && closeCount > 0) \"No\"\n  \
    \      else if (openCount == closeCount) \"Yes\"\n        else matchParens(stack.toList)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvfg9qot4.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvfg9qot4.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvfg9qot4.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvfg9qot4.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979826
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!stack.isEmpty &&\
    \ x == \")\") stack.pop() else if (!stack.isEmpty && x == \"(\") stack += x else\
    \ if (!stack.isEmpty && x == \")\") stack.pop() else if (!stack.isEmpty && x ==\
    \ \"(\") stack += x else if (!stack.isEmpty && x == \")\") stack.pop() else if\
    \ (!stack.isEmpty && x == \"(\") stack += x else if (!stack.isEmpty && x == \"\
    )\") stack.pop() else if (!stack.isEmpty && x == \"(\") stack += x else if (!stack.isEmpty\
    \ && x == \")\") stack.pop() else if (!stack.isEmpty && x == \"(\") stack += x\
    \ else if (!stack.isEmpty && x == \")\") stack.pop() else if (!stack.isEmpty &&\
    \ x == \"(\") stack += x else if (!stack.isEmpty && x == \")\") stack.pop() else\
    \ if (!stack.isEmpty && x == \"(\") stack += x else if (!stack.isEmpty && x ==\
    \ \")\") stack.pop() else if (!stack.isEmpty && x == \"(\") stack += x else if\
    \ (!stack.isEmpty && x == \")\") stack.pop() else if (!stack.isEmpty && x == \"\
    (\") stack += x else if (!stack.isEmpty && x == \")\") stack.pop() else if (!stack.isEmpty\
    \ && x == \"(\") stack += x else if (!stack.isEmpty && x == \")\") stack.pop()\
    \ else if (!stack.isEmpty && x == \"(\") stack += x else if (!stack.isEmpty &&\
    \ x == \")\") stack.pop() else if (!stack.isEmpty && x == \"(\") stack += x else\
    \ if (!stack.isEmpty && x == \")\") stack.pop() else if (!stack.isEmpty && x ==\
    \ \"(\") stack += x else if (!stack.isEmpty && x == \")\") stack.pop() else if\
    \ (!stack.isEmpty && x == \"(\") stack += x else if (!stack.isEmpty && x == \"\
    )\") stack.pop() else if (!stack.isEmpty && x == \"(\") stack += x else if (!stack.isEmpty\
    \ && x == \")\") stack.pop() else if (!stack.isEmpty && x == \"(\") stack += x\
    \ else if (!stack.isEmpty && x == \")\") stack.pop() else if (!stack.isEmpty &&\
    \ x == \"(\") stack += x else if (!stack.isEmpty && x == \")\") stack.pop() else\
    \ if (!stack.isEmpty && x == \"(\") stack += x else if (!stack.isEmpty && x ==\
    \ \")\") stack.pop() else if (!stack.isEmpty && x == \"(\") stack += \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpti2opx6k.scala:16:1890 -------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x "
  stdout: ''
  timestamp: 1659979826
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.add(x)\n                case \")(\"  =>\n    \
    \                open.add(x)\n                case \")()\" =>\n              \
    \      open.add(x)\n                case \")()()\" =>\n                    open.add(x)\n\
    \                case \")()()()\" =>\n                    open.add(x)\n      \
    \          case \")()()()()\" =>\n                    open.add(x)\n          \
    \      case \")()()()()()\" =>\n                    open.add(x)\n            \
    \    case \")()()()()()()\" =>\n                    open.add(x)\n            \
    \    case \")()()()()()()()\" =>\n                    open.add(x)\n          \
    \      case \")()()()()()()()()\" =>\n                    open.add(x)\n      \
    \          case \")()()()()()()()()()\" =>\n                    open.add(x)\n\
    \                case \")()()()()()()()()()()\" =>\n                    open.add(x)\n\
    \                case \")()()()()()()()()()()()\" =>\n                    open.add(x)\n\
    \                case \")()()()()()()()()()()()\" =>\n                    open.add(x)\n\
    \                case \")()()()()()()()()()()()\" =>\n                    open.add(x)\n\
    \                case \")()()()()()()()()()()()()\" =>\n                    open.add(x)\n\
    \                case \")()()()()()()()()()()()()\" =>\n                    open.add(x)\n\
    \                case \")()()()()()()()()()()()()()\" =>\n                   \
    \ open.add(x)\n                case \")()()()()()()()()()()()()()\" =>\n     \
    \               open.add(x)\n                case \")()()()()()()()()()()()()()\"\
    \ =>\n                    open.add(x)\n                case \")()()()()()()()()()()()()()()\"\
    \ =>\n                    open.add(x)\n                case \")()()()()()()()()()()()()()()\"\
    \ =>\n                    open.add(x)\n                case \")()()()()()()()()()()()()()()\"\
    \ =>\n                    open.add(x)\n                case \")()()()()()()()()()()()()()()()\"\
    \ =>\n                    open.add(x)\n                case \")()\n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp_2zwjwa2.scala:68:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m                \e[33mcase\e[0m \")()\n\e[31m\e[31m \
    \  |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmp_2zwjwa2.scala:70:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_2zwjwa2.scala:86:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m86 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp_2zwjwa2.scala:14:20 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp_2zwjwa2.scala:15:21 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_2zwjwa2.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp_2zwjwa2.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.S"
  stdout: ''
  timestamp: 1659979826
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\"\
    ) => stack += x\n            case x if x.startsWith(\")\") => queue += x\n   \
    \         case _ => bad += x\n        })\n        while(stack.nonEmpty || queue.nonEmpty)\
    \ {\n            val x = stack.pop() match {\n                case x if x.startsWith(\"\
    (\") => stack += x\n                case x if x.startsWith(\")\") => queue +=\
    \ x\n                case _ => bad += x\n            }\n            good += x\n\
    \        }\n        if (good.size == lst.size) {\n            return \"Yes\"\n\
    \        } else {\n            return \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb5d6xxov.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb5d6xxov.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpb5d6xxov.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpb5d6xxov.scala:17:18 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979827
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n\
    \            } else if (x == \")\") {\n                if (stack.size == 0) {\n\
    \                    result += \"No\"\n                } else {\n            \
    \        val top = stack.pop()\n                    if (top == \"(\") {\n    \
    \                    result += \"Yes\"\n                    } else {\n       \
    \                 result += \"No\"\n                    }\n                }\n\
    \            }\n        })\n        result += \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2xb95agv.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2xb95agv.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val open = s.indexOf('(')\n         \
    \   val close = s.lastIndexOf(')')\n            if (open < 0 || close < 0 || open\
    \ > close) {\n                result.append(\"No\")\n            } else {\n  \
    \              val newStack = mutable.Stack[String]()\n                stack.push(s)\n\
    \                while (!stack.isEmpty && open > stack.peek().indexOf(')')) {\n\
    \                    newStack.push(stack.peek())\n                    stack.pop()\n\
    \                }\n                while (!stack.isEmpty && close < stack.peek().indexOf('('))\
    \ {\n                    newStack.push(stack.peek())\n                    stack.pop()\n\
    \                }\n                while (!stack.isEmpty && open < stack.peek().indexOf('('))\
    \ {\n                    newStack.push(stack.peek())\n                    stack.pop()\n\
    \                }\n                if (newStack.isEmpty) {\n                \
    \    result.append(\"Yes\")\n                } else {\n                    result.append(\"\
    No\")\n                }\n            }\n        }\n        return result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmwztjj48.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmwztjj48.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpmwztjj48.scala:22:31 ------------------------\e\
    [0m\e[0m\n\e[31m22 |\e[0m                \e[33mval\e[0m \e[36mnewStack\e[0m =\
    \ mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    if(str == \"(\") {\n                stack += str\n            } else if(str\
    \ == \")\") {\n                val s = stack.pop()\n                if(s == \"\
    (\") {\n                    stack += s\n                } else {\n           \
    \         result += \"No\"\n                    break\n                }\n   \
    \         } else {\n                result += \"No\"\n                break\n\
    \            }\n        }\n        if(result.size == lst.size) {\n           \
    \ result += \"Yes\"\n        } else {\n            result += \"No\"\n        }\n\
    \        return result.toString\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbj97tkjx.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbj97tkjx.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbj97tkjx.scala:26:20 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbj97tkjx.scala:30:16\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m                break\n\e\
    [31m\e[31m   |\e[0m                ^^^^^\e[0m\n\e[31m   |\e[0m               \
    \ Not found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1659979828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n\
    \        val bad = mutable.Set[String]()\n        lst.foreach(x => {\n       \
    \     if (x == \"(\") {\n                stack.push(x)\n            } else if\
    \ (x == \")\") {\n                if (stack.nonEmpty) {\n                    val\
    \ top = stack.pop()\n                    if (top == \"(\") {\n               \
    \         good.add(top)\n                    } else {\n                      \
    \  bad.add(top)\n                    }\n                }\n            }\n   \
    \     })\n        if (good.size == lst.size) {\n            return \"Yes\"\n \
    \       } else {\n            return \"No\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpda2f3i80.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpda2f3i80.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpda2f3i80.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979828
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n                return result.toString\n            }\n            val stackStr\
    \ = str.substring(0, open)\n            val stackStr = stackStr + str.substring(open\
    \ + 1, close)\n            val stackStr = stackStr + str.substring(close + 1)\n\
    \            stackStr match {\n                case \"\" => result.append(\"Yes\"\
    )\n                case _ => stackStr match {\n                    case \"\" =>\
    \ result.append(\"Yes\")\n                    case _ => stack.append(stackStr)\n\
    \                }\n            }\n        }\n        result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6od77erq.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp6od77erq.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp6od77erq.scala:25:16 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e[0m \e[36mstackStr\e[0m = stackStr\
    \ + str.substring(open + \e[31m1\e[0m, close)\n\e[31m\e[31m   |\e[0m         \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mstackStr is already defined as \e[33mvalue\e[0m \e[35mstackStr\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp6od77erq.scala:26:16 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m            \e[33mval\e[0m \e[36mstackStr\e[0m = stackStr + str.substring(close\
    \ + \e[31m1\e[0m)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackStr is already defined as \e[33mvalue\e[0m \e[35mstackStr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1659979830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val str = stack.pop()\n            if(str.startsWith(\"(\")) {\n     \
    \           result += \"(\"\n                stack += str\n            } else\
    \ if(str.startsWith(\")\")) {\n                result += \")\"\n             \
    \   stack += str\n            } else {\n                result += \"(\"\n    \
    \            stack += str\n                result += \"(\"\n                stack\
    \ += str\n                result += \")\"\n                stack += str\n    \
    \        }\n        }\n        if(result.size == lst.length)\n            return\
    \ \"Yes\"\n        else\n            return \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq_pl81rc.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpq_pl81rc.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { x =>\n            if (x contains \"(\") {\n           \
    \     open += x\n                stack += x\n            } else if (x contains\
    \ \")\") {\n                close += x\n                stack -= x\n         \
    \   } else {\n                result += x\n            }\n        }\n        if\
    \ (stack.size == 0) {\n            if (open.size == close.size) {\n          \
    \      result += \"Yes\"\n            } else {\n                result += \"No\"\
    \n            }\n        } else {\n            val openCount = open.size\n   \
    \         val closeCount = close.size\n            if (openCount == closeCount)\
    \ {\n                result += \"Yes\"\n            } else {\n               \
    \ result += \"No\"\n            }\n        }\n        result.toString\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcof0xc5b.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcof0xc5b.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcof0xc5b.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpcof0xc5b.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979830
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop() match {\n                        case\
    \ \"\" => result.append(\"Yes\")\n                        case x => result.append(\"\
    No\")\n                    }\n                }\n                case \"(\" =>\
    \ {\n                    stack.push(x)\n                }\n                case\
    \ _ => {\n                    stack.append(x)\n                }\n           \
    \ }\n        })\n        result.last\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpg20zaiqs.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpg20zaiqs.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979831
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n        val stackSize = lst.size\n        val stackSize = lst.size\n\
    \        val stackSize = lst.size\n        val stackSize = lst.size\n        val\
    \ stackSize = lst.size\n        val stackSize = lst.size\n        val stackSize\
    \ = lst.size\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqmomrq6m.scala:17:12 ---------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize\
    \ is already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqmomrq6m.scala:18:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqmomrq6m.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqmomrq6m.scala:20:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m20 |\e[0m        \e[33mval\e[0m\
    \ \e[36mstackSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackSize is already defined as \e[33mvalue\e[0m \e[35mstackSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpqmomrq6m.scala:21:12 ---------------------------\e[0m\e[0m\n\e\
    [31m21 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same gro"
  stdout: ''
  timestamp: 1659979834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer.empty[String]\n        val close = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    stack.push(x)\n                }\n  \
    \              case \")()\" => {\n                    val openCount = open.size\n\
    \                    val closeCount = close.size\n                    if (openCount\
    \ == closeCount) {\n                        val openStr = open.toList\n      \
    \                  val closeStr = close.toList\n                        val openStrLen\
    \ = openStr.size\n                        val closeStrLen = closeStr.size\n  \
    \                      if (openStrLen > closeStrLen) {\n                     \
    \       result.append(\"Yes\")\n                        } else {\n           \
    \                 result.append(\"No\")\n                        }\n         \
    \           } else {\n                        result.append(\"No\")\n        \
    \            }\n                }\n                case \")\" => {\n         \
    \           close.push(x)\n                }\n                case \")()\" =>\
    \ {\n                    val openCount = open.size\n                    val closeCount\
    \ = close.size\n                    if (openCount == closeCount) {\n         \
    \               val openStr = open.toList\n                        val closeStr\
    \ = close.toList\n                        val openStrLen = openStr.size\n    \
    \                    val closeStrLen = closeStr.size\n                       \
    \ if (openStrLen < closeStrLen) {\n                            result.append(\"\
    Yes\")\n                        } else {\n                            result.append(\"\
    No\")\n                        }\n                    } else {\n             \
    \           result.append(\"No\")\n                    }\n                }\n\
    \                case \")()\" => {\n                    val openCount = open.size\n\
    \                    val closeCount = close.size\n                    if (openCount\
    \ == closeCount) {\n                        val openStr = open.toList\n      \
    \                  val closeStr = close.toList\n                        val openStrLen\
    \ = openStr.size\n                        val closeStrLen = closeStr.size\n  \
    \                      if (openStrLen > closeStrLen) {\n                     \
    \       result.append(\"Yes\")\n                        } else {\n           \
    \                 result.append(\"No\")\n                        }\n         \
    \           } else {\n                        result.append(\"No\")\n        \
    \            }\n                }\n                case \")()\" => {\n       \
    \             val openCount = open.size\n                    val closeCount =\
    \ close.size\n                    if (openCount == closeCount) {\n           \
    \             val openStr = open.toList\n                        val closeStr\
    \ = close.toList\n                        val openStrLen = openStr.size\n    \
    \                    val closeStrLen = closeStr.size\n                       \
    \ if (openStrLen < closeStrLen) {\n                            result.append(\"\
    Yes\")\n                        } else {\n                            result.append(\"\
    No\")\n                        }\n                    } else {\n             \
    \           result.append(\"No\")\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp46yks_ip.scala:112:0 ---------------------------\e\
    [0m\e[0m\n\e[31m112 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp46yks_ip.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp46yks_ip.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp46yks_ip.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp46yks_ip.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m   |\e\
    [0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp46yks_ip.scala:18:19\
    \ --------------------\e[0m\e[0m\n\e[31m 18 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 19 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 20 |\e[0m                \e[33mcase\e[0m \e"
  stdout: ''
  timestamp: 1659979835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.ListBuffer[String]()\n\
    \        val bad = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n\
    \            if (x == \"(\") stack += x\n            if (x == \")\") stack -=\
    \ x\n            if (stack.nonEmpty) {\n                if (stack.head == \"(\"\
    ) good += x\n                if (stack.head == \")\") bad += x\n            }\n\
    \        })\n        if (good.size == lst.length) \"Yes\" else \"No\"\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnovu5xuq.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnovu5xuq.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpnovu5xuq.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979831
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val openCount = open + 1\n            val closeCount = close +\
    \ 1\n            val openParens = open - openCount\n            val closeParens\
    \ = close - closeCount\n            val openParensCount = openParens + 1\n   \
    \         val closeParensCount = closeParens + 1\n            if(openParensCount\
    \ < closeParensCount) {\n                stack.push(str)\n            } else if(openParensCount\
    \ > closeParensCount) {\n                val popped = stack.pop()\n          \
    \      result += (popped + str)\n            } else {\n                result\
    \ += (str)\n            }\n        }\n        if(stack.nonEmpty) {\n         \
    \   \"No\"\n        } else {\n            \"Yes\"\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_pesotri.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_pesotri.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979831
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")(\" => open.add(x)\n                case \")()\" => open.add(x)\n\
    \                case \")()()\" => open.add(x)\n                case \")(\" =>\
    \ close.add(x)\n                case \")()\" => close.add(x)\n               \
    \ case \")()()\" => close.add(x)\n                case _ => stack.push(x)\n  \
    \          }\n        })\n        val openCount = open.size\n        val closeCount\
    \ = close.size\n        val openStack = stack.take(openCount)\n        val closeStack\
    \ = stack.drop(closeCount)\n        val openStackSize = openStack.size\n     \
    \   val closeStackSize = closeStack.size\n        val openStackIsEmpty = openStack.isEmpty\n\
    \        val closeStackIsEmpty = closeStack.isEmpty\n        val openStackIsFull\
    \ = openStackSize == openCount\n        val closeStackIsFull = closeStackSize\
    \ == closeCount\n        val openStackIsEmptyOrFull = openStackIsEmpty || openStackIsFull\n\
    \        val closeStackIsEmptyOrFull = closeStackIsEmpty || closeStackIsFull\n\
    \        val openStackIsFullOrEmpty = openStackIsFull || openStackIsEmpty\n  \
    \      val closeStackIsFullOrEmpty = closeStackIsFull || closeStackIsEmpty\n \
    \       val openStackIsEmptyOrFullOrEmpty = openStackIsEmptyOrFull || closeStackIsEmptyOrFull\n\
    \        val closeStackIsEmptyOrFullOrEmpty = closeStackIsEmptyOrFull || closeStackIsEmptyOrEmpty\n\
    \        val openStackIsFullOrFullOrEmpty = openStackIsFullOrEmpty || closeStackIsFullOrEmpty\n\
    \        val closeStackIsFullOrFullOrEmpty = closeStackIsFullOrEmpty || closeStackIsFullOrEmpty\n\
    \        val openStackIsEmptyOrFullOrFullOrEmpty = openStackIsEmptyOrFullOrEmpty\
    \ || closeStackIsEmptyOrFullOrEmpty\n        val closeStackIsEmptyOrFullOrFullOrEmpty\
    \ = closeStackIsEmptyOrFullOrEmpty || closeStackIsFullOrFullOrEmpty\n        val\
    \ \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp2i7tpf_n.scala:53:11 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmp2i7tpf_n.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2i7tpf_n.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2i7tpf_n.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp2i7tpf_n.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp2i7tpf_n.scala:54:5 ---------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explana"
  stdout: ''
  timestamp: 1659979834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n\
    \            } else if (x == \")\") {\n                val top = stack.pop()\n\
    \                if (top == \"(\") {\n                    result += \"(\" + top\
    \ + \")\"\n                } else {\n                    result += \"(\" + top\
    \ + \")\"\n                }\n            }\n        })\n        if (stack.size\
    \ == 0) {\n            result.append(\"No\")\n        } else {\n            result.append(\"\
    Yes\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9cfzxfp8.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9cfzxfp8.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n\
    \            } else if (x == \")\") {\n                if (stack.isEmpty) {\n\
    \                    result += \"No\"\n                } else {\n            \
    \        val top = stack.pop()\n                    result += \"Yes\"\n      \
    \          }\n            }\n        })\n        result.mkString(\",\")\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuq6pe3h8.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpuq6pe3h8.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n\
    \            } else if (x == \")\") {\n                if (stack.size == 0) {\n\
    \                    result += \"No\"\n                } else {\n            \
    \        result += \"Yes\"\n                    stack.pop()\n                }\n\
    \            }\n        })\n        result mkString \"\\n\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn9ia9h1d.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpn9ia9h1d.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979832
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!stack.isEmpty &&\
    \ x == \"(\") stack.pop() else if (!stack.isEmpty && x == \")\") stack.pop() else\
    \ if (!stack.isEmpty && x == \")\") stack += x else stack += x)\n        if (stack.size\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpscqv0uhw.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpscqv0uhw.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!stack.isEmpty &&\
    \ x == \"(\") stack.pop() else if (!stack.isEmpty && x == \")\") stack.pop() else\
    \ if (!stack.isEmpty && x == \")\") stack += x else if (!stack.isEmpty && x ==\
    \ \"(\") stack += x else stack += x))\n        val stackSize = stack.size\n  \
    \      if (stackSize == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2pcr6veb.scala:16:260 --------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack.pop() \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\")\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!stack.isEmpty\
    \ && x == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m stack += x))\n\e[31m\e\
    [31m   |\e[0m                                                                \
    \                                                                            \
    \                                                                            \
    \                                            ^\e[0m\n\e[31m   |\e[0m         \
    \                                    '}' expected, but ')' found\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmp2pcr6veb.scala:35:0 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m}\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0meof expected,\
    \ but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2pcr6veb.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2pcr6veb.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2pcr6veb.scala:17:24\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstackSize\e[0m = stack.size\n\e[31m\e[31m   |\e[0m                       \
    \ ^^^^^\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1659979833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    if(stack.isEmpty) {\n                        result\
    \ += \"No\"\n                    } else {\n                        result += \"\
    Yes\"\n                    }\n                }\n                case \")(\" \
    \ => open += x\n                case \")(\"  => close += x\n                case\
    \ \")\"  => stack += x\n                case _    => stack += x\n            }\n\
    \        })\n        if(open.isEmpty && close.isEmpty) {\n            result +=\
    \ \"No\"\n        } else {\n            result += \"Yes\"\n        }\n       \
    \ result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpalks5lxv.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpalks5lxv.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpalks5lxv.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpalks5lxv.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979833
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val s = stack.pop()\n            val l = s.lastIndexOf('(')\n        \
    \    val r = s.lastIndexOf(')')\n            if(l < r) {\n                result\
    \ += (s.substring(l+1, r))\n            } else {\n                result += (s.substring(l+1,\
    \ r+1))\n            }\n        }\n        if(result.size == lst.size) {\n   \
    \         val str = result.mkString\n            if(str.contains(\"()\") && str.contains(\"\
    ()\")) {\n                return \"Yes\"\n            } else {\n             \
    \   return \"No\"\n            }\n        } else {\n            return \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbjftn17s.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbjftn17s.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979834
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \"(\"\
    \ => open += x\n                case \")\" => close += x\n                case\
    \ _ => stack += x\n            }\n        })\n        while(!stack.isEmpty) {\n\
    \            val x = stack.pop()\n            x match {\n                case\
    \ \"(\" => open += x\n                case \")\" => close += x\n             \
    \   case _ => stack += x\n            }\n        }\n        val openCount = open.count\n\
    \        val closeCount = close.count\n        if(openCount == closeCount) {\n\
    \            val openStr = open.toList\n            val closeStr = close.toList\n\
    \            val openStrLen = openStr.count\n            val closeStrLen = closeStr.count\n\
    \            val openStrLenMinusCloseStrLen = openStrLen - closeStrLen\n     \
    \       if(openStrLenMinusCloseStrLen == 0) {\n                val openStrLenMinusCloseStrLenMinus1\
    \ = openStrLen - closeStrLen - 1\n                if(openStrLenMinusCloseStrLenMinus1\
    \ == 0) {\n                    val openStrLenMinusCloseStrLenMinus2 = openStrLen\
    \ - closeStrLen - 2\n                    if(openStrLenMinusCloseStrLenMinus2 ==\
    \ 0) {\n                        val openStrLenMinusCloseStrLenMinus3 = openStrLen\
    \ - closeStrLen - 3\n                        if(openStrLenMinusCloseStrLenMinus3\
    \ == 0) {\n                            val openStrLenMinusCloseStrLenMinus4 =\
    \ openStrLen - closeStrLen - 4\n                            if(openStrLenMinusCloseStrLenMinus4\
    \ == 0) {\n                                val openStrLenMinusCloseStrLenMinus5\
    \ = openStrLen - closeStrLen - 5\n                                if(openStrLenMinusCloseStrLenMinus5\
    \ == 0) {\n                                    val openStrLenMinusCloseStrLenMinus6\
    \ = openStrLen - closeStrLen - 6\n                                    if(openStrLenMinusCloseStrLenMinus6\
    \ == 0) {\n                                        val openStrLenMinusCloseStrLenMinus7\
    \ = openStrLen - closeStrLen - 7\n                                        if(openStrLenMinusCloseStrLenMinus7\
    \ == 0) {\n                                            val openStrLenMinusCloseStrLenMinus8\
    \ = openStrLen - closeStrLen \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqctw6ua9.scala:74:0 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqctw6ua9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqctw6ua9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqctw6ua9.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqctw6ua9.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpqctw6ua9.scala:35:8\
    \ ---------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mif\e[0m(openCount\
    \ == closeCount) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    Unit\n\e[31m   |\e[0m        Required: String\n\e[31m   |\e[0m \
    \       Maybe you are missing an else part for the conditional?\n\e[31m36 |\e\
    [0m        "
  stdout: ''
  timestamp: 1659979835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ for(i <- 0 until stackSize) {\n            val str = lst(i)\n            val\
    \ open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\")\n    \
    \        val stackStr = str.substring(open + 1, close)\n            val stackStrList\
    \ = stackStr.split(\",\")\n            val stackStrListSize = stackStrList.size\n\
    \            val stackStrListSize = stackStrListSize - 1\n            val stackStrListSize\
    \ = stackStrListSize - 1\n            val stackStrListSize = stackStrListSize\
    \ - 1\n            val stackStrListSize = stackStrListSize - 1\n            val\
    \ stackStrListSize = stackStrListSize - 1\n            val stackStrListSize =\
    \ stackStrListSize - 1\n            val stackStrListSize = stackStrListSize -\
    \ 1\n            val stackStrListSize = stackStrListSize - 1\n            val\
    \ stackStrListSize = stackStrListSize - 1\n            val stackStrListSize =\
    \ stackStrListSize - 1\n            val stackStrListSize = stackStrListSize -\
    \ 1\n            val stackStrListSize = stackStrListSize - 1\n            val\
    \ stackStrListSize = stackStrListSize - 1\n            val stackStrListSize =\
    \ stackStrListSize - 1\n            val stackStrListSize = stackStrListSize -\
    \ 1\n            val stackStrListSize = stackStrListSize - 1\n            val\
    \ stackStrListSize = stackStrListSize - 1\n            val stackStrListSize =\
    \ stackStrListSize - 1\n            val stackStrListSize = stackStrListSize -\
    \ 1\n            val stackStrListSize = stackStrListSize - 1\n            val\
    \ stackStrListSize = stackStrListSize - 1\n            val stackStrListSize =\
    \ stackStrListSize - 1\n            val stackStrListSize = stackStrListSize -\
    \ 1\n            val stackStrListSize = stackStrListSize - 1\n            val\
    \ stackStrListSize = stackStrListSize - 1\n            val stackStrListSize =\
    \ stackStrListSize - 1\n            val stackStrListSize = stackStrListSize -\
    \ 1\n            val stackStrListSize = stackStrListSize - 1\n            val\
    \ stackStrListSize = stackStrListSize - 1\n            val stackStrListSize =\
    \ stackStrListSize - 1\n            val stackStrListSize = stackStrListSize -\
    \ 1\n            val stackStrListSize = stackStrListSize - 1\n            val\
    \ stackStrListSize = stackStrListSize - 1\n            val stackStrListSize =\
    \ stackStrList\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvq0gcx43.scala:76:0 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvq0gcx43.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvq0gcx43.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvq0gcx43.scala:25:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m            \e[33mval\e\
    [0m \e[36mstackStrListSize\e[0m = stackStrListSize - \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mstackStrListSize is already defined as \e[33mvalue\e[0m \e[35mstackStrListSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvq0gcx43.scala:26:16 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m            \e[33mval\e[0m \e[36mstackStrListSize\e[0m = stackStrListSize\
    \ - \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackStrListSize is already defined as \e[33mvalue\e[0m \e\
    [35mstackStrListSize\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpvq0gcx43.scala:27:16 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            \e[33mval\e[0m \e[36mstackS"
  stdout: ''
  timestamp: 1659979837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val curr = stack.pop()\n            if(curr == \"(\") {\n            \
    \    result += \"(\"\n                stack += \")\"\n            } else if(curr\
    \ == \")\") {\n                result += \")\"\n                stack += \")\"\
    \n            } else {\n                result += \"(\" + curr\n            }\n\
    \        }\n        if(result.nonEmpty) {\n            return \"Yes\"\n      \
    \  } else {\n            return \"No\"\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpkdtnithq.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpkdtnithq.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    close.push(x)\n                }\n               \
    \ case \")(\"  => {\n                    stack.push(x)\n                }\n  \
    \              case \")(\" => {\n                    val s = stack.pop()\n   \
    \                 val c = close.pop()\n                    val stack2 = stack.takeWhile(x\
    \ => x != s)\n                    val close2 = close.takeWhile(x => x != c)\n\
    \                    val stack3 = stack2.takeWhile(x => x != c)\n            \
    \        val close3 = close2.takeWhile(x => x != s)\n                    val stack4\
    \ = stack3.takeWhile(x => x != s)\n                    val close4 = close3.takeWhile(x\
    \ => x != c)\n                    val stack5 = stack4.takeWhile(x => x != c)\n\
    \                    val close5 = close4.takeWhile(x => x != s)\n            \
    \        val stack6 = stack5.takeWhile(x => x != c)\n                    val close6\
    \ = close5.takeWhile(x => x != s)\n                    val stack7 = stack6.takeWhile(x\
    \ => x != c)\n                    val close7 = close6.takeWhile(x => x != s)\n\
    \                    val stack8 = stack7.takeWhile(x => x != c)\n            \
    \        val close8 = close7.takeWhile(x => x != s)\n                    val stack9\
    \ = stack8.takeWhile(x => x != c)\n                    val close9 = close8.takeWhile(x\
    \ => x != s)\n                    val stack10 = stack9.takeWhile(x => x != c)\n\
    \                    val close10 = close9.takeWhile(x => x != s)\n           \
    \         val stack11 = stack10.takeWhile(x => x != c)\n                    val\
    \ close11 = close10.takeWhile(x => x != s)\n                    val stack12 =\
    \ stack11.takeWhile(x => x != c)\n                    val close12 = close11.takeWhile(x\
    \ => x != s)\n                    val stack13 = stack12.takeWhile(x => x != c)\n\
    \                    val close13 = close12.takeWhile(x => x != s)\n          \
    \          val stack14 = stack13.takeWhile(x => x != c)\n                    val\
    \ close14 = close13.takeWhile(x => x != s)\n                    val stack15 =\
    \ stack14.takeWhile(x => x != c)\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp61ahd4g0.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp61ahd4g0.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp61ahd4g0.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp61ahd4g0.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp61ahd4g0.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp61ahd4g0.scala:18:19\
    \ --------------------\e[0m\e[0m\n\e[31m18 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0m        Found: \
    \   Unit\n\e[31m   |\e[0m        Required: String\n\e[31m19 |\e[0m           \
    \ x \e[33mmatch\e[0m {\n\e[31m20 |\e[0m                \e[33mcase\e[0m \e[31m\"\
    )\"\e[0m => {\n\e[31m21 |\e[0m     "
  stdout: ''
  timestamp: 1659979839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val x = stack.pop()\n            val y = stack.pop()\n            val\
    \ z = x + y\n            if(z.length <= 1) {\n                result += \"(\"\
    \ + z + \")\"\n            } else {\n                result += \"(\" + z + \"\
    )\"\n                stack += z\n            }\n        }\n        if(result.nonEmpty)\
    \ {\n            return \"Yes\"\n        } else {\n            return \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwa2oegmc.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwa2oegmc.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result += \"No\"\n\
    \                return result.toString\n            }\n            val openCount\
    \ = stack.length\n            val closeCount = stack.length\n            val openParen\
    \ = open\n            val closeParen = close\n            while(openCount > closeCount)\
    \ {\n                stack += str\n                openCount -= 1\n          \
    \      closeCount += 1\n            }\n            while(openCount < closeCount)\
    \ {\n                stack += str\n                openCount += 1\n          \
    \      closeCount -= 1\n            }\n            while(openParen < closeParen)\
    \ {\n                stack += str\n                openParen += 1\n          \
    \      closeParen -= 1\n            }\n            while(openParen > closeParen)\
    \ {\n                stack += str\n                openParen -= 1\n          \
    \      closeParen += 1\n            }\n            result += \"Yes\"\n       \
    \ }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnxvpv1be.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnxvpv1be.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpnxvpv1be.scala:40:26 ------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                openParen += \e[31m1\e[0m\n\e[31m\e[31m\
    \   |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value\
    \ += is not a member of Int - did you mean openParen.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpnxvpv1be.scala:41:27 ------------------------\e[0m\e\
    [0m\n\e[31m41 |\e[0m                closeParen -= \e[31m1\e[0m\n\e[31m\e[31m \
    \  |\e[0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value -=\
    \ is not a member of Int - did you mean closeParen.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpnxvpv1be.scala:45:26 ------------------------\e[0m\e\
    [0m\n\e[31m45 |\e[0m                openParen -= \e[31m1\e[0m\n\e[31m\e[31m  \
    \ |\e[0m                ^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -=\
    \ is not a member of Int - did you mean openParen.!=?\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmpnxvpv1be.scala:46:27 ------------------------\e[0m\e[0m\n\
    \e[31m46 |\e[0m                closeParen += \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m           value += is not\
    \ a member of Int - did you mean closeParen.!=?\n6 errors found\n"
  stdout: ''
  timestamp: 1659979839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else stack.pop() match {\n\
    \            case \"\" => result += \"No\"\n            case \")\" => result +=\
    \ \"Yes\"\n            case x => result += \"No\"\n        })\n        result.mkString(\"\
    ,\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_6d8jmtm.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_6d8jmtm.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979835
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            if (x == \"(\") stack.push(x)\n     \
    \       if (x == \")\") stack.pop() match {\n                case Some(x) => result\
    \ += \"(\" + x + \")\"\n                case None => result += \"(\" + x + \"\
    )\"\n            }\n        })\n        if (stack.size == 0) \"No\" else \"Yes\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppwcpkzry.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppwcpkzry.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(s => if (s.contains(\"(\")) stack.push(s) else if (!s.contains(\"\
    (\")) stack.pop() else ())\n        if (stack.size == 0) \"No\" else \"Yes\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpc8ox1yzf.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpc8ox1yzf.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979837
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stackMax = stackSize - 1\n        val resultMax = resultSize - 1\n     \
    \   val stackIndex = 0\n        val resultIndex = 0\n        val stackMaxIndex\
    \ = stackSize - 1\n        val resultMaxIndex = resultSize - 1\n        val stackMaxIndex2\
    \ = stackSize - 2\n        val resultMaxIndex2 = resultSize - 2\n        val stackMaxIndex3\
    \ = stackSize - 3\n        val resultMaxIndex3 = resultSize - 3\n        val stackMaxIndex4\
    \ = stackSize - 4\n        val resultMaxIndex4 = resultSize - 4\n        val stackMaxIndex5\
    \ = stackSize - 5\n        val resultMaxIndex5 = resultSize - 5\n        val stackMaxIndex6\
    \ = stackSize - 6\n        val resultMaxIndex6 = resultSize - 6\n        val stackMaxIndex7\
    \ = stackSize - 7\n        val resultMaxIndex7 = resultSize - 7\n        val stackMaxIndex8\
    \ = stackSize - 8\n        val resultMaxIndex8 = resultSize - 8\n        val stackMaxIndex9\
    \ = stackSize - 9\n        val resultMaxIndex9 = resultSize - 9\n        val stackMaxIndex10\
    \ = stackSize - 10\n        val resultMaxIndex10 = resultSize - 10\n        val\
    \ stackMaxIndex11 = stackSize - 11\n        val resultMaxIndex11 = resultSize\
    \ - 11\n        val stackMaxIndex12 = stackSize - 12\n        val resultMaxIndex12\
    \ = resultSize - 12\n        val stackMaxIndex13 = stackSize - 13\n        val\
    \ resultMaxIndex13 = resultSize - 13\n        val stackMaxIndex14 = stackSize\
    \ - 14\n        val resultMaxIndex14 = resultSize - 14\n        val stackMaxIndex15\
    \ = stackSize - 15\n        val resultMaxIndex15 = resultSize - 15\n        val\
    \ stackMaxIndex16 = stackSize - 16\n        val resultMaxIndex16 = resultSize\
    \ - 16\n        val stackMaxIndex17 = stackSize - 17\n        val resultMaxIndex17\
    \ = resultSize - 17\n        val stackMaxIndex18 = stackSize - 18\n        val\
    \ resultMaxIndex18 = resultSize - 18\n        val stackMaxIndex19 = stackSize\
    \ - 19\n        val resultMaxIndex19 = resultSize - 19\n        val stackMaxIndex20\
    \ = stackSize - 20\n        val \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpulalhqf5.scala:61:11 ---------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpulalhqf5.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpulalhqf5.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpulalhqf5.scala:62:5 ---------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: String\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1659979841
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val newStr = str.substring(0, open)\n            val newStr2 =\
    \ str.substring(open + 1, close)\n            val newStr3 = str.substring(close\
    \ + 1)\n            val newStr4 = str.substring(open + 1, close + 1)\n       \
    \     val newStr5 = str.substring(close + 2)\n            val newStr6 = str.substring(open\
    \ + 2, close + 2)\n            val newStr7 = str.substring(close + 3)\n      \
    \      val newStr8 = str.substring(open + 3, close + 3)\n            val newStr9\
    \ = str.substring(close + 4)\n            val newStr10 = str.substring(open +\
    \ 4, close + 4)\n            val newStr11 = str.substring(close + 5)\n       \
    \     val newStr12 = str.substring(open + 5, close + 5)\n            val newStr13\
    \ = str.substring(close + 6)\n            val newStr14 = str.substring(open +\
    \ 6, close + 6)\n            val newStr15 = str.substring(close + 7)\n       \
    \     val newStr16 = str.substring(open + 7, close + 7)\n            val newStr17\
    \ = str.substring(close + 8)\n            val newStr18 = str.substring(open +\
    \ 8, close + 8)\n            val newStr19 = str.substring(close + 9)\n       \
    \     val newStr20 = str.substring(open + 9, close + 9)\n            val newStr21\
    \ = str.substring(close + 10)\n            val newStr22 = str.substring(open +\
    \ 10, close + 10)\n            val newStr23 = str.substring(close + 11)\n    \
    \        val newStr24 = str.substring(open + 11, close + 11)\n            val\
    \ newStr25 = str.substring(close + 12)\n            val newStr26 = str.substring(open\
    \ + 12, close + 12)\n            val newStr27 = str.substring(close + 13)\n  \
    \          val newStr28 = str.substring(open + 13, close + 13)\n            val\
    \ newStr29 = str.substring(close + 14)\n            val newStr30 = str.substring(open\
    \ + 14, close + 14)\n            val newStr31 = str.substring(close + 15)\n  \
    \          val newStr32 = str.substring(open + 15, close + 15)\n            val\
    \ newStr33 = str.substring(close + 16)\n            val newStr34 = str.substring(open\
    \ + 16, close + 16)\n            val newStr35 = str.substring(close + 17)\n  \
    \          \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpaaqthnlz.scala:73:0 ----------------------------\e\
    [0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaaqthnlz.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaaqthnlz.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpaaqthnlz.scala:72:1\
    \ ---------------------\e[0m\e[0m\n\e[31m72 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e\
    [0m\n\e[31m   |\e[0m Found:    Unit\n\e[31m   |\e[0m Required: String\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[33m\e[33m-- Warning: /tmp/tmpaaqthnlz.scala:57:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m57 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n\
    \            } else if (x == \")\") {\n                if (stack.isEmpty) {\n\
    \                    result.append(\"No\")\n                } else {\n       \
    \             val top = stack.pop()\n                    if (top == \"(\") {\n\
    \                        result.append(\"Yes\")\n                    } else {\n\
    \                        result.append(\"No\")\n                    }\n      \
    \          }\n            }\n        })\n        if (result.size == 0) {\n   \
    \         result.append(\"No\")\n        } else {\n            result.toString()\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp03xt2u04.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp03xt2u04.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979838
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(\")\") =>\n                 \
    \               result ++= stack.toList\n                                stack.clear()\n\
    \                                close.synchronized {\n                      \
    \              open.remove(stack.toList)\n                                }\n\
    \                            case _ =>\n                        }\n          \
    \          }\n                case \")(\"  =>\n                    stack.synchronized\
    \ {\n                        open += x\n                    }\n              \
    \  case \")(\"  =>\n                    stack.synchronized {\n               \
    \         open += x\n                    }\n                case \")(\" =>\n \
    \                   stack.synchronized {\n                        open += x\n\
    \                    }\n                case \")(\" =>\n                    stack.synchronized\
    \ {\n                        open += x\n                    }\n              \
    \  case \")\" =>\n                    stack.synchronized {\n                 \
    \       open += x\n                    }\n                case \")\" =>\n    \
    \                stack.synchronized {\n                        open += x\n   \
    \                 }\n                case \")\" =>\n                    stack.synchronized\
    \ {\n                        open += x\n                    }\n              \
    \  case \")\" =>\n                    stack.synchronized {\n                 \
    \       open += x\n                    }\n                case \")\" =>\n    \
    \                stack.synchronized {\n                        open += x\n   \
    \                 }\n                case \")\" =>\n                    stack.synchronized\
    \ {\n                        open += x\n                    }\n              \
    \  case \")\" =>\n                    stack.synchronized {\n                 \
    \       open += x\n                    }\n                case \")\" =>\n    \
    \                stack.synchronized {\n                        open += x\n   \
    \                 }\n                case \")\" =>\n                    stack.synchronized\
    \ {\n                        open += x\n                    }\n              \
    \  case \")\" =>\n                    stack.synchronized {\n                 \
    \       open += x\n                    }\n                case \")\" =>\n    \
    \                stack.synchronized {\n                        open += x\n   \
    \                 }\n                case \")\" =>\n                    stack.synchronized\
    \ {\n                        open += x\n                    }\n              \
    \  case \")\" =>\n                    stack.synchronized {\n                 \
    \       open += x\n                    }\n                case \")\" =>\n    \
    \                stack.synchronized {\n                        open += x\n   \
    \                 }\n                case \")\" =>\n                    stack.synchronized\
    \ {\n                        open += x\n                    }\n              \
    \  case \")\" =>\n                    stack.synchronized {\n                 \
    \       open += x\n                    }\n                case \")\" =>\n    \
    \                stack.synchronized {\n                        open += x\n   \
    \                 }\n                case \")\" =>\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx_m9sd7v.scala:135:0 ---------------------------\e\
    [0m\e[0m\n\e[31m135 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx_m9sd7v.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx_m9sd7v.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx_m9sd7v.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx_m9sd7v.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx_m9sd7v.scala:18:19\
    \ --------------------\e[0m\e[0m\n\e[31m 18 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 19 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 20 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m =>\n\e[31m 2"
  stdout: ''
  timestamp: 1659979843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val open = s.indexOf(\"(\")\n       \
    \     val close = s.indexOf(\")\")\n            if (open < 0 || close < 0 || open\
    \ > close) {\n                result.append(\"No\")\n            } else {\n  \
    \              val openCount = stack.length\n                val closeCount =\
    \ stack.length\n                val openParens = open + 1\n                val\
    \ closeParens = close + 1\n                stack.push(s)\n                while\
    \ (openCount > 0 && closeCount > 0) {\n                    val openParensCount\
    \ = stack.length\n                    val closeParensCount = stack.length\n  \
    \                  if (openParensCount < closeParensCount) {\n               \
    \         val openParensString = stack.pop()\n                        val closeParensString\
    \ = stack.pop()\n                        if (openParensString == closeParensString)\
    \ {\n                            result.append(\"Yes\")\n                    \
    \        result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            result.append(\"\
    Yes\")\n                            result.append(\"Yes\")\n                 \
    \           result.append(\"Yes\")\n                            \n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpm2mij60i.scala:108:0 ---------------------------\e\
    [0m\e[0m\n\e[31m108 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm2mij60i.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpm2mij60i.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpm2mij60i.scala:16:20\
    \ --------------------\e[0m\e[0m\n\e[31m 16 |\e[0m        lst.foreach { \e[36ms\e\
    [0m =>\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found: \
    \   Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 17 |\e[0m         \
    \   \e[33mval\e[0m \e[36mopen\e[0m = s.indexOf(\e[31m\"(\"\e[0m)\n\e[31m 18 |\e\
    [0m            \e[33mval\e[0m \e[36mclose\e[0m = s.indexOf(\e[31m\")\"\e[0m)\n\
    \e[31m 19 |\e[0m            \e[33mif\e[0m (open < \e[31m0\e[0m || close < \e[31m0\e\
    [0m || open > close) {\n\e[31m 20 |\e[0m                result.append(\e[31m\"\
    No\"\e[0m)\n\e[31m 21 |\e[0m            } \e[33melse\e[0m {\n\e[31m 22 |\e[0m\
    \                \e[33mval\e[0m \e[36mopenCount\e[0m = stack.length\n\e[31m 23\
    \ |\e[0m                \e[33mval\e[0m \e[36mcloseCount\e[0m = stack.length\n\e\
    [31m 24 |\e[0m                \e[33mval\e[0m \e[36mopenParens\e[0m = open + \e\
    [31m1\e[0m\n\e[31m 25 |\e[0m                \e[33mval\e[0m \e[36mcloseParens\e\
    [0m = close + \e[31m1\e[0m\n\e[31m 26 |\e[0m                stack.push(s)\n\e\
    [31m 27 |\e[0m                \e[33mwhile\e[0m (openCount > \e[31m0\e[0m && closeCount\
    \ > \e[31m0\e[0m) {\n\e[31m 28 |\e[0m           "
  stdout: ''
  timestamp: 1659979843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    close.synchronized {\n                        stack.pop()\
    \ match {\n                            case Some(\"(\") => open.remove(stack.pop())\n\
    \                            case _ => ()\n                        }\n       \
    \             }\n                case \")(\"  =>\n                    stack.synchronized\
    \ {\n                        open.append(x)\n                    }\n         \
    \       case \")(\"  =>\n                    stack.synchronized {\n          \
    \              open.append(x)\n                    }\n                case \"\
    )(\"  =>\n                    stack.synchronized {\n                        open.append(x)\n\
    \                    }\n                case \")(\"  =>\n                    stack.synchronized\
    \ {\n                        open.append(x)\n                    }\n         \
    \       case \")(\"  =>\n                    stack.synchronized {\n          \
    \              open.append(x)\n                    }\n                case \"\
    )(\"  =>\n                    stack.synchronized {\n                        open.append(x)\n\
    \                    }\n                case \")(\"  =>\n                    stack.synchronized\
    \ {\n                        open.append(x)\n                    }\n         \
    \       case \")(\"  =>\n                    stack.synchronized {\n          \
    \              open.append(x)\n                    }\n                case \"\
    )(\"  =>\n                    stack.synchronized {\n                        open.append(x)\n\
    \                    }\n                case \")(\"  =>\n                    stack.synchronized\
    \ {\n                        open.append(x)\n                    }\n         \
    \       case \")(\"  =>\n                    stack.synchronized {\n          \
    \              open.append(x)\n                    }\n                case \"\
    )(\"  =>\n                    stack.synchronized {\n                        open.append(x)\n\
    \                    }\n                case \")(\"  =>\n                    stack.synchronized\
    \ {\n                        open.append(x)\n                    }\n         \
    \       case \")(\"  =>\n                    stack.synchronized {\n          \
    \              open.append(x)\n                    }\n                case \"\
    )(\"  =>\n                    stack.synchronized {\n                        open.append(x)\n\
    \                    }\n                case \")(\"  =>\n                    stack.synchronized\
    \ {\n                        open.append(x)\n                    }\n         \
    \       case \")(\"  =>\n                    stack.synchronized {\n          \
    \              open.append(x)\n                    }\n                case \"\
    )(\"  =>\n                    stack.synchronized {\n                        open.append(x)\n\
    \                    }\n                case \")(\"  =>\n                    stack.synchronized\
    \ {\n                        open.append(x)\n                    }\n         \
    \       case \")(\"  =>\n                    stack.synchronized {\n          \
    \              open.append(x)\n                    }\n                case \"\
    )(\"  =>\n                    stack.synchronized {\n                        open.append(x)\n\
    \                    }\n                case \")(\"  =>\n                    stack.synchronized\
    \ {\n\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb2qojxsn.scala:131:0 ---------------------------\e\
    [0m\e[0m\n\e[31m131 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb2qojxsn.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb2qojxsn.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb2qojxsn.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb2qojxsn.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb2qojxsn.scala:18:19\
    \ --------------------\e[0m\e[0m\n\e[31m 18 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 19 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 20 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m =>\n\e[31m 21 |\e"
  stdout: ''
  timestamp: 1659979844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => if (x == \"(\") stack.push(x) else stack.pop())\n  \
    \      if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1q7hdapu.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1q7hdapu.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979839
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \")()\" => close.push(x)\n            case x if x\
    \ == \")()()\" => close.push(x)\n            case x if x == \")()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()\" => close.push(x)\n            case x\
    \ if x == \")()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()\"\
    \ => close.push(x)\n            case x if x == \")()()()()()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()()()()()\" => close.push(x)\n         \
    \   case x if x == \")()()()()()()()()()\" => close.push(x)\n            case\
    \ x if x == \")()()()()()()()()()()\" => close.push(x)\n            case x if\
    \ x == \")()()()()()()()()()()()\" => close.push(x)\n            case x if x ==\
    \ \")()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \"\
    )()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \"\
    )()()()()()()()()()()()()()()\" => close.push(x)\n            case x if x == \"\
    )()()()()()()()()()()()()()()()\" => close.push(x)\n            case x if x ==\
    \ \")()()()()()()()()()()()()()()()\" => close.push(x)\n            case x if\
    \ x == \")()()()()()()()()()()()()()()()\" => close.push(x)\n            case\
    \ x if x == \")()()()()()()()()()()()()()()()()\" => close.push(x)\n         \
    \   case x if x == \")()()()()()()()()()()()()()()()()\" => close.push(x)\n  \
    \          case x if x == \")()()()()()()()()()()()()()()()()()\" => close.push(x)\n\
    \            case x if \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdo8i7qmf.scala:40:21 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m            \e[33mcase\e[0m x \e[33mif\e[0m \n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E040] Syntax Error: /tmp/tmpdo8i7qmf.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpdo8i7qmf.scala:58:0 ----------------------------\e[0m\e[0m\n\e[31m58\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdo8i7qmf.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdo8i7qmf.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdo8i7qmf.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdo8i7qmf.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e"
  stdout: ''
  timestamp: 1659979840
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop\n                }\n                case\
    \ \")()\" => {\n                    stack.pop\n                    stack.pop\n\
    \                }\n                case \")()()\" => {\n                    stack.pop\n\
    \                    stack.pop\n                    stack.pop\n              \
    \  }\n                case \")(\" => {\n                    stack += x\n     \
    \           }\n                case \")()()\" => {\n                    stack\
    \ += x\n                    stack += x\n                }\n                case\
    \ \")(\" => {\n                    stack += x\n                }\n           \
    \     case \")()\" => {\n                    stack += x\n                    stack\
    \ += x\n                }\n                case \")(\" => {\n                \
    \    stack += x\n                }\n                case _ => {\n            \
    \        stack += x\n                }\n            }\n        })\n        if\
    \ (stack.size == 0) {\n            result.append(\"Yes\")\n        } else {\n\
    \            result.append(\"No\")\n        }\n        result.toString()\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp084idfvr.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp084idfvr.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979840
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop()\n                }\n                case\
    \ \")(\"  => {\n                    stack.push(x)\n                }\n       \
    \         case \")()\" => {\n                    stack.push(x)\n             \
    \   }\n                case \")(\" => {\n                    stack.push(x)\n \
    \               }\n                case _ => {\n                    stack.push(x)\n\
    \                }\n            }\n        })\n        if (stack.size == 0) {\n\
    \            result.append(\"Yes\")\n        } else {\n            result.append(\"\
    No\")\n        }\n        result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgkt7g21i.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgkt7g21i.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") {\n                stack.push(x)\n\
    \            } else if (x == \")\") {\n                while (!stack.isEmpty)\
    \ {\n                    val top = stack.pop()\n                    if (top ==\
    \ \"(\") {\n                        stack.push(top)\n                    } else\
    \ if (top == \")\") {\n                        result.add(\"(\" + top + \")\"\
    )\n                        break\n                    }\n                }\n \
    \           }\n        })\n        if (result.size == lst.size) {\n          \
    \  return \"Yes\"\n        } else {\n            return \"No\"\n        }\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr3oqn0z_.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpr3oqn0z_.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpr3oqn0z_.scala:26:24 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979841
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop() match {\n                    case \")\" => result += \"(\"\n\
    \                    case \")()\" => result += \"()\"\n                    case\
    \ \")(\" => result += \"()\"\n                    case \")()()\" => result +=\
    \ \"()()\"\n                    case \")(())\" => result += \"()()\"\n       \
    \             case \")(())()\" => result += \"()()()\"\n                    case\
    \ \")(())(\" => result += \"()()()\"\n                    case \")(())()()\" =>\
    \ result += \"()()()()\"\n                    case \")(())(())\" => result +=\
    \ \"()()()()\"\n                    case \")(())(())()\" => result += \"()()()()()\"\
    \n                    case \")(())(())(\" => result += \"()()()()()\"\n      \
    \              case \")(())(())()()\" => result += \"()()()()()()\"\n        \
    \            case \")(())(())(())\" => result += \"()()()()()()\"\n          \
    \          case \")(())(())(())()\" => result += \"()()()()()()()\"\n        \
    \            case \")(())(())(())(\" => result += \"()()()()()()()\"\n       \
    \             case \")(())(())(())()()\" => result += \"()()()()()()()()\"\n \
    \                   case \")(())(())(())(())\" => result += \"()()()()()()()()()\"\
    \n                    case \")(())(())(())(())()\" => result += \"()()()()()()()()()\"\
    \n                    case \")(())(())(())(())(\" => result += \"()()()()()()()()()\"\
    \n                    case \")(())(())(())(())()()\" => result += \"()()()()()()()()()()\"\
    \n                    case \")(())(())(())(())(())\" => result += \"()()()()()()()()()()\"\
    \n                    case \")(())(())(())(())(())()\" => result += \"()()()()()()()()()()()\"\
    \n                    case \")(())(())(())(())(())(\" => result += \"()()()()()()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmprciyebw1.scala:43:63 -----------------------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                    \e[33mcase\e[0m \e[31m\")(())(())(())(())(())(\"\
    \e[0m => result += \"()()()()()()\n\e[31m\e[31m   |\e[0m                     \
    \                                          ^\e[0m\n\e[31m   |\e[0m           \
    \                                      unclosed string literal\n\e[31m\e[31m--\
    \ Error: /tmp/tmprciyebw1.scala:45:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmprciyebw1.scala:61:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m61 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmprciyebw1.scala:14:20 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmprciyebw1.scala:15:21 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmprciyebw1.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found"
  stdout: ''
  timestamp: 1659979842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop() match {\n                    case \")\" => result += \"()\"\n\
    \                    case \")()\" => result += \"()()\"\n                    case\
    \ \")(\" => result += \"()(\"\n                    case \")()()\" => result +=\
    \ \"()()()\"\n                    case \")(()\" => result += \"()()(\"\n     \
    \               case \")(())\" => result += \"()()(())\"\n                   \
    \ case \")(())()\" => result += \"()()(())()\"\n                    case \")(())(\"\
    \ => result += \"()()(())(\"\n                    case \")(())()()\" => result\
    \ += \"()()(())()()\"\n                    case \")(())(())\" => result += \"\
    ()()(())(())\"\n                    case \")(())(())()\" => result += \"()()(())(())()\"\
    \n                    case \")(())(())(\" => result += \"()()(())(())(\"\n   \
    \                 case \")(())(())()()\" => result += \"()()(())(())()()\"\n \
    \                   case \")(())(())(())\" => result += \"()()(())(())(())\"\n\
    \                    case \")(())(())(())()\" => result += \"()()(())(())(())()\"\
    \n                    case \")(())(())(())(\" => result += \"()()(())(())(())(\"\
    \n                    case \")(())(())(())()()\" => result += \"()()(())(())(())()()\"\
    \n                    case \")(())(())(())(())\" => result += \"()()(())(())(())(())\"\
    \n                    case \")(())(())(())(())()\" => result += \"()()(())(())(())(())()\"\
    \n                    case \")(())(())(())(())(\" => result += \"()()(())(())(())(())(\"\
    \n                    case \")(())(())(())(())()()\" => result += \"()()(())(())(())(())()()\"\
    \n                    case \")(())(())(())(())(())\" => result += \"()()(())(())(())(())(())\"\
    \n                    case \")(())(())(())(())(())()\" => result += \"()()(())(())(())(())(())()\"\
    \n                    case \")(())(())(())(())(())(\" => result += \"()()(\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzft9w9t_.scala:42:63 -----------------------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m                    \e[33mcase\e[0m \e[31m\")(())(())(())(())(())(\"\
    \e[0m => result += \"()()(\n\e[31m\e[31m   |\e[0m                            \
    \                                   ^\e[0m\n\e[31m   |\e[0m                  \
    \                               unclosed string literal\n\e[31m\e[31m-- Error:\
    \ /tmp/tmpzft9w9t_.scala:44:34 -----------------------------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e\
    [0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                           \
    \       ^\e[0m\n\e[31m   |\e[0m                                 end of statement\
    \ expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpzft9w9t_.scala:60:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpzft9w9t_.scala:14:20 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpzft9w9t_.scala:15:21 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpzft9w9t_.scala:44:4 -------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    Not found: ()()(def\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1659979841
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \"(\" => open.push(x)\n            case _ => stack.push(x)\n\
    \        })\n        val openCount = open.size\n        val closeCount = close.size\n\
    \        if (openCount == closeCount) {\n            val openStack = stack.take(openCount)\n\
    \            val closeStack = stack.drop(closeCount)\n            val openStackSize\
    \ = openStack.size\n            val closeStackSize = closeStack.size\n       \
    \     val openStack = openStack.mkString\n            val closeStack = closeStack.mkString\n\
    \            if (openStackSize == closeStackSize) {\n                val openStack\
    \ = openStack.split(\"\\\\)\")\n                val closeStack = closeStack.split(\"\
    \\\\(\")\n                val openStackSize = openStack.size\n               \
    \ val closeStackSize = closeStack.size\n                if (openStackSize == closeStackSize)\
    \ {\n                    val openStack = openStack.mkString\n                \
    \    val closeStack = closeStack.mkString\n                    if (openStack ==\
    \ closeStack) {\n                        result.append(\"Yes\")\n            \
    \        } else {\n                        result.append(\"No\")\n           \
    \         }\n                } else {\n                    result.append(\"No\"\
    )\n                }\n            } else {\n                result.append(\"No\"\
    )\n            }\n        } else {\n            result.append(\"No\")\n      \
    \  }\n        result.toString()\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2tpa3p7t.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2tpa3p7t.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp2tpa3p7t.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp2tpa3p7t.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2tpa3p7t.scala:30:16 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            \e[33mval\e[0m \e[36mopenStack\e[0m = openStack.mkString\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mopenStack is already defined as \e[33mvalue\e[0m \e[35mopenStack\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp2tpa3p7t.scala:31:16 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m"
  stdout: ''
  timestamp: 1659979842
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \"(\"\
    \ => stack.push(x)\n                case \")\" => stack.pop() match {\n      \
    \              case x if x == \")\" => result.add(x)\n                    case\
    \ x => result.add(x)\n                }\n            }\n        })\n        if\
    \ (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplggsx7vv.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmplggsx7vv.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openCount = stack.length\n      \
    \          val closeCount = stack.length\n                while(openCount > 0\
    \ && closeCount > 0) {\n                    val open = stack.pop()\n         \
    \           val close = stack.pop()\n                    if(open == close) {\n\
    \                        openCount -= 1\n                        closeCount -=\
    \ 1\n                    } else {\n                        result.append(\"No\"\
    )\n                        break\n                    }\n                }\n \
    \               stack += str\n                result.append(\"Yes\")\n       \
    \     }\n        }\n        result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwpo1vst_.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpwpo1vst_.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpwpo1vst_.scala:33:24 ------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m                        break\n\e[31m\e[31m   |\e[0m\
    \                        ^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: break\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val x = stack.pop()\n            val y = stack.pop()\n            val\
    \ z = x + y\n            result += z\n            stack.push(z)\n        }\n \
    \       val str = result.toList\n        if(str.size == lst.size)\n          \
    \  return \"Yes\"\n        else\n            return \"No\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpcbv0ygyv.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpcbv0ygyv.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979843
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val stackStr = stack.toList\n            if(open < 0 || close <\
    \ 0 || open > close || open == close || open == -1) {\n                stackStr.clear()\n\
    \                result.clear()\n                return \"No\"\n            }\n\
    \            else if(open == -1) {\n                stackStr.clear()\n       \
    \         result.clear()\n                return \"Yes\"\n            }\n    \
    \        else if(close == -1) {\n                stackStr.clear()\n          \
    \      result.clear()\n                return \"Yes\"\n            }\n       \
    \     else if(open > close) {\n                stackStr.clear()\n            \
    \    result.clear()\n                return \"No\"\n            }\n          \
    \  else if(open == close) {\n                stackStr.clear()\n              \
    \  result.clear()\n                return \"Yes\"\n            }\n           \
    \ else if(open < close) {\n                stackStr.clear()\n                result.clear()\n\
    \                stackStr += str\n                stackStr += str\n          \
    \      stackStr += str\n                stackStr += str\n                stackStr\
    \ += str\n                stackStr += str\n                stackStr += str\n \
    \               stackStr += str\n                stackStr += str\n           \
    \     stackStr += str\n                stackStr += str\n                stackStr\
    \ += str\n                stackStr += str\n                stackStr += str\n \
    \               stackStr += str\n                stackStr += str\n           \
    \     stackStr += str\n                stackStr += str\n                stackStr\
    \ += str\n                stackStr += str\n                stackStr += str\n \
    \               stackStr += str\n                stackStr += str\n           \
    \     stackStr += str\n                stackStr += str\n                stackStr\
    \ += str\n                stackStr += str\n                stackStr += str\n \
    \               stackStr += str\n                stackStr += str\n           \
    \     stackStr += str\n                stackStr += str\n                stackStr\
    \ += str\n                stackStr += str\n                stackStr += str\n \
    \               stackStr += str\n                stackStr += str\n           \
    \     stackStr += str\n                stackStr += str\n                stackStr\
    \ += str\n                stackStr += str\n                stackStr += str\n \
    \               stackStr += str\n                stackStr += str\n           \
    \     stackStr += str\n                stackStr += str\n                stackStr\
    \ += str\n                stackStr += str\n                stackStr += str\n \
    \               stackStr += \n    }\n    def main(args: Array[String]) = {\n \
    \   assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n \
    \   assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpdrhq1z9q.scala:98:27 ---------------------------\e\
    [0m\e[0m\n\e[31m98 |\e[0m                stackStr += \n\e[31m\e[31m   |\e[0m \
    \                          ^\e[0m\n\e[31m   |\e[0m                           expression\
    \ expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpdrhq1z9q.scala:116:0 ---------------------------\e[0m\e[0m\n\e[31m116\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdrhq1z9q.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdrhq1z9q.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[33m\e\
    [33m-- Warning: /tmp/tmpdrhq1z9q.scala:100:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m100 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979844
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val s = stack.pop()\n            val open = s.indexOf('(')\n         \
    \   val close = s.lastIndexOf(')')\n            if(open < 0 || close < 0 || open\
    \ > close || open > stack.size) {\n                result += \"No\"\n        \
    \    } else {\n                result += \"Yes\"\n            }\n        }\n \
    \       return result.toString()\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8qjn9hh4.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8qjn9hh4.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.ListBuffer(lst.head.length)\n        val close = mutable.ListBuffer(lst.last.length)\n\
    \        val openCount = mutable.ListBuffer.empty[Int]\n        val closeCount\
    \ = mutable.ListBuffer.empty[Int]\n        lst.foreach(x => {\n            x match\
    \ {\n                case x if x == \")\" => closeCount += x.length\n        \
    \        case x if x == \")\" => closeCount += x.length\n                case\
    \ x if x == \"(\" => openCount += x.length\n                case x if x == \"\
    (\" => openCount += x.length\n                case x => stack += x\n         \
    \   }\n        })\n        val openCount = openCount.toList\n        val closeCount\
    \ = closeCount.toList\n        val open = open.toList\n        val close = close.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        val openCount = openCount.toList\n        val closeCount = closeCount.toList\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzwfcmi_6.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount.toList\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzwfcmi_6.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount.toList\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcloseCount\
    \ is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzwfcmi_6.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopen\e[0m = open.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopen is already defined as \e[33mvalue\e[0m \e[35mopen\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzwfcmi_6.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = close.toList\n\e[31m\e[31m \
    \  |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mclose is already\
    \ defined as \e[33mvalue\e[0m \e[35mclose\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0mNote that overloaded methods must all be defined in the same group of toplevel\
    \ definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzwfcmi_6.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopenCount\e[0m = openCount.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods mus"
  stdout: ''
  timestamp: 1659979848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val left = str.substring(0, open)\n \
    \               val right = str.substring(close + 1)\n                val newStack\
    \ = mutable.Stack[String]()\n                val newResult = mutable.ListBuffer.empty[String]\n\
    \                for(j <- 0 until stack.size) {\n                    val cur =\
    \ stack.pop()\n                    if(cur == left) {\n                       \
    \ newStack.push(right)\n                    } else {\n                       \
    \ newStack.push(cur)\n                    }\n                }\n             \
    \   stack = newStack\n                result = newResult\n            }\n    \
    \    }\n        if(result.size == lst.size) {\n            val str = result.mkString(\"\
    (\", \", \", \")\")\n            if(str.contains(\"(\") && str.contains(\")\"\
    )) {\n                return \"Yes\"\n            } else {\n                return\
    \ \"No\"\n            }\n        } else {\n            return \"No\"\n       \
    \ }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfj61lyp4.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfj61lyp4.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpfj61lyp4.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[36mnewStack\e[0m =\
    \ mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfj61lyp4.scala:26:32\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e\
    [0m \e[36mnewResult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e\
    [31m   |\e[0m                                ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpfj61lyp4.scala:35:22 -----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m                stack = newStack\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val stack\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E052] Type Error: /tmp/tmpfj61lyp4.scala:36:23\
    \ -----------------------------\e[0m\e[0m\n\e[31m36 |\e[0m           "
  stdout: ''
  timestamp: 1659979845
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    if(str == \"(\") {\n                stack.push(str)\n            } else if(str\
    \ == \")\") {\n                val top = stack.pop()\n                if(top ==\
    \ \"(\") {\n                    result += \"(\"\n                } else {\n  \
    \                  result += \"(\"\n                    result += top\n      \
    \          }\n            } else {\n                result += \"(\"\n        \
    \        result += str\n                result += \"(\"\n                stack.push(str)\n\
    \            }\n        }\n        if(stack.size == 0) {\n            result +=\
    \ \"()\"\n        } else {\n            result += \"()\"\n        }\n        if(result.size\
    \ == lst.size) {\n            result += \"()\"\n        } else {\n           \
    \ result += \"()\"\n        }\n        if(result.size == lst.size) {\n       \
    \     result += \"()\"\n        } else {\n            result += \"()\"\n     \
    \   }\n        if(result.size == lst.size) {\n            result += \"()\"\n \
    \       } else {\n            result += \"()\"\n        }\n        if(result.size\
    \ == lst.size) {\n            result += \"()\"\n        } else {\n           \
    \ result += \"()\"\n        }\n        if(result.size == lst.size) {\n       \
    \     result += \"()\"\n        } else {\n            result += \"()\"\n     \
    \   }\n        if(result.size == lst.size) {\n            result += \"()\"\n \
    \       } else {\n            result += \"()\"\n        }\n        if(result.size\
    \ == lst.size) {\n            result += \"()\"\n        } else {\n           \
    \ result += \"()\"\n        }\n        if(result.size == lst.size) {\n       \
    \     result += \"()\"\n        } else {\n            result += \"()\"\n     \
    \   }\n        if(result.size == lst.size) {\n            result += \"()\"\n \
    \       } else {\n            result += \"()\"\n        }\n        if(result.size\
    \ == lst.size) {\n            result += \"()\"\n        } else {\n           \
    \ result += \"()\"\n        }\n        if(result.size == lst.size) {\n       \
    \     result += \"()\"\n        } else {\n            result += \"()\"\n     \
    \   }\n        if(result.size == lst.size) {\n            result += \"()\"\n \
    \       } else {\n            result += \"()\"\n        }\n        if(result.size\
    \ == lst.size) {\n            result += \"()\"\n        } else {\n           \
    \ result += \"()\"\n        }\n        if(result.size == lst.size) {\n       \
    \     result += \"()\"\n        } else {\n            result += \"()\"\n     \
    \   }\n        if(result.size == lst.size) {\n            result += \"()\"\n \
    \       } else {\n            result += \"()\"\n        }\n        if(result.size\
    \ == lst.size) {\n            result += \"()\"\n        } else {\n           \
    \ result += \"()\"\n        }\n        if(result.size == lst.size) {\n       \
    \     result \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjchzjuwq.scala:139:0 ---------------------------\e\
    [0m\e[0m\n\e[31m139 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjchzjuwq.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpjchzjuwq.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpjchzjuwq.scala:138:1\
    \ --------------------\e[0m\e[0m\n\e[31m138 |\e[0m}\n\e[31m\e[31m    |\e[0m ^\e\
    [0m\n\e[31m    |\e[0m Found:    Unit\n\e[31m    |\e[0m Required: String\n\e[31m\
    \    |\e[0m\n\e[31m    |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmpjchzjuwq.scala:123:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m123 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m    |\e[0m    ^\e[0m\n\
    \e[33m    |\e[0m    Line is indented too far to the left, or a `}` is missing\n\
    1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openCount = stack.length\n      \
    \          val closeCount = stack.length\n                val openParens = open\n\
    \                val closeParens = close\n                while(openCount > 0\
    \ && closeCount > 0) {\n                    if(openCount > closeCount) {\n   \
    \                     stack.pop\n                        closeCount -= 1\n   \
    \                 } else {\n                        stack.pop\n              \
    \          openCount -= 1\n                    }\n                }\n        \
    \        while(openCount > 0) {\n                    stack.append(str.substring(0,\
    \ openParens))\n                    openCount -= 1\n                }\n      \
    \          while(closeCount > 0) {\n                    stack.append(str.substring(closeParens\
    \ + 1))\n                    closeCount -= 1\n                }\n            \
    \    val newStr = stack.toList.reverse.mkString\n                result.append(\"\
    Yes\")\n            }\n        }\n        result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpe0463wyv.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpe0463wyv.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979846
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val cur = lst(i)\n        \
    \    val open = cur match {\n                case \"(\" => true\n            \
    \    case \")\" => false\n                case _ => throw new Exception(\"Invalid\
    \ parenthesis\")\n            }\n            if(!open) {\n                stack\
    \ += cur\n            } else {\n                val last = stack.pop()\n     \
    \           val next = last match {\n                    case \"(\" => \")\"\n\
    \                    case \")\" => \")\"\n                    case _ => throw\
    \ new Exception(\"Invalid parenthesis\")\n                }\n                result\
    \ += cur + next\n            }\n        }\n        if(result.size == lst.size)\
    \ {\n            return \"Yes\"\n        } else {\n            return \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoceq7jme.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpoceq7jme.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979847
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsnwpmztj.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsnwpmztj.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsnwpmztj.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsnwpmztj.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresultSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresultSize is already defined as \e[33mvalue\e[0m \e[35mresultSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsnwpmztj.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e[0m\n\
    \e[31"
  stdout: ''
  timestamp: 1659979850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n\
    \        val bad = mutable.Set[String]()\n        lst.foreach(x => if (x == \"\
    (\") stack += x else if (!x == \"(\") bad += x else stack.pop())\n        val\
    \ goodString = stack.toList\n        val badString = bad.toList\n        if (goodString.size\
    \ == 0 && badString.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9yy3ckgn.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9yy3ckgn.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp9yy3ckgn.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp9yy3ckgn.scala:17:59 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) bad += x \e[33melse\e[0m stack.pop())\n\e[31m\e[31m   |\e[0m       \
    \                                                    ^^\e[0m\n\e[31m   |\e[0m\
    \                                 value unary_! is not a member of String\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.Set[String]()\n\
    \        val bad = mutable.Set[String]()\n        lst.foreach(x => {\n       \
    \     x match {\n                case \")\" =>\n                    stack.pop()\n\
    \                case \")(\"  =>\n                    stack.pop()\n          \
    \      case \")()\" =>\n                    stack.pop()\n                case\
    \ \")()()\" =>\n                    stack.pop()\n                case \")()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()\" =>\n\
    \                    stack.pop()\n                case \")()()()()()\" =>\n  \
    \                  stack.pop()\n                case \")()()()()()()\" =>\n  \
    \                  stack.pop()\n                case \")()()()()()()()\" =>\n\
    \                    stack.pop()\n                case \")()()()()()()()()\" =>\n\
    \                    stack.pop()\n                case \")()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()()()()()()()()()()\"\
    \ =>\n                    stack.pop()\n                case \")()()()()()()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpj6rq1fvx.scala:69:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m69 |\e[0m                \e[33mcase\e[0m \")()()()()()()\n\e[31m\e\
    [31m   |\e[0m                     ^\e[0m\n\e[31m   |\e[0m                    \
    \ unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmpj6rq1fvx.scala:71:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m71 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpj6rq1fvx.scala:87:0 ----------------------------\e\
    [0m\e[0m\n\e[31m87 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m')' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj6rq1fvx.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj6rq1fvx.scala:15:19\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj6rq1fvx.scala:16:18\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m       \
    \           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpj6rq1fvx.scala:71:4\
    \ -------------------------\e[0m\e[0m\n\e[31m71 |\e[0m    \e[33mdef\e[0m \e[36mmain\e\
    [0m(\e[36margs\e[0m: \e[35mAr"
  stdout: ''
  timestamp: 1659979848
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val cur = stack.pop()\n            val next = stack.pop()\n          \
    \  if(cur == \"(\" && next == \")\") {\n                result += \"(\" + cur\
    \ + \")\"\n            } else if(cur == \")\" && next == \"(\") {\n          \
    \      result += \"(\" + cur + \")\"\n            } else if(cur == \"(\" && next\
    \ == \")\") {\n                result += \"(\" + cur + \")\"\n            } else\
    \ if(cur == \")\" && next == \"(\") {\n                result += \"(\" + cur +\
    \ \")\"\n            } else {\n                result += \"(\" + cur + \")\"\n\
    \            }\n        }\n        if(result.size == lst.length)\n           \
    \ \"Yes\"\n        else\n            \"No\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaspn3mfa.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpaspn3mfa.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val left = str.substring(0, open)\n \
    \               val right = str.substring(close + 1)\n                val left\
    \ = stack.toList.reverse.takeWhile(x => x != left).reverse\n                val\
    \ right = stack.toList.reverse.takeWhile(x => x != right).reverse\n          \
    \      val newLeft = left.mkString(\"\")\n                val newRight = right.mkString(\"\
    \")\n                if(newLeft.isEmpty) {\n                    result.append(\"\
    No\")\n                } else {\n                    if(newRight.isEmpty) {\n\
    \                        result.append(\"Yes\")\n                    } else {\n\
    \                        result.append(\"Yes\")\n                    }\n     \
    \           }\n            }\n            stack += str\n        }\n        result.toString()\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp_bpvpxp0.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp_bpvpxp0.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp_bpvpxp0.scala:25:20 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m                \e[33mval\e[0m \e[36mleft\e[0m = stack.toList.reverse.takeWhile(\e\
    [36mx\e[0m => x != left).reverse\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleft is already defined as \e[33mvalue\e[0m \e[35mleft\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp_bpvpxp0.scala:26:20 ---------------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m                \e[33mval\e[0m \e[36mright\e[0m = stack.toList.reverse.takeWhile(\e\
    [36mx\e[0m => x != right).reverse\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mright is already defined as \e[33mvalue\e[0m \e[35mright\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n4 errors found\n"
  stdout: ''
  timestamp: 1659979850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val cur = lst(i)\n        \
    \    val open = cur match {\n                case '('  => stack.push('(')\n  \
    \              case ')'  => stack.pop()\n                case _    => throw new\
    \ IllegalArgumentException(\"Invalid parenthesis \" + cur)\n            }\n  \
    \          if(open == -1) {\n                result ++= cur\n            } else\
    \ {\n                while(open != -1) {\n                    result ++= stack.pop()\n\
    \                    open -= 1\n                }\n                result ++=\
    \ cur\n            }\n        }\n        if(result.size == lst.size) {\n     \
    \       val str = result.toList\n            val len = str.size\n            for(i\
    \ <- 0 until len) {\n                if(!(str(i) == \"()\" && str(i + 1) == \"\
    ()\")) {\n                    return \"No\"\n                }\n            }\n\
    \            return \"Yes\"\n        }\n        return \"No\"\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp76u_d7ys.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp76u_d7ys.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ Error: /tmp/tmp76u_d7ys.scala:19:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m19 |\e[0m                \e[33mcase\e[0m \e[31m'('\e[0m  => stack.push(\e\
    [31m'('\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e\
    [0m        Values of types Char and String cannot be compared with == or !=\n\e\
    [31m\e[31m-- Error: /tmp/tmp76u_d7ys.scala:20:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m20 |\e[0m                \e[33mcase\e[0m \e[31m')'\e[0m  => stack.pop()\n\
    \e[31m\e[31m   |\e[0m                     ^^^\e[0m\n\e[31m   |\e[0m        Values\
    \ of types Char and String cannot be compared with == or !=\n4 errors found\n"
  stdout: ''
  timestamp: 1659979852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.ListBuffer[String]()\n\
    \        val bad = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n\
    \            x match {\n                case \")\" => stack.pop() match {\n  \
    \                  case \")\" => good += x\n                    case \")()\" =>\
    \ bad += x\n                    case _ => bad += x\n                }\n      \
    \          case \")()\" => stack += x\n                case _ => stack += x\n\
    \            }\n        })\n        if (stack.isEmpty) good.toString.toUpperCase\n\
    \        else bad.toString.toUpperCase\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpat76q2rs.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpat76q2rs.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpat76q2rs.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val open = s.indexOf(\"(\")\n       \
    \     val close = s.indexOf(\")\")\n            if (open < 0 || close < 0) {\n\
    \                result.append(\"No\")\n            } else {\n               \
    \ val stackSize = stack.size\n                if (open > close || (open < 0 &&\
    \ close < 0)) {\n                    result.append(\"No\")\n                }\
    \ else {\n                    if (stackSize > 0) {\n                        val\
    \ top = stack.toList(0)\n                        if (top.length == stackSize)\
    \ {\n                            if (top.head == close) {\n                  \
    \              result.append(\"Yes\")\n                            } else {\n\
    \                                result.append(\"No\")\n                     \
    \       }\n                        } else {\n                            result.append(\"\
    No\")\n                        }\n                    } else {\n             \
    \           result.append(\"No\")\n                    }\n                }\n\
    \            }\n            stack.push(s)\n        }\n        result.mkString(\"\
    ,\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppon2wc31.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmppon2wc31.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979849
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \"(\"\
    \ => open += x\n                case \")\" => close += x\n                case\
    \ _ => stack += x\n            }\n        })\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        if (openCount == closeCount) {\n\
    \            val openList = open.iterator\n            val closeList = close.iterator\n\
    \            while (openList.hasNext && closeList.hasNext) {\n               \
    \ val open = openList.next()\n                val close = closeList.next()\n \
    \               if (open == close) {\n                    result += \"(\" + open\
    \ + \")\"\n                    openList.remove()\n                    closeList.remove()\n\
    \                } else {\n                    result += \"(\" + open + \")\"\
    \ + close\n                    openList.remove()\n                    closeList.remove()\n\
    \                }\n            }\n            if (openList.nonEmpty) {\n    \
    \            result += \"(\" + openList.mkString(\",\") + \")\"\n            }\n\
    \            if (closeList.nonEmpty) {\n                result += \"(\" + closeList.mkString(\"\
    ,\") + \")\"\n            }\n            if (result.nonEmpty) {\n            \
    \    return \"Yes\"\n            } else {\n                return \"No\"\n   \
    \         }\n        } else {\n            return \"No\"\n        }\n    }\n \
    \   def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpciln469i.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpciln469i.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpciln469i.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpciln469i.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop()\n                }\n                case\
    \ \")(\"  => {\n                    stack += x\n                }\n          \
    \      case \")()\" => {\n                    stack += x\n                   \
    \ stack.pop()\n                }\n                case \")()()\" => {\n      \
    \              stack += x\n                    stack += x\n                  \
    \  stack.pop()\n                }\n                case \")()()()\" => {\n   \
    \                 stack += x\n                    stack += x\n               \
    \     stack += x\n                    stack.pop()\n                }\n       \
    \         case \")()()()()\" => {\n                    stack += x\n          \
    \          stack += x\n                    stack += x\n                    stack\
    \ += x\n                    stack.pop()\n                }\n                case\
    \ \")()()()()()\" => {\n                    stack += x\n                    stack\
    \ += x\n                    stack += x\n                    stack += x\n     \
    \               stack += x\n                    stack.pop()\n                }\n\
    \                case \")()()()()()()\" => {\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack += x\n                    stack += x\n                    stack\
    \ += x\n                    stack.pop()\n                }\n                case\
    \ \")()()()()()()()\" => {\n                    stack += x\n                 \
    \   stack += x\n                    stack += x\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack += x\n                    stack.pop()\n                }\n    \
    \            case \")()()()()()()()()\" => {\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack += x\n                    stack += x\n                    stack\
    \ += x\n                    stack += x\n                    stack += x\n     \
    \               stack.pop()\n                }\n                case \")()()()()()()()()()\"\
    \ => {\n                    stack += x\n                    stack += x\n     \
    \               stack += x\n                    stack += x\n                 \
    \   stack += x\n                    stack += x\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack.pop()\n                }\n                case \")()()()()()()()()()\"\
    \ => {\n                    stack += x\n                    stack += x\n     \
    \               stack += x\n                    stack += x\n                 \
    \   stack += x\n                    stack += x\n                    stack += x\n\
    \                    stack += x\n                    stack += x\n            \
    \        stack.pop()\n                }\n                case \")()()()()()()()()()()\"\
    \ => {\n                    stack += \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmp1me2xam3.scala:109:28 --------------------------\e\
    [0m\e[0m\n\e[31m109 |\e[0m                    stack += \n\e[31m\e[31m    |\e[0m\
    \                            ^\e[0m\n\e[31m    |\e[0m                        \
    \    expression expected but \e[31m'}'\e[0m found\n\e[31m    |\e[0m\n\e[31m  \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E040] Syntax Error: /tmp/tmp1me2xam3.scala:127:0 ---------------------------\e\
    [0m\e[0m\n\e[31m127 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1me2xam3.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1me2xam3.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[33m\e[33m-- Warning: /tmp/tmp1me2xam3.scala:111:4\
    \ ---------------------------------------\e[0m\e[0m\n\e[33m111 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[33m\e[33m    |\e[0m    ^\e[0m\n\e[33m    |\e[0m    Line is indented too far\
    \ to the left, or a `}` is missing\n1 warning found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979817
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    stack.pop\n                case \")(\"  => stack.append(x)\n\
    \                case _ =>\n                    stack.append(x)\n            }\n\
    \        })\n        stack.foreach(x => result.append(x))\n        result.mkString(\"\
    (\", \", \", \")\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiop6j56m.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpiop6j56m.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => {\n      \
    \      if (x == \"(\") {\n                stack += x\n            } else if (x\
    \ == \")\") {\n                while (!stack.isEmpty && stack.head != \"(\") {\n\
    \                    good += stack.head\n                    stack = stack.pop\n\
    \                }\n                stack = stack.pop\n                queue +=\
    \ x\n            } else if (x != \"(\") {\n                queue += x\n      \
    \      }\n        })\n        if (queue.size == 0) {\n            return \"No\"\
    \n        }\n        while (queue.size > 0) {\n            good += queue.dequeue\n\
    \        }\n        if (good.size == 0) {\n            return \"No\"\n       \
    \ }\n        if (good.size == 1) {\n            if (good.head == \"(\") {\n  \
    \              return \"Yes\"\n            } else {\n                return \"\
    No\"\n            }\n        }\n        val goodStr = good.mkString(\"(\", \"\
    )\")\n        val goodLen = goodStr.length\n        val stackLen = stack.length\n\
    \        val queueLen = queue.length\n        if (goodLen > stackLen + queueLen)\
    \ {\n            return \"No\"\n        }\n        if (goodLen < stackLen + queueLen)\
    \ {\n            return \"Yes\"\n        }\n        val goodLenStr = goodStr.length\n\
    \        val stackLenStr = stackLen.toString\n        val queueLenStr = queueLen.toString\n\
    \        if (goodLenStr < stackLenStr + queueLenStr) {\n            return \"\
    Yes\"\n        }\n        if (goodLenStr > stackLenStr + queueLenStr) {\n    \
    \        return \"No\"\n        }\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxenyxim8.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxenyxim8.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxenyxim8.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E052] Type Error: /tmp/tmpxenyxim8.scala:23:26 -----------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    stack = stack.pop\n\e[31m\e[31m \
    \  |\e[0m                    ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Reassignment to val stack\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E052]\
    \ Type Error: /tmp/tmpxenyxim8.scala:25:22 -----------------------------\e[0m\e\
    [0m\n\e[31m25 |\e[0m                stack = stack.pop\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                Reassignment\
    \ to val stack\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpxenyxim8.scala:63:8\
    \ ---------------------\e[0m\e[0m\n\e[31m63 |\e[0m        \e[33mif\e[0m (goodLenStr\
    \ > stackLenStr + queueLenStr) {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m\
    \   |\e[0m        Foun"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop()\n                }\n                case\
    \ \")(\"  => {\n                    stack += x\n                }\n          \
    \      case \")()\" => {\n                    stack += x\n                   \
    \ result += (x + \"(\")\n                }\n                case \")()()\" =>\
    \ {\n                    stack += x\n                    result += (x + \"(\"\
    )\n                }\n                case \")(\" => {\n                    stack\
    \ += x\n                }\n                case \")(()\" => {\n              \
    \      stack += x\n                    result += (x + \"(\")\n               \
    \ }\n                case \")(()()\" => {\n                    stack += x\n  \
    \                  result += (x + \"(\")\n                }\n                case\
    \ \")(\" => {\n                    stack += x\n                }\n           \
    \     case \")(()\" => {\n                    stack += x\n                   \
    \ result += (x + \"(\")\n                }\n                case \")(()()\" =>\
    \ {\n                    stack += x\n                    result += (x + \"(\"\
    )\n                }\n                case \")(\" => {\n                    stack\
    \ += x\n                }\n                case \")(()\" => {\n              \
    \      stack += x\n                    result += (x + \"(\")\n               \
    \ }\n                case \")(()()\" => {\n                    stack += x\n  \
    \                  result += (x + \"(\")\n                }\n                case\
    \ \")(\" => {\n                    stack += x\n                }\n           \
    \     case \")(()\" => {\n                    stack += x\n                   \
    \ result += (x + \"(\")\n                }\n                case \")(()()\" =>\
    \ {\n                    stack += x\n                    result += (x + \"(\"\
    )\n                }\n                case \")(\" => {\n                    stack\
    \ += x\n                }\n                case \")(()\" => {\n              \
    \      stack += x\n                    result += (x + \"(\")\n               \
    \ }\n                case \")(()()\" => {\n                    stack += x\n  \
    \                  result += (x + \"(\")\n                }\n                case\
    \ \")(\" => {\n                    stack += x\n                }\n           \
    \     case \")(()\" => {\n                    stack += x\n                   \
    \ result += (x + \"(\")\n                }\n                case \")(()()\" =>\
    \ {\n                    stack += x\n                    result += (x + \"(\"\
    )\n                }\n                case \")(\" => {\n                    stack\
    \ += x\n                }\n                case \")(()\" => {\n              \
    \      stack += x\n                    result += (x + \"(\")\n               \
    \ }\n                case \")(()()\" => {\n                    stack += x\n  \
    \                  result += (x + \"(\")\n                }\n                case\
    \ \")(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpzb0tqep6.scala:109:21 ----------------------------------------\e\
    [0m\e[0m\n\e[31m109 |\e[0m                \e[33mcase\e[0m \")(\n\e[31m\e[31m \
    \   |\e[0m                     ^\e[0m\n\e[31m    |\e[0m                     unclosed\
    \ string literal\n\e[31m\e[31m-- Error: /tmp/tmpzb0tqep6.scala:111:34 ----------------------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m           \
    \                       ^\e[0m\n\e[31m    |\e[0m                             \
    \  end of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpzb0tqep6.scala:127:0 ---------------------------\e[0m\e[0m\n\e[31m127\
    \ |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m')' expected, but eof\
    \ found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpzb0tqep6.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzb0tqep6.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpzb0tqep6.scala:111:4 ------------------------\e\
    [0m\e[0m\n\e[31m111 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m    |\e[0m    ^^^\e[0m\n\
    \e[31m    |\e[0m    Not found: )(def\n\e[31m    |\e[0m\n\e[31m    |\e[0m longer\
    \ explanation available when compiling with `-explain`\n6 errors found\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop()\n                case \")(\"  => stack.append(x)\n          \
    \      case _ => stack.append(x)\n            }\n        })\n        if (stack.size\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0d8dey3i.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0d8dey3i.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => {\n                    stack.pop() match {\n                        case\
    \ \")\" => result.append(\")\")\n                        case \")()\" => result.append(\"\
    )\")\n                        case \")(\" => result.append(\")\")\n          \
    \              case _ => result.append(\")\")\n                    }\n       \
    \         }\n                case \"(\" => {\n                    stack.push(x)\n\
    \                }\n                case _ => {\n                    stack.append(x)\n\
    \                }\n            }\n        })\n        if (stack.size == 0) \"\
    No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp9iucf073.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp9iucf073.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => x match {\n\
    \            case x if x.startsWith(\"(\") => stack += x\n            case x if\
    \ x.startsWith(\")\") => queue += x\n            case _ => good(x)\n        })\n\
    \        if (stack.size == 0 && queue.size == 0) \"No\"\n        else if (stack.size\
    \ == 0 && queue.size > 0) \"Yes\"\n        else if (stack.size > 0 && queue.size\
    \ == 0) \"No\"\n        else if (stack.size > 0 && queue.size > 0) \"Yes\"\n \
    \       else matchParens(stack.toList ++ queue.toList)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgsj333u7.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgsj333u7.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgsj333u7.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979851
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.equals(\"(\") =>\
    \ stack.push(x)\n            case x if x.equals(\")\") => stack.pop() match {\n\
    \                case x if x.equals(\"(\") => stack.push(x)\n                case\
    \ x if x.equals(\")\") => stack.pop()\n                case _ => result.add(x)\n\
    \            }\n            case _ => result.add(x)\n        })\n        if (stack.size\
    \ == 0) \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8jf3bq52.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp8jf3bq52.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openParen = str.substring(0, open)\n\
    \                val closeParen = str.substring(close+1)\n                val\
    \ newStr = openParen + closeParen\n                val newStack = mutable.Stack[String]()\n\
    \                val newResult = mutable.ListBuffer.empty[String]\n          \
    \      for(j <- 0 until openParen.length)\n                    newStack.push(openParen.charAt(j))\n\
    \                for(j <- 0 until closeParen.length)\n                    newStack.push(closeParen.charAt(j))\n\
    \                while(!newStack.isEmpty) {\n                    val c = newStack.pop()\n\
    \                    if(c != '(' && c != ')') {\n                        newResult.append(c)\n\
    \                    } else {\n                        if(newStack.isEmpty)\n\
    \                            result.append(\"Yes\")\n                        else\
    \ {\n                            val newOpen = str.substring(0, newStack.size)\n\
    \                            val newClose = str.substring(newStack.size)\n   \
    \                         val newStr = newOpen + newClose\n                  \
    \          val newStack = mutable.Stack[String]()\n                          \
    \  val newResult = mutable.ListBuffer.empty[String]\n                        \
    \    for(j <- 0 until newOpen.length)\n                                newStack.push(newOpen.charAt(j))\n\
    \                            for(j <- 0 until newClose.length)\n             \
    \                   newStack.push(newClose.charAt(j))\n                      \
    \      while(!newStack.isEmpty) {\n                                val c = newStack.pop()\n\
    \                                if(c != '(' && c != ')') {\n                \
    \                    newResult.append(c)\n                                } else\
    \ {\n                                    if(newStack.isEmpty)\n              \
    \                          result.append(\"Yes\")\n                          \
    \          else {\n                                        val newOpen = str.substring(0,\
    \ newStack.size)\n                                        val newClose = str.substring(newStack.size)\n\
    \                                        val newStr = newOpen + newClose\n   \
    \                                     val newStack = mutable.Stack[String]()\n\
    \                                        val newResult = mutable.ListBuffer.empty[String]\n\
    \                                        for(j <- 0 until newOpen.length)\n  \
    \                                          newStack.push(newOpen.charAt(j))\n\
    \                                        for(j <- 0 until newClose.length)\n \
    \                                           newStack.push(newClose.charAt(j))\n\
    \                                        while(!newStack.isEmpty) {\n\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp00w0444w.scala:85:0 ----------------------------\e\
    [0m\e[0m\n\e[31m85 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp00w0444w.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp00w0444w.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp00w0444w.scala:26:31\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m                \e[33mval\e\
    [0m \e[36mnewStack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                               ^^^^^^^\e[0m\n\e[31m   |\e[0m              \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp00w0444w.scala:27:32 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m                \e[33mval\e[0m \e[36mnewResult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp00w0444w.scala:43:43 ------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m                            \e[33mval\e[0m \e[36mnewStack\e\
    [0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m              \
    \                             ^^^^^^^\e[0m\n\e[31m   |"
  stdout: ''
  timestamp: 1659979853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            val newStack = mutable.Stack[String]()\n\
    \            val newResult = mutable.ListBuffer[String]()\n            val open\
    \ = s.indexOf(\"(\")\n            val close = s.indexOf(\")\")\n            val\
    \ openCount = if (open < 0) 0 else open + 1\n            val closeCount = if (close\
    \ < 0) 0 else close + 1\n            val openParen = if (openCount > closeCount)\
    \ 1 else 0\n            val closeParen = if (closeCount > openCount) 1 else 0\n\
    \            val newOpen = if (openParen == 0) open else open\n            val\
    \ newClose = if (closeParen == 0) close else close\n            val newStack =\
    \ if (openParen == 0) stack else stack.take(openParen)\n            val newResult\
    \ = if (closeParen == 0) result else result.take(closeParen)\n            newStack\
    \ += s\n            newResult += s\n            while (newStack.nonEmpty && newResult.nonEmpty)\
    \ {\n                val newOpen = newStack.last\n                val newClose\
    \ = newResult.last\n                val newOpenCount = if (newOpen < 0) 0 else\
    \ newOpen + 1\n                val newCloseCount = if (newClose < 0) 0 else newClose\
    \ + 1\n                val newOpenParen = if (newOpenCount > newCloseCount) 1\
    \ else 0\n                val newCloseParen = if (newCloseCount > newOpenCount)\
    \ 1 else 0\n                val newNewOpen = if (newOpenParen == 0) newOpen else\
    \ newOpen\n                val newNewClose = if (newCloseParen == 0) newClose\
    \ else newClose\n                newStack = newStack.dropRight(newOpenParen)\n\
    \                newResult = newResult.dropRight(newCloseParen)\n            \
    \    newStack += newNewOpen\n                newResult += newNewClose\n      \
    \      }\n            stack += newStack.mkString\n            result += newResult.mkString\n\
    \        }\n        if (stack.nonEmpty && result.nonEmpty) stack.toString + \"\
    (\" + result.toString + \")\"\n        else \"\"\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqv10upny.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqv10upny.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpqv10upny.scala:17:27 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mnewStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqv10upny.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mnewResult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpqv10upny.scala:40:25 -----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m                newStack = newStack.dropRight(newOpenParen)\n\
    \e[31m\e[31m   |\e[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                Reassignment to val newStack\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E052] Type Error: /tmp/tmpqv10upny.scala:41:26 -----------------------------\e\
    [0m\e[0m"
  stdout: ''
  timestamp: 1659979852
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        lst.foreach(x => {\n      \
    \      x match {\n                case \")\" => stack.pop() match {\n        \
    \            case \")\" => queue.remove(x)\n                    case \")()\" =>\
    \ queue.remove(x)\n                    case \")()()\" => queue.remove(x)\n   \
    \                 case \")()()()\" => queue.remove(x)\n                    case\
    \ \")()()()()\" => queue.remove(x)\n                    case \")()()()()()\" =>\
    \ queue.remove(x)\n                    case \")()()()()()()\" => queue.remove(x)\n\
    \                    case \")()()()()()()()\" => queue.remove(x)\n           \
    \         case \")()()()()()()()()\" => queue.remove(x)\n                    case\
    \ \")()()()()()()()()()\" => queue.remove(x)\n                    case \")()()()()()()()()()\"\
    \ => queue.remove(x)\n                    case \")()()()()()()()()()()\" => queue.remove(x)\n\
    \                    case \")()()()()()()()()()()\" => queue.remove(x)\n     \
    \               case \")()()()()()()()()()()()\" => queue.remove(x)\n        \
    \            case \")()()()()()()()()()()()\" => queue.remove(x)\n           \
    \         case \")()()()()()()()()()()()\" => queue.remove(x)\n              \
    \      case \")()()()()()()()()()()()()\" => queue.remove(x)\n               \
    \     case \")()()()()()()()()()()()()\" => queue.remove(x)\n                \
    \    case \")()()()()()()()()()()()()()\" => queue.remove(x)\n               \
    \     case \")()()()()()()()()()()()()()\" => queue.remove(x)\n              \
    \      case \")()()()()()()()()()()()()()\" => queue.remove(x)\n             \
    \       case \")()()()()()()()()()()()()()\" => queue.remove(x)\n            \
    \        case \")()()()()()()()()()()()()()()\" => queue.remove(x)\n         \
    \           case \")()()()()()()()()()()()()()()\" => queue.remove(x)\n      \
    \              case \")()()()()()()()()()()()()()()\" => queue.remove(x)\n   \
    \                 case \")()()()()()()()()()()()()()()\" => queue.remove(x)\n\
    \                    case \")()()()()()()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp33a72hi5.scala:46:25 -----------------------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m                    \e[33mcase\e[0m \")()()()()()()\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 unclosed string literal\n\e[31m\e[31m-- Error: /tmp/tmp33a72hi5.scala:48:34\
    \ -----------------------------------------\e[0m\e[0m\n\e[31m48 |\e[0m    \e[33mdef\e\
    [0m \e[36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\
    \e[31m\e[31m   |\e[0m                                  ^\e[0m\n\e[31m   |\e[0m\
    \                                 end of statement expected but '=' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmp33a72hi5.scala:64:0 ----------------------------\e\
    [0m\e[0m\n\e[31m64 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp33a72hi5.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp33a72hi5.scala:15:20\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mqueue\e[0m = mutable.Queue[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp33a72hi5.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp33a72hi5.scala:48:4\
    \ -------------------------\e[0m\e[0m\n\e[31m48 |\e[0m    \e[33mdef\e[0m \e[36mmain\e\
    [0m(\e["
  stdout: ''
  timestamp: 1659979853
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") stack.push(x)\n     \
    \       if (x == \")\") stack.pop() match {\n                case Some(x) => result\
    \ += (x + \"(\")\n                case None => result += x\n            }\n  \
    \      })\n        if (stack.size == 0) \"No\" else \"Yes\"\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpnh1s5_q8.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpnh1s5_q8.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979854
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.equals(\"(\") =>\
    \ stack += x\n            case x if x.equals(\")\") => stack += x\n          \
    \  case x => stack += x\n        })\n        stack.foreach(x => result += x)\n\
    \        if (result.size == lst.length) result.mkString(\"(\", \")\", \"(\", \"\
    )\")\n        else result.mkString(\"(\", \")\")\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpw9_ah_6e.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpw9_ah_6e.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open.add(x)\n       \
    \     if (x == \")\") close.add(x)\n            if (open.isEmpty && close.isEmpty)\
    \ stack += x\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\
    \n            if (close.isEmpty && !open.isEmpty) result += \"Yes\"\n        \
    \    if (open.isEmpty && close.isEmpty) result += \"No\"\n        })\n       \
    \ stack.toList.reverse.foreach(x => result += \"No\")\n        result.toList.reverse.mkString\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpbq60mklx.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbq60mklx.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpbq60mklx.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpbq60mklx.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979855
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => x match {\n            case \")\" => stack.pop() match\
    \ {\n                case \")\" => result += \"()\"\n                case \")()\"\
    \ => result += \"()\"\n                case \")()()\" => result += \"()()\"\n\
    \                case _ => result += \"()\"\n            }\n            case \"\
    )()\" => stack.pop() match {\n                case \")\" => result += \"()\"\n\
    \                case \")()\" => result += \"()()\"\n                case \")()()\"\
    \ => result += \"()()()\"\n                case _ => result += \"()()\"\n    \
    \        }\n            case \")()()\" => stack.pop() match {\n              \
    \  case \")\" => result += \"()()\"\n                case \")()\" => result +=\
    \ \"()()()\"\n                case \")()()\" => result += \"()()()()\"\n     \
    \           case _ => result += \"()()()\"\n            }\n            case _\
    \ => stack += x\n        })\n        if (stack.size == 0) \"No\" else \"Yes\"\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpuwhsw1v2.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpuwhsw1v2.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(s => {\n            val open = s.indexOf(\"(\")\n       \
    \     val close = s.indexOf(\")\")\n            if (open < 0 || close < 0) {\n\
    \                result.append(\"No\")\n            } else {\n               \
    \ val stackSize = stack.size\n                if (open > close || (open < 0 &&\
    \ close < 0)) {\n                    result.append(\"No\")\n                }\
    \ else {\n                    if (stackSize > 0) {\n                        val\
    \ top = stack.toList(0)\n                        if (top.length == stackSize)\
    \ {\n                            if (top.head == close) {\n                  \
    \              stack.toList.remove(top.head)\n                               \
    \ result.append(\"Yes\")\n                            } else {\n             \
    \                   result.append(\"No\")\n                            }\n   \
    \                     } else {\n                            result.append(\"No\"\
    )\n                        }\n                    } else {\n                 \
    \       result.append(\"No\")\n                    }\n                }\n    \
    \        }\n            stack.push(s)\n        })\n        result.mkString(\"\
    ,\")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp569o7juo.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp569o7juo.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            val open = s.indexOf(\"(\")\n       \
    \     val close = s.indexOf(\")\")\n            if (open < 0 || close < 0) return\n\
    \            if (open > close) {\n                stack += s.substring(open +\
    \ 1, close)\n            } else {\n                stack += s.substring(close\
    \ + 1, open)\n            }\n        }\n        val openCount = stack.count(\"\
    (\")\n        val closeCount = stack.count(\")\")\n        if (openCount != closeCount)\
    \ {\n            return \"No\"\n        }\n        val open = stack.indexOf(\"\
    (\")\n        val close = stack.indexOf(\")\")\n        if (open < 0 || close\
    \ < 0) return\n        if (open > close) {\n            stack += stack.substring(open\
    \ + 1, close)\n        } else {\n            stack += stack.substring(close +\
    \ 1, open)\n        }\n        val openCount = stack.count(\"(\")\n        val\
    \ closeCount = stack.count(\")\")\n        if (openCount != closeCount) {\n  \
    \          return \"No\"\n        }\n        val open = stack.indexOf(\"(\")\n\
    \        val close = stack.indexOf(\")\")\n        if (open < 0 || close < 0)\
    \ return\n        if (open > close) {\n            stack += stack.substring(open\
    \ + 1, close)\n        } else {\n            stack += stack.substring(close +\
    \ 1, open)\n        }\n        val openCount = stack.count(\"(\")\n        val\
    \ closeCount = stack.count(\")\")\n        if (openCount != closeCount) {\n  \
    \          return \"No\"\n        }\n        val open = stack.indexOf(\"(\")\n\
    \        val close = stack.indexOf(\")\")\n        if (open < 0 || close < 0)\
    \ return\n        if (open > close) {\n            stack += stack.substring(open\
    \ + 1, close)\n        } else {\n            stack += stack.substring(close +\
    \ 1, open)\n        }\n        val openCount = stack.count(\"(\")\n        val\
    \ closeCount = stack.count(\")\")\n        if (openCount != closeCount) {\n  \
    \          return \"No\"\n        }\n        val open = stack.indexOf(\"(\")\n\
    \        val close = stack.indexOf(\")\")\n        if (open < 0 || close < 0)\
    \ return\n        if (open > close) {\n            stack += stack.substring(open\
    \ + 1, close)\n        } else {\n            stack += stack.substring(close +\
    \ 1, open)\n        }\n        val openCount = stack.count(\"(\")\n        val\
    \ closeCount = stack.count(\")\")\n        if (openCount != closeCount) {\n  \
    \          return \"No\"\n        }\n        val open = stack.indexOf(\"(\")\n\
    \        val close = stack.indexOf(\")\")\n        if (open < 0 || close < 0)\
    \ return\n        if (\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpvsros74e.scala:86:12 ---------------------------\e\
    [0m\e[0m\n\e[31m86 |\e[0m        \e[33mif\e[0m (\n\e[31m\e[31m   |\e[0m      \
    \      ^\e[0m\n\e[31m   |\e[0m            expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvsros74e.scala:39:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopenCount\e[0m = stack.count(\e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopenCount is already\
    \ defined as \e[33mvalue\e[0m \e[35mopenCount\e[0m\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0mNote that overloaded methods must all be defined in the same group of\
    \ toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvsros74e.scala:40:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcloseCount\e[0m = stack.count(\e[31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcloseCount is\
    \ already defined as \e[33mvalue\e[0m \e[35mcloseCount\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvsros74e.scala:44:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopen\e[0m = stack.indexOf(\e[31m\"(\"\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopen is already defined\
    \ as \e[33mvalue\e[0m \e[35mopen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvsros74e.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = stack.indexOf(\e\
    [31m\")\"\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mclose is already defined as \e[33mvalue\e[0m \e[35mclose\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of topleve"
  stdout: ''
  timestamp: 1659979861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   else if (x == \")\") close += x\n            else stack += x\n        })\n\
    \        if (open.size == 0 && close.size == 0) \"No\"\n        else if (open.size\
    \ == 0 && close.size > 0) \"Yes\"\n        else if (open.size > 0 && close.size\
    \ == 0) \"No\"\n        else if (open.size > 0 && close.size > 0) \"Yes\"\n  \
    \      else matchParens(stack.toList)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps9418vxs.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps9418vxs.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmps9418vxs.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmps9418vxs.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n4 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val cur = stack.pop()\n            if(cur == \"(\") {\n              \
    \  result += \"(\"\n                stack += \")\"\n            } else if(cur\
    \ == \")\") {\n                result += \"(\"\n                stack += \")\"\
    \n            } else {\n                result += cur\n            }\n       \
    \ }\n        if(result.length == lst.length) result.mkString\n        else \"\
    No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp296x0rvf.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp296x0rvf.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            s match {\n                case \")\"\
    \ =>\n                    close.foreach(c => stack += c)\n                   \
    \ result ++= stack\n                    stack = mutable.Stack[String]()\n    \
    \            case \")(\"  =>\n                    open += s\n                case\
    \ \")(\"  =>\n                    open -= s\n                case \")\" =>\n \
    \                   close += s\n                case \")\" =>\n              \
    \      close -= s\n                case _ =>\n                    stack += s\n\
    \            }\n        }\n        if (stack.nonEmpty) result += \"No\"\n    \
    \    else result += \"Yes\"\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n  \
    \  assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    (()(())\", \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"\
    )())\", \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    (())))\", \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvn9as2kn.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvn9as2kn.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvn9as2kn.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvn9as2kn.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvn9as2kn.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m                    stack = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n5 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979856
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x == \")\" => close.push(x)\n\
    \            case x if x == \")()\" => close.push(x)\n            case x if x\
    \ == \"(\" => open.push(x)\n            case x if x == \")(\" => open.push(x)\n\
    \            case x if x == \")()()\" => close.push(x)\n            case x if\
    \ x == \")()()()\" => close.push(x)\n            case x if x == \")()()()()\"\
    \ => close.push(x)\n            case x if x == \")()()()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()()()\" => close.push(x)\n            case\
    \ x if x == \")()()()()()()()\" => close.push(x)\n            case x if x == \"\
    )()()()()()()()()\" => close.push(x)\n            case x if x == \")()()()()()()()()()\"\
    \ => close.push(x)\n            case x if x == \")()()()()()()()()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()()()()()()()\" => close.push(x)\n     \
    \       case x if x == \")()()()()()()()()()()()\" => close.push(x)\n        \
    \    case x if x == \")()()()()()()()()()()()()\" => close.push(x)\n         \
    \   case x if x == \")()()()()()()()()()()()()()\" => close.push(x)\n        \
    \    case x if x == \")()()()()()()()()()()()()()\" => close.push(x)\n       \
    \     case x if x == \")()()()()()()()()()()()()()\" => close.push(x)\n      \
    \      case x if x == \")()()()()()()()()()()()()()()\" => close.push(x)\n   \
    \         case x if x == \")()()()()()()()()()()()()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()()()()()()()()()()()\" => close.push(x)\n\
    \            case x if x == \")()()()()()()()()()()()()()()\" => \n    }\n   \
    \ def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"()(\"\
    , \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"\
    )\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\", \"\
    ())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvrg9tj_e.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m    ^^^\e[0m\n\e\
    [31m   |\e[0m    ')' expected, but 'def' found\n\e[31m\e[31m-- [E040] Syntax Error:\
    \ /tmp/tmpvrg9tj_e.scala:59:0 ----------------------------\e[0m\e[0m\n\e[31m59\
    \ |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvrg9tj_e.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvrg9tj_e.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpvrg9tj_e.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpvrg9tj_e.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n6 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.ListBuffer[String]()\n\
    \        val bad = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n\
    \            if (x == \"(\") stack.push(x)\n            if (x == \")\") stack.pop()\
    \ match {\n                case Some(\"(\") => good.add(x)\n                case\
    \ _ => bad.add(x)\n            }\n        })\n        if (good.size == lst.size)\
    \ good.toList(\"(\", \")\").toString.toUpperCase\n        else bad.toList(\"(\"\
    , \")\").toString.toUpperCase\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmplk3mpk3x.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmplk3mpk3x.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmplk3mpk3x.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach { s =>\n            val newStack = mutable.Stack[String]()\n\
    \            val newResult = mutable.ListBuffer.empty[String]\n            val\
    \ open = s.indexOf('(')\n            val close = s.lastIndexOf(')')\n        \
    \    val newOpen = open + 1\n            val newClose = close + 1\n          \
    \  val newLen = newOpen - newClose\n            val newStr = s.substring(newOpen,\
    \ newClose)\n            val newStrLen = newStr.length\n            val newStrLen2\
    \ = newStrLen / 2\n            val newStrLen3 = newStrLen / 3\n            val\
    \ newStrLen4 = newStrLen / 4\n            val newStrLen5 = newStrLen / 5\n   \
    \         val newStrLen6 = newStrLen / 6\n            val newStrLen7 = newStrLen\
    \ / 7\n            val newStrLen8 = newStrLen / 8\n            val newStrLen9\
    \ = newStrLen / 9\n            val newStrLen10 = newStrLen / 10\n            val\
    \ newStrLen11 = newStrLen / 11\n            val newStrLen12 = newStrLen / 12\n\
    \            val newStrLen13 = newStrLen / 13\n            val newStrLen14 = newStrLen\
    \ / 14\n            val newStrLen15 = newStrLen / 15\n            val newStrLen16\
    \ = newStrLen / 16\n            val newStrLen17 = newStrLen / 17\n           \
    \ val newStrLen18 = newStrLen / 18\n            val newStrLen19 = newStrLen /\
    \ 19\n            val newStrLen20 = newStrLen / 20\n            val newStrLen21\
    \ = newStrLen / 21\n            val newStrLen22 = newStrLen / 22\n           \
    \ val newStrLen23 = newStrLen / 23\n            val newStrLen24 = newStrLen /\
    \ 24\n            val newStrLen25 = newStrLen / 25\n            val newStrLen26\
    \ = newStrLen / 26\n            val newStrLen27 = newStrLen / 27\n           \
    \ val newStrLen28 = newStrLen / 28\n            val newStrLen29 = newStrLen /\
    \ 29\n            val newStrLen30 = newStrLen / 30\n            val newStrLen31\
    \ = newStrLen / 31\n            val newStrLen32 = newStrLen / 32\n           \
    \ val newStrLen33 = newStrLen / 33\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpiwjlfdmw.scala:76:0 ----------------------------\e\
    [0m\e[0m\n\e[31m76 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiwjlfdmw.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiwjlfdmw.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpiwjlfdmw.scala:17:27\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m\
    \ \e[36mnewStack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpiwjlfdmw.scala:18:28 ------------------------\e[0m\e[0m\n\e[31m18 |\e\
    [0m            \e[33mval\e[0m \e[36mnewResult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpiwjlfdmw.scala:75:1 ---------------------\e\
    [0m\e[0m\n\e[31m75 |\e[0m}\n\e[31m\e[31m   |\e[0m ^\e[0m\n\e[31m   |\e[0m Found:\
    \    Unit\n\e[31m   |\e[0m Required: String\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tm"
  stdout: ''
  timestamp: 1659979861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.ListBuffer[String]()\n\
    \        val bad = mutable.ListBuffer[String]()\n        lst.foreach(x => x match\
    \ {\n            case x if x.startsWith(\"(\") => stack.push(x)\n            case\
    \ x if x.startsWith(\")\") => stack.pop() match {\n                case x if x\
    \ == \")\" => good.append(x)\n                case x => bad.append(x)\n      \
    \      }\n        })\n        if (good.size == lst.size) good.mkString(\"(\",\
    \ \")\") else \"No\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpoli040b2.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpoli040b2.scala:15:19 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpoli040b2.scala:16:18 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1659979857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val openParen = str.substring(0, open)\n\
    \                val closeParen = str.substring(close+1, str.length)\n       \
    \         val newStr = openParen + closeParen\n                stack += newStr\n\
    \                result.append(\"Yes\")\n            }\n        }\n        if(stack.size\
    \ == 0) {\n            result.append(\"No\")\n        } else {\n            result.append(\"\
    Yes\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmphwwludui.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmphwwludui.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979857
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop\n                case \")(\"  => stack.append(x)\n            \
    \    case _ => stack.append(x)\n            }\n        })\n        stack.toList\
    \ match {\n            case Nil => result.append(\"Yes\")\n            case x\
    \ :: Nil => result.append(\"No\")\n            case x :: y => result.append(\"\
    Yes\")\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxa5p3lgv.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxa5p3lgv.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val x = stack.pop()\n            val y = stack.pop()\n            val\
    \ z = (x + \"(\" + y + \")\")\n            result += (x + \"(\" + y + \")\")\n\
    \            stack += z\n        }\n        if (result.size == lst.size) {\n \
    \           return \"Yes\"\n        } else {\n            return \"No\"\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx1866w9b.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpx1866w9b.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979858
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")()\" => stack.push(x)\n                case \")()()\" => stack.push(x)\n\
    \                case \")(\" => open.push(x)\n                case \")()\" =>\
    \ open.push(x)\n                case _ => stack.push(x)\n            }\n     \
    \   })\n        val openCount = open.count\n        val closeCount = close.count\n\
    \        val openStack = stack.take(openCount)\n        val closeStack = stack.drop(closeCount)\n\
    \        val openStackCount = openStack.count\n        val closeStackCount = closeStack.count\n\
    \        val openStack = openStack.take(openStackCount)\n        val closeStack\
    \ = closeStack.drop(closeStackCount)\n        val openStackCount = openStack.count\n\
    \        val closeStackCount = closeStack.count\n        val openStack = openStack.take(openStackCount)\n\
    \        val closeStack = closeStack.drop(closeStackCount)\n        val openStackCount\
    \ = openStack.count\n        val closeStackCount = closeStack.count\n        val\
    \ openStack = openStack.take(openStackCount)\n        val closeStack = closeStack.drop(closeStackCount)\n\
    \        val openStackCount = openStack.count\n        val closeStackCount = closeStack.count\n\
    \        val openStack = openStack.take(openStackCount)\n        val closeStack\
    \ = closeStack.drop(closeStackCount)\n        val openStackCount = openStack.count\n\
    \        val closeStackCount = closeStack.count\n        val openStack = openStack.take(openStackCount)\n\
    \        val closeStack = closeStack.drop(closeStackCount)\n        val openStackCount\
    \ = openStack.count\n        val closeStackCount = closeStack.count\n        val\
    \ openStack = openStack.take(openStackCount)\n        val closeStack = closeStack.drop(closeStackCount)\n\
    \        val openStackCount = openStack.count\n        val closeStackCount = closeStack.count\n\
    \        val openStack = openStack.take(openStackCount)\n        val closeStack\
    \ = closeStack.drop(\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpj15lbezd.scala:60:41 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mcloseStack\e[0m = closeStack.drop(\n\
    \e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e[31m \
    \  |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj15lbezd.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mopenStack\e[0m = openStack.take(openStackCount)\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mopenStack\
    \ is already defined as \e[33mvalue\e[0m \e[35mopenStack\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj15lbezd.scala:36:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcloseStack\e[0m = closeStack.drop(closeStackCount)\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mcloseStack is already defined as \e[33mvalue\e[0m \e[35mcloseStack\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpj15lbezd.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mopenStackCount\e[0m = openStack.count\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mopenStackCount is already defined as \e[33mvalue\e[0m \e[35mopenStackCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj15lbezd.scala:38:12 ---------------------------\e[0m\e[0m\n\e\
    [31m38 |\e[0m        \e[33mval\e[0m \e[36mcloseStackCount\e[0m = closeStack.count\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \  "
  stdout: ''
  timestamp: 1659979860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => if (x == \"(\") stack += x else if (!x == \"(\") queue\
    \ += x else if (!x == \")\") bad += x else if (!x == \")\") good += x)\n     \
    \   if (stack.size == 0 && queue.size == 0) \"No\"\n        else if (stack.size\
    \ == 0 && queue.size > 0) \"Yes\"\n        else if (stack.size > 0 && queue.size\
    \ == 0) \"No\"\n        else if (stack.size > 0 && queue.size > 0) \"Yes\"\n \
    \       else matchParens(stack.toList ++ queue.toList)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpdav4wbt9.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdav4wbt9.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpdav4wbt9.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpdav4wbt9.scala:17:18 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpdav4wbt9.scala:18:59 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        lst.foreach(\e[36mx\e[0m => \e[33mif\e[0m (x\
    \ == \e[31m\"(\"\e[0m) stack += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\"\
    (\"\e[0m) queue += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) bad\
    \ += x \e[33melse\e[0m \e[33mif\e[0m (!x == \e[31m\")\"\e[0m) good += x)\n\e[31m\e\
    [31m   |\e[0m                                                           ^^\e[0m\n\
    \e[31m   |\e[0m                                 value unary_! is not a member\
    \ of String\n\e[31m\e[31m-- [E008] Not Found Error: /"
  stdout: ''
  timestamp: 1659979862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open != -1 && close != -1) {\n                val left = str.substring(0,\
    \ open)\n                val right = str.substring(close + 1)\n              \
    \  val newStr = left + right\n                if(!stack.contains(newStr)) {\n\
    \                    stack.push(newStr)\n                    result += newStr\n\
    \                }\n            }\n        }\n        if(result.size == lst.size)\
    \ {\n            return \"Yes\"\n        } else {\n            return \"No\"\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr6kxd86p.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpr6kxd86p.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979859
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ for(i <- 0 until stackSize){\n            val str = lst(i)\n            val\
    \ len = str.length\n            val open = str.indexOf(\"(\")\n            val\
    \ close = str.indexOf(\")\")\n            val isOpen = open != -1\n          \
    \  val isClose = close != -1\n            val isOpenClose = open != -1 && close\
    \ != -1\n            val isOpenCloseOpen = open != -1 && close != -1 && open <\
    \ close\n            val isOpenCloseClose = open != -1 && close != -1 && open\
    \ < close\n            val isOpenCloseOpenClose = open != -1 && close != -1 &&\
    \ open < close && close < close\n            val isOpenCloseCloseOpen = open !=\
    \ -1 && close != -1 && open < close && close < open && close < close\n       \
    \     val isOpenCloseCloseClose = open != -1 && close != -1 && open < close &&\
    \ close < open && close < close\n            val isOpenCloseCloseOpenClose = open\
    \ != -1 && close != -1 && open < close && close < open && close < close && close\
    \ < open\n            val isOpenCloseCloseCloseOpen = open != -1 && close != -1\
    \ && open < close && close < open && close < close && close < open && close <\
    \ close\n            val isOpenCloseCloseCloseClose = open != -1 && close != -1\
    \ && open < close && close < open && close < close && close < open && close <\
    \ close\n            val isOpenCloseCloseCloseOpen = open != -1 && close != -1\
    \ && open < close && close < open && close < close && close < open && close <\
    \ close\n            val isOpenCloseCloseCloseClose = open != -1 && close != -1\
    \ && open < close && close < open && close < close && close < open && close <\
    \ close\n            val isOpenCloseCloseCloseOpen = open != -1 && close != -1\
    \ && open < close && close < open && close < close && close < open && close <\
    \ close\n            val isOpenCloseCloseCloseCloseClose = open != -1 && close\
    \ != -1 && open < close && close < open && close < close && close < open && close\
    \ < close\n            val isOpenCloseCloseCloseCloseOpen = open != -1 && close\
    \ != -1 && open < close && close < open \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpz88dwgey.scala:56:0 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz88dwgey.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpz88dwgey.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz88dwgey.scala:34:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m            \e[33mval\e\
    [0m \e[36misOpenCloseCloseCloseOpen\e[0m = open != -\e[31m1\e[0m && close != -\e\
    [31m1\e[0m && open < close && close < open && close < close && close < open &&\
    \ close < close\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0misOpenCloseCloseCloseOpen is already defined as \e[33mvalue\e\
    [0m \e[35misOpenCloseCloseCloseOpen\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpz88dwgey.scala:35:16 ---------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e[0m \e[36misOpenCloseCloseCloseClose\e\
    [0m = open != -\e[31m1\e[0m && close != -\e[31m1\e[0m && open < close && close\
    \ < open && close < close && close < open && close < close\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1659979862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val result = mutable.ListBuffer[String]()\n        lst.foreach { s =>\n\
    \            val open = s.indexOf(\"(\")\n            val close = s.indexOf(\"\
    )\")\n            if (open < 0 || close < 0) {\n                result += \"No\"\
    \n            } else {\n                result += \"Yes\"\n                stack.push(s)\n\
    \                queue.enqueue(s)\n            }\n        }\n        val stackSize\
    \ = stack.size\n        val queueSize = queue.size\n        if (stackSize == queueSize)\
    \ {\n            result += \"Yes\"\n        } else {\n            result += \"\
    No\"\n        }\n        return result.toString\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpep02tgzj.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpep02tgzj.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpep02tgzj.scala:16:21 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n3 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n        val resultSize = lst.size\n       \
    \ val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val stackSize = lst.size\n\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsnwpmztj.scala:18:12 ---------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsnwpmztj.scala:19:12 ---------------------------\e[0m\e[0m\n\e\
    [31m19 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresult is already defined as \e[33mvalue\e[0m \e[35mresult\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsnwpmztj.scala:20:12 ---------------------------\e[0m\e[0m\n\e\
    [31m20 |\e[0m        \e[33mval\e[0m \e[36mstackSize\e[0m = lst.size\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mstackSize is\
    \ already defined as \e[33mvalue\e[0m \e[35mstackSize\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsnwpmztj.scala:21:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m21 |\e[0m        \e[33mval\e[0m\
    \ \e[36mresultSize\e[0m = lst.size\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mresultSize is already defined as \e[33mvalue\e[0m \e[35mresultSize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpsnwpmztj.scala:22:12 ---------------------------\e[0m\e[0m\n\e\
    [31m22 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mstack is already defined as \e[33mvalue\e[0m \e[35mstack\e[0m\n\
    \e[31"
  stdout: ''
  timestamp: 1659979850
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \"(\"\
    \ => open += x\n                case \")\" => close += x\n                case\
    \ _ => stack += x\n            }\n        })\n        val openCount = open.size\n\
    \        val closeCount = close.size\n        val openCount = openCount + closeCount\n\
    \        val openCount = openCount + 1\n        val closeCount = closeCount +\
    \ 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = openCount + 1\n        val closeCount = closeCount\
    \ + 1\n        val openCount = \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmphux9hjlo.scala:72:23 ---------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmphux9hjlo.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount\
    \ + closeCount\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphux9hjlo.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmphux9hjlo.scala:29:12 ---------------------------\e[0m\e[0m\n\e[31m29\
    \ |\e[0m        \e[33mval\e[0m \e[36mcloseCount\e[0m = closeCount + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcloseCount is already defined as \e[33mvalue\e[0m \e[35mcloseCount\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmphux9hjlo.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mopenCount\e[0m = openCount + \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mopenCount is already defined as \e[33mvalue\e[0m \e[35mopenCount\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloade"
  stdout: ''
  timestamp: 1659979862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => stack += x)\n        while(stack.nonEmpty) {\n     \
    \       val x = stack.pop()\n            val y = stack.pop()\n            if(x\
    \ == \")\" && y == \")\") result += \"()\"\n            if(x == \"(\" && y ==\
    \ \")\") result += \"()\"\n            if(x == \"(\" && y == \"(\") result +=\
    \ \"()\"\n            if(x == \")\" && y == \"(\") result += \"()\"\n        \
    \    if(x == \")\" && y == \")\") result += \"()\"\n        }\n        if(result.isEmpty)\
    \ \"No\" else \"Yes\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq6cbvqgm.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpq6cbvqgm.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1659979860
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val queue = mutable.Queue[String]()\n\
    \        val good = mutable.Set[String]()\n        val bad = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ =>\n                    if (!stack.isEmpty) {\n                        val top\
    \ = stack.pop()\n                        if (top != \"(\") {\n               \
    \             bad.add(top)\n                        }\n                    }\n\
    \                case \")(\"  =>\n                    if (!queue.isEmpty) {\n\
    \                        val top = queue.pop()\n                        if (top\
    \ != \"(\") {\n                            bad.add(top)\n                    \
    \    }\n                    }\n                case \")()\" =>\n             \
    \       if (!queue.isEmpty) {\n                        val top = queue.pop()\n\
    \                        if (top != \"(\") {\n                            bad.add(top)\n\
    \                        }\n                    }\n                case \")()()\"\
    \ =>\n                    if (!stack.isEmpty) {\n                        val top\
    \ = stack.pop()\n                        if (top != \"(\") {\n               \
    \             bad.add(top)\n                        }\n                    }\n\
    \                case \")()()()\" =>\n                    if (!queue.isEmpty)\
    \ {\n                        val top = queue.pop()\n                        if\
    \ (top != \"(\") {\n                            bad.add(top)\n               \
    \         }\n                    }\n                case \")()()()()\" =>\n  \
    \                  if (!stack.isEmpty) {\n                        val top = stack.pop()\n\
    \                        if (top != \"(\") {\n                            bad.add(top)\n\
    \                        }\n                    }\n                case \")()()()()()\"\
    \ =>\n                    if (!queue.isEmpty) {\n                        val top\
    \ = queue.pop()\n                        if (top != \"(\") {\n               \
    \             bad.add(top)\n                        }\n                    }\n\
    \                case \")()()()()()()\" =>\n                    if (!stack.isEmpty)\
    \ {\n                        val top = stack.pop()\n                        if\
    \ (top != \"(\") {\n                            bad.add(top)\n               \
    \         }\n                    }\n                case \")()()()()()()()()\"\
    \ =>\n                    if (!queue.isEmpty) {\n                        val top\
    \ = queue.pop()\n                        if (top != \"(\") {\n               \
    \             bad.add(top)\n                        }\n                    }\n\
    \                case \")()()()()()()()()\" =>\n                    if (!stack.isEmpty)\
    \ {\n                        val top = stack.pop()\n                        if\
    \ (top != \"(\") {\n                            bad.add(top)\n               \
    \         }\n                    }\n                case \")()()()()()()()()()\"\
    \ =>\n                    if (!queue.isEmpty) {\n                        val top\
    \ = queue.pop()\n                        if (top != \"(\") {\n               \
    \             bad.add(top)\n                        }\n                    }\n\
    \                case \")()()()()()()()()()()\" =>\n                    if (!stack.isEmpty)\
    \ {\n                        val top = stack.pop()\n                        if\
    \ (top != \"(\"\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp70mnjboz.scala:101:4 ---------------------------\e\
    [0m\e[0m\n\e[31m101 |\e[0m    }\n\e[31m\e[31m    |\e[0m    ^\e[0m\n\e[31m    |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp70mnjboz.scala:118:0\
    \ ---------------------------\e[0m\e[0m\n\e[31m118 |\e[0m\n\e[31m\e[31m    |\e\
    [0m^\e[0m\n\e[31m    |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp70mnjboz.scala:14:20 ------------------------\e[0m\e\
    [0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp70mnjboz.scala:15:20 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mqueue\e[0m = mutable.Queue[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp70mnjboz.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mgood\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp70mnjboz.scala:17:18 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mbad\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                  ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmp70mnjboz.scala:102:4 ---------------------------------------\e\
    [0m\e[0m\n\e[33m102 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m:\
    \ \e[35mArray\e[0m[\e[35mString\e[0m]) = "
  stdout: ''
  timestamp: 1659979861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.ListBuffer[String]()\n        val close = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => if (x == \"(\") open.append(x))\n        lst.foreach(x\
    \ => if (x == \")\") close.append(x))\n        val openCount = open.count\n  \
    \      val closeCount = close.count\n        if (openCount == closeCount) {\n\
    \            val openStack = mutable.Stack[String]()\n            open.foreach(x\
    \ => openStack.append(x))\n            close.foreach(x => openStack.pop())\n \
    \           val openStackCount = openStack.count\n            if (openStackCount\
    \ == 0) {\n                val closeStack = mutable.Stack[String]()\n        \
    \        close.foreach(x => closeStack.append(x))\n                val closeStackCount\
    \ = closeStack.count\n                if (closeStackCount == 0) {\n          \
    \          result.append(\"Yes\")\n                } else {\n                \
    \    result.append(\"No\")\n                }\n            } else {\n        \
    \        result.append(\"No\")\n            }\n        } else {\n            result.append(\"\
    No\")\n        }\n        result.toString()\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfs9z3gfo.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfs9z3gfo.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfs9z3gfo.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpfs9z3gfo.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpfs9z3gfo.scala:23:28 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m            \e[33mval\e[0m \e[36mopenStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfs9z3gfo.scala:28:33 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m                \e[33mval\e[0m \e[3"
  stdout: ''
  timestamp: 1659979861
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => close.push(x)\n                case \")(\"  => stack.push(x)\n          \
    \      case \")(\"  => stack.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\" => close.push(x)\n                case \")\" => close.push(x)\n\
    \                case \")\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmp1rx4uuul.scala:70:21 -----------------------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m                \e[33mcase\e[0m \")\n\e[31m\e[31m   |\e\
    [0m                     ^\e[0m\n\e[31m   |\e[0m                     unclosed string\
    \ literal\n\e[31m\e[31m-- Error: /tmp/tmp1rx4uuul.scala:72:34 -----------------------------------------\e\
    [0m\e[0m\n\e[31m72 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e[31m   |\e[0m                \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but '=' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1rx4uuul.scala:88:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m88 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmp1rx4uuul.scala:14:20 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp1rx4uuul.scala:15:21 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp1rx4uuul.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp1rx4uuul.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set"
  stdout: ''
  timestamp: 1659979862
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            if(open < 0 || close < 0) {\n                result.append(\"No\"\
    )\n            } else {\n                val stackStr = str.substring(0, open)\n\
    \                val stackStr = stackStr.substring(stackStr.indexOf(\"(\") + 1,\
    \ stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\")\"))\n                val stackStr = stackStr.substring(stackStr.indexOf(\"\
    (\") + 1, stackStr.indexOf(\"\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n   \
    \ assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpae4i8j_z.scala:41:94 -----------------------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m                \e[33mval\e[0m \e[36mstackStr\e[0m =\
    \ stackStr.substring(stackStr.indexOf(\e[31m\"(\"\e[0m) + \e[31m1\e[0m, stackStr.indexOf(\"\
    \n\e[31m\e[31m   |\e[0m                                                      \
    \                                        ^\e[0m\n\e[31m   |\e[0m             \
    \                                    unclosed string literal\n\e[31m\e[31m-- [E040]\
    \ Syntax Error: /tmp/tmpae4i8j_z.scala:59:0 ----------------------------\e[0m\e\
    [0m\n\e[31m59 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpae4i8j_z.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpae4i8j_z.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer.empty[\e[35mString\e[0m]\n\e[31m\e[31m  \
    \ |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpae4i8j_z.scala:24:20\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m                \e[33mval\e\
    [0m \e[36mstackStr\e[0m = stackStr.substring(stackStr.indexOf(\e[31m\"(\"\e[0m)\
    \ + \e[31m1\e[0m, stackStr.indexOf(\e[31m\")\"\e[0m))\n\e[31m\e[31m   |\e[0m \
    \               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mstackStr is already defined as \e[33mvalue\e[0m \e[35mstackStr\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpae4i8j_z.scala:25:20 ---------------------------"
  stdout: ''
  timestamp: 1659979863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val good = mutable.ListBuffer[String]()\n\
    \        val bad = mutable.ListBuffer[String]()\n        lst.foreach(x => {\n\
    \            x match {\n                case \")\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n                    }\n    \
    \            }\n                case \")(\" => {\n                    stack.pop\n\
    \                    x match {\n                        case \"(\" => stack.push(x)\n\
    \                        case _ => bad.append(x)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"Yes\"\
    )));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\")));\n\
    \    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppl3h39bq.scala:125:0 ---------------------------\e\
    [0m\e[0m\n\e[31m125 |\e[0m\n\e[31m\e[31m    |\e[0m^\e[0m\n\e[31m    |\e[0m'}'\
    \ expected, but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppl3h39bq.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppl3h39bq.scala:15:19\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mgood\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppl3h39bq.scala:16:18\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mbad\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                  Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppl3h39bq.scala:17:19\
    \ --------------------\e[0m\e[0m\n\e[31m 17 |\e[0m        lst.foreach(\e[36mx\e\
    [0m => {\n\e[31m\e[31m    |\e[0m        ^\e[0m\n\e[31m    |\e[0m        Found:\
    \    Unit\n\e[31m    |\e[0m        Required: String\n\e[31m 18 |\e[0m        \
    \    x \e[33mmatch\e[0m {\n\e[31m 19 |\e[0m                \e[33mcase\e[0m \e\
    [31m\")\"\e[0m => {\n\e[31m 20 |\e[0m                    stack.pop\n\e[31m 21\
    \ |\e[0m                    x \e[33mmatch\e[0m {\n\e[31m 22 |\e[0m           \
    \             \e[33mcase\e[0m \e[31m\"(\"\e[0m => stack.push(x)\n\e[31m 23 |\e\
    [0m                        \e[33mcase\e[0m _ => bad.append(x)\n\e[31m 24 |\e[0m\
    \                    }\n\e[31m 25 |\e[0m                }\n\e[31m 26 |\e[0m  \
    \              \e[33mcase\e[0m \e[31m\")(\"\e[0m => {\n\e"
  stdout: ''
  timestamp: 1659979864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach(x => {\n            if (x == \"(\") open += x\n         \
    \   if (x == \")\") close += x\n            if (open.isEmpty && close.isEmpty)\
    \ result += \"Yes\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (close.isEmpty && !open.isEmpty) result += \"No\"\n \
    \           if (open.isEmpty && close.isEmpty) result += \"No\"\n            if\
    \ (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n \
    \           if (open.isEmpty && !close.isEmpty) result += \"No\"\n           \
    \ if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n \
    \           if (open.isEmpty && !close.isEmpty) result += \"No\"\n           \
    \ if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n \
    \           if (open.isEmpty && !close.isEmpty) result += \"No\"\n           \
    \ if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close.isEmpty) result +=\
    \ \"No\"\n            if (open.isEmpty && !close.isEmpty) result += \"No\"\n \
    \           if (open.isEmpty && !close.isEmpty) result += \"No\"\n           \
    \ if (open.isEmpty && !close.isEmpty) result += \"No\"\n            if (open.isEmpty\
    \ && !close.isEmpty) result += \"No\"\n            if (open.isEmpty && !close.isEmpty)\
    \ result += \"No\"\n            if (open.isEmpty && !close\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvwrvvjha.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpvwrvvjha.scala:54:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m54 |\e[0m    \e[33mdef\e[0m \e\
    [36mmain\e[0m(\e[36margs\e[0m: \e[35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[31m\e\
    [31m   |\e[0m    ^^^\e[0m\n\e[31m   |\e[0m    ')' expected, but 'def' found\n\e\
    [31m\e[31m-- [E040] Syntax Error: /tmp/tmpvwrvvjha.scala:70:0 ----------------------------\e\
    [0m\e[0m\n\e[31m70 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvwrvvjha.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvwrvvjha.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ListBuffer[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvwrvvjha.scala:16:19\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mopen\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m      \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                   Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpvwrvvjha.scala:17:20\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mclose\e[0m = mutable.Set[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m     \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e["
  stdout: ''
  timestamp: 1659979863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val stack2 = mutable.Stack[String]()\n\
    \        val stack3 = mutable.Stack[String]()\n        val stack4 = mutable.Stack[String]()\n\
    \        val stack5 = mutable.Stack[String]()\n        val stack6 = mutable.Stack[String]()\n\
    \        val stack7 = mutable.Stack[String]()\n        val stack8 = mutable.Stack[String]()\n\
    \        val stack9 = mutable.Stack[String]()\n        val stack10 = mutable.Stack[String]()\n\
    \        val stack11 = mutable.Stack[String]()\n        val stack12 = mutable.Stack[String]()\n\
    \        val stack13 = mutable.Stack[String]()\n        val stack14 = mutable.Stack[String]()\n\
    \        val stack15 = mutable.Stack[String]()\n        val stack16 = mutable.Stack[String]()\n\
    \        val stack17 = mutable.Stack[String]()\n        val stack18 = mutable.Stack[String]()\n\
    \        val stack19 = mutable.Stack[String]()\n        val stack20 = mutable.Stack[String]()\n\
    \        val stack21 = mutable.Stack[String]()\n        val stack22 = mutable.Stack[String]()\n\
    \        val stack23 = mutable.Stack[String]()\n        val stack24 = mutable.Stack[String]()\n\
    \        val stack25 = mutable.Stack[String]()\n        val stack26 = mutable.Stack[String]()\n\
    \        val stack27 = mutable.Stack[String]()\n        val stack28 = mutable.Stack[String]()\n\
    \        val stack29 = mutable.Stack[String]()\n        val stack30 = mutable.Stack[String]()\n\
    \        val stack31 = mutable.Stack[String]()\n        val stack32 = mutable.Stack[String]()\n\
    \        val stack33 = mutable.Stack[String]()\n        val stack34 = mutable.Stack[String]()\n\
    \        val stack35 = mutable.Stack[String]()\n        val stack36 = mutable.Stack[String]()\n\
    \        val stack37 = mutable.Stack[String]()\n        val stack38 = mutable.Stack[String]()\n\
    \        val stack39 = mutable.Stack[String]()\n        val stack40 = mutable.Stack[String]()\n\
    \        val stack4\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpq0i217z9.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:14:20\
    \ ------------------------\e[0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e\
    [36mstack\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m   \
    \                 ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:15:21\
    \ ------------------------\e[0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e\
    [36mstack2\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:16:21\
    \ ------------------------\e[0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e\
    [36mstack3\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:17:21\
    \ ------------------------\e[0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e\
    [36mstack4\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpq0i217z9.scala:18:21\
    \ ------------------------\e[0m\e[0m\n\e[31m18 |\e[0m        \e[33mval\e[0m \e\
    [36mstack5\e[0m = mutable.Stack[\e[35mString\e[0m]()\n\e[31m\e[31m   |\e[0m  \
    \                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compil"
  stdout: ''
  timestamp: 1659979813
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        for(i <- 0 until lst.size) {\n            val str = lst(i)\n        \
    \    val open = str.indexOf(\"(\")\n            val close = str.indexOf(\")\"\
    )\n            val openCount = if (open < 0) 0 else open + 1\n            val\
    \ closeCount = if (close < 0) 0 else close + 1\n            val count = openCount\
    \ + closeCount\n            if (openCount > closeCount) {\n                stack\
    \ += str\n            } else if (closeCount > openCount) {\n                result\
    \ += str\n            }\n        }\n        if (stack.size == result.size) {\n\
    \            return \"Yes\"\n        } else {\n            return \"No\"\n   \
    \     }\n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpgibrinm_.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpgibrinm_.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach(x => x match {\n            case x if x.startsWith(\"(\"\
    ) => stack.push(x)\n            case x if x.startsWith(\")\") => stack.pop() match\
    \ {\n                case x if x != \"(\" => result += \"(\" + x + \")\"\n   \
    \             case x if x == \")\" => result += \"(\" + x + \")\"\n          \
    \      case _ => result += \"(\" + x + \")\"\n            }\n            case\
    \ _ => result += x\n        })\n        if (stack.size == 0) \"No\" else \"Yes\"\
    \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpu42_6xxv.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpu42_6xxv.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1659979863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        lst.foreach(x => {\n            x match {\n                case \")\"\
    \ => stack.pop\n                case \")(\"  => stack.pop\n                case\
    \ \")()\" => stack.pop\n                case \")()()\" => stack.pop\n        \
    \        case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" => stack.pop\n\
    \                case \")(\" => stack.pop\n                case \")()\" \n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpygqyelsv.scala:78:4 ----------------------------\e\
    [0m\e[0m\n\e[31m78 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=>' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpygqyelsv.scala:95:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m95 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m')' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpygqyelsv.scala:14:20 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpygqyelsv.scala:15:21 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[33m\e[33m--\
    \ Warning: /tmp/tmpygqyelsv.scala:79:4 ----------------------------------------\e\
    [0m\e[0m\n\e[33m79 |\e[0m    \e[33mdef\e[0m \e[36mmain\e[0m(\e[36margs\e[0m: \e\
    [35mArray\e[0m[\e[35mString\e[0m]) = {\n\e[33m\e[33m   |\e[0m    ^\e[0m\n\e[33m\
    \   |\e[0m    Line is indented too far to the left, or a `}` is missing\n1 warning\
    \ found\n4 errors found\n"
  stdout: ''
  timestamp: 1659979863
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer[String]()\n\
    \        lst.foreach { s =>\n            val newStack = mutable.Stack[String]()\n\
    \            val newResult = mutable.ListBuffer[String]()\n            val open\
    \ = s.indexOf('(')\n            val close = s.lastIndexOf(')')\n            val\
    \ newOpen = open + 1\n            val newClose = close + 1\n            val newStr\
    \ = s.substring(newOpen, newClose)\n            val newStr2 = s.substring(newOpen,\
    \ newClose)\n            val newStr3 = s.substring(newOpen, newClose)\n      \
    \      val newStr4 = s.substring(newOpen, newClose)\n            val newStr5 =\
    \ s.substring(newOpen, newClose)\n            val newStr6 = s.substring(newOpen,\
    \ newClose)\n            val newStr7 = s.substring(newOpen, newClose)\n      \
    \      val newStr8 = s.substring(newOpen, newClose)\n            val newStr9 =\
    \ s.substring(newOpen, newClose)\n            val newStr10 = s.substring(newOpen,\
    \ newClose)\n            val newStr11 = s.substring(newOpen, newClose)\n     \
    \       val newStr12 = s.substring(newOpen, newClose)\n            val newStr13\
    \ = s.substring(newOpen, newClose)\n            val newStr14 = s.substring(newOpen,\
    \ newClose)\n            val newStr15 = s.substring(newOpen, newClose)\n     \
    \       val newStr16 = s.substring(newOpen, newClose)\n            val newStr17\
    \ = s.substring(newOpen, newClose)\n            val newStr18 = s.substring(newOpen,\
    \ newClose)\n            val newStr19 = s.substring(newOpen, newClose)\n     \
    \       val newStr20 = s.substring(newOpen, newClose)\n            val newStr21\
    \ = s.substring(newOpen, newClose)\n            val newStr22 = s.substring(newOpen,\
    \ newClose)\n            val newStr23 = s.substring(newOpen, newClose)\n     \
    \       val newStr24 = s.substring(newOpen, newClose)\n            val newStr25\
    \ = s.substring(newOpen, newClose)\n            val newStr26 = s.substring(newOpen,\
    \ newClose)\n            val newStr27 = s.substring(newOpen, newClose)\n     \
    \       val newStr28 = s.substring(newOpen, newClose)\n            val newStr29\
    \ = s.substring(newOpen, \n    }\n    def main(args: Array[String]) = {\n    assert(matchParens((List[String](\"\
    ()(\", \")\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\"\
    , \")\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(())\"\
    , \"())())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")())\"\
    , \"(()()(\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"(())))\"\
    , \"(()())((\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"\
    ()\", \"())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(()(\"\
    , \"()))()\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\"((((\"\
    , \"((())\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(()\"\
    , \"(()(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\")(\"\
    , \")(\"))).equals((\"No\")));\n    assert(matchParens((List[String](\"(\", \"\
    )\"))).equals((\"Yes\")));\n    assert(matchParens((List[String](\")\", \"(\"\
    ))).equals((\"Yes\")));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmc4jhmn4.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmc4jhmn4.scala:69:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m69 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpmc4jhmn4.scala:14:20 ------------------------\e[0m\e[0m\n\
    \e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e[35mString\e\
    [0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpmc4jhmn4.scala:15:21 ------------------------\e[0m\e\
    [0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpmc4jhmn4.scala:17:27 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m            \e[33mval\e[0m \e[36mnewStack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmc4jhmn4.scala:18:28 ------------------------\e\
    [0m\e[0m\n\e[31m18 |\e[0m            \e[33mval\e[0m \e[36mnewResult\e[0m = mutable.ListBuffer[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                            ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: mutable\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmc4jhmn4.scala:68:1 ---------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m}\n\e[31m\e[31m   |\e"
  stdout: ''
  timestamp: 1659979864
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You are given a list of two strings, both strings consist of open\n\
    \    // parentheses '(' or close parentheses ')' only.\n    // Your job is to\
    \ check if it is possible to concatenate the two strings in\n    // some order,\
    \ that the resulting string will be good.\n    // A string S is considered to\
    \ be good if and only if all parentheses in S\n    // are balanced. For example:\
    \ the string '(())()' is good, while the string\n    // '())' is not.\n    //\
    \ Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\
    \    // Examples:\n    def matchParens(lst : List[String]) : String = {\n    \
    \    val stack = mutable.Stack[String]()\n        val result = mutable.ListBuffer.empty[String]\n\
    \        val open = mutable.Set[String]()\n        val close = mutable.Set[String]()\n\
    \        lst.foreach { s =>\n            if (s.startsWith(\"(\")) {\n        \
    \        open += s\n            } else if (s.startsWith(\")\")) {\n          \
    \      close += s\n            } else {\n                stack += s\n        \
    \    }\n        }\n        if (open.isEmpty && close.isEmpty) {\n            result.append(\"\
    Yes\")\n        } else {\n            while (!stack.isEmpty) {\n             \
    \   val s = stack.pop()\n                if (close.contains(s)) {\n          \
    \          result.append(\"No\")\n                    break\n                }\n\
    \                if (open.contains(s)) {\n                    result.append(\"\
    Yes\")\n                    break\n                }\n                result.append(\"\
    Yes\")\n            }\n        }\n        result.toString()\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(matchParens((List[String](\"()(\", \")\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\")\", \")\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(()(())\", \"())())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")())\", \"(()()(\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"(())))\", \"(()())((\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"()\", \"())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\"(()(\", \"()))()\"))).equals((\"\
    Yes\")));\n    assert(matchParens((List[String](\"((((\", \"((())\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(()\", \"(()(\"))).equals((\"\
    No\")));\n    assert(matchParens((List[String](\")(\", \")(\"))).equals((\"No\"\
    )));\n    assert(matchParens((List[String](\"(\", \")\"))).equals((\"Yes\")));\n\
    \    assert(matchParens((List[String](\")\", \"(\"))).equals((\"Yes\")));\n  \
    \  }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0fy2honh.scala:14:20 ------------------------\e\
    [0m\e[0m\n\e[31m14 |\e[0m        \e[33mval\e[0m \e[36mstack\e[0m = mutable.Stack[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0fy2honh.scala:15:21 ------------------------\e\
    [0m\e[0m\n\e[31m15 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ListBuffer.empty[\e\
    [35mString\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp0fy2honh.scala:16:19 ------------------------\e\
    [0m\e[0m\n\e[31m16 |\e[0m        \e[33mval\e[0m \e[36mopen\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmp0fy2honh.scala:17:20 ------------------------\e\
    [0m\e[0m\n\e[31m17 |\e[0m        \e[33mval\e[0m \e[36mclose\e[0m = mutable.Set[\e\
    [35mString\e[0m]()\n\e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                    Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmp0fy2honh.scala:34:20 ------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m                    break\n\e[31m\e[31m   |\e[0m    \
    \                ^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: break\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0fy2honh.scala:38:20\
    \ ------------------------\e[0m\e[0m\n\e[31m38 |\e[0m                    break\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not foun"
  stdout: ''
  timestamp: 1659979863
