language: scala
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots - hungry\n        val hungryMeals = meals - hungry\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8bfn90x2.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val leftCarrots = remaining - carrots\n        val result = if (hungry) List(meals,\
    \ leftCarrots) else List(0, 0)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpfi6b7kbr.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    \e[1m\e[31m(\e\
    [0m\e[1m\e[31mresult\e[0m\e[1m\e[31m \e[0m\e[1m\e[31m:\e[0m\e[1m\e[31m \e[0mList[Long\e\
    [1m\e[31m \e[0m\e[1m\e[31m|\e[0m\e[1m\e[31m \e[0m\e[1m\e[31mInt\e[0m]\e[1m\e[31m)\e\
    [0m\n\e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val carrots_left = mutable.ArrayBuffer(need)\n        var carrots_eaten\
    \ = 0\n        var carrots_left2 = 0\n        while(carrots_eaten < carrots.size\
    \ && carrots_left2 < carrots_left.size) {\n            carrots_eaten += carrots(carrots_eaten)\n\
    \            carrots_left2 += carrots_left(carrots_left2)\n        }\n       \
    \ if(carrots_eaten < carrots.size) {\n            carrots_eaten += carrots.size\
    \ - carrots_eaten\n        }\n        if(carrots_left2 < carrots_left.size) {\n\
    \            carrots_left2 += carrots_left.size - carrots_left2\n        }\n \
    \       carrots_eaten :: carrots_left2\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpaust4cx5.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpaust4cx5.scala:24:27 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmpaust4cx5.scala:37:22 ------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        carrots_eaten :: carrots_left2\n\e[31m\e[31m\
    \   |\e[0m                      ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \               value :: is not a member of Int\n3 errors found\n"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val carrots_left = need - carrots\n        val carrots_left_after_meals\
    \ = carrots - carrots_left\n        val carrots_left_after_meals_after_meals =\
    \ carrots_left - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals - carrots_left_after_meals_after_meals\n        val\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_me\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp33rhr4wl.scala:30:174 --------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                                          ^\e[0m\n\e[31m   |\e[0mRecursive \e\
    [33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp33rhr4wl.scala:31:111 -----------------------\e[0m\e[0m\n\e[31m31 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp33rhr4wl.scala:32:147\
    \ -----------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m ="
  stdout: ''
  timestamp: 1660010459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrots_left = remaining - carrots\n        val meals = List(need\
    \ + carrots)\n        val carrots_left_after_meals = carrots - carrots_left\n\
    \        val carrots_after_meals = List(need + carrots_left)\n        val carrots_after_meals_left\
    \ = carrots_left - carrots_left_after_meals\n        val carrots_after_meals_left_after_meals\
    \ = carrots_left_after_meals - carrots_after_meals\n        val carrots_after_meals_left_after_meals_left\
    \ = carrots_left_after_meals_left - carrots_after_meals_left\n        val carrots_after_meals_left_after_meals_left_after_meals\
    \ = carrots_left_after_meals_left_after_meals - carrots_after_meals_left_after_meals\n\
    \        val carrots_after_meals_left_after_meals_left_after_meals_left = carrots_left_after_meals_left_after_meals_left\
    \ - carrots_after_meals_left_after_meals_left\n        val carrots_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ = carrots_left_after_meals_left_after_meals_left_after_meals - carrots_after_meals_left_after_meals_left_after_meals\n\
    \        val carrots_after_meals_left_after_meals_left_after_meals_left_after_meals_left\
    \ = carrots_left_after_meals_left_after_meals_left_after_meals - carrots_after_meals_left_after_meals_left_after_meals_left\n\
    \        val carrots_after_meals_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ = carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ - carrots_after_meals_left_after_meals_left_after_meals_left_after_meals_left\n\
    \        val carrots_after_meals_left_after_meals_left_after_meals_left_after_meals_left_after_meals_left\
    \ = carrots_left_after_meals_left_after_meals_left_after_meals_left_after_meals_left_after_meals\
    \ - carrots_after_meals_left_after_me\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmpwm6wuvfj.scala:29:76 -----------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_left_after_meals\e\
    [0m = carrots_left_after_meals - carrots_after_meals\n\e[31m\e[31m   |\e[0m  \
    \                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e\
    [35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x:\
    \ Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long):\
    \ Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m\
    \   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch\
    \ arguments ((carrots_after_meals : List[Long]))\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpwm6wuvfj.scala:30:56 ------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_left_after_meals_left\e\
    [0m = carrots_left_after_meals_left - carrots_after_meals_left\n\e[31m\e[31m \
    \  |\e[0m                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: carrots_left_after_meals_left\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwm6wuvfj.scala:31:68\
    \ ------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_after_meals_left_after_meals_left_after_meals\e[0m = carrots_left_after_meals_left_after_meals\
    \ - carrots_after_meals_left_after_meals\n\e[31m\e[31m   |\e[0m              \
    \                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                    Not found: carrots_left_after_meals_left_after_meals\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpwm6wuvfj.scala:32:73\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_after_meals_left_after_meals_left_after_meals_left\e[0m = car"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = math.min(math.max(math.ceil(remaining\
    \ / 5), 1), 10)\n        val carrotsLeft = math.min(math.max(math.ceil(remaining\
    \ / meals), 1), 10)\n        val carrotsLeftList = List(carrotsLeft)\n       \
    \ val mealsLeft = math.min(math.max(math.ceil(remaining / carrotsLeft), 1), 10)\n\
    \        val mealsLeftList = List(mealsLeft)\n        val mealsLeftAndCarrotsLeft\
    \ = mealsLeft + carrotsLeft\n        val mealsLeftAndCarrotsLeftList = List(mealsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeft = mealsLeftAndCarrotsLeft +\
    \ carrotsLeftList\n        val mealsLeftAndCarrotsLeftAndCarrotsLeftList = List(mealsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft = mealsLeftAndCarrotsLeftAndCarrotsLeft\
    \ + carrotsLeftList\n        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList\
    \ = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft\
    \ = mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft + carrotsLeftList\n  \
    \      val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList\
    \ = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft)\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft\
    \ = mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft + carrotsLeftList\n\
    \        val mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftList\
    \ = List(mealsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeftAndCarrotsLeft\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpphicud7f.scala:40:4 ----------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpphicud7f.scala:24:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining - carrots\n\e[31m\e[31m   |\e[0m          \
    \              ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E134] Type Error:\
    \ /tmp/tmpphicud7f.scala:32:76 -----------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsLeftAndCarrotsLeftAndCarrotsLeft\e[0m\
    \ = mealsLeftAndCarrotsLeft + carrotsLeftList\n\e[31m\e[31m   |\e[0m         \
    \                                           ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m+\e\
    [0m in \e[33mclass\e[0m \e[35mDouble\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Double\n\e[31m   |\e[0m (x: Long): Double\n\
    \e[31m   |\e[0m (x: Int): Double\n\e[31m   |\e[0m (x: Char): Double\n\e[31m  \
    \ |\e[0m (x: Short): Double\n\e[31m   |\e[0m (x: Byte): Double\n\e[31m   |\e[0m\
    \ (x: String): String\n\e[31m   |\e[0mmatch arguments ((carrotsLeftList : List[Double]))\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpphicud7f.scala:40:5 ---------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals + carrots\n\
    \        val mealsRight = meals - carrots\n        val mealsLeft = mealsLeft +\
    \ carrots\n        val mealsRight = mealsRight + carrots\n        val mealsLeft\
    \ = mealsLeft + carrots\n        val mealsRight = mealsRight + carrots\n     \
    \   val mealsLeft = mealsLeft + carrots\n        val mealsRight = mealsRight +\
    \ carrots\n        val mealsLeft = mealsLeft + carrots\n        val mealsRight\
    \ = mealsRight + carrots\n        val mealsLeft = mealsLeft + carrots\n      \
    \  val mealsRight = mealsRight + carrots\n        val mealsLeft = mealsLeft +\
    \ carrots\n        val mealsRight = mealsRight + carrots\n        val mealsLeft\
    \ = mealsLeft + carrots\n        val mealsRight = mealsRight + carrots\n     \
    \   val mealsLeft = mealsLeft + carrots\n        val mealsRight = mealsRight +\
    \ carrots\n        val mealsLeft = mealsLeft + carrots\n        val mealsRight\
    \ = mealsRight + carrots\n        val mealsLeft = mealsLeft + carrots\n      \
    \  val mealsRight = mealsRight + carrots\n        val mealsLeft = mealsLeft +\
    \ carrots\n        val mealsRight = mealsRight + carrots\n        val mealsLeft\
    \ = mealsLeft + carrots\n        val mealsRight = mealsRight + carrots\n     \
    \   val mealsLeft = mealsLeft + carrots\n        val mealsRight = mealsRight +\
    \ carrots\n        val mealsLeft = mealsLeft + carrots\n        val mealsRight\
    \ = mealsRight + carrots\n        val mealsLeft = mealsLeft + carrots\n      \
    \  val mealsRight = mealsRight + carrots\n        val mealsLeft = mealsLeft +\
    \ carrots\n        val mealsRight = mealsRight + carrots\n        val mealsLeft\
    \ = mealsLeft + carrots\n        val mealsRight = mealsRight + carrots\n     \
    \   val mealsLeft = mealsLeft \n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpszysx05h.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft\
    \ + carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpszysx05h.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mmealsRight\e[0m = mealsRight + carrots\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmealsRight is already defined as \e[33mvalue\e[0m \e[35mmealsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpszysx05h.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft + carrots\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpszysx05h.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsRight\e[0m = mealsRight + carrots\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmealsRight is already defined as \e[33mvalue\e[0m \e[35mmealsRight\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpszysx05h.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft + carrots\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmealsLeft is already defined as \e[3"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrotsLeft = remaining - carrots\n        val meals = carrotsLeft\
    \ / 3\n        val carrotsLeft2 = carrotsLeft % 3\n        val carrotsLeft3 =\
    \ carrotsLeft2 / 3\n        val carrotsLeft4 = carrotsLeft3 % 3\n        val carrotsLeft5\
    \ = carrotsLeft4 / 3\n        val carrotsLeft6 = carrotsLeft5 % 3\n        val\
    \ carrotsLeft7 = carrotsLeft6 / 3\n        val carrotsLeft8 = carrotsLeft7 % 3\n\
    \        val carrotsLeft9 = carrotsLeft8 / 3\n        val carrotsLeft10 = carrotsLeft9\
    \ % 3\n        val carrotsLeft11 = carrotsLeft10 / 3\n        val carrotsLeft12\
    \ = carrotsLeft11 % 3\n        val carrotsLeft13 = carrotsLeft12 / 3\n       \
    \ val carrotsLeft14 = carrotsLeft13 % 3\n        val carrotsLeft15 = carrotsLeft14\
    \ / 3\n        val carrotsLeft16 = carrotsLeft15 % 3\n        val carrotsLeft17\
    \ = carrotsLeft16 / 3\n        val carrotsLeft18 = carrotsLeft17 % 3\n       \
    \ val carrotsLeft19 = carrotsLeft18 / 3\n        val carrotsLeft20 = carrotsLeft19\
    \ % 3\n        val carrotsLeft21 = carrotsLeft20 / 3\n        val carrotsLeft22\
    \ = carrotsLeft21 % 3\n        val carrotsLeft23 = carrotsLeft22 / 3\n       \
    \ val carrotsLeft24 = carrotsLeft23 % 3\n        val carrotsLeft25 = carrotsLeft24\
    \ / 3\n        val carrotsLeft26 = carrotsLeft25 % 3\n        val carrotsLeft27\
    \ = carrotsLeft26 / 3\n        val carrotsLeft28 = carrotsLeft27 % 3\n       \
    \ val carrotsLeft29 = carrotsLeft28 / 3\n        val carrotsLeft30 = carrotsLeft29\
    \ % 3\n        val carrotsLeft31 = carrotsLeft30 / 3\n        val carrotsLeft32\
    \ = carrotsLeft\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpwzzl__4j.scala:57:5\
    \ ---------------------\e[0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val left  = mutable.ArrayBuffer(remaining)\n\
    \        val meals  = mutable.ArrayBuffer(number)\n        val result = mutable.ArrayBuffer(number)\n\
    \        val hungryCount = mutable.ArrayBuffer(number)\n        val leftCount\
    \  = mutable.ArrayBuffer(number)\n        val mealsCount = mutable.ArrayBuffer(number)\n\
    \        val hungryCount2 = mutable.ArrayBuffer(number)\n        val leftCount2\
    \  = mutable.ArrayBuffer(number)\n        val mealsCount2 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount3 = mutable.ArrayBuffer(number)\n        val leftCount3\
    \  = mutable.ArrayBuffer(number)\n        val mealsCount3 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount4 = mutable.ArrayBuffer(number)\n        val leftCount4\
    \  = mutable.ArrayBuffer(number)\n        val mealsCount4 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount5 = mutable.ArrayBuffer(number)\n        val leftCount5\
    \  = mutable.ArrayBuffer(number)\n        val mealsCount5 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount6 = mutable.ArrayBuffer(number)\n        val leftCount6\
    \  = mutable.ArrayBuffer(number)\n        val mealsCount6 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount7 = mutable.ArrayBuffer(number)\n        val leftCount7\
    \  = mutable.ArrayBuffer(number)\n        val mealsCount7 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount8 = mutable.ArrayBuffer(number)\n        val leftCount8\
    \  = mutable.ArrayBuffer(number)\n        val mealsCount8 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount9 = mutable.ArrayBuffer(number)\n        val leftCount9\
    \  = mutable.ArrayBuffer(number)\n        val mealsCount9 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount10 = mutable.ArrayBuffer(number)\n        val leftCount10\
    \ = mutable.ArrayBuffer(number)\n        val mealsCount10 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount11 = mutable.ArrayBuffer(number)\n        val leftCount11\
    \ = mutable.ArrayBuffer(number)\n        val mealsCount11 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount12 = mutable.ArrayBuffer(number)\n        val leftCount12\
    \ = mutable.ArrayBuffer(number)\n        val mealsCount12 = mutable.ArrayBuffer(number)\n\
    \        val hungryCount\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx6csk_55.scala:65:4 ----------------------------\e\
    [0m\e[0m\n\e[31m65 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx6csk_55.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx6csk_55.scala:24:21\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx6csk_55.scala:25:20\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mleft\e[0m  = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m       \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx6csk_55.scala:26:21\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mmeals\e[0m  = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m         \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx6csk_55.scala:27:21\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m         \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e"
  stdout: ''
  timestamp: 1660010460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        if (remaining <= 0) {\n            val carrots = number - remaining\n\
    \            val meals = need - carrots\n            val result = List(meals,\
    \ carrots)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj26tvgy.scala:34)\n\tat Problem.main(tmpmj26tvgy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(carrots, meals)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp09_tw5ij.scala:29)\n\tat Problem.main(tmp09_tw5ij.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots - hungry\n        val hungryMeals = meals - hungry\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8bfn90x2.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val hungry = math.min(need, carrots)\n        val eaten = math.min(need,\
    \ carrots - hungry)\n        val left  = math.min(need, carrots - eaten)\n   \
    \     List(math.max(hungry, 0), math.max(eaten, 0)) :: eat(left, need, remaining)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpy6ho3xol.scala:27:12\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        List(math.max(hungry,\
    \ \e[31m0\e[0m), math.max(eaten, \e[31m0\e[0m)) :: eat(left, need, remaining)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0m        Found:    \e[1m\e[31mList\e[0m\e[1m\e[31m[\e[0mLong\e[1m\e\
    [31m]\e[0m\n\e[31m   |\e[0m        Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010458
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingArray = Array.ofDim[Long](mealsRemaining)\n\
    \        val mealsRemainingArrayArray = Array.ofDim[Array[Long]](meals)\n    \
    \    val mealsRemainingArrayArrayArray = Array.ofDim[Array[Array[Long]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArray = Array.ofDim[Array[Array[Array[Long]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArray = Array.ofDim[Array[Array[Array[Array[Long]]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArray = Array.ofDim[Array[Array[Array[Array[Array[Long]]]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArray = Array.ofDim[Array[Array[Array[Array[Array[Long]]]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArray = Array.ofDim[Array[Array[Array[Array[Array[Array[Long]]]]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArray = Array.ofDim[Array[Array[Array[Array[Array[Array[Long]]]]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArray = Array.ofDim[Array[Array[Array[Array[Array[Array[Long]]]]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArray = Array.ofDim[Array[Array[Array[Array[Array[Array[Long]]]]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array.ofDim[Array[Array[Array[Array[Array[Array[Array[Long]]]]]]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array.ofDim[Array[Array[Array[Array[Array[Array[Array[Long]]]]]]]]](meals)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array.ofDim[Array[Array[Array[Array[\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- Error: /tmp/tmpdm40p0b1.scala:37:145 ----------------------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\e\
    [0m = Array.ofDim[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mArray\e\
    [0m[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mLong\e[0m]]]]]]]]](meals)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \             ^\e[0m\n\e[31m   |\e[0m                                 end of statement\
    \ expected but ']' found\n\e[31m\e[31m-- Error: /tmp/tmpdm40p0b1.scala:38:150\
    \ ----------------------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e\
    [33mval\e[0m \e[36mmealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\e\
    [0m = Array.ofDim[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mArray\e\
    [0m[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mLong\e[0m]]]]]]]]](meals)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \                  ^\e[0m\n\e[31m   |\e[0m                                 end\
    \ of statement expected but ']' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpdm40p0b1.scala:40:4\
    \ ----------------------------\e[0m\e[0m\n\e[31m40 |\e[0m    }\n\e[31m\e[31m \
    \  |\e[0m    ^\e[0m\n\e[31m   |\e[0m    an identifier expected, but '}' found\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdm40p0b1.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayArrayArrayArrayArrayArray\e\
    [0m = Array.ofDim[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mArray\e[0m[\e[35mArray\e\
    [0m[\e[35mArray\e[0m[\e[35mLong\e[0m]]]]]](meals)\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayArrayArrayArrayArrayArray is already defined\
    \ as \e[33mvalue\e[0m \e[35mmealsRemainingArrayArrayArrayArrayArrayArray\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   "
  stdout: ''
  timestamp: 1660010462
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number\
    \ - remaining\n        val hungryRabbits = math.min(need, hungryRabbit)\n    \
    \    val hungryRabbits = math.max(0, hungryRabbits)\n        val hungryRabbits\
    \ = math.max(0, hungryRabbits)\n        val hungryRabbits = math.max(0, hungryRabbits)\n\
    \        val hungryRabbits = math.max(0, hungryRabbits)\n        val hungryRabbits\
    \ = math.max(0, hungryRabbits)\n        val hungryRabbits = math.max(0, hungryRabbits)\n\
    \        val hungryRabbits = math.max(0, hungryRabbits)\n        val hungryRabbits\
    \ = math.max(0, hungryRabbits)\n        val hungryRabbits = math.max(0, hungryRabbits)\n\
    \        val hungryRabbits = math.max(0, hungryRabbits)\n        val hungryRabbits\
    \ = math.max(0, hungryRabbits)\n        val hungryRabbits = math.max(0, hungryRabbits)\n\
    \        val hungryRabbits = math.max(0, hungryRabbits)\n        val hungryRabbits\
    \ = math.max(0, hungryRabbits)\n        val hungryRabbits = math.max(0, hungryRabbits)\n\
    \        val hungryRabbits = math.max(0, hungryRabbits)\n        val hungryRabbits\
    \ = math.max(0, hungryRabbits)\n        val hungryRabbits = math.max(0, hungryRabbits)\n\
    \        val hungryRabbits = math.max(0, hungryRabbits)\n        val hungryRabbits\
    \ = math.max(0, hungryRabbits)\n        val hungryRabbits = math.max(0, hungryRabbits)\n\
    \        val hungryRabbits = math.max(0, hungryRabbits)\n        val hungryRabbits\
    \ = math.max(0, hun\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpmnxz6zju.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpmnxz6zju.scala:25:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryRabbits\e[0m = math.max(\e[31m0\e[0m, hungryRabbits)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmnxz6zju.scala:26:12 ---------------------------\e[0m\e[0m\n\e\
    [31m26 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = math.max(\e[31m0\e\
    [0m, hungryRabbits)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmnxz6zju.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = math.max(\e[31m0\e\
    [0m, hungryRabbits)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpmnxz6zju.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = math.max(\e[31m0\e\
    [0m, hungryRabbits)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ def"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val hungry = math.max(0, carrots - need)\n        val eaten = math.max(0,\
    \ carrots + need)\n        val remaining = math.max(0, carrots - eaten)\n    \
    \    List(math.max(0, carrots), math.max(0, remaining))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp64_tiqe1.scala:26:36 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = math.max(\e\
    [31m0\e[0m, carrots - eaten)\n\e[31m\e[31m   |\e[0m                          \
    \          ^\e[0m\n\e[31m   |\e[0m                                    Recursive\
    \ \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010451
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftString = mealsLeft.toString\n\
    \        val mealsLeftArray = mealsLeftString.toCharArray\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeftArray.length\n        val mealsLeftArrayLength = mealsLeftArray.length\n\
    \        val mealsLeftArrayLength = mealsLeftArray.length\n        val mealsLeftArrayLength\
    \ = mealsLeft\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp81x7ia0s.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftArrayLength\e[0m\
    \ = mealsLeftArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp81x7ia0s.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftArrayLength\e[0m\
    \ = mealsLeftArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp81x7ia0s.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftArrayLength\e[0m\
    \ = mealsLeftArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp81x7ia0s.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftArrayLength\e[0m\
    \ = mealsLeftArray.length\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftArrayLength is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftArrayLength\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp81x7ia0s.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val carrots_left = need - carrots\n        val carrots_left_to_eat =\
    \ (carrots_left / carrots).toInt\n        val carrots_left_to_eat_with_extra =\
    \ carrots_left % carrots\n        val carrots_left_to_eat_with_extra_with_extra\
    \ = carrots_left_to_eat_with_extra * carrots\n        val carrots_left_to_eat_with_extra_with_extra_with_extra\
    \ = carrots_left_to_eat_with_extra_with_extra * carrots\n        val carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_left_to_eat_with_extra_with_extra_with_extra * carrots\n        val\
    \ carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra =\
    \ carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra * carrots\n\
    \        val carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ * carrots\n        val carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ * carrots\n        val carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ * carrots\n        val carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ * carrots\n        val carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ * carrots\n        val carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ * carrots\n        val carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpt8hd0kmo.scala:37:143 --------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\e\
    [0m = \n\e[31m\e[31m   |\e[0m                                                \
    \                                                                            \
    \                   ^\e[0m\n\e[31m   |\e[0m                                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpt8hd0kmo.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\e\
    [0m = carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ * carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmpt8hd0kmo.scala:36:12 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra_with_extra\e\
    [0m = carrots_left_to_eat_with_extra_with_extra_with_extra_with_extra_with_extra\
    \ * carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining2\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining3 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining4 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining5\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining6 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining7 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining8\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining9 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining10 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining11 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining12\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining13 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining14 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining15 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining16\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining17 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining18 = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedsRemaining19 = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining20\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining21 = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemaining22 = mutable.ListBuffer[Long]()\n\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxt70z8on.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpxt70z8on.scala:24:21 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpxt70z8on.scala:25:30 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                              ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                              Not found: mutable\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxt70z8on.scala:26:26 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhungryNeeds\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpxt70z8on.scala:27:35 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedsRemaining\e[0m\
    \ = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \          Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpxt70z8on.scala:28:36 "
  stdout: ''
  timestamp: 1660010459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingInt = mealsRemaining.toInt\n        val mealsRemainingIntArray\
    \ = Array.ofDim[Int](mealsRemainingInt)\n        val mealsRemainingArray = mealsRemainingIntArray.map(x\
    \ => mealsRemainingInt - x)\n        val mealsRemainingArrayArray = mealsRemainingArray.map(x\
    \ => Array.ofDim[Int](x))\n        val mealsRemainingArrayArrayArray = mealsRemainingArrayArray.map(x\
    \ => x.map(y => mealsRemainingInt - y))\n        val mealsRemainingArrayArrayArrayArray\
    \ = mealsRemainingArrayArrayArray.map(x => x.map(y => Array.ofDim[Int](y)))\n\
    \        val mealsRemainingArrayArrayArrayArray = mealsRemainingArrayArrayArrayArray.map(x\
    \ => x.map(y => Array.ofDim[Int](y)))\n        val mealsRemainingArrayArrayArrayArrayArray\
    \ = mealsRemainingArrayArrayArrayArrayArray.map(x => x.map(y => Array.ofDim[Int](y)))\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArray = mealsRemainingArrayArrayArrayArrayArrayArray.map(x\
    \ => x.map(y => Array.ofDim[Int](y)))\n        val mealsRemainingArrayArrayArrayArrayArrayArray\
    \ = mealsRemainingArrayArrayArrayArrayArrayArrayArray.map(x => x.map(y => Array.ofDim[Int](y)))\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArray = mealsRemainingArrayArrayArrayArrayArrayArrayArray.map(x\
    \ => x.map(y => Array.ofDim[Int](y)))\n        val mealsRemainingArrayArrayArrayArrayArrayArrayArray\
    \ = mealsRemainingArrayArrayArrayArrayArrayArrayArrayArray.map(x => x.map(y =>\
    \ Array.ofDim[Int](y)))\n        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArray\
    \ = mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArray.map(x => x.map(y\
    \ => Array.ofDim[Int](y)))\n        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArray.map(x =>\
    \ x.map(y => Array.ofDim[Int](y)))\n        val mealsRemain\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpr86d9fm7.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr86d9fm7.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayArrayArrayArray\e[0m = mealsRemainingArrayArrayArrayArray.map(\e\
    [36mx\e[0m => x.map(\e[36my\e[0m => Array.ofDim[\e[35mInt\e[0m](y)))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayArrayArrayArray is already defined as \e\
    [33mvalue\e[0m \e[35mmealsRemainingArrayArrayArrayArray\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpr86d9fm7.scala:35:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayArrayArrayArrayArrayArray\e[0m = mealsRemainingArrayArrayArrayArrayArrayArrayArray.map(\e\
    [36mx\e[0m => x.map(\e[36my\e[0m => Array.ofDim[\e[35mInt\e[0m](y)))\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayArrayArrayArrayArrayArray is already defined\
    \ as \e[33mvalue\e[0m \e[35mmealsRemainingArrayArrayArrayArrayArrayArray\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpr86d9fm7.scala:37:12 ---------------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayArrayArrayArrayArrayArrayArray\e\
    [0m = mealsRemainingArrayArrayArrayArrayArrayArrayArrayArray.map(\e[36mx\e[0m\
    \ => x.map(\e[36my\e[0m => Array.ofDim[\e[35mInt\e[0m](y)))\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010462
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        if (carrots > 0) {\n            val newRemaining = remaining - carrots\n\
    \            val newNumber = number + carrots\n            val newNeed = need\
    \ + carrots\n            val newResult = eat(newNumber, newNeed, newRemaining)\n\
    \            result ::: newResult\n        } else {\n            result\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo01gxct8.scala:37)\n\tat Problem.main(tmpo01gxct8.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungry = mutable.ArrayBuffer.empty[Long]\n        val hungryCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount2 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount3 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount4\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount5 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount6 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount7\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount8 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount9 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount10\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount11 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount12 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount13\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount14 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount15 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount16\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount17 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount18 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount19\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount20 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount21 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount22\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount23 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount24 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount25\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount26 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount27 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount28\
    \ = mut\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:24:21 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:25:26 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:26:27 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhungryCount2\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhungryCount3\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:28:27 --------"
  stdout: ''
  timestamp: 1660010459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val hungry = carrots <= need\n        val hungryCarrots = if (hungry)\
    \ carrots else 0\n        val hungryRemaining = if (hungry) remaining - carrots\
    \ else 0\n        val hungryEaten = if (hungry) need - carrots else 0\n      \
    \  val hungryEatenCarrots = if (hungryEaten) hungryEaten else 0\n        val hungryEatenRemaining\
    \ = if (hungryEaten) hungryEaten else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n        val hungryEatenRemainingCarrots\
    \ = if (hungryEatenRemaining) hungryEatenRemaining else 0\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdiww5b0p.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryEatenRemainingCarrots\e\
    [0m = \e[33mif\e[0m (hungryEatenRemaining) hungryEatenRemaining \e[33melse\e[0m\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryEatenRemainingCarrots is already defined as \e[33mvalue\e\
    [0m \e[35mhungryEatenRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdiww5b0p.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryEatenRemainingCarrots\e\
    [0m = \e[33mif\e[0m (hungryEatenRemaining) hungryEatenRemaining \e[33melse\e[0m\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryEatenRemainingCarrots is already defined as \e[33mvalue\e\
    [0m \e[35mhungryEatenRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdiww5b0p.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryEatenRemainingCarrots\e\
    [0m = \e[33mif\e[0m (hungryEatenRemaining) hungryEatenRemaining \e[33melse\e[0m\
    \ \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryEatenRemainingCarrots is already defined as \e[33mvalue\e\
    [0m \e[35mhungryEatenRemainingCarrots\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpdiww5b0p.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryEatenRemainingCarrots\e\
    [0m = \e[33mif\e[0m (hungryEatenRemaining) hungryEatenRemaining \e[33mels"
  stdout: ''
  timestamp: 1660010461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number - remaining\n\
    \        val left  = need - eaten\n        val meals = List(left, remaining)\n\
    \        meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp88uzw0_w.scala:29)\n\tat Problem.main(tmp88uzw0_w.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010476
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots - hungry\n        val hungryCarrotsToEat = meals\
    \ - hungry\n        val hungryCarrotsToEatList = List(hungryCarrotsToEat)\n  \
    \      val hungryCarrotsToEatListWithRemaining = hungryCarrotsToEatList.take(remaining)\n\
    \        val hungryCarrotsToEatListWithRemainingList = List(hungryCarrotsToEatListWithRemaining)\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemaining = hungryCarrotsToEatListWithRemaining.take(remaining)\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingList = List(hungryCarrotsToEatListWithRemainingListWithRemaining)\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingListWithRemaining.take(remaining)\n   \
    \     val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingList\
    \ = List(hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemaining)\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingList.take(remaining)\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemainingList.take(remaining)\n\
    \        val hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemainingListWithRemainingListWithRemainingListWithRemaining\
    \ = hungryCarrotsToEatListWithRemainingListWithRemainingListWithRemain\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E134] Type Error: /tmp/tmptl176w79.scala:26:36 -----------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = carrots\
    \ - hungry\n\e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e\
    [0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double):\
    \ Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\
    \e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x: Char): Long\n\e[31m   |\e\
    [0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\e[31m   |\e[0mmatch arguments\
    \ ((hungry : Boolean))\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmptl176w79.scala:27:39\
    \ -----------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e\
    [0m \e[36mhungryCarrotsToEat\e[0m = meals - hungry\n\e[31m\e[31m   |\e[0m    \
    \                             ^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded\
    \ alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e\
    [0m with types\n\e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float):\
    \ Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m\
    \   |\e[0m (x: Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m\
    \ (x: Byte): Long\n\e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmptl176w79.scala:29:78 --------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsToEatListWithRemaining\e\
    [0m = hungryCarrotsToEatList.take(remaining)\n\e[31m\e[31m   |\e[0m          \
    \                                                                    ^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                            Found:    (remaining\
    \ : Long)\n\e[31m   |\e[0m                                            Required:\
    \ Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmptl176w79.scala:31:108\
    \ -------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsToEatListWithRemainingListWithRemaining\e\
    [0m = hungryCarrotsToEatListWit"
  stdout: ''
  timestamp: 1660010482
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrotsLeft = remaining - carrots\n        val carrotsLeftAfterMeals\
    \ = carrotsLeft - carrots // carrots left after meals\n        val carrotsLeftAfterMealsRemaining\
    \ = carrotsLeft - carrotsLeftAfterMeals // carrots left after meals remaining\n\
    \        val carrotsLeftAfterMealsRemainingArray = Array(carrotsLeftAfterMealsRemaining)\
    \ //convert to array\n        val carrotsLeftAfterMealsRemainingArrayLength =\
    \ carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val carrotsLeftAfterMealsRemainingArrayLength\
    \ = carrotsLeftAfterMealsRemainingArray.length\n        val \n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpuvr38e60.scala:44:11 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E161] Naming Error: /tmp/tmpuvr38e60.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeftAfterMealsRemainingArrayLength\e\
    [0m = carrotsLeftAfterMealsRemainingArray.length\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsLeftAfterMealsRemainingArrayLength is already defined\
    \ as \e[33mvalue\e[0m \e[35mcarrotsLeftAfterMealsRemainingArrayLength\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuvr38e60.scala:30:12 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeftAfterMealsRemainingArrayLength\e\
    [0m = carrotsLeftAfterMealsRemainingArray.length\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsLeftAfterMealsRemainingArrayLength is already defined\
    \ as \e[33mvalue\e[0m \e[35mcarrotsLeftAfterMealsRemainingArrayLength\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpuvr38e60.scala:31:12 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeftAfterMealsRemainingArrayLength\e\
    [0m = carrotsLeftAfterMealsRemainingArray.length\n\e[31m\e[31m   |\e[0m      \
    \  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsLeftAfterMealsRemainingArrayLength is already defined\
    \ as \e[33mvalue\e[0m \e[35mcarrotsLeftAfterMealsRemainingArrayLength\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote tha"
  stdout: ''
  timestamp: 1660010477
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingArray = Array.ofDim[Long](mealsRemaining)\n\
    \        val mealsRemainingArrayCopy = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopy2 = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopy3\
    \ = mealsRemainingArrayCopy2.clone()\n        val mealsRemainingArrayCopy4 = mealsRemainingArrayCopy3.clone()\n\
    \        val mealsRemainingArrayCopy5 = mealsRemainingArrayCopy4.clone()\n   \
    \     val mealsRemainingArrayCopy6 = mealsRemainingArrayCopy5.clone()\n      \
    \  val mealsRemainingArrayCopy7 = mealsRemainingArrayCopy6.clone()\n        val\
    \ mealsRemainingArrayCopy8 = mealsRemainingArrayCopy7.clone()\n        val mealsRemainingArrayCopy9\
    \ = mealsRemainingArrayCopy8.clone()\n        val mealsRemainingArrayCopy10 =\
    \ mealsRemainingArrayCopy9.clone()\n        val mealsRemainingArrayCopy11 = mealsRemainingArrayCopy10.clone()\n\
    \        val mealsRemainingArrayCopy12 = mealsRemainingArrayCopy11.clone()\n \
    \       val mealsRemainingArrayCopy13 = mealsRemainingArrayCopy12.clone()\n  \
    \      val mealsRemainingArrayCopy14 = mealsRemainingArrayCopy13.clone()\n   \
    \     val mealsRemainingArrayCopy15 = mealsRemainingArrayCopy14.clone()\n    \
    \    val mealsRemainingArrayCopy16 = mealsRemainingArrayCopy15.clone()\n     \
    \   val mealsRemainingArrayCopy17 = mealsRemainingArrayCopy16.clone()\n      \
    \  val mealsRemainingArrayCopy18 = mealsRemainingArrayCopy17.clone()\n       \
    \ val mealsRemainingArrayCopy19 = mealsRemainingArrayCopy18.clone()\n        val\
    \ mealsRemainingArrayCopy20 = mealsRemainingArrayCopy19.clone()\n        val mealsRemainingArrayCopy21\
    \ = mealsRemainingArrayCopy20.clone()\n        val mealsRemainingArrayCopy22 =\
    \ mealsRemainingArrayCopy21.clone()\n        val mealsRemainingArrayCopy23 = mealsRemainingArrayCopy22.clone()\n\
    \        val mealsRemainingArrayCopy24 = mealsRemainingArrayCopy23.clone()\n \
    \       val mealsRemainingArrayCopy25 = mealsRemainingArrayCopy24.clone()\n  \
    \      \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpplq6xjqi.scala:26:52\
    \ --------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArray\e\
    [0m = Array.ofDim[\e[35mLong\e[0m](mealsRemaining)\n\e[31m\e[31m   |\e[0m    \
    \                                                ^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0m                                       Found:    (mealsRemaining : Long)\n\
    \e[31m   |\e[0m                                       Required: Int\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpplq6xjqi.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxq_q2e_8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e\
    [35mLong\e[0m](carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsArray is already defined as \e[33mvalue\e[0m \e[35mcarrotsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmealsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsArray is already defined as \e[33mvalue\e[0m \e[35mmealsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsArray is already defined as \e[33mvalue\e[0m \e[35mcarrotsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmealsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsArray is already defined as \e[33mvalue\e[0m \e[35mmealsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m]("
  stdout: ''
  timestamp: 1660010482
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val hungry = if (carrots > 0) true else false\n        val meals = if\
    \ (carrots > need) need else carrots\n        val eaten = if (carrots > need)\
    \ carrots - need else 0\n        val left = if (carrots > need) carrots - (need\
    \ - eaten) else 0\n        val result = List(meals, eaten, left)\n        if (hungry)\
    \ result :+ 0\n        else result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpami92918.scala:33)\n\tat Problem.main(tmpami92918.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010482
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrots_left = remaining - carrots\n        val meals = if (carrots_left\
    \ > 0) carrots_left else 0\n        val result = List(meals, carrots)\n      \
    \  result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp57ngz6wy.scala:30)\n\tat Problem.main(tmp57ngz6wy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010482
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeft2 = mealsLeft * mealsLeft\n        val mealsLeft3 = mealsLeft2\
    \ * mealsLeft\n        val mealsLeft4 = mealsLeft3 * mealsLeft\n        val mealsLeft5\
    \ = mealsLeft4 * mealsLeft\n        val mealsLeft6 = mealsLeft5 * mealsLeft\n\
    \        val mealsLeft7 = mealsLeft6 * mealsLeft\n        val mealsLeft8 = mealsLeft7\
    \ * mealsLeft\n        val mealsLeft9 = mealsLeft8 * mealsLeft\n        val mealsLeft10\
    \ = mealsLeft9 * mealsLeft\n        val mealsLeft11 = mealsLeft10 * mealsLeft\n\
    \        val mealsLeft12 = mealsLeft11 * mealsLeft\n        val mealsLeft13 =\
    \ mealsLeft12 * mealsLeft\n        val mealsLeft14 = mealsLeft13 * mealsLeft\n\
    \        val mealsLeft15 = mealsLeft14 * mealsLeft\n        val mealsLeft16 =\
    \ mealsLeft15 * mealsLeft\n        val mealsLeft17 = mealsLeft16 * mealsLeft\n\
    \        val mealsLeft18 = mealsLeft17 * mealsLeft\n        val mealsLeft19 =\
    \ mealsLeft18 * mealsLeft\n        val mealsLeft20 = mealsLeft19 * mealsLeft\n\
    \        val mealsLeft21 = mealsLeft20 * mealsLeft\n        val mealsLeft22 =\
    \ mealsLeft21 * mealsLeft\n        val mealsLeft23 = mealsLeft22 * mealsLeft\n\
    \        val mealsLeft24 = mealsLeft23 * mealsLeft\n        val mealsLeft25 =\
    \ mealsLeft24 * mealsLeft\n        val mealsLeft26 = mealsLeft25 * mealsLeft\n\
    \        val mealsLeft27 = mealsLeft26 * mealsLeft\n        val mealsLeft28 =\
    \ mealsLeft27 * mealsLeft\n        val mealsLeft29 = mealsLeft28 * mealsLeft\n\
    \        val mealsLeft30 = mealsLeft29 * mealsLeft\n        val mealsLeft31 =\
    \ mealsLeft30 * mealsLeft\n        val mealsLeft32 = mealsLeft31 * mealsLeft\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpo3k0ae5u.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo3k0ae5u.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val hungry = carrots > 0\n        val hungryCarrots = carrots - need\n\
    \        val hungryCarrotsToEat = if (hungry) need else remaining\n        val\
    \ hungryCarrotsToEatList = List(hungryCarrotsToEat)\n        val hungryCarrotsToEatListWithRemaining\
    \ = hungryCarrotsToEatList.zipWithIndex.map { case (item, index) =>\n        \
    \    if (index == 0) item else remaining - item\n        }\n        val hungryCarrotsToEatListWithRemainingList\
    \ = hungryCarrotsToEatListWithRemaining.toList\n        if (hungry) {\n      \
    \      hungryCarrotsToEatListWithRemainingList.map { item =>\n               \
    \ if (item > 0) item else remaining\n            }\n        } else {\n       \
    \     hungryCarrotsToEatListWithRemainingList\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp35qn4kt4.scala:41)\n\tat Problem.main(tmp35qn4kt4.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result :: eat(number, need, remaining)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7k6n4z9_.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result :: eat(number,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (result : List[Long])\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        if (meals < 0) result.reverse else result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpy1y912av.scala:29)\n\tat Problem.main(tmpy1y912av.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010482
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result: List[Long] = new ArrayList[Long]()\n\
    \        val hungry = true\n        val hungryIndex = -1\n        val hungryIndex2\
    \ = -1\n        val hungryIndex3 = -1\n        val hungryIndex4 = -1\n       \
    \ val hungryIndex5 = -1\n        val hungryIndex6 = -1\n        val hungryIndex7\
    \ = -1\n        val hungryIndex8 = -1\n        val hungryIndex9 = -1\n       \
    \ val hungryIndex10 = -1\n        val hungryIndex11 = -1\n        val hungryIndex12\
    \ = -1\n        val hungryIndex13 = -1\n        val hungryIndex14 = -1\n     \
    \   val hungryIndex15 = -1\n        val hungryIndex16 = -1\n        val hungryIndex17\
    \ = -1\n        val hungryIndex18 = -1\n        val hungryIndex19 = -1\n     \
    \   val hungryIndex20 = -1\n        val hungryIndex21 = -1\n        val hungryIndex22\
    \ = -1\n        val hungryIndex23 = -1\n        val hungryIndex24 = -1\n     \
    \   val hungryIndex25 = -1\n        val hungryIndex26 = -1\n        val hungryIndex27\
    \ = -1\n        val hungryIndex28 = -1\n        val hungryIndex29 = -1\n     \
    \   val hungryIndex30 = -1\n        val hungryIndex31 = -1\n        val hungryIndex32\
    \ = -1\n        val hungryIndex33 = -1\n        val hungryIndex34 = -1\n     \
    \   val hungryIndex35 = -1\n        val hungryIndex36 = -1\n        val hungryIndex37\
    \ = -1\n        val hungryIndex38 = -1\n        val hungryIndex39 = -1\n     \
    \   val hungryIndex40 = -1\n        val hungryIndex41 = -1\n        val hungryIndex42\
    \ = -1\n        val hungryIndex43 = -1\n        val hungryIndex44 = -1\n     \
    \   val hungryIndex45 = -1\n        val hungryIndex46 = -1\n        val hungry\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmps_x_c1ix.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmps_x_c1ix.scala:25:37\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e\
    [0m[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                \
    \     ^^^^^^^^^\e[0m\n\e[31m   |\e[0m                                     Not\
    \ found: type ArrayList\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmps_x_c1ix.scala:74:5\
    \ ---------------------\e[0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010479
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val leftCarrots = math.max(0,\
    \ carrots - meals)\n        val result = List(meals, leftCarrots)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmplg2eep9h.scala:30)\n\tat Problem.main(tmplg2eep9h.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val carrots_left = need - carrots\n        val carrots_left_to_eat =\
    \ (carrots_left / carrots).toInt\n        val carrots_left_to_eat_with_remaining\
    \ = carrots_left % carrots\n        val carrots_to_eat = if (carrots_left_to_eat_with_remaining\
    \ > 0) carrots_left_to_eat_with_remaining else carrots_left_to_eat\n        val\
    \ carrots_to_eat_with_remaining = if (carrots_to_eat > 0) carrots_to_eat else\
    \ 0\n        val carrots_to_eat_with_remaining_with_remaining = if (carrots_to_eat_with_remaining\
    \ > 0) carrots_to_eat_with_remaining else 0\n        val carrots_to_eat_with_remaining_with_remaining_with_remaining\
    \ = if (carrots_to_eat_with_remaining_with_remaining > 0) carrots_to_eat_with_remaining_with_remaining\
    \ else 0\n        val carrots_to_eat_with_remaining_with_remaining_with_remaining_with_remaining\
    \ = if (carrots_to_eat_with_remaining_with_remaining_with_remaining > 0) carrots_to_eat_with_remaining_with_remaining_with_remaining\
    \ else 0\n        val carrots_to_eat_with_remaining_with_remaining_with_remaining_with_remaining_with_remaining\
    \ = if (carrots_to_eat_with_remaining_with_remaining_with_remaining > 0) carrots_to_eat_with_remaining_with_remaining_with_remaining_with_remaining\
    \ else 0\n        val carrots_to_eat_with_remaining_with_remaining_with_remaining_with_remaining_with_remaining_with_remaining\
    \ = if (carrots_to_eat_with_remaining_with_remaining_with_remaining_with_remaining\
    \ > 0) carrots_to_eat_with_remaining_with_remaining_with_remaining_with_remaining_with_remaining\
    \ else 0\n        val carrots_to_eat_with_remaining_with_remaining_with_remaining_with_remaining_with_remaining_with_remaining_with_remaining\
    \ = if (carrots_to_eat_with_remaining_with_remaining_with_remaining_with_remaining_with_remaining\
    \ > 0) carrots_to_eat_with_remaining_with_remain\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpylq17uuy.scala:28:63 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcarrots_to_eat_with_remaining\e\
    [0m = \e[33mif\e[0m (carrots_to_eat > \e[31m0\e[0m) carrots_to_eat \e[33melse\e\
    [0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                                      \
    \          ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue > is not a member of AnyVal,\
    \ but could be made available as an extension method.\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0mOne of the following imports might make progress towards fixing the\
    \ problem:\n\e[31m   |\e[0m\n\e[31m   |\e[0m  import math.Ordered.orderingToOrdered\n\
    \e[31m   |\e[0m  import math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e\
    [0m\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpylq17uuy.scala:29:93 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mcarrots_to_eat_with_remaining_with_remaining\e\
    [0m = \e[33mif\e[0m (carrots_to_eat_with_remaining > \e[31m0\e[0m) carrots_to_eat_with_remaining\
    \ \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                        \
    \                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mvalue > is not a member of AnyVal, but could be made available\
    \ as an extension method.\n\e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following\
    \ imports might make progress towards fixing the problem:\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m  import math.Ordered.orderingToOrdered\n\e[31m   |\e[0m  import\
    \ math.Ordering.Implicits.infixOrderingOps\n\e[31m   |\e[0m\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpylq17uuy.scala:30:123 -----------------------\e[0m\e\
    [0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mcarrots_to_eat_with_remaining_with_remaining_with_remaining\e\
    [0m = \e[33mif\e[0m (carrots_to_eat_with_remaining_with_remaining > \e[31m0\e\
    [0m) carrots_to_eat_with_remaining_with_remaining \e[33melse\e[0m \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mvalue > is not a member of AnyVal, but could be made available as\
    \ an extension method"
  stdout: ''
  timestamp: 1660010485
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result: List[Long] = List(meals,\
    \ carrots)\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2cx8r71j.scala:29)\n\tat Problem.main(tmp2cx8r71j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010482
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left  = remaining - need\n        val meals = List(need)\n      \
    \  val carrots = List(number)\n        val result = List(List(need, left))\n \
    \       val mealsRemaining = List(need)\n        val carrotsRemaining = List(number)\n\
    \        while(meals.nonEmpty && carrots.nonEmpty) {\n            val meal = meals.head\n\
    \            val carrot = carrots.head\n            meals -= meal\n          \
    \  carrots -= carrot\n            mealsRemaining += meal\n            carrotsRemaining\
    \ += carrot\n            val newMeals = meals.takeWhile(x => x <= left)\n    \
    \        val newCarrots = carrots.takeWhile(x => x <= left)\n            val newMealsRemaining\
    \ = mealsRemaining.takeWhile(x => x <= left)\n            val newCarrotsRemaining\
    \ = carrotsRemaining.takeWhile(x => x <= left)\n            val newResult = eat(newMeals.head,\
    \ newMealsRemaining.head, newCarrotsRemaining.head)\n            val newMealsRemaining2\
    \ = newMealsRemaining.tail\n            val newCarrotsRemaining2 = newCarrotsRemaining.tail\n\
    \            val newResult2 = eat(newMeals.tail, newMealsRemaining2, newCarrotsRemaining2)\n\
    \            val newMealsRemaining3 = newMealsRemaining2.tail\n            val\
    \ newCarrotsRemaining3 = newCarrotsRemaining2.tail\n            val newResult3\
    \ = eat(newMeals.tail, newMealsRemaining3, newCarrotsRemaining3)\n           \
    \ val newMealsRemaining4 = newMealsRemaining3.tail\n            val newCarrotsRemaining4\
    \ = newCarrotsRemaining3.tail\n            val newResult4 = eat(newMeals.tail,\
    \ newMealsRemaining4, newCarrotsRemaining4)\n            val newMealsRemaining5\
    \ = newMealsRemaining4.tail\n            val newCarrotsRemaining5 = newCarrotsRemaining4.tail\n\
    \            val newResult5 = eat(newMeals.tail, newMealsRemaining5, newCarrotsRemaining5)\n\
    \            val newMealsRemaining6 = newMealsRemaining5.tail\n            val\
    \ newCarrotsRemaining6 = newCarrotsRemaining5.tail\n            val \n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmp60pok0fn.scala:56:15 ---------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m            \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m  \
    \             ^\e[0m\n\e[31m   |\e[0m               pattern expected\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp60pok0fn.scala:68:0 ----------------------------\e\
    [0m\e[0m\n\e[31m68 |\e[0m\n\e[31m\e[31m   |\e[0m^\e[0m\n\e[31m   |\e[0m'}' expected,\
    \ but eof found\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp60pok0fn.scala:33:18\
    \ ------------------------\e[0m\e[0m\n\e[31m33 |\e[0m            meals -= meal\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^\e[0m\n\e[31m   |\e[0m         value\
    \ -= is not a member of List[Long] - did you mean meals.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp60pok0fn.scala:34:20 ------------------------\e[0m\e\
    [0m\n\e[31m34 |\e[0m            carrots -= carrot\n\e[31m\e[31m   |\e[0m     \
    \       ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value -= is not a member of List[Long]\
    \ - did you mean carrots.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp60pok0fn.scala:35:27\
    \ ------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            mealsRemaining\
    \ += meal\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mvalue += is not a member of List[Long] - did you mean mealsRemaining.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmp60pok0fn.scala:36:29 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m            carrotsRemaining += carrot\n\e[31m\e[31m\
    \   |\e[0m            ^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue += is not\
    \ a member of List[Long] - did you mean carrotsRemaining.!=?\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmp60pok0fn.scala:44:42 --------------------\e[0m\e\
    [0m\n\e[31m44 |\e[0m            \e[33mval\e[0m \e[36mnewResult2\e[0m = eat(newMeals.tail,\
    \ newMealsRemaining2, newCarrotsRemaining2)\n\e[31m\e[31m   |\e[0m           \
    \                      ^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \              Found:    List[Long @uncheckedVariance]\n\e[31m   |\e[0m      \
    \                           Required: Long\n\e[31m "
  stdout: ''
  timestamp: 1660010485
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(carrots, meals)\n\
    \        if (meals > 0) {\n            val remainingCarrots = number - meals\n\
    \            val remainingMeals = need - remainingCarrots\n            val newResult\
    \ = eat(number - remainingCarrots, need - remainingMeals, remainingCarrots)\n\
    \            result ::: newResult\n        } else {\n            result\n    \
    \    }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpb8y1oyb5.scala:36)\n\tat Problem.main(tmpb8y1oyb5.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val remaining = carrots\
    \ - meals\n        val result = List(meals, remaining)\n        if (remaining\
    \ <= 0) {\n            List(meals, 0)\n        } else {\n            List(meals,\
    \ remaining) :: eat(number, need, remaining)\n        }\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpluiawpb4.scala:25:24 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = carrots\
    \ - meals\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpluiawpb4.scala:30:16\
    \ --------------------\e[0m\e[0m\n\e[31m30 |\e[0m            List(meals, remaining)\
    \ :: eat(number, need, remaining)\n\e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m            Found:    List[Nothing]\n\e[31m   |\e[0m     \
    \       Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010481
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result :: eat(number, need, remaining)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7k6n4z9_.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result :: eat(number,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (result : List[Long])\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010480
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val leftCarrots = math.max(0,\
    \ carrots - meals)\n        List(meals, leftCarrots)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8w2yv1g3.scala:29)\n\tat Problem.main(tmp8w2yv1g3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result :: eat(number, need, remaining)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7k6n4z9_.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result :: eat(number,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (result : List[Long])\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val carrots_left = need - remaining\n        val carrots_left_after_meals\
    \ = carrots - carrots_left\n        val carrots_left_after_meals_after_meals =\
    \ carrots_left - carrots_left_after_meals\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals - carrots_left_after_meals_after_meals\n        val\
    \ carrots_left_after_meals_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_me\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgtjlkda3.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpgtjlkda3.scala:32:123\
    \ --------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                   ^\e[0m\n\e\
    [31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpgtjlkda3.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010481
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val hungry = mutable.ArrayBuffer(0)\n        val hungryRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryEaten = mutable.ArrayBuffer(0)\n        val hungryEatenRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMeals = mutable.ArrayBuffer(0)\n\
    \        val hungryEatenMealsRemaining = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMeals\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungry\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungryRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungryEaten\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungryEatenRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungryEatenMeals\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungryEatenMealsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungryEatenMealsRemainingHungry\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungryEatenMealsRemainingHungryRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungryEatenMealsRemainingHungryEaten\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenMealsRemainingMealsRemainingHungryEatenMealsRemainingHungr\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpfsl3i9hn.scala:44:4 ----------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfsl3i9hn.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfsl3i9hn.scala:24:20\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mmeals\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m            \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfsl3i9hn.scala:25:24\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfsl3i9hn.scala:26:21\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpfsl3i9hn.scala:27:30\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemaining\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanatio"
  stdout: ''
  timestamp: 1660010483
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val carrotsLeft = need - carrots\n        val carrotsLeftList = List(carrotsLeft)\n\
    \        val carrotsLeftList2 = List(carrotsLeft)\n        val carrotsLeftList3\
    \ = List(carrotsLeft)\n        val carrotsLeftList4 = List(carrotsLeft)\n    \
    \    val carrotsLeftList5 = List(carrotsLeft)\n        val carrotsLeftList6 =\
    \ List(carrotsLeft)\n        val carrotsLeftList7 = List(carrotsLeft)\n      \
    \  val carrotsLeftList8 = List(carrotsLeft)\n        val carrotsLeftList9 = List(carrotsLeft)\n\
    \        val carrotsLeftList10 = List(carrotsLeft)\n        val carrotsLeftList11\
    \ = List(carrotsLeft)\n        val carrotsLeftList12 = List(carrotsLeft)\n   \
    \     val carrotsLeftList13 = List(carrotsLeft)\n        val carrotsLeftList14\
    \ = List(carrotsLeft)\n        val carrotsLeftList15 = List(carrotsLeft)\n   \
    \     val carrotsLeftList16 = List(carrotsLeft)\n        val carrotsLeftList17\
    \ = List(carrotsLeft)\n        val carrotsLeftList18 = List(carrotsLeft)\n   \
    \     val carrotsLeftList19 = List(carrotsLeft)\n        val carrotsLeftList20\
    \ = List(carrotsLeft)\n        val carrotsLeftList21 = List(carrotsLeft)\n   \
    \     val carrotsLeftList22 = List(carrotsLeft)\n        val carrotsLeftList23\
    \ = List(carrotsLeft)\n        val carrotsLeftList24 = List(carrotsLeft)\n   \
    \     val carrotsLeftList25 = List(carrotsLeft)\n        val carrotsLeftList26\
    \ = List(carrotsLeft)\n        val carrotsLeftList27 = List(carrotsLeft)\n   \
    \     val carrotsLeftList28 = List(carrotsLeft)\n        val carrotsLeftList29\
    \ = List(carrotsLeft)\n        val carrotsLeftList30 = List(c\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpl8jtfsyb.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpl8jtfsyb.scala:54:37\
    \ ------------------------\e[0m\e[0m\n\e[31m54 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrotsLeftList30\e[0m = List(c\n\e[31m\e[31m   |\e[0m                   \
    \                  ^\e[0m\n\e[31m   |\e[0m                                   \
    \  Not found: c\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpl8jtfsyb.scala:55:5\
    \ ---------------------\e[0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val carrotsArray2\
    \ = Array.ofDim[Long](carrots)\n        val carrotsArray3 = Array.ofDim[Long](carrots)\n\
    \        val carrotsArray4 = Array.ofDim[Long](carrots)\n        val carrotsArray5\
    \ = Array.ofDim[Long](carrots)\n        val carrotsArray6 = Array.ofDim[Long](carrots)\n\
    \        val carrotsArray7 = Array.ofDim[Long](carrots)\n        val carrotsArray8\
    \ = Array.ofDim[Long](carrots)\n        val carrotsArray9 = Array.ofDim[Long](carrots)\n\
    \        val carrotsArray10 = Array.ofDim[Long](carrots)\n        val carrotsArray11\
    \ = Array.ofDim[Long](carrots)\n        val carrotsArray12 = Array.ofDim[Long](carrots)\n\
    \        val carrotsArray13 = Array.ofDim[Long](carrots)\n        val carrotsArray14\
    \ = Array.ofDim[Long](carrots)\n        val carrotsArray15 = Array.ofDim[Long](carrots)\n\
    \        val carrotsArray16 = Array.ofDim[Long](carrots)\n        val carrotsArray17\
    \ = Array.ofDim[Long](carrots)\n        val carrotsArray18 = Array.ofDim[Long](carrots)\n\
    \        val carrotsArray19 = Array.ofDim[Long](carrots)\n        val carrotsArray20\
    \ = Array.ofDim[Long](carrots)\n        val carrotsArray21 = Array.ofDim[Long](carrots)\n\
    \        val carrotsArray22 = Array.ofDim[Long](carrots)\n        val carrotsArray23\
    \ = Array.ofDim[Long](carrots)\n        val carrotsArray24 = Array.ofDim[Long](carrots)\n\
    \        val carrotsArray25 = Array.ofDim[Long](carrots)\n        val carrotsArray26\
    \ = Array.ofDim[Long\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppclj21bd.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ']' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmppclj21bd.scala:25:42 --------------------\e[0m\e[0m\n\e[31m25 |\e[0m\
    \        \e[33mval\e[0m \e[36mmealArray\e[0m = Array.ofDim[\e[35mLong\e[0m](meals)\n\
    \e[31m\e[31m   |\e[0m                                          ^^^^^\e[0m\n\e\
    [31m   |\e[0m                                          Found:    (meals : Long)\n\
    \e[31m   |\e[0m                                          Required: Int\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmppclj21bd.scala:26:45 --------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e\
    [35mLong\e[0m](carrots)\n\e[31m\e[31m   |\e[0m                               \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                                 \
    \            Found:    (carrots : Long)\n\e[31m   |\e[0m                     \
    \                        Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmppclj21bd.scala:27:46 --------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray2\e[0m = Array.ofDim[\e\
    [35mLong\e[0m](carrots)\n\e[31m\e[31m   |\e[0m                               \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \              Found:    (carrots : Long)\n\e[31m   |\e[0m                   \
    \                           Required: Int\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E007]\
    \ Type Mismatch Error: /tmp/tmppclj21bd.scala:28:46 --------------------\e[0m\e\
    [0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray3\e[0m = Array.ofDim[\e\
    [35mLong\e[0m](carrots)\n\e[31m\e[31m   |\e[0m                               \
    \               ^^^^^^^\e[0m\n\e[31m   |\e[0m                                \
    \              Fou"
  stdout: ''
  timestamp: 1660010491
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = mutable.ArrayBuffer(number)\n\
    \        val left = mutable.ArrayBuffer(need)\n        val result = mutable.ArrayBuffer(0)\n\
    \        val hungry = true\n        while(left.length < remaining && hungry) {\n\
    \            val carrots = math.min(left.length, number.toInt)\n            left.resize(carrots,\
    \ 0)\n            number.resize(carrots, 0)\n            val hungryRabbit = math.min(math.min(left.length,\
    \ number.toInt), number.toInt)\n            val hungryRabbits = math.min(hungryRabbit,\
    \ left.length)\n            val eatenRabbits = math.min(hungryRabbits, number.toInt)\n\
    \            val eatenRabbit = math.min(eatenRabbits, eaten.toInt)\n         \
    \   val eatenRabbits = eatenRabbit + eatenRabbits\n            val hungryRabbits\
    \ = math.min(hungryRabbits, eatenRabbits)\n            val hungryRabbit = math.min(hungryRabbits,\
    \ eatenRabbits)\n            val hungryRabbits = math.min(hungryRabbits, eatenRabbits)\n\
    \            val hungryRabbit = math.min(hungryRabbits, eatenRabbits)\n      \
    \      val hungryRabbits = math.min(hungryRabbits, eatenRabbits)\n           \
    \ val hungryRabbit = math.min(hungryRabbits, eatenRabbits)\n            val hungryRabbits\
    \ = math.min(hungryRabbits, eatenRabbits)\n            val hungryRabbit = math.min(hungryRabbits,\
    \ eatenRabbits)\n            val hungryRabbits = math.min(hungryRabbits, eatenRabbits)\n\
    \            val hungryRabbit = math.min(hungryRabbits, eatenRabbits)\n      \
    \      val hungryRabbits = math.min(hungryRabbits, eatenRabbits)\n           \
    \ val hungryRabbit = math.min(hungryRabbits, eatenRabbits)\n            val hungryR\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppw19lhhq.scala:49:4 ----------------------------\e\
    [0m\e[0m\n\e[31m49 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmppw19lhhq.scala:60:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m60 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmppw19lhhq.scala:23:20 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36meaten\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmppw19lhhq.scala:24:19 ------------------------\e[0m\e[0m\n\e[31m24 |\e\
    [0m        \e[33mval\e[0m \e[36mleft\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e\
    [31m   |\e[0m                   ^^^^^^^\e[0m\n\e[31m   |\e[0m                \
    \   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmppw19lhhq.scala:25:21\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmppw19lhhq.scala:35:16\
    \ ---------------------------\e[0m\e[0m\n\e[31m35 |\e[0m            \e[33mval\e\
    [0m \e[36meatenRabbits\e[0m = eatenRabbit + eatenRabbits\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0meatenRabbits is already defined as \e[33mvalue\e[0m \e[35meatenRabbits\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmppw19lhhq.scala:36:16 ---------------------------\e[0m\e[0m\n\e[3"
  stdout: ''
  timestamp: 1660010500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val leftOver = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer.empty[Long]\n        while(number >\
    \ 0 && need > 0 && remaining > 0) {\n            carrots.takeWhile(_ > 0).foreach(n\
    \ => hungry.takeWhile(_ > 0).foreach(n => leftOver.takeWhile(_ > 0).foreach(n\
    \ => result += n)))\n            number -= 1\n            need -= 1\n        \
    \    leftOver -= 1\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp8f3qguxy.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp8f3qguxy.scala:24:21 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp8f3qguxy.scala:25:23 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mleftOver\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m    \
    \                   Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp8f3qguxy.scala:26:21 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E008] Not Found Error: /tmp/tmp8f3qguxy.scala:29:19 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp8f3qguxy.scala:30:17\
    \ ------------------------\e[0m\e[0m\n\e[31m30 |\e[0m            need -= \e[31m1\e\
    [0m\n\e[31m\e[31m   |\e[0m            ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \  value -= is not a member of Long - did you mean need.!=?\n6"
  stdout: ''
  timestamp: 1660010499
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeftList = List(mealsLeft)\n        val mealsLeftList2 = List(mealsLeft\
    \ + 1)\n        val mealsLeftList3 = List(mealsLeft + 2)\n        val mealsLeftList4\
    \ = List(mealsLeft + 3)\n        val mealsLeftList5 = List(mealsLeft + 4)\n  \
    \      val mealsLeftList6 = List(mealsLeft + 5)\n        val mealsLeftList7 =\
    \ List(mealsLeft + 6)\n        val mealsLeftList8 = List(mealsLeft + 7)\n    \
    \    val mealsLeftList9 = List(mealsLeft + 8)\n        val mealsLeftList10 = List(mealsLeft\
    \ + 9)\n        val mealsLeftList11 = List(mealsLeft + 10)\n        val mealsLeftList12\
    \ = List(mealsLeft + 11)\n        val mealsLeftList13 = List(mealsLeft + 12)\n\
    \        val mealsLeftList14 = List(mealsLeft + 13)\n        val mealsLeftList15\
    \ = List(mealsLeft + 14)\n        val mealsLeftList16 = List(mealsLeft + 15)\n\
    \        val mealsLeftList17 = List(mealsLeft + 16)\n        val mealsLeftList18\
    \ = List(mealsLeft + 17)\n        val mealsLeftList19 = List(mealsLeft + 18)\n\
    \        val mealsLeftList20 = List(mealsLeft + 19)\n        val mealsLeftList21\
    \ = List(mealsLeft + 20)\n        val mealsLeftList22 = List(mealsLeft + 21)\n\
    \        val mealsLeftList23 = List(mealsLeft + 22)\n        val mealsLeftList24\
    \ = List(mealsLeft + 23)\n        val mealsLeftList25 = List(mealsLeft + 24)\n\
    \        val mealsLeftList26 = List(mealsLeft + 25)\n        val mealsLeftList27\
    \ = List(mealsLeft + 26)\n        val mealsLeftList28 = List(mealsLeft + 27)\n\
    \        val mealsLeftList29 = List(mealsLeft + 28)\n        val mealsLeftList30\
    \ = List(mealsLeft + 29)\n        val mealsLeftList31 = List(mealsLeft + 30)\n\
    \        val mealsLeftList32 = List(mealsLeft + 31)\n        val mealsLeftList33\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb3s7jv2a.scala:58:29 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftList33\e[0m = \n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb3s7jv2a.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(carrots, meals)\n\
    \        result :: eat(number, need, remaining - carrots)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp0qp5jg2b.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result :: eat(number,\
    \ need, remaining - carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m\
    \   |\e[0m        Found:    (result : List[Long])\n\e[31m   |\e[0m        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = if (remaining\
    \ > 0) 1 else 0\n        val carrots = if (carrots > 0) 1 else 0\n        val\
    \ result = List(carrots, meals)\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp9zve7ms6.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = \e[33mif\e\
    [0m (carrots > \e[31m0\e[0m) \e[31m1\e[0m \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmp9zve7ms6.scala:24:24 ---------------------------\e[0m\e[0m\n\e[31m24\
    \ |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining - carrots\n\e\
    [31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m           \
    \             Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp9zve7ms6.scala:28:8 ---------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        result\n\e[31m\e[31m   |\e[0m        ^^^^^^\e\
    [0m\n\e[31m   |\e[0m        Found:    (result : List[AnyVal])\n\e[31m   |\e[0m\
    \        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010500
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungry = mutable.ArrayBuffer.empty[Long]\n        val hungryCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount2 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount3 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount4\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount5 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount6 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount7\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount8 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount9 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount10\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount11 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount12 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount13\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount14 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount15 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount16\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount17 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount18 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount19\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount20 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount21 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount22\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount23 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount24 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount25\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount26 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount27 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount28\
    \ = mut\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:24:21 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:25:26 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:26:27 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhungryCount2\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhungryCount3\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:28:27 --------"
  stdout: ''
  timestamp: 1660010459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val result = new mutable.ListBuffer[Long]()\n\
    \        if (remaining <= 0) {\n            result ++= List(remaining)\n     \
    \   } else {\n            val carrots = math.min(remaining, number)\n        \
    \    result ++= List(carrots)\n            val need = math.min(need, carrots)\n\
    \            val remaining = math.min(remaining, need)\n            val result\
    \ = eat(number, need, remaining)\n        }\n        return result.toList\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsz1aa0mv.scala:24:24 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e\
    [0m                        Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsz1aa0mv.scala:25:25\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = \e[33mnew\e[0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e\
    [31m   |\e[0m                         ^^^^^^^\e[0m\n\e[31m   |\e[0m          \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpsz1aa0mv.scala:32:37 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mval\e[0m \e[36mremaining\e[0m = math.min(remaining,\
    \ need)\n\e[31m\e[31m   |\e[0m                                     ^\e[0m\n\e\
    [31m   |\e[0m                                    Recursive \e[33mvalue\e[0m \e\
    [35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpsz1aa0mv.scala:31:32 ---------------------------\e[0m\e[0m\n\e[31m31\
    \ |\e[0m            \e[33mval\e[0m \e[36mneed\e[0m = math.min(need, carrots)\n\
    \e[31m\e[31m   |\e[0m                                ^\e[0m\n\e[31m   |\e[0m \
    \                               Recursive \e[33mvalue\e[0m \e[35mneed\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsz1aa0mv.scala:31:38\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m            \e[33mval\e\
    [0m \e[36mneed\e[0m = math.min(need, carrots)\n\e[31m\e[31m   |\e[0m         \
    \                             ^\e[0m\n\e[31m   |\e[0m                        \
    \              Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation ava"
  stdout: ''
  timestamp: 1660010501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeft2 = mealsLeft * mealsLeft\n        val mealsLeft3 = mealsLeft2\
    \ * mealsLeft\n        val mealsLeft4 = mealsLeft3 * mealsLeft\n        val mealsLeft5\
    \ = mealsLeft4 * mealsLeft\n        val mealsLeft6 = mealsLeft5 * mealsLeft\n\
    \        val mealsLeft7 = mealsLeft6 * mealsLeft\n        val mealsLeft8 = mealsLeft7\
    \ * mealsLeft\n        val mealsLeft9 = mealsLeft8 * mealsLeft\n        val mealsLeft10\
    \ = mealsLeft9 * mealsLeft\n        val mealsLeft11 = mealsLeft10 * mealsLeft\n\
    \        val mealsLeft12 = mealsLeft11 * mealsLeft\n        val mealsLeft13 =\
    \ mealsLeft12 * mealsLeft\n        val mealsLeft14 = mealsLeft13 * mealsLeft\n\
    \        val mealsLeft15 = mealsLeft14 * mealsLeft\n        val mealsLeft16 =\
    \ mealsLeft15 * mealsLeft\n        val mealsLeft17 = mealsLeft16 * mealsLeft\n\
    \        val mealsLeft18 = mealsLeft17 * mealsLeft\n        val mealsLeft19 =\
    \ mealsLeft18 * mealsLeft\n        val mealsLeft20 = mealsLeft19 * mealsLeft\n\
    \        val mealsLeft21 = mealsLeft20 * mealsLeft\n        val mealsLeft22 =\
    \ mealsLeft21 * mealsLeft\n        val mealsLeft23 = mealsLeft22 * mealsLeft\n\
    \        val mealsLeft24 = mealsLeft23 * mealsLeft\n        val mealsLeft25 =\
    \ mealsLeft24 * mealsLeft\n        val mealsLeft26 = mealsLeft25 * mealsLeft\n\
    \        val mealsLeft27 = mealsLeft26 * mealsLeft\n        val mealsLeft28 =\
    \ mealsLeft27 * mealsLeft\n        val mealsLeft29 = mealsLeft28 * mealsLeft\n\
    \        val mealsLeft30 = mealsLeft29 * mealsLeft\n        val mealsLeft31 =\
    \ mealsLeft30 * mealsLeft\n        val mealsLeft32 = mealsLeft31 * mealsLeft\n\
    \        val \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpo3k0ae5u.scala:57:11 ---------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpo3k0ae5u.scala:58:5 ---------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010479
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number\
    \ - remaining\n        val hungryRabbits = hungryRabbit.toLong\n        val hungryRabbitsLeft\
    \ = (need - hungryRabbits).toLong\n        val hungryRabbitsLeftArray = Array.ofDim[Long](2)\n\
    \        hungryRabbitsLeftArray(0) = hungryRabbitsLeft\n        hungryRabbitsLeftArray(1)\
    \ = hungryRabbits\n        val hungryRabbitsLeftArrayList = List(hungryRabbitsLeftArray)\n\
    \        val hungryRabbitsLeftArrayListArray = List(hungryRabbitsLeftArrayList)\n\
    \        val hungryRabbitsLeftArrayListArrayArray = List(hungryRabbitsLeftArrayListArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArray = List(hungryRabbitsLeftArrayListArrayArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArrayArray = List(hungryRabbitsLeftArrayListArrayArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArrayArray = List(hungryRabbitsLeftArrayListArrayArrayArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArrayArray = List(hungryRabbitsLeftArrayListArrayArrayArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArrayArray = List(hungryRabbitsLeftArrayListArrayArrayArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArrayArray = List(hungryRabbitsLeftArrayListArrayArrayArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArrayArrayArray = List(hungryRabbitsLeftArrayListArrayArrayArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArrayArrayArray = List(hungryRabbitsLeftArrayListArrayArrayArrayArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArrayArrayArray = List(hungryRabbitsLeftArrayListArrayArrayArrayArray)\n\
    \        val hungryRabbitsLeftArrayListArrayArrayArrayArrayArray = List(hungryRabbitsLeftArrayListArrayArrayArrayArray)\n\
    \        val hungr\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8ijecvhe.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8ijecvhe.scala:32:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryRabbitsLeftArrayListArrayArray\e[0m = List(hungryRabbitsLeftArrayListArrayArray)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbitsLeftArrayListArrayArray is already defined as\
    \ \e[33mvalue\e[0m \e[35mhungryRabbitsLeftArrayListArrayArray\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8ijecvhe.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryRabbitsLeftArrayListArrayArrayArray\e[0m = List(hungryRabbitsLeftArrayListArrayArrayArray)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbitsLeftArrayListArrayArrayArray is already defined\
    \ as \e[33mvalue\e[0m \e[35mhungryRabbitsLeftArrayListArrayArrayArray\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmp8ijecvhe.scala:35:12 ---------------------------\e[0m\e[0m\n\e[31m35\
    \ |\e[0m        \e[33mval\e[0m \e[36mhungryRabbitsLeftArrayListArrayArrayArray\e\
    [0m = List(hungryRabbitsLeftArrayListArrayArrayArray)\n\e[31m\e[31m   |\e[0m \
    \       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbitsLeftArrayListArrayArrayArray is already defined\
    \ as \e[33mvalue\e[0m \e[35mhungryRabbitsLeftArrayListArrayArrayArray\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Nami"
  stdout: ''
  timestamp: 1660010503
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val remaining = carrots\
    \ - meals\n        List(meals, remaining)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyvq_f20o.scala:25:24 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = carrots\
    \ - meals\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010494
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number - need\n\
    \        val left  = remaining - eaten\n        val result = List(need, left)\n\
    \        result :: eat(number, need, left)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmb9sawcr.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result :: eat(number,\
    \ need, left)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \   Found:    (result : List[Long])\n\e[31m   |\e[0m        Required: Long\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010501
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingArray = mealsRemaining.toArray\n        val\
    \ mealsRemainingArrayLength = mealsRemainingArray.length\n        val mealsRemainingArrayCopy\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopyLength = mealsRemainingArrayCopy.length\n\
    \        val mealsRemainingArrayCopy2 = mealsRemainingArrayCopy.clone()\n    \
    \    val mealsRemainingArrayCopy2Length = mealsRemainingArrayCopy2.length\n  \
    \      val mealsRemainingArrayCopy3 = mealsRemainingArrayCopy2.clone()\n     \
    \   val mealsRemainingArrayCopy3Length = mealsRemainingArrayCopy3.length\n   \
    \     val mealsRemainingArrayCopy4 = mealsRemainingArrayCopy3.clone()\n      \
    \  val mealsRemainingArrayCopy4Length = mealsRemainingArrayCopy4.length\n    \
    \    val mealsRemainingArrayCopy5 = mealsRemainingArrayCopy4.clone()\n       \
    \ val mealsRemainingArrayCopy5Length = mealsRemainingArrayCopy5.length\n     \
    \   val mealsRemainingArrayCopy6 = mealsRemainingArrayCopy5.clone()\n        val\
    \ mealsRemainingArrayCopy6Length = mealsRemainingArrayCopy6.length\n        val\
    \ mealsRemainingArrayCopy7 = mealsRemainingArrayCopy6.clone()\n        val mealsRemainingArrayCopy7Length\
    \ = mealsRemainingArrayCopy7.length\n        val mealsRemainingArrayCopy8 = mealsRemainingArrayCopy7.clone()\n\
    \        val mealsRemainingArrayCopy8Length = mealsRemainingArrayCopy8.length\n\
    \        val mealsRemainingArrayCopy9 = mealsRemainingArrayCopy8.clone()\n   \
    \     val mealsRemainingArrayCopy9Length = mealsRemainingArrayCopy9.length\n \
    \       val mealsRemainingArrayCopy10 = mealsRemainingArrayCopy9.clone()\n   \
    \     val mealsRemainingArrayCopy10Length = mealsRemainingArrayCopy10.length\n\
    \        val mealsRemainingArrayCopy11 = mealsRemainingArrayCopy10.clone()\n \
    \       val mealsRemainingArrayCopy11Length = mealsRemainingArrayCopy11.length\n\
    \        val mealsRemainingArrayCopy12 = mealsRemainingArrayCopy11.clone()\n \
    \       val mealsRemainingArrayCopy12Length = mealsRemainingArrayCopy12.length\n\
    \        val mealsRemainingArrayCopy13 = me\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpmftcslr2.scala:26:49 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArray\e[0m\
    \ = mealsRemaining.toArray\n\e[31m\e[31m   |\e[0m                            \
    \      ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                          \
    \        value toArray is not a member of Long\n\e[31m\e[31m-- [E006] Not Found\
    \ Error: /tmp/tmpmftcslr2.scala:52:40 ------------------------\e[0m\e[0m\n\e[31m52\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayCopy13\e[0m = me\n\e[31m\e\
    [31m   |\e[0m                                        ^^\e[0m\n\e[31m   |\e[0m\
    \                                        Not found: me\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpmftcslr2.scala:53:5 ---------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        var total = 0\n        var left = 0\n        while(meals.size < remaining.size)\
    \ {\n            total += carrots(meals.size)\n            left += carrots(meals.size)\n\
    \            meals += carrots(meals.size)\n        }\n        meals.toList\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp509hwwj5.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp509hwwj5.scala:24:20 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmeals\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp509hwwj5.scala:25:24 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result: List[Long] = List(meals,\
    \ carrots)\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2cx8r71j.scala:29)\n\tat Problem.main(tmp2cx8r71j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010482
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val result = new\
    \ mutable.ListBuffer[Long]()\n        val carrotsArrayIndex = 0\n        val mealArrayIndex\
    \ = 0\n        val carrotsArraySize = carrotsArray.length\n        val mealArraySize\
    \ = mealArray.length\n        while (mealArrayIndex < mealArraySize && carrotsArrayIndex\
    \ < carrotsArraySize) {\n            mealArray(mealArrayIndex) = mealArrayIndex\n\
    \            carrotsArray(carrotsArrayIndex) = carrotsArrayIndex\n           \
    \ mealArrayIndex += 1\n            carrotsArrayIndex += 1\n        }\n       \
    \ val mealArraySize = mealArray.length\n        val carrotsArraySize = carrotsArray.length\n\
    \        val carrotsArrayIndex = 0\n        val mealArrayIndex = 0\n        while\
    \ (mealArrayIndex < mealArraySize && carrotsArrayIndex < carrotsArraySize) {\n\
    \            val meal = mealArray(mealArrayIndex)\n            val carrots = carrotsArray(carrotsArrayIndex)\n\
    \            if (meal < carrots) {\n                mealArrayIndex += 1\n    \
    \            carrotsArrayIndex += 1\n            } else {\n                result.add(carrots)\n\
    \                carrotsArrayIndex += 1\n                mealArrayIndex += 1\n\
    \            }\n        }\n        result.toList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpzhxr925a.scala:38:12 ---------------------------\e\
    [0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m \e[36mmealArraySize\e[0m = mealArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mmealArraySize is already defined as \e[33mvalue\e[0m \e[35mmealArraySize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzhxr925a.scala:39:12 ---------------------------\e[0m\e[0m\n\e\
    [31m39 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArraySize\e[0m = carrotsArray.length\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcarrotsArraySize is already defined as \e[33mvalue\e[0m \e[35mcarrotsArraySize\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpzhxr925a.scala:40:12 ---------------------------\e[0m\e[0m\n\e\
    [31m40 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArrayIndex\e[0m = \e[31m0\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrotsArrayIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mcarrotsArrayIndex\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpzhxr925a.scala:41:12 ---------------------------\e[0m\e[0m\n\e[31m41\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealArrayIndex\e[0m = \e[31m0\e[0m\n\e[31m\e\
    [31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealArrayIndex\
    \ is already defined as \e[33mvalue\e[0m \e[35mmealArrayIndex\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpzhxr925a.scala:25:42\
    \ --------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmealArray\e\
    [0m = Array.ofDim[\e[35mLong\e[0m](meals)\n\e[31m\e[31m   |\e[0m             \
    \                             ^^^^^\e[0m\n\e[31m "
  stdout: ''
  timestamp: 1660010506
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number\
    \ - remaining\n        val hungryRabbits = hungryRabbit / need\n        val leftover\
    \ = hungryRabbit % need\n        val carrots = leftover\n        val hungryRabbits\
    \ = hungryRabbits :: leftover :: Nil\n        hungryRabbits.toList\n    }\n  \
    \  def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmprog35jy0.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = hungryRabbits\
    \ :: leftover :: Nil\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E008] Not\
    \ Found Error: /tmp/tmprog35jy0.scala:28:22 ------------------------\e[0m\e[0m\n\
    \e[31m28 |\e[0m        hungryRabbits.toList\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mvalue toList is not a member of Long - did you mean hungryRabbits.toInt?\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010502
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = new mutable.ListBuffer[Long]()\n\
    \        if (meals > 0) {\n            result.add(carrots)\n            val carrotsLeft\
    \ = remaining - carrots\n            if (carrotsLeft > 0) {\n                result.add(carrotsLeft)\n\
    \            }\n        }\n        return result.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp5u9lq2fr.scala:25:25 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010496
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val remainingCarrots = math.max(0,\
    \ carrots - meals)\n        val hungry = math.max(0, remainingCarrots - meals)\n\
    \        val result = List(hungry, remainingCarrots)\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9y4s13wq.scala:31)\n\tat Problem.main(tmp9y4s13wq.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010506
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val hungryCarrots = math.min(need, carrots)\n        val eatenCarrots\
    \ = math.min(hungryCarrots, carrots)\n        val remainingCarrots = math.min(hungryCarrots\
    \ + eatenCarrots, carrots)\n        val totalCarrots = math.min(hungryCarrots\
    \ + eatenCarrots + remainingCarrots, carrots)\n        val hungryCarrotsList =\
    \ List(hungryCarrots)\n        val eatenCarrotsList = List(eatenCarrots)\n   \
    \     val remainingCarrotsList = List(remainingCarrots)\n        val totalCarrotsList\
    \ = List(totalCarrots)\n        val hungryCarrotsListString = hungryCarrotsList.mkString(\"\
    ,\")\n        val eatenCarrotsListString = eatenCarrotsList.mkString(\",\")\n\
    \        val remainingCarrotsListString = remainingCarrotsList.mkString(\",\"\
    )\n        val totalCarrotsListString = totalCarrotsList.mkString(\",\")\n   \
    \     List(hungryCarrotsListString, eatenCarrotsListString, remainingCarrotsListString,\
    \ totalCarrotsListString)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp1dfgosqw.scala:36:13\
    \ --------------------\e[0m\e[0m\n\e[31m36 |\e[0m        List(hungryCarrotsListString,\
    \ eatenCarrotsListString, remainingCarrotsListString, totalCarrotsListString)\n\
    \e[31m\e[31m   |\e[0m             ^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \             Found:    (hungryCarrotsListString : String)\n\e[31m   |\e[0m  \
    \           Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1dfgosqw.scala:36:38 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        List(hungryCarrotsListString, eatenCarrotsListString, remainingCarrotsListString,\
    \ totalCarrotsListString)\n\e[31m\e[31m   |\e[0m                             \
    \         ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                       \
    \      Found:    (eatenCarrotsListString : String)\n\e[31m   |\e[0m          \
    \                   Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp1dfgosqw.scala:36:62 --------------------\e[0m\e[0m\n\e[31m36\
    \ |\e[0m        List(hungryCarrotsListString, eatenCarrotsListString, remainingCarrotsListString,\
    \ totalCarrotsListString)\n\e[31m\e[31m   |\e[0m                             \
    \                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                         Found:    (remainingCarrotsListString : String)\n\e\
    [31m   |\e[0m                         Required: Long\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp1dfgosqw.scala:36:90 --------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        List(hungryCarrotsListString, eatenCarrotsListString,\
    \ remainingCarrotsListString, totalCarrotsListString)\n\e[31m\e[31m   |\e[0m \
    \                                                                            \
    \             ^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \          Found:    (totalCarrotsListString : String)\n\e[31m   |\e[0"
  stdout: ''
  timestamp: 1660010506
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingArray = Array.ofDim[Long](mealsRemaining)\n\
    \        val mealsRemainingArrayCopy = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopy2 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy3\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy4 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy5 = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopy6 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy7\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy8 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy9 = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopy10 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy11\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy12 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy13 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy14 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy15\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy16 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy17 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy18 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy19\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy20 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy21 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy22 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy23\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy24 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy25 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy26 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy27\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy28 = mealsRemainingArray.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6s35hf5e.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6s35hf5e.scala:26:52 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArray\e[0m = Array.ofDim[\e\
    [35mLong\e[0m](mealsRemaining)\n\e[31m\e[31m   |\e[0m                        \
    \                            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                           Found:    (mealsRemaining : Long)\n\e[31m   |\e[0m\
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp6s35hf5e.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = carrots - meals\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = mealsLeft.toString.toLong\n        val mealsLeft = mealsLeft.toString.toLong\n\
    \        val mealsLeft = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpet0wk1cj.scala:60:23 ---------------------------\e\
    [0m\e[0m\n\e[31m60 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = \n\e[31m\e\
    [31m   |\e[0m                       ^\e[0m\n\e[31m   |\e[0m                  \
    \     expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpet0wk1cj.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toString.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpet0wk1cj.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toString.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpet0wk1cj.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toString.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpet0wk1cj.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmealsLeft\e[0m = mealsLeft.toString.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmealsLeft is already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e\
    [0m\n\e"
  stdout: ''
  timestamp: 1660010505
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val remaining = carrots\
    \ - meals\n        val hungry = math.min(need, remaining)\n        val eaten =\
    \ math.min(number, hungry)\n        val left  = math.min(number, eaten)\n    \
    \    List(math.max(eaten, hungry), math.max(left, need))\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp5pg2hubb.scala:25:24 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = carrots\
    \ - meals\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010499
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeftList = List(mealsLeft)\n        val mealsLeftListWithRemaining\
    \ = mealsLeftList :+ remaining\n        val mealsLeftListWithRemainingList = List(mealsLeftListWithRemaining)\n\
    \        val mealsLeftListWithRemainingListWithMealsLeft = mealsLeftListWithRemainingList\
    \ :+ mealsLeft\n        val mealsLeftListWithRemainingListWithMealsLeftList =\
    \ List(mealsLeftListWithRemainingListWithMealsLeft)\n        val mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeft\
    \ = mealsLeftListWithRemainingListWithMealsLeftList :+ mealsLeftListWithRemainingListWithMealsLeft\n\
    \        val mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftList\
    \ = List(mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeft)\n     \
    \   val mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeft\
    \ = mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftList\
    \ :+ mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemaining\n\
    \        val mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemainingListWithMealsLeft\
    \ = mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemainingListWithMealsLeftList\
    \ :+ mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemaining\n\
    \        val mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemainingListWithMealsLeft\
    \ = mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemainingListWithMealsLeft\n\
    \        val mealsLeftListWithRemainingListWith\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpli4gozqz.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpli4gozqz.scala:33:109\
    \ -----------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e\
    [36mmealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeft\e\
    [0m = mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftList\
    \ :+ mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemaining\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftList\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpli4gozqz.scala:34:143\
    \ -----------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e\
    [36mmealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemainingListWithMealsLeft\e\
    [0m = mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemainingListWithMealsLeftList\
    \ :+ mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemaining\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                            \
    \           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mNot found: mealsLeftListWithRemainingListWithMealsLeftListWithMealsLeftListWithRemainingListWithMealsLeftListWithRemainingListWithMealsLeftList\n\
    \e[31m   |\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1660010504
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        if (remaining <= 0) {\n            val carrots = number - remaining\n\
    \            val meals = need - carrots\n            val result = List(meals,\
    \ carrots)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj26tvgy.scala:34)\n\tat Problem.main(tmpmj26tvgy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrotsLeft = remaining - carrots\n        val meals = carrotsLeft\
    \ / 3\n        val carrotsLeft2 = carrotsLeft % 3\n        val meals2 = carrotsLeft2\
    \ / 3\n        val carrotsLeft3 = carrotsLeft2 % 3\n        val meals3 = carrotsLeft3\
    \ / 3\n        val carrotsLeft4 = carrotsLeft3 % 3\n        val meals4 = carrotsLeft4\
    \ / 3\n        val carrotsLeft5 = carrotsLeft4 % 3\n        val meals5 = carrotsLeft5\
    \ / 3\n        val carrotsLeft6 = carrotsLeft5 % 3\n        val meals6 = carrotsLeft6\
    \ / 3\n        val carrotsLeft7 = carrotsLeft6 % 3\n        val meals7 = carrotsLeft7\
    \ / 3\n        val carrotsLeft8 = carrotsLeft7 % 3\n        val meals8 = carrotsLeft8\
    \ / 3\n        val carrotsLeft9 = carrotsLeft8 % 3\n        val meals9 = carrotsLeft9\
    \ / 3\n        val carrotsLeft10 = carrotsLeft9 % 3\n        val meals10 = carrotsLeft10\
    \ / 3\n        val carrotsLeft11 = carrotsLeft10 % 3\n        val meals11 = carrotsLeft11\
    \ / 3\n        val carrotsLeft12 = carrotsLeft11 % 3\n        val meals12 = carrotsLeft12\
    \ / 3\n        val carrotsLeft13 = carrotsLeft12 % 3\n        val meals13 = carrotsLeft13\
    \ / 3\n        val carrotsLeft14 = carrotsLeft13 % 3\n        val meals14 = carrotsLeft14\
    \ / 3\n        val carrotsLeft15 = carrotsLeft14 % 3\n        val meals15 = carrotsLeft15\
    \ / 3\n        val carrotsLeft16 = carrotsLeft15 % 3\n        val meals16 = carrotsLeft16\
    \ / 3\n        val carrotsLeft17 = carrotsLeft16 % 3\n        val meals17 = carrotsLeft17\
    \ / 3\n        val carrotsLeft18 = \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpkh86bnrh.scala:58:27 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeft18\e[0m = \n\e\
    [31m\e[31m   |\e[0m                           ^\e[0m\n\e[31m   |\e[0m        \
    \                   expression expected but \e[31m'}'\e[0m found\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpkh86bnrh.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010506
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryCarrots = number\
    \ - remaining\n        val hungryCarrotsToEat = need - remaining\n        val\
    \ hungryCarrotsToEatInt = hungryCarrotsToEat match {\n            case 0 => 0\n\
    \            case n => n\n        }\n        val hungryCarrotsToEatDouble = hungryCarrotsToEatInt\
    \ match {\n            case 0 => 0\n            case n => n\n        }\n     \
    \   val hungryCarrotsToEatLong = hungryCarrotsToEatDouble match {\n          \
    \  case 0 => 0\n            case n => n\n        }\n        val hungryCarrotsToEatFloat\
    \ = hungryCarrotsToEatLong match {\n            case 0 => 0\n            case\
    \ n => n\n        }\n        val hungryCarrotsToEatDouble = hungryCarrotsToEatFloat\
    \ match {\n            case 0 => 0\n            case n => n\n        }\n     \
    \   val hungryCarrotsToEatLong = hungryCarrotsToEatDouble match {\n          \
    \  case 0 => 0\n            case n => n\n        }\n        val hungryCarrotsToEatFloat\
    \ = hungryCarrotsToEatLong match {\n            case 0 => 0\n            case\
    \ n => n\n        }\n        val hungryCarrotsToEatDouble = hungryCarrotsToEatFloat\
    \ match {\n            case 0 => 0\n            case n => n\n        }\n     \
    \   val hungryCarrotsToEatLong = hungryCarrotsToEatDouble match {\n          \
    \  case 0 => 0\n            case n => n\n        }\n        val hungryCarrotsToEatFloat\
    \ = hungryCarrotsToEatLong match {\n            case 0 => 0\n            case\
    \ n => n\n        }\n        val hungryCarrotsToEatDouble = hungryCarrotsToEatFloat\
    \ match {\n            case 0 => 0\n            case n => n\n        }\n     \
    \   val hungryCarrotsToEatLong = hungryCarrotsToEatDouble match {\n          \
    \  case 0 => 0\n            case n => n\n        }\n        val hungr\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpqex077cf.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqex077cf.scala:41:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCarrotsToEatDouble\e[0m = hungryCarrotsToEatFloat \e[33mmatch\e\
    [0m {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mhungryCarrotsToEatDouble\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungryCarrotsToEatDouble\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m42 |\e[0m            \e[33mcase\e\
    [0m \e[31m0\e[0m => \e[31m0\e[0m\n\e[31m43 |\e[0m            \e[33mcase\e[0m n\
    \ => n\n\e[31m44 |\e[0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqex077cf.scala:45:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCarrotsToEatLong\e[0m = hungryCarrotsToEatDouble \e[33mmatch\e[0m\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mhungryCarrotsToEatLong\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungryCarrotsToEatLong\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m46 |\e[0m            \e[33mcase\e\
    [0m \e[31m0\e[0m => \e[31m0\e[0m\n\e[31m47 |\e[0m            \e[33mcase\e[0m n\
    \ => n\n\e[31m48 |\e[0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqex077cf.scala:49:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m49 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCarrotsToEatFloat\e[0m = hungryCarrotsToEatLong \e[33mmatch\e[0m\
    \ {\n\e[31m\e[31m   |\e[0m        ^\e[0m\n\e[31m   |\e[0mhungryCarrotsToEatFloat\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungryCarrotsToEatFloat\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m50 |\e[0m            \e[33mcase\e\
    [0m \e[31m0\e[0m => \e[31m0\e[0m\n\e[31m51 |\e[0m            \e[33mcase\e[0m n\
    \ => n\n\e[31m52 |\e[0m        }\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqex077cf.scala:53:"
  stdout: ''
  timestamp: 1660010506
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while(number\
    \ > 0 && carrots_left > 0) {\n            carrots += number\n            number\
    \ -= 1\n            carrots_left -= 1\n            hungry = false\n        }\n\
    \        carrots ++= carrots_left until carrots_left == 0\n        if(hungry)\
    \ {\n            carrots ++= carrots_left until carrots_left == 0\n        }\n\
    \        carrots.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6_mtmo88.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp6_mtmo88.scala:28:19 ------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010513
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum2 * hungryRemainingSum\n \
    \       val hungryRemainingSum4 = hungryRemainingSum3 * hungryRemainingSum\n \
    \       val hungryRemainingSum5 = hungryRemainingSum4 * hungryRemainingSum\n \
    \       val hungryRemainingSum6 = hungryRemainingSum5 * hungryRemainingSum\n \
    \       val hungryRemainingSum7 = hungryRemainingSum6 * hungryRemainingSum\n \
    \       val hungryRemainingSum8 = hungryRemainingSum7 * hungryRemainingSum\n \
    \       val hungryRemainingSum9 = hungryRemainingSum8 * hungryRemainingSum\n \
    \       val hungryRemainingSum10 = hungryRemainingSum9 * hungryRemainingSum\n\
    \        val hungryRemainingSum11 = hungryRemainingSum10 * hungryRemainingSum\n\
    \        val hungryRemainingSum12 = hungryRemainingSum11 * hungryRemainingSum\n\
    \        val hungryRemainingSum13 = hungryRemainingSum12 * hungryRemainingSum\n\
    \        val hungryRemainingSum14 = hungryRemainingSum13 * hungryRemainingSum\n\
    \        val hungryRemainingSum15 = hungryRemainingSum14 * hungryRemainingSum\n\
    \        val hungryRemainingSum16 = hungryRemainingSum15 * hungryRemainingSum\n\
    \        val hungryRemainingSum17 = hungryRemainingSum16 * hungryRemainingSum\n\
    \        val hungryRemainingSum18 = hungryRemainingSum17 * hungryRemainingSum\n\
    \        val hun\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6rm11hpb.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rm11hpb.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rm11hpb.scala:24:21\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rm11hpb.scala:25:30\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6rm11hpb.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010516
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        if (meals == 0) {\n            List(meals, carrots)\n        } else {\n\
    \            List(meals, carrots)\n        }\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpfkopu89x.scala:33)\n\tat Problem.main(tmpfkopu89x.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val left  = mutable.ArrayBuffer(remaining)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val result = mutable.ArrayBuffer(need)\n\
    \        val hungryRemaining = mutable.ArrayBuffer(need)\n        val leftRemaining\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeft = mutable.ArrayBuffer(need)\n\
    \        val leftLeft = mutable.ArrayBuffer(need)\n        val hungryLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val leftLeftLeft = mutable.ArrayBuffer(need)\n\
    \        val hungryLeftLeftLeft = mutable.ArrayBuffer(need)\n        val leftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeftLeftLeftLeft = mutable.ArrayBuffer(need)\n\
    \        val leftLeftLeftLeftLeft = mutable.ArrayBuffer(need)\n        val hungryLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val leftLeftLeftLeftLeftLeft = mutable.ArrayBuffer(need)\n\
    \        val hungryLeftLeftLeftLeftLeftLeft = mutable.ArrayBuffer(need)\n    \
    \    val leftLeftLeftLeftLeftLeftLeft = mutable.ArrayBuffer(need)\n        val\
    \ hungryLeftLeftLeftLeftLeftLeftLeft = mutable.ArrayBuffer(need)\n        val\
    \ leftLeftLeftLeftLeftLeftLeftLeft = mutable.ArrayBuffer(need)\n        val hungryLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val leftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val leftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val leftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val leftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val leftLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.ArrayBuffer(need)\n        val hungryLeftLeftLeftLeftLeftLeftLeftLeft\
    \ = mutable.\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpsj85eekj.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsj85eekj.scala:46:12 ---------------------------\e[0m\e[0m\n\e[31m46\
    \ |\e[0m        \e[33mval\e[0m \e[36mhungryLeftLeftLeftLeftLeftLeftLeftLeft\e\
    [0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftLeftLeftLeftLeftLeftLeftLeft is already defined\
    \ as \e[33mvalue\e[0m \e[35mhungryLeftLeftLeftLeftLeftLeftLeftLeft\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsj85eekj.scala:47:12 ---------------------------\e[0m\e[0m\n\e[31m47\
    \ |\e[0m        \e[33mval\e[0m \e[36mleftLeftLeftLeftLeftLeftLeftLeftLeft\e[0m\
    \ = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftLeftLeftLeftLeftLeftLeftLeftLeft is already defined as\
    \ \e[33mvalue\e[0m \e[35mleftLeftLeftLeftLeftLeftLeftLeftLeft\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpsj85eekj.scala:48:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m48 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryLeftLeftLeftLeftLeftLeftLeftLeft\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftLeftLeftLeftLeftLeftLeftLeft is already defined\
    \ as \e[33mvalue\e[0m \e[35mhungryLeftLeftLeftLeftLeftLeftLeftLeft\e[0m\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpsj85eekj.scala:49:12 ---------------------------\e[0m\e[0m\n\e[31m49\
    \ |\e[0m        \e[33mval\e[0m \e[36mleftLeftLeftLeftLeftLe"
  stdout: ''
  timestamp: 1660010518
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val eaten = math.min(meals,\
    \ carrots)\n        val left = (carrots - eaten)\n        List(meals, left)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp3u5tyccc.scala:30)\n\tat Problem.main(tmp3u5tyccc.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = carrots - meals\n\
    \        val mealsLeftList = List(mealsLeft)\n        val mealsLeftList2 = List(mealsLeft)\n\
    \        val mealsLeftList3 = List(mealsLeft)\n        val mealsLeftList4 = List(mealsLeft)\n\
    \        val mealsLeftList5 = List(mealsLeft)\n        val mealsLeftList6 = List(mealsLeft)\n\
    \        val mealsLeftList7 = List(mealsLeft)\n        val mealsLeftList8 = List(mealsLeft)\n\
    \        val mealsLeftList9 = List(mealsLeft)\n        val mealsLeftList10 = List(mealsLeft)\n\
    \        val mealsLeftList11 = List(mealsLeft)\n        val mealsLeftList12 =\
    \ List(mealsLeft)\n        val mealsLeftList13 = List(mealsLeft)\n        val\
    \ mealsLeftList14 = List(mealsLeft)\n        val mealsLeftList15 = List(mealsLeft)\n\
    \        val mealsLeftList16 = List(mealsLeft)\n        val mealsLeftList17 =\
    \ List(mealsLeft)\n        val mealsLeftList18 = List(mealsLeft)\n        val\
    \ mealsLeftList19 = List(mealsLeft)\n        val mealsLeftList20 = List(mealsLeft)\n\
    \        val mealsLeftList21 = List(mealsLeft)\n        val mealsLeftList22 =\
    \ List(mealsLeft)\n        val mealsLeftList23 = List(mealsLeft)\n        val\
    \ mealsLeftList24 = List(mealsLeft)\n        val mealsLeftList25 = List(mealsLeft)\n\
    \        val mealsLeftList26 = List(mealsLeft)\n        val mealsLeftList27 =\
    \ List(mealsLeft)\n        val mealsLeftList28 = List(mealsLeft)\n        val\
    \ mealsLeftList29 = List(mealsLeft)\n        val mealsLeftList30 = List(mealsLeft)\n\
    \        val mealsLeftList31 = List(mealsLeft)\n        val mealsLeftList32 =\
    \ List(mealsLeft)\n        val mealsLeftList33 = List(mealsLeft)\n        val\
    \ mealsLeftList34 = List(mealsLeft)\n        val mealsLeftList35 = List(mealsLeft)\n\
    \        val meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_0xysn1_.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_0xysn1_.scala:62:5 ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingArray = Array.ofDim[Long](mealsRemaining)\n\
    \        val mealsRemainingArrayCopy = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopy2 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy3\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy4 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy5 = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopy6 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy7\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy8 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy9 = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopy10 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy11\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy12 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy13 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy14 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy15\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy16 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy17 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy18 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy19\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy20 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy21 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy22 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy23\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy24 = mealsRemainingArray.clone()\n\
    \        val mealsRemainingArrayCopy25 = mealsRemainingArray.clone()\n       \
    \ val mealsRemainingArrayCopy26 = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy27\
    \ = mealsRemainingArray.clone()\n        val mealsRemainingArrayCopy28 = mealsRemainingArray.\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6s35hf5e.scala:55:4 ----------------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    an identifier expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6s35hf5e.scala:26:52 --------------------\e[0m\e[0m\n\e[31m26\
    \ |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArray\e[0m = Array.ofDim[\e\
    [35mLong\e[0m](mealsRemaining)\n\e[31m\e[31m   |\e[0m                        \
    \                            ^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            \
    \                           Found:    (mealsRemaining : Long)\n\e[31m   |\e[0m\
    \                                       Required: Int\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp6s35hf5e.scala:55:5 ---------------------\e\
    [0m\e[0m\n\e[31m55 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    3 errors found\n"
  stdout: ''
  timestamp: 1660010504
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number - remaining\n\
    \        val left  = need - remaining\n        val result = new Array[Long](2)\n\
    \        result(0) = eaten\n        result(1) = left\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7l0tfqkv.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val mealsLeft = mealsLeft.toString.toInt\n        val mealsLeft = mealsLeft.toString.toInt\n\
    \        val meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp48x52d0z.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp48x52d0z.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp48x52d0z.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp48x52d0z.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp48x52d0z.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeft\e[0m = mealsLeft.toString.toInt\n\e[31m\e[31m   |\e[0m     \
    \   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mmealsLeft is\
    \ already defined as \e[33mvalue\e[0m \e[35mmealsLeft\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp48x52d0z.scala:30:12\
    \ ------"
  stdout: ''
  timestamp: 1660010520
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        if (remaining < 0)\n            result :+ remaining\n        else\n \
    \           result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpjdja4san.scala:32)\n\tat Problem.main(tmpjdja4san.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010523
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val remaining = remaining - carrots\n        val meals = math.max(math.min(remaining,\
    \ 100), 0) // if there are not enough carrots, eat all remaining carrots, but\
    \ will still be hungry.\n        val hungry = math.max(math.min(remaining, 100),\
    \ 0) // if there are not enough carrots, eat all remaining carrots, but will still\
    \ be hungry.\n        val eaten = math.max(math.min(remaining, 100), 0) // if\
    \ there are not enough carrots, eat all remaining carrots, but will still be hungry.\n\
    \        val hungryCarrots = math.max(math.min(remaining, 100), 0) // if there\
    \ are not enough carrots, eat all remaining carrots, but will still be hungry.\n\
    \        val hungryEaten = math.max(math.min(remaining, 100), 0) // if there are\
    \ not enough carrots, eat all remaining carrots, but will still be hungry.\n \
    \       val hungryRemaining = math.max(math.min(remaining, 100), 0) // if there\
    \ are not enough carrots, eat all remaining carrots, but will still be hungry.\n\
    \        val hungryEatenCarrots = math.max(math.min(remaining, 100), 0) // if\
    \ there are not enough carrots, eat all remaining carrots, but will still be hungry.\n\
    \        val hungryEatenRemaining = math.max(math.min(remaining, 100), 0) // if\
    \ there are not enough carrots, eat all remaining carrots, but will still be hungry.\n\
    \        val hungryEatenRemainingCarrots = math.max(math.min(remaining, 100),\
    \ 0) // if there are not enough carrots, eat all remaining carrots, but will still\
    \ be hungry.\n        val hungryEatenRemainingCarrotsCarrots = math.max(math.min(remaining,\
    \ 100), 0) // if there are not enough carrots, eat all remaining carrots, but\
    \ will still be hungry.\n        val hungryEatenRemainingCarrotsCarrotsCarrots\
    \ = math.max(math.min(remaining, 100), 0) // if there are not enough carrots,\
    \ eat all remaining carrots, but will still be hungry.\n        val hungryEatenRemainingCarro\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6i93f1nq.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6i93f1nq.scala:24:24\
    \ ---------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = remaining - carrots\n\e[31m\e[31m   |\e[0m          \
    \              ^\e[0m\n\e[31m   |\e[0m                        Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6i93f1nq.scala:37:5 ---------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010520
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots - hungry\n        val hungryMeals = meals - hungry\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8bfn90x2.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while(number\
    \ > 0 && carrots_left > 0 && hungry) {\n            carrots_left -= 1\n      \
    \      carrots += number\n            hungry = false\n            number -= 1\n\
    \        }\n        carrots.toList\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp0qyss_hu.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp0qyss_hu.scala:30:19 ------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010521
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxq_q2e_8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e\
    [35mLong\e[0m](carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsArray is already defined as \e[33mvalue\e[0m \e[35mcarrotsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmealsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsArray is already defined as \e[33mvalue\e[0m \e[35mmealsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsArray is already defined as \e[33mvalue\e[0m \e[35mcarrotsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmealsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsArray is already defined as \e[33mvalue\e[0m \e[35mmealsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m]("
  stdout: ''
  timestamp: 1660010482
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingArray = Array.ofDim[Long](mealsRemaining)\n\
    \        val mealsRemainingArrayCopy = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy\
    \ = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy =\
    \ mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n\
    \        val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n \
    \       val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n  \
    \      val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n   \
    \     val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n    \
    \    val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n     \
    \   val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n      \
    \  val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n       \
    \ val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n        val\
    \ mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy\
    \ = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy =\
    \ mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n\
    \        val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n \
    \       val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n  \
    \      val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n   \
    \     val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n    \
    \    val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n     \
    \   val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n      \
    \  val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n       \
    \ val mealsRemainingArrayCopyCopy\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp40gz3wsf.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp40gz3wsf.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayCopyCopy\e[0m = mealsRemainingArrayCopy.clone()\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp40gz3wsf.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayCopyCopy\e\
    [0m = mealsRemainingArrayCopy.clone()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp40gz3wsf.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayCopyCopy\e\
    [0m = mealsRemainingArrayCopy.clone()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp40gz3wsf.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayCopyCopy\e\
    [0m = mealsRemainingArrayCopy.clone()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010523
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while\
    \ (hungry && carrots_left > 0) {\n            carrots += carrots_left\n      \
    \      carrots_left -= 1\n            hungry = false\n        }\n        carrots\
    \ ++ List(remaining)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp31q311b2.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val meals_left = carrots - meals\n\
    \        val carrots_left = remaining - meals\n        val carrots_left_after_meals\
    \ = carrots_left - meals\n        val carrots_left_after_meals_after_meals = carrots_left_after_meals\
    \ - meals\n        val carrots_left_after_meals_after_meals_after_meals = carrots_left_after_meals_after_meals\
    \ - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals - meals\n   \
    \     val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - meals\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp8etwhpud.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp8etwhpud.scala:37:5 ---------------------\e[0m\e[0m\n\e[31m37 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010522
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeftList = List(mealsLeft)\n        val mealsLeftList2 = List(mealsLeft\
    \ + 1)\n        val mealsLeftList3 = List(mealsLeft + 2)\n        val mealsLeftList4\
    \ = List(mealsLeft + 3)\n        val mealsLeftList5 = List(mealsLeft + 4)\n  \
    \      val mealsLeftList6 = List(mealsLeft + 5)\n        val mealsLeftList7 =\
    \ List(mealsLeft + 6)\n        val mealsLeftList8 = List(mealsLeft + 7)\n    \
    \    val mealsLeftList9 = List(mealsLeft + 8)\n        val mealsLeftList10 = List(mealsLeft\
    \ + 9)\n        val mealsLeftList11 = List(mealsLeft + 10)\n        val mealsLeftList12\
    \ = List(mealsLeft + 11)\n        val mealsLeftList13 = List(mealsLeft + 12)\n\
    \        val mealsLeftList14 = List(mealsLeft + 13)\n        val mealsLeftList15\
    \ = List(mealsLeft + 14)\n        val mealsLeftList16 = List(mealsLeft + 15)\n\
    \        val mealsLeftList17 = List(mealsLeft + 16)\n        val mealsLeftList18\
    \ = List(mealsLeft + 17)\n        val mealsLeftList19 = List(mealsLeft + 18)\n\
    \        val mealsLeftList20 = List(mealsLeft + 19)\n        val mealsLeftList21\
    \ = List(mealsLeft + 20)\n        val mealsLeftList22 = List(mealsLeft + 21)\n\
    \        val mealsLeftList23 = List(mealsLeft + 22)\n        val mealsLeftList24\
    \ = List(mealsLeft + 23)\n        val mealsLeftList25 = List(mealsLeft + 24)\n\
    \        val mealsLeftList26 = List(mealsLeft + 25)\n        val mealsLeftList27\
    \ = List(mealsLeft + 26)\n        val mealsLeftList28 = List(mealsLeft + 27)\n\
    \        val mealsLeftList29 = List(mealsLeft + 28)\n        val mealsLeftList30\
    \ = List(mealsLeft + 29)\n        val mealsLeftList31 = List(mealsLeft + 30)\n\
    \        val mealsLeftList32 = List(mealsLeft + 31)\n        val mealsLeftList33\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb3s7jv2a.scala:58:29 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftList33\e[0m = \n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb3s7jv2a.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrotsLeft = remaining - carrots\n        val meals = carrotsLeft\
    \ / 3\n        val carrotsLeft = carrotsLeft % 3\n        val carrotsLeft2 = carrotsLeft\
    \ / 2\n        val carrotsLeft3 = carrotsLeft % 2\n        val carrotsLeft4 =\
    \ carrotsLeft / 4\n        val carrotsLeft5 = carrotsLeft % 4\n        val carrotsLeft6\
    \ = carrotsLeft / 6\n        val carrotsLeft7 = carrotsLeft % 6\n        val carrotsLeft8\
    \ = carrotsLeft / 8\n        val carrotsLeft9 = carrotsLeft % 8\n        val carrotsLeft10\
    \ = carrotsLeft / 10\n        val carrotsLeft11 = carrotsLeft % 10\n        val\
    \ carrotsLeft12 = carrotsLeft / 12\n        val carrotsLeft13 = carrotsLeft %\
    \ 12\n        val carrotsLeft14 = carrotsLeft / 14\n        val carrotsLeft15\
    \ = carrotsLeft % 14\n        val carrotsLeft16 = carrotsLeft / 16\n        val\
    \ carrotsLeft17 = carrotsLeft % 16\n        val carrotsLeft18 = carrotsLeft /\
    \ 18\n        val carrotsLeft19 = carrotsLeft % 18\n        val carrotsLeft20\
    \ = carrotsLeft / 20\n        val carrotsLeft21 = carrotsLeft % 20\n        val\
    \ carrotsLeft22 = carrotsLeft / 22\n        val carrotsLeft23 = carrotsLeft %\
    \ 22\n        val carrotsLeft24 = carrotsLeft / 24\n        val carrotsLeft25\
    \ = carrotsLeft % 24\n        val carrotsLeft26 = carrotsLeft / 26\n        val\
    \ carrotsLeft27 = carrotsLeft % 26\n        val carrotsLeft28 = carrotsLeft /\
    \ 28\n        val carrotsLeft29 = carrotsLeft % 28\n        val carrotsLeft30\
    \ = carrotsLeft / 30\n        val carrotsLeft31 = carrotsLeft % 30\n        val\
    \ carrotsLeft32 = carrotsLeft / 32\n        val carrotsLeft33 = carrotsLeft \n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqjjki9_t.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeft\e[0m = carrotsLeft\
    \ % \e[31m3\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsLeft is already defined as \e[33mvalue\e[0m \e[35mcarrotsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E007] Type\
    \ Mismatch Error: /tmp/tmpqjjki9_t.scala:59:5 ---------------------\e[0m\e[0m\n\
    \e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:\
    \    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n2 errors\
    \ found\n"
  stdout: ''
  timestamp: 1660010525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsList = mutable.ListBuffer[Long]()\n\
    \        mealsList.add(meals)\n        mealsList.add(carrots)\n        mealsList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv685fupa.scala:25:24 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmealsList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrotsLeft = remaining - carrots\n        val carrotsLeftAfterMeals\
    \ = carrotsLeft - carrots // carrots left after meals\n        val carrotsLeftAfterMealsAfterMeals\
    \ = carrotsLeftAfterMeals - carrots // carrots left after meals after meals\n\
    \        val carrotsLeftAfterMealsAfterMealsAfterMeals = carrotsLeftAfterMealsAfterMeals\
    \ - carrots // carrots left after meals after meals after meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMeals - carrots // carrots left after\
    \ meals after meals after meals after meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMeals - carrots // carrots left\
    \ after meals after meals after meals after meals after meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - carrots //\
    \ carrots left after meals after meals after meals after meals after meals after\
    \ meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals -\
    \ carrots // carrots left after meals after meals after meals after meals after\
    \ meals after meals after meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - carrots // carrots left after meals after meals after meals after meals after\
    \ meals after meals after meals after meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfter\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpczu_88n3.scala:34:4 ----------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpczu_88n3.scala:34:5 ---------------------\e[0m\e[0m\n\e[31m34 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n        val carrotsArray =\
    \ Array.ofDim[Long](carrots)\n        val mealsArray = Array.ofDim[Long](meals)\n\
    \        val carrotsArray = Array.ofDim[Long](carrots)\n        val mealsArray\
    \ = Array.ofDim[Long](meals)\n        val carrotsArray = Array.ofDim[Long](carrots)\n\
    \        val mealsArray = Array.ofDim[Long](meals)\n\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxq_q2e_8.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e\
    [35mLong\e[0m](carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsArray is already defined as \e[33mvalue\e[0m \e[35mcarrotsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmealsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsArray is already defined as \e[33mvalue\e[0m \e[35mmealsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsArray is already defined as \e[33mvalue\e[0m \e[35mcarrotsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mmealsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m](meals)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsArray is already defined as \e[33mvalue\e[0m \e[35mmealsArray\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpxq_q2e_8.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mcarrotsArray\e[0m = Array.ofDim[\e[35mLong\e\
    [0m]("
  stdout: ''
  timestamp: 1660010482
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsList = List(meals)\n   \
    \     val carrotsList = List(carrots)\n        val carrotsList2 = List(carrots)\n\
    \        val carrotsList3 = List(carrots)\n        val carrotsList4 = List(carrots)\n\
    \        val carrotsList5 = List(carrots)\n        val carrotsList6 = List(carrots)\n\
    \        val carrotsList7 = List(carrots)\n        val carrotsList8 = List(carrots)\n\
    \        val carrotsList9 = List(carrots)\n        val carrotsList10 = List(carrots)\n\
    \        val carrotsList11 = List(carrots)\n        val carrotsList12 = List(carrots)\n\
    \        val carrotsList13 = List(carrots)\n        val carrotsList14 = List(carrots)\n\
    \        val carrotsList15 = List(carrots)\n        val carrotsList16 = List(carrots)\n\
    \        val carrotsList17 = List(carrots)\n        val carrotsList18 = List(carrots)\n\
    \        val carrotsList19 = List(carrots)\n        val carrotsList20 = List(carrots)\n\
    \        val carrotsList21 = List(carrots)\n        val carrotsList22 = List(carrots)\n\
    \        val carrotsList23 = List(carrots)\n        val carrotsList24 = List(carrots)\n\
    \        val carrotsList25 = List(carrots)\n        val carrotsList26 = List(carrots)\n\
    \        val carrotsList27 = List(carrots)\n        val carrotsList28 = List(carrots)\n\
    \        val carrotsList29 = List(carrots)\n        val carrotsList30 = List(carrots)\n\
    \        val carrotsList31 = List(carrots)\n        val carrotsList32 = List(carrots)\n\
    \        val carrotsList33 = List(carrots)\n        val carrotsList34 = List(carrots)\n\
    \        val carrotsList35 = List(carrots)\n        val carro\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1bhou36u.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp1bhou36u.scala:62:5 ---------------------\e[0m\e[0m\n\e[31m62 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left  = remaining - need\n        val meals = hungry + left\n   \
    \     val carrots = List(need)\n        val result = List(meals, carrots)\n  \
    \      result :: eat(number, need, remaining)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmqp_s9bd.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        result :: eat(number,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (result : List[Matchable])\n\e[31m   |\e[0m        Required:\
    \ Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010525
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeftList = List(mealsLeft)\n        val mealsLeftList2 = List(mealsLeft\
    \ + 1)\n        val mealsLeftList3 = List(mealsLeft + 2)\n        val mealsLeftList4\
    \ = List(mealsLeft + 3)\n        val mealsLeftList5 = List(mealsLeft + 4)\n  \
    \      val mealsLeftList6 = List(mealsLeft + 5)\n        val mealsLeftList7 =\
    \ List(mealsLeft + 6)\n        val mealsLeftList8 = List(mealsLeft + 7)\n    \
    \    val mealsLeftList9 = List(mealsLeft + 8)\n        val mealsLeftList10 = List(mealsLeft\
    \ + 9)\n        val mealsLeftList11 = List(mealsLeft + 10)\n        val mealsLeftList12\
    \ = List(mealsLeft + 11)\n        val mealsLeftList13 = List(mealsLeft + 12)\n\
    \        val mealsLeftList14 = List(mealsLeft + 13)\n        val mealsLeftList15\
    \ = List(mealsLeft + 14)\n        val mealsLeftList16 = List(mealsLeft + 15)\n\
    \        val mealsLeftList17 = List(mealsLeft + 16)\n        val mealsLeftList18\
    \ = List(mealsLeft + 17)\n        val mealsLeftList19 = List(mealsLeft + 18)\n\
    \        val mealsLeftList20 = List(mealsLeft + 19)\n        val mealsLeftList21\
    \ = List(mealsLeft + 20)\n        val mealsLeftList22 = List(mealsLeft + 21)\n\
    \        val mealsLeftList23 = List(mealsLeft + 22)\n        val mealsLeftList24\
    \ = List(mealsLeft + 23)\n        val mealsLeftList25 = List(mealsLeft + 24)\n\
    \        val mealsLeftList26 = List(mealsLeft + 25)\n        val mealsLeftList27\
    \ = List(mealsLeft + 26)\n        val mealsLeftList28 = List(mealsLeft + 27)\n\
    \        val mealsLeftList29 = List(mealsLeft + 28)\n        val mealsLeftList30\
    \ = List(mealsLeft + 29)\n        val mealsLeftList31 = List(mealsLeft + 30)\n\
    \        val mealsLeftList32 = List(mealsLeft + 31)\n        val mealsLeftList33\
    \ = \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpb3s7jv2a.scala:58:29 ---------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftList33\e[0m = \n\
    \e[31m\e[31m   |\e[0m                             ^\e[0m\n\e[31m   |\e[0m    \
    \                         expression expected but \e[31m'}'\e[0m found\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpb3s7jv2a.scala:59:5 ---------------------\e\
    [0m\e[0m\n\e[31m59 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    2 errors found\n"
  stdout: ''
  timestamp: 1660010497
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots - hungry\n        val hungryMeals = meals - hungry\n\
    \        val hungryCarrotsList = List(hungryCarrots)\n        val hungryMealsList\
    \ = List(hungryMeals)\n        val hungryList = List(hungry)\n        val hungryListList\
    \ = List(hungryList)\n        val hungryListListList = List(hungryListList)\n\
    \        val hungryListListListList = List(hungryListListList)\n        val hungryListListListListList\
    \ = List(hungryListListListList)\n        val hungryListListListListListList =\
    \ List(hungryListListListListList)\n        val hungryListListListListListListList\
    \ = List(hungryListListListListListList)\n        val hungryListListListListListListListList\
    \ = List(hungryListListListListListListList)\n        val hungryListListListListListListListListList\
    \ = List(hungryListListListListListListListList)\n        val hungryListListListListListListListListListList\
    \ = List(hungryListListListListListListListListListList)\n        val hungryListListListListListListListListListListList\
    \ = List(hungryListListListListListListListListListList)\n        val hungryListListListListListListListListListListListList\
    \ = List(hungryListListListListListListListListListListList)\n        val hungryListListListListListListListListListListListList\
    \ = List(hungryListListListListListListListListListListList)\n        val hungryListListListListListListListListListListListList\
    \ = List(hungryListListListListListListListListListListListList)\n        val\
    \ hungryListListListListListListListListListListListListList = List(hungryListListListListListListListListListListListListList)\n\
    \        val hungryListListListListListList\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpkekiv_l4.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpkekiv_l4.scala:42:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m42 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryListListListListListListListListListListListList\e[0m = List(hungryListListListListListListListListListListList)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryListListListListListListListListListListListList is\
    \ already defined as \e[33mvalue\e[0m \e[35mhungryListListListListListListListListListListListList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpkekiv_l4.scala:43:12 ---------------------------\e[0m\e[0m\n\e\
    [31m43 |\e[0m        \e[33mval\e[0m \e[36mhungryListListListListListListListListListListListList\e\
    [0m = List(hungryListListListListListListListListListListListList)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryListListListListListListListListListListListList is\
    \ already defined as \e[33mvalue\e[0m \e[35mhungryListListListListListListListListListListListList\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E134] Type\
    \ Error: /tmp/tmpkekiv_l4.scala:26:36 -----------------------------\e[0m\e[0m\n\
    \e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = carrots - hungry\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mNone of the overloaded alternatives of \e[33mmethod\e[0m \e[35m-\e[0m in \e\
    [33mclass\e[0m \e[35mLong\e[0m with types\n\e[31m   |\e[0m (x: Double): Double\n\
    \e[31m   |\e[0m (x: Float): Float\n\e[31m   |\e[0m (x: Long): Long\n\e[31m   |\e\
    [0m "
  stdout: ''
  timestamp: 1660010527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        var carrots_left = remaining\n        while(number > 0 && carrots_left\
    \ > 0) {\n            carrots_left -= 1\n            number -= 1\n           \
    \ carrots += number\n        }\n        carrots.toList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpqucai5i5.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmpqucai5i5.scala:27:19 ------------------------\e[0m\e\
    [0m\n\e[31m27 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010526
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots - hungry\n        val hungryCarrotsList = List(hungryCarrots)\n\
    \        val hungryCarrotsList2 = List(hungryCarrots)\n        val hungryCarrotsList3\
    \ = List(hungryCarrots)\n        val hungryCarrotsList4 = List(hungryCarrots)\n\
    \        val hungryCarrotsList5 = List(hungryCarrots)\n        val hungryCarrotsList6\
    \ = List(hungryCarrots)\n        val hungryCarrotsList7 = List(hungryCarrots)\n\
    \        val hungryCarrotsList8 = List(hungryCarrots)\n        val hungryCarrotsList9\
    \ = List(hungryCarrots)\n        val hungryCarrotsList10 = List(hungryCarrots)\n\
    \        val hungryCarrotsList11 = List(hungryCarrots)\n        val hungryCarrotsList12\
    \ = List(hungryCarrots)\n        val hungryCarrotsList13 = List(hungryCarrots)\n\
    \        val hungryCarrotsList14 = List(hungryCarrots)\n        val hungryCarrotsList15\
    \ = List(hungryCarrots)\n        val hungryCarrotsList16 = List(hungryCarrots)\n\
    \        val hungryCarrotsList17 = List(hungryCarrots)\n        val hungryCarrotsList18\
    \ = List(hungryCarrots)\n        val hungryCarrotsList19 = List(hungryCarrots)\n\
    \        val hungryCarrotsList20 = List(hungryCarrots)\n        val hungryCarrotsList21\
    \ = List(hungryCarrots)\n        val hungryCarrotsList22 = List(hungryCarrots)\n\
    \        val hungryCarrotsList23 = List(hun\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpct37n938.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E134] Type Error: /tmp/tmpct37n938.scala:26:36\
    \ -----------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e\
    [0m \e[36mhungryCarrots\e[0m = carrots - hungry\n\e[31m\e[31m   |\e[0m       \
    \                     ^^^^^^^^^\e[0m\n\e[31m   |\e[0mNone of the overloaded alternatives\
    \ of \e[33mmethod\e[0m \e[35m-\e[0m in \e[33mclass\e[0m \e[35mLong\e[0m with types\n\
    \e[31m   |\e[0m (x: Double): Double\n\e[31m   |\e[0m (x: Float): Float\n\e[31m\
    \   |\e[0m (x: Long): Long\n\e[31m   |\e[0m (x: Int): Long\n\e[31m   |\e[0m (x:\
    \ Char): Long\n\e[31m   |\e[0m (x: Short): Long\n\e[31m   |\e[0m (x: Byte): Long\n\
    \e[31m   |\e[0mmatch arguments ((hungry : Boolean))\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpct37n938.scala:49:39 ------------------------\e[0m\e[0m\n\
    \e[31m49 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsList23\e[0m = List(hun\n\
    \e[31m\e[31m   |\e[0m                                       ^^^\e[0m\n\e[31m \
    \  |\e[0m                                       Not found: hun\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpct37n938.scala:50:5 ---------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010527
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(carrots, meals)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp09_tw5ij.scala:29)\n\tat Problem.main(tmp09_tw5ij.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = new Array[Long](2)\n\
    \        result(0) = carrots\n        result(1) = remaining\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpsi36qoi6.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val hungry = if (carrots > 0) true else false\n        val meals = if\
    \ (hungry) need else 0\n        val eaten = if (hungry) carrots else 0\n     \
    \   val remaining = if (hungry) remaining - carrots else 0\n        List(meals,\
    \ eaten, remaining)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptwuug0it.scala:24:25 ---------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = \e[33mif\e\
    [0m (carrots > \e[31m0\e[0m) \e[31mtrue\e[0m \e[33melse\e[0m \e[31mfalse\e[0m\n\
    \e[31m\e[31m   |\e[0m                         ^\e[0m\n\e[31m   |\e[0m        \
    \                 Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmptwuug0it.scala:27:36\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = \e[33mif\e[0m (hungry) remaining - carrots \e[33melse\e\
    [0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m                                    ^\e\
    [0m\n\e[31m   |\e[0m                                    Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010527
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals)\n      \
    \  val carrotsLeft = remaining - meals\n        if (remaining > 0)\n         \
    \   result ::: eat(carrotsLeft, need, remaining)\n        else\n            result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.immutable.List.prependedAll(List.scala:148)\n\
    \tat scala.collection.immutable.List$.from(List.scala:684)\n\tat scala.collection.immutable.List$.from(List.scala:681)\n\
    \tat scala.collection.IterableFactory.apply(Factory.scala:103)\n\tat scala.collection.IterableFactory.apply$(Factory.scala:103)\n\
    \tat scala.collection.immutable.List$.apply(List.scala:681)\n\tat Problem$.eat(tmpx2dgqmbh.scala:25)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\tat Problem$.eat(tmpx2dgqmbh.scala:28)\n\
    \tat Problem$.eat(tmpx2dgqmbh"
  stdout: ''
  timestamp: 1660010539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val meals = math.min(math.max(math.ceil(remaining / carrots), 1), 1000)\n\
    \        val remaining = math.min(math.max(math.ceil(remaining - meals * carrots),\
    \ 0), 1000)\n        val hungry = math.min(math.max(math.ceil(remaining / carrots),\
    \ 1), 1000)\n        val hungryRemaining = math.min(math.max(math.ceil(remaining\
    \ - hungry * carrots), 0), 1000)\n        val hungryEaten = math.min(math.max(math.ceil(remaining\
    \ / carrots), 1), 1000)\n        val hungryEatenRemaining = math.min(math.max(math.ceil(remaining\
    \ - hungryEaten * carrots), 0), 1000)\n        val hungryEatenEaten = math.min(math.max(math.ceil(remaining\
    \ / carrots), 1), 1000)\n        val hungryEatenEatenRemaining = math.min(math.max(math.ceil(remaining\
    \ - hungryEatenEaten * carrots), 0), 1000)\n        val hungryEatenEatenEaten\
    \ = math.min(math.max(math.ceil(remaining / carrots), 1), 1000)\n        val hungryEatenEatenEatenRemaining\
    \ = math.min(math.max(math.ceil(remaining - hungryEatenEatenEaten * carrots),\
    \ 0), 1000)\n        val hungryEatenEatenEatenEaten = math.min(math.max(math.ceil(remaining\
    \ / carrots), 1), 1000)\n        val hungryEatenEatenEatenEatenRemaining = math.min(math.max(math.ceil(remaining\
    \ - hungryEatenEatenEatenEaten * carrots), 0), 1000)\n        val hungryEatenEatenEatenEatenEaten\
    \ = math.min(math.max(math.ceil(remaining / carrots), 1), 1000)\n        val hungryEatenEatenEatenEatenEatenRemaining\
    \ = math.min(math.max(math.ceil(remaining - hungryEatenEatenEatenEaten * carrots),\
    \ 0), 1000)\n        val hungryEatenEatenEatenEat\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpanh6oufv.scala:39:4 ----------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpanh6oufv.scala:25:52\
    \ ---------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m\
    \ \e[36mremaining\e[0m = math.min(math.max(math.ceil(remaining - meals * carrots),\
    \ \e[31m0\e[0m), \e[31m1000\e[0m)\n\e[31m\e[31m   |\e[0m                     \
    \                               ^\e[0m\n\e[31m   |\e[0m                      \
    \              Recursive \e[33mvalue\e[0m \e[35mremaining\e[0m needs type\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpanh6oufv.scala:39:5\
    \ ---------------------\e[0m\e[0m\n\e[31m39 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result: List[Long] = new ArrayList[Long]()\n\
    \        if (meals > 0) {\n            result.add(meals)\n            result.add(carrots)\n\
    \        }\n        return result\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6c6v8yqq.scala:25:37 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e\
    [0m[\e[35mLong\e[0m] = \e[33mnew\e[0m \e[35mArrayList\e[0m[\e[35mLong\e[0m]()\n\
    \e[31m\e[31m   |\e[0m                                     ^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                                     Not found: type ArrayList\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6c6v8yqq.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            result.add(meals)\n\e[31m\e[31m   |\e[0m\
    \            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value add is not a member\
    \ of List[Long]\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp6c6v8yqq.scala:28:19\
    \ ------------------------\e[0m\e[0m\n\e[31m28 |\e[0m            result.add(carrots)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^\e[0m\n\e[31m   |\e[0mvalue add is\
    \ not a member of List[Long], but could be made available as an extension method.\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mOne of the following imports might fix the problem:\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.seq\
    \ AsJavaList\n\e[31m   |\e[0m  import collection.convert.ImplicitConversions.collection\
    \ asJava\n\e[31m   |\e[0m  import collection.convert.ImplicitConversionsToJava.collection\
    \ asJava\n\e[31m   |\e[0m\n3 errors found\n"
  stdout: ''
  timestamp: 1660010540
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val left  = mutable.ArrayBuffer(remaining)\n\
    \        val meals  = mutable.ArrayBuffer(0)\n        val hungryMeals  = mutable.ArrayBuffer(0)\n\
    \        val leftMeals  = mutable.ArrayBuffer(0)\n        val hungryLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeft  = mutable.ArrayBuffer(0)\n        val hungryLeftLeft  =\
    \ mutable.ArrayBuffer(0)\n        val leftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeft  = mutable.ArrayBuffer(0)\n        val leftLeftLeftLeft\
    \  = mutable.ArrayBuffer(0)\n        val hungryLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n        val hungryLeftLeftLeftLeftLeft\
    \  = mutable.ArrayBuffer(0)\n        val leftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n      \
    \  val leftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n        val hungryLeftLeftLeftLeftLeftLeftLeft\
    \  = mutable.ArrayBuffer(0)\n        val leftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeftLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val leftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeftLeft  = mutable.ArrayBuffer(0)\n\
    \        val h\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpn4pu101q.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn4pu101q.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn4pu101q.scala:24:21\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn4pu101q.scala:25:20\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mleft\e[0m  = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m       \
    \             ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn4pu101q.scala:26:21\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mmeals\e[0m  = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpn4pu101q.scala:27:27\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryMeals\e[0m  = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e\
    [0m                           ^^^^^^^\e[0m\n\e[31m   |\e[0m                  \
    \         Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when c"
  stdout: ''
  timestamp: 1660010538
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val remaining = math.max(0,\
    \ carrots - meals)\n        val result = List(meals, remaining)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpnubfh6xo.scala:25:36 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = math.max(\e\
    [31m0\e[0m, carrots - meals)\n\e[31m\e[31m   |\e[0m                          \
    \          ^\e[0m\n\e[31m   |\e[0m                                    Recursive\
    \ \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010533
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val leftCarrots = math.max(0,\
    \ carrots - meals)\n        List(meals, leftCarrots)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8w2yv1g3.scala:29)\n\tat Problem.main(tmp8w2yv1g3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010484
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = new Array[Long](2)\n\
    \        result(0) = carrots\n        result(1) = meals\n        result\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpf94ae4p9.scala:28:8\
    \ ---------------------\e[0m\e[0m\n\e[31m28 |\e[0m        result\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m        Found:    (result : Array[Long])\n\
    \e[31m   |\e[0m        Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m\
    \ longer explanation available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010539
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsList = mutable.ListBuffer[Long]()\n\
    \        mealsList += meals\n        mealsList += carrots\n        mealsList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpsukx_51b.scala:25:24 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmealsList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010533
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number - need\n\
    \        val left  = remaining - eaten\n        val meals = List(need, left)\n\
    \        meals.toList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpcjg5mml3.scala:29)\n\tat Problem.main(tmpcjg5mml3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010543
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val meals = List(leftCarrots)\n\
    \        val totalCarrots = List(leftCarrots)\n        val hungry = List(leftCarrots)\n\
    \        val hungryCarrots = List(leftCarrots)\n        val hungryCarrotsRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsNeeds = List(leftCarrots)\n  \
    \      val hungryCarrotsTotal = List(leftCarrots)\n        val hungryCarrotsTotalRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeeds = List(leftCarrots)\n\
    \        val hungryCarrotsTotalNeedsRemaining = List(leftCarrots)\n        val\
    \ hungryCarrotsTotalNeedsRemainingRemaining = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemainingRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemainingRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining\
    \ = List(leftCarrots)\n        val hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining\
    \ = List(leftCarrots)\n\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1mdqqv0w.scala:40:12 ---------------------------\e\
    [0m\e[0m\n\e[31m40 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemaining\e\
    [0m = List(leftCarrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp1mdqqv0w.scala:44:12 ---------------------------\e\
    [0m\e[0m\n\e[31m44 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining\e\
    [0m = List(leftCarrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  hungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmp1mdqqv0w.scala:45:12 ---------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrotsTotalNeedsRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemainingRemaining\e\
    [0m = List(leftCarrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrotsTotalNeedsRemainin"
  stdout: ''
  timestamp: 1660010541
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrots_left = remaining - carrots\n        val meals = if (carrots_left\
    \ > 0) carrots_left else 0\n        val carrots_after_meals = carrots + meals\n\
    \        val carrots_left_after_meals = carrots_left - meals\n        val carrots_after_meals_without_carrots_left\
    \ = carrots_after_meals - carrots_left\n        val carrots_left_after_meals_without_carrots_left\
    \ = carrots_left_after_meals - carrots_left\n        val carrots_after_meals_without_carrots_left_without_carrots_left\
    \ = carrots_after_meals_without_carrots_left - carrots_left_without_carrots_left\n\
    \        val carrots_left_after_meals_without_carrots_left_without_carrots_left\
    \ = carrots_left_after_meals_without_carrots_left - carrots_left_without_carrots_left\n\
    \        val carrots_after_meals_without_carrots_left_without_carrots_left_without_carrots_left\
    \ = carrots_after_meals_without_carrots_left_without_carrots_left - carrots_left_without_carrots_left_without_carrots_left\n\
    \        val carrots_left_after_meals_without_carrots_left_without_carrots_left_without_carrots_left\
    \ = carrots_left_after_meals_without_carrots_left_without_carrots_left_without_carrots_left\
    \ - carrots_left_without_carrots_left_without_carrots_left_without_carrots_left\n\
    \        val carrots_after_meals_without_carrots_left_without_carrots_left_without_carrots_left_without_carrots_left\
    \ = carrots_after_meals_without_carrots_left_without_carrots_left_without_carrots_left_without_carrots_left\
    \ - carrots_left_without_carrots_left_without_carrots_left_without_carrots_left_without_carrots_left\n\
    \        val carrots_left_after_meals_without_carrots_left_without_carrots_left_without_carrots_left_without_carrots_left\
    \ = carrots_left_after_meals_without_carrots_left_without_carrots_left_without_carrots_left_without_carrots_left_without_carrots_left\
    \ - carrots_left_without_carrots_left_without_carrots_left_without_carrots_left_without_carrots_left_without_carrot\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6444_uwt.scala:30:119 -----------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mcarrots_after_meals_without_carrots_left_without_carrots_left\e\
    [0m = carrots_after_meals_without_carrots_left - carrots_left_without_carrots_left\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: carrots_left_without_carrots_left\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6444_uwt.scala:31:129\
    \ -----------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left_after_meals_without_carrots_left_without_carrots_left\e[0m =\
    \ carrots_left_after_meals_without_carrots_left - carrots_left_without_carrots_left\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                            Not found: carrots_left_without_carrots_left\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp6444_uwt.scala:33:102\
    \ --------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_without_carrots_left_without_carrots_left_without_carrots_left\e\
    [0m = carrots_left_after_meals_without_carrots_left_without_carrots_left_without_carrots_left\
    \ - carrots_left_without_carrots_left_without_carrots_left_without_carrots_left\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                              ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_without_carrots_left_without_carrots_left_without_carrots_left\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when co"
  stdout: ''
  timestamp: 1660010542
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = List(carrots,\
    \ leftCarrots)\n        result\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpewxqmmqr.scala:29)\n\tat Problem.main(tmpewxqmmqr.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while(number > 0 && carrots_left\
    \ > 0) {\n            carrots += carrots_left\n            number -= 1\n     \
    \       carrots_left -= 1\n        }\n        carrots.reverse\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp2f1a8203.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmp2f1a8203.scala:27:19 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010542
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number - need\n\
    \        val left  = remaining - eaten\n        if (left <= 0) {\n           \
    \ List(number, need)\n        } else {\n            List(number, need, left)\n\
    \        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp99m5ard1.scala:32)\n\tat Problem.main(tmp99m5ard1.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010546
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result :+ remaining\n    }\n    def main(args: Array[String]) = {\n \
    \   assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp1zyrtfxj.scala:29)\n\tat Problem.main(tmp1zyrtfxj.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryRemainingNeeds = mutable.ListBuffer[Long]()\n        val hungryNeedsRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemainingNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemainingNeedsRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemainingNeedsRemainingNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemainingNeedsRemainingNeedsRemaining = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeeds = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining =\
    \ mutable.ListBuffer[Long]()\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeed\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpebkr7jn1.scala:42:4 ----------------------------\e\
    [0m\e[0m\n\e[31m42 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpebkr7jn1.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpebkr7jn1.scala:24:21\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m\
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpebkr7jn1.scala:25:30\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemaining\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpebkr7jn1.scala:26:26 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhungryNeeds\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpebkr7jn1.scala:27:35 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhungryRemainingNeeds\e[0m\
    \ = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                 "
  stdout: ''
  timestamp: 1660010544
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = mutable.ArrayBuffer(number)\n\
    \        val left = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val hungry = mutable.ArrayBuffer(0)\n        val hungryRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryEaten = mutable.ArrayBuffer(0)\n        val hungryLeftEaten\
    \ = mutable.ArrayBuffer(0)\n        val hungryLeftRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftEaten = mutable.ArrayBuffer(0)\n        val hungryLeftRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryLeftEaten = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftRemaining = mutable.ArrayBuffer(0)\n        val hungryLeftEaten\
    \ = mutable.ArrayBuffer(0)\n        val hungryLeftRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftEaten = mutable.ArrayBuffer(0)\n        val hungryLeftRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryLeftEaten = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftRemaining = mutable.ArrayBuffer(0)\n        val hungryLeftEaten\
    \ = mutable.ArrayBuffer(0)\n        val hungryLeftRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftEaten = mutable.ArrayBuffer(0)\n        val hungryLeftRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryLeftEaten = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftRemaining = mutable.ArrayBuffer(0)\n        val hungryLeftEaten\
    \ = mutable.ArrayBuffer(0)\n        val hungryLeftRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftEaten = mutable.ArrayBuffer(0)\n        val hungryLeftRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryLeftEaten = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftRemaining = mutable.ArrayBuffer(0)\n        val hungryLeftEaten\
    \ = mutable.ArrayBuffer(0)\n        val hungryLeftRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryLeftEaten = mutable.ArrayBuffer(0)\n        val hungr\n   \
    \ }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2vm5ig2x.scala:57:4 ----------------------------\e\
    [0m\e[0m\n\e[31m57 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp2vm5ig2x.scala:31:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryLeftEaten\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0mhungryLeftEaten is already defined as \e[33mvalue\e[0m \e[35mhungryLeftEaten\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp2vm5ig2x.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftRemaining\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftRemaining is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryLeftRemaining\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2vm5ig2x.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftEaten\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftEaten is already defined as \e[33mvalue\e[0m \e\
    [35mhungryLeftEaten\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp2vm5ig2x.scala:34:12 ---------------------------\e\
    [0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m \e[36mhungryLeftRemaining\e[0m\
    \ = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryLeftRemaining is already defined as \e[33mvalue\e[0m\
    \ \e[35mhungryLeftRemaining\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that ov"
  stdout: ''
  timestamp: 1660010545
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result: List[Long] = List(meals,\
    \ carrots)\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2cx8r71j.scala:29)\n\tat Problem.main(tmp2cx8r71j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010482
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, remaining)\n        val result = List(meals)\n\
    \        if (meals > 0) {\n            val carrots = math.min(meals, remaining)\n\
    \            val meals = math.min(meals, carrots)\n            val meals = math.min(meals,\
    \ remaining)\n            val carrots = math.min(meals, carrots)\n           \
    \ val meals = math.min(meals, carrots)\n            val carrots = math.min(meals,\
    \ carrots)\n            val meals = math.min(meals, carrots)\n            val\
    \ carrots = math.min(meals, carrots)\n            val meals = math.min(meals,\
    \ carrots)\n            val carrots = math.min(meals, carrots)\n            val\
    \ meals = math.min(meals, carrots)\n            val carrots = math.min(meals,\
    \ carrots)\n            val meals = math.min(meals, carrots)\n            val\
    \ carrots = math.min(meals, carrots)\n            val meals = math.min(meals,\
    \ carrots)\n            val carrots = math.min(meals, carrots)\n            val\
    \ meals = math.min(meals, carrots)\n            val carrots = math.min(meals,\
    \ carrots)\n            val meals = math.min(meals, carrots)\n            val\
    \ carrots = math.min(meals, carrots)\n            val meals = math.min(meals,\
    \ carrots)\n            val carrots = math.min(meals, carrots)\n            val\
    \ meals = math.min(meals, carrots)\n            val carrots = math.min(meals,\
    \ carrots)\n            val meals = math.min(meals, carrots)\n            val\
    \ carrots = math.min(meals, carrots)\n            val meals = math.min(meals,\
    \ carrots)\n            val carrots = math.min(meals, carrots)\n            val\
    \ meals = math.min(meals, carrots)\n            val carrots = math.min(meals,\
    \ carrots)\n            val meals = math.min(meals, carrots)\n            val\
    \ carrots = math.min(meals, carrots)\n            val meals = math.min(meals,\
    \ carrots)\n            val carrots = math.min(meals, carrots)\n            val\
    \ me\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgjrrk5lm.scala:62:4 ----------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpgjrrk5lm.scala:73:0\
    \ ----------------------------\e[0m\e[0m\n\e[31m73 |\e[0m\n\e[31m\e[31m   |\e\
    [0m^\e[0m\n\e[31m   |\e[0m'}' expected, but eof found\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgjrrk5lm.scala:29:16 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m            \e[33mval\e[0m \e[36mmeals\e[0m = math.min(meals, remaining)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mmeals is already defined as \e[33mvalue\e[0m \e[35mmeals\e[0m\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgjrrk5lm.scala:30:16 ---------------------------\e[0m\e[0m\n\e[31m30\
    \ |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = math.min(meals, carrots)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpgjrrk5lm.scala:31:16 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m            \e[33mval\e[0m \e[36mmeals\e[0m = math.min(meals, carrots)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mmeals is already defined as \e[33mvalue\e[0m \e[35mmeals\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpgjrrk5lm.scala:32:16 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m            \e[33mval\e[0m \e[36mcarrots\e[0m = math.min(meals, carrots)\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m  "
  stdout: ''
  timestamp: 1660010547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrots_left = remaining - carrots\n        val meals = List(need\
    \ + carrots)\n        val carrots_left = remaining - carrots\n        val meals\
    \ = List(need + carrots)\n        val carrots_left = remaining - carrots\n   \
    \     val meals = List(need + carrots)\n        val carrots_left = remaining -\
    \ carrots\n        val meals = List(need + carrots)\n        val carrots_left\
    \ = remaining - carrots\n        val meals = List(need + carrots)\n        val\
    \ carrots_left = remaining - carrots\n        val meals = List(need + carrots)\n\
    \        val carrots_left = remaining - carrots\n        val meals = List(need\
    \ + carrots)\n        val carrots_left = remaining - carrots\n        val meals\
    \ = List(need + carrots)\n        val carrots_left = remaining - carrots\n   \
    \     val meals = List(need + carrots)\n        val carrots_left = remaining -\
    \ carrots\n        val meals = List(need + carrots)\n        val carrots_left\
    \ = remaining - carrots\n        val meals = List(need + carrots)\n        val\
    \ carrots_left = remaining - carrots\n        val meals = List(need + carrots)\n\
    \        val carrots_left = remaining - carrots\n        val meals = List(need\
    \ + carrots)\n        val carrots_left = remaining - carrots\n        val meals\
    \ = List(need + carrots)\n        val carrots_left = remaining - carrots\n   \
    \     val meals = List(need + carrots)\n        val carrots_left = remaining -\
    \ carrots\n        val meals = List(need + carrots)\n        val carrots_left\
    \ = remaining - carrots\n        val meals = List(need + carrots)\n        val\
    \ carrots_left = remaining - carrots\n        val meals = List(need + carrots)\n\
    \        val carrots_left = remaining - carrots\n        val meals = List(need\
    \ + carrots)\n        val carrots_left = remaining - carrots\n        val meals\
    \ = List(need + carrots)\n        val carrots_left = remaining - carrots\n   \
    \     val meals = List(need + carrots)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1mhbyhe9.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = remaining\
    \ - carrots\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1mhbyhe9.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mmeals\e[0m = List(need + carrots)\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0mmeals is already defined as \e[33mvalue\e[0m \e[35mmeals\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1mhbyhe9.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left\e[0m = remaining - carrots\n\e[31m\e[31m   |\e[0m       \
    \ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots_left is\
    \ already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp1mhbyhe9.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmeals\e[0m = List(need + carrots)\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmeals is already defined as \e[33mvalue\e[0m \e[35mmeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp1mhbyhe9.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = remaining - carrots\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcarrots_left is already defined as \e[33mvalue"
  stdout: ''
  timestamp: 1660010546
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum * hungryRemainingSum\n  \
    \      val hungryRemainingSum4 = hungryRemainingSum * hungryRemainingSum\n   \
    \     val hungryRemainingSum5 = hungryRemainingSum * hungryRemainingSum\n    \
    \    val hungryRemainingSum6 = hungryRemainingSum * hungryRemainingSum\n     \
    \   val hungryRemainingSum7 = hungryRemainingSum * hungryRemainingSum\n      \
    \  val hungryRemainingSum8 = hungryRemainingSum * hungryRemainingSum\n       \
    \ val hungryRemainingSum9 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum10 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum11 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum12 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum13 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum14 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum15 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum16 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum17 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum18 = hungryRemainingSum * hungryRemainingSum\n        val\
    \ hungryRemainingSum19 = hungry\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpr01132hv.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpr01132hv.scala:24:21 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpr01132hv.scala:25:30 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmpr01132hv.scala:45:5 ---------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010546
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result: List[Long] = List(meals,\
    \ carrots)\n        result\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp2cx8r71j.scala:29)\n\tat Problem.main(tmp2cx8r71j.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010482
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrots_left = remaining - carrots\n        val meals = carrots_left\
    \ / 4\n        val carrots_left = carrots_left % 4\n        val carrots_left =\
    \ carrots_left * 4\n        val carrots_left = carrots_left / 4\n        val carrots_left\
    \ = carrots_left % 4\n        val carrots_left = carrots_left * 4\n        val\
    \ carrots_left = carrots_left / 4\n        val carrots_left = carrots_left % 4\n\
    \        val carrots_left = carrots_left * 4\n        val carrots_left = carrots_left\
    \ / 4\n        val carrots_left = carrots_left % 4\n        val carrots_left =\
    \ carrots_left * 4\n        val carrots_left = carrots_left / 4\n        val carrots_left\
    \ = carrots_left % 4\n        val carrots_left = carrots_left * 4\n        val\
    \ carrots_left = carrots_left / 4\n        val carrots_left = carrots_left % 4\n\
    \        val carrots_left = carrots_left * 4\n        val carrots_left = carrots_left\
    \ / 4\n        val carrots_left = carrots_left % 4\n        val carrots_left =\
    \ carrots_left * 4\n        val carrots_left = carrots_left / 4\n        val carrots_left\
    \ = carrots_left % 4\n        val carrots_left = carrots_left * 4\n        val\
    \ carrots_left = carrots_left / 4\n        val carrots_left = carrots_left % 4\n\
    \        val carrots_left = carrots_left * 4\n        val carrots_left = carrots_left\
    \ / 4\n        val carrots_left = carrots_left % 4\n        val carrots_left =\
    \ carrots_left * 4\n        val carrots_left = carrots_left / 4\n        val carrots_left\
    \ = carrots_left % 4\n        val carrots_left = carrots_left * 4\n        val\
    \ carrots_left = carrots_left / 4\n        val carrots_left = carrots_left % 4\n\
    \        val carrots_left = carrots_left * 4\n        val carrots_left = carrots_left\
    \ / 4\n        val carrots_left = carrots_left % \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpjogxen17.scala:62:41 ---------------------------\e\
    [0m\e[0m\n\e[31m62 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left\e[0m = carrots_left\
    \ % \n\e[31m\e[31m   |\e[0m                                         ^\e[0m\n\e\
    [31m   |\e[0m                                       expression expected but \e\
    [31m'}'\e[0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjogxen17.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left\e[0m = carrots_left % \e[31m4\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots_left\
    \ is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjogxen17.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left\e[0m = carrots_left * \e[31m4\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots_left\
    \ is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjogxen17.scala:28:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left\e[0m = carrots_left / \e[31m4\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots_left\
    \ is already defined as \e[33mvalue\e[0m \e[35mcarrots_left\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjogxen17.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left\e[0m = carrots_left % \e[31m4\e[0m\n\e[31m\e[31m   |\e[0m\
    \        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots_l"
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        val hungry = mutable.ListBuffer[Long]()\n        val hungryRemaining\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeed = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedRemaining = mutable.ListBuffer[Long]()\n        val hungryRemainingNeed\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n\
    \        val hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val\
    \ hungryNeedRemainingNeed = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed\
    \ = mutable.ListBuffer[Long]()\n        val hungryNeedRemainingNeed = mut\n  \
    \  }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcqqg17a7.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedRemainingNeed\e\
    [0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeedRemainingNeed is already defined as \e[33mvalue\e\
    [0m \e[35mhungryNeedRemainingNeed\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcqqg17a7.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedRemainingNeed\e\
    [0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeedRemainingNeed is already defined as \e[33mvalue\e\
    [0m \e[35mhungryNeedRemainingNeed\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcqqg17a7.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedRemainingNeed\e\
    [0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeedRemainingNeed is already defined as \e[33mvalue\e\
    [0m \e[35mhungryNeedRemainingNeed\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpcqqg17a7.scala:33:12 ---------------------------\e\
    [0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m \e[36mhungryNeedRemainingNeed\e\
    [0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryNeedRemainingNeed is already defined as \e[33mvalue\e\
    [0m \e[35mhungryNeedRemainingNeed\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of tople"
  stdout: ''
  timestamp: 1660010547
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val mealsLeftInt = mealsLeft.toInt\n        val mealsLeftInt = mealsLeft.toInt\n\
    \        val meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpapqlq1om.scala:61:4 ----------------------------\e\
    [0m\e[0m\n\e[31m61 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpapqlq1om.scala:27:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsLeftInt\e[0m = mealsLeft.toInt\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftInt is already defined as \e[33mvalue\e[0m \e[35mmealsLeftInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpapqlq1om.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftInt\e[0m = mealsLeft.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmealsLeftInt is already defined as \e[33mvalue\e[0m \e[35mmealsLeftInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpapqlq1om.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftInt\e[0m = mealsLeft.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmealsLeftInt is already defined as \e[33mvalue\e[0m \e[35mmealsLeftInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpapqlq1om.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftInt\e[0m = mealsLeft.toInt\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m \
    \  |\e[0mmealsLeftInt is already defined as \e[33mvalue\e[0m \e[35mmealsLeftInt\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpapqlq1om.scala:31:12 ---------------------------\e[0"
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val needs = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer(2)\n        val hungry = mutable.ArrayBuffer(0)\n\
    \        val hungryRemaining = mutable.ArrayBuffer(0)\n        val hungryNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryRemainingNeeds = mutable.ArrayBuffer(0)\n\
    \        val hungryNeedsRemaining = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryNeedsRemainingNeedsRemainingNeeds = mutable.ArrayBuffer(0)\n\
    \        val hungryNeedsRemainingNeedsRemainingNeedsRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeeds = mutable.ArrayBuffer(0)\n\
    \        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining =\
    \ mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeedsRemainingNeeds\
    \ = mutable.ArrayBuffer(0)\n        val hungryNeeds\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpyysm4o25.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyysm4o25.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyysm4o25.scala:24:20\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mneeds\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m            \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                    Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyysm4o25.scala:25:24\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m   \
    \                     ^^^^^^^\e[0m\n\e[31m   |\e[0m                        Not\
    \ found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyysm4o25.scala:26:21\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mresult\e[0m = mutable.ArrayBuffer(\e[31m2\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpyysm4o25.scala:27:21\
    \ ------------------------\e[0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(\e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m   \
    \                  ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling "
  stdout: ''
  timestamp: 1660010548
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots - hungry\n        val hungryMeals = meals - hungry\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8bfn90x2.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1660010460
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        if (remaining <= 0) {\n            val carrots = number - remaining\n\
    \            val meals = need - carrots\n            val result = List(meals,\
    \ carrots)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj26tvgy.scala:34)\n\tat Problem.main(tmpmj26tvgy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val remaining = carrots\
    \ - meals\n        List(meals, remaining)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpyvq_f20o.scala:25:24 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = carrots\
    \ - meals\n\e[31m\e[31m   |\e[0m                        ^\e[0m\n\e[31m   |\e[0m\
    \                        Recursive \e[33mvalue\e[0m \e[35mcarrots\e[0m needs type\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010494
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number\
    \ - need\n        val hungryRabbitRemaining = remaining - hungryRabbit\n     \
    \   val hungryRabbitEaten = hungryRabbitRemaining / 2\n        val hungryRabbitLeft\
    \ = hungryRabbitRemaining - hungryRabbitEaten\n        val hungryRabbitEatenList\
    \ = List(hungryRabbitEaten)\n        val hungryRabbitLeftList = List(hungryRabbitLeft)\n\
    \        val hungryRabbitList = List(hungryRabbitEatenList ++ hungryRabbitLeftList)\n\
    \        hungryRabbitList\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp_x5504p6.scala:30:8\
    \ ---------------------\e[0m\e[0m\n\e[31m30 |\e[0m        hungryRabbitList\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0m        Found:\
    \    (hungryRabbitList : List[List[Long]])\n\e[31m   |\e[0m        Required: List[Long]\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010554
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val carrotsNeeded = mutable.ArrayBuffer(need)\n        val carrotsRemaining\
    \ = mutable.ArrayBuffer(remaining)\n        val carrotsEaten = mutable.ArrayBuffer(number)\n\
    \        val carrotsLeftToEat = mutable.ArrayBuffer(number)\n        val carrotsEatenSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsLeftToEatSoFar = mutable.ArrayBuffer(number)\n\
    \        val carrotsEatenSoFarSoFar = mutable.ArrayBuffer(number)\n        val\
    \ carrotsLeftToEatSoFarSoFar = mutable.ArrayBuffer(number)\n        val carrotsEatenSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsLeftToEatSoFarSoFarSoFar =\
    \ mutable.ArrayBuffer(number)\n        val carrotsEatenSoFarSoFarSoFarSoFar =\
    \ mutable.ArrayBuffer(number)\n        val carrotsLeftToEatSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsEatenSoFarSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsLeftToEatSoFarSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsEatenSoFarSoFarSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsLeftToEatSoFarSoFarSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsEatenSoFarSoFarSoFarSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsLeftToEatSoFarSoFarSoFarSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsEatenSoFarSoFarSoFarSoFarSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsLeftToEatSoFarSoFarSoFarSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsEatenSoFarSoFarSoFarSoFarSoFarSoFarSoFarSoFarSoFar\
    \ = mutable.ArrayBuffer(number)\n        val carrotsLeftToEatSoFarSoFarSoFarSoFarSoFar\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpxd05mlcs.scala:46:4 ----------------------------\e\
    [0m\e[0m\n\e[31m46 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpxd05mlcs.scala:43:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m43 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsLeftToEatSoFarSoFarSoFarSoFarSoFarSoFarSoFar\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsLeftToEatSoFarSoFarSoFarSoFarSoFarSoFarSoFar is already\
    \ defined as \e[33mvalue\e[0m \e[35mcarrotsLeftToEatSoFarSoFarSoFarSoFarSoFarSoFarSoFar\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E006] Not\
    \ Found Error: /tmp/tmpxd05mlcs.scala:23:22 ------------------------\e[0m\e[0m\n\
    \e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpxd05mlcs.scala:24:28 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mcarrotsNeeded\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                            ^^^^^^^\e[0m\n\e[31m   |\e[0m\
    \                            Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpxd05mlcs.scala:25:31 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mcarrotsRemaining\e[0m =\
    \ mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e[0m                      \
    \         ^^^^^^^\e[0m\n\e[31m   |\e[0m                               Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpxd05mlcs.scala:26:27\
    \ --"
  stdout: ''
  timestamp: 1660010553
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsList = List(meals)\n   \
    \     val carrotsList = List(carrots)\n        val result = carrotsList.zipWithIndex.map\
    \ {\n            case (carrots, index) =>\n                if (carrots > 0) {\n\
    \                    mealsList.take(index).sum\n                } else {\n   \
    \                 mealsList.sum\n                }\n        }\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphbsk16mf.scala:38)\n\tat Problem.main(tmphbsk16mf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010563
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsLeftInStock = remaining - meals\n        val mealsLeftInStockInt\
    \ = mealsLeftInStock.toInt\n        val mealsLeftInStockInt = mealsLeftInStockInt.toLong\n\
    \        val mealsLeftInStockInt = mealsLeftInStockInt.toFloat\n        val mealsLeftInStockInt\
    \ = mealsLeftInStockInt.toDouble\n        val mealsLeftInStockInt = mealsLeftInStockInt.toChar\n\
    \        val mealsLeftInStockInt = mealsLeftInStockInt.toShort\n        val mealsLeftInStockInt\
    \ = mealsLeftInStockInt.toByte\n        val mealsLeftInStockInt = mealsLeftInStockInt.toInt\n\
    \        val mealsLeftInStockInt = mealsLeftInStockInt.toLong\n        val mealsLeftInStockInt\
    \ = mealsLeftInStockInt.toFloat\n        val mealsLeftInStockInt = mealsLeftInStockInt.toDouble\n\
    \        val mealsLeftInStockInt = mealsLeftInStockInt.toChar\n        val mealsLeftInStockInt\
    \ = mealsLeftInStockInt.toShort\n        val mealsLeftInStockInt = mealsLeftInStockInt.toByte\n\
    \        val mealsLeftInStockInt = mealsLeftInStockInt.toInt\n        val mealsLeftInStockInt\
    \ = mealsLeftInStockInt.toLong\n        val mealsLeftInStockInt = mealsLeftInStockInt.toFloat\n\
    \        val mealsLeftInStockInt = mealsLeftInStockInt.toDouble\n        val mealsLeftInStockInt\
    \ = mealsLeftInStockInt.toChar\n        val mealsLeftInStockInt = mealsLeftInStockInt.toShort\n\
    \        val mealsLeftInStockInt = mealsLeftInStockInt.toByte\n        val mealsLeftInStockInt\
    \ = mealsLeftInStockInt.toInt\n        val mealsLeftInStockInt = mealsLeftInStockInt.toLong\n\
    \        val mealsLeftInStockInt = mealsLeftInStockInt.toFloat\n        val mealsLeftInStockInt\
    \ = mealsLeftIn\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0gaefi0h.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftInStockInt\e[0m\
    \ = mealsLeftInStockInt.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftInStockInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftInStockInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0gaefi0h.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftInStockInt\e[0m\
    \ = mealsLeftInStockInt.toFloat\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftInStockInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftInStockInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0gaefi0h.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftInStockInt\e[0m\
    \ = mealsLeftInStockInt.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftInStockInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftInStockInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0gaefi0h.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmealsLeftInStockInt\e[0m\
    \ = mealsLeftInStockInt.toChar\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsLeftInStockInt is already defined as \e[33mvalue\e[0m\
    \ \e[35mmealsLeftInStockInt\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmp0gaefi0h.scala:32:12 ---------------"
  stdout: ''
  timestamp: 1660010559
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsList = List(meals)\n   \
    \     val carrotsList = List(carrots)\n        val mealsRemaining = meals - carrots\n\
    \        val carrotsRemaining = carrots - meals\n        val mealsRemainingList\
    \ = List(mealsRemaining)\n        val carrotsRemainingList = List(carrotsRemaining)\n\
    \        val mealsRemainingList2 = List(mealsRemaining)\n        val carrotsRemainingList2\
    \ = List(carrotsRemaining)\n        val mealsRemainingList3 = List(mealsRemaining)\n\
    \        val carrotsRemainingList3 = List(carrotsRemaining)\n        val mealsRemainingList4\
    \ = List(mealsRemaining)\n        val carrotsRemainingList4 = List(carrotsRemaining)\n\
    \        val mealsRemainingList5 = List(mealsRemaining)\n        val carrotsRemainingList5\
    \ = List(carrotsRemaining)\n        val mealsRemainingList6 = List(mealsRemaining)\n\
    \        val carrotsRemainingList6 = List(carrotsRemaining)\n        val mealsRemainingList7\
    \ = List(mealsRemaining)\n        val carrotsRemainingList7 = List(carrotsRemaining)\n\
    \        val mealsRemainingList8 = List(mealsRemaining)\n        val carrotsRemainingList8\
    \ = List(carrotsRemaining)\n        val mealsRemainingList9 = List(mealsRemaining)\n\
    \        val carrotsRemainingList9 = List(carrotsRemaining)\n        val mealsRemainingList10\
    \ = List(mealsRemaining)\n        val carrotsRemainingList10 = List(carrotsRemaining)\n\
    \        val mealsRemainingList11 = List(mealsRemaining)\n        val carrotsRemainingList11\
    \ = List(carrotsRemaining)\n        val mealsRemainingList12 = List(mealsRemaining)\n\
    \        val carrotsRemainingList12 = List(carrotsRemaining)\n        val mealsRemainingList13\
    \ = List(mealsRemaining)\n        val carrotsRemainingList13 = List(carrotsRemaining)\n\
    \        val mealsRemainingList14 = List(mealsRemaining)\n        val carrotsRemainingList14\
    \ = List(carrotsRemaining)\n        val mealsRemainingList\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp3ci8qc1p.scala:58:4 ----------------------------\e\
    [0m\e[0m\n\e[31m58 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp3ci8qc1p.scala:58:5 ---------------------\e[0m\e[0m\n\e[31m58 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010560
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingSum2 = hungryRemainingSum * hungryRemainingSum\n \
    \       val hungryRemainingSum3 = hungryRemainingSum2 * hungryRemainingSum\n \
    \       val hungryRemainingSum4 = hungryRemainingSum3 * hungryRemainingSum\n \
    \       val hungryRemainingSum5 = hungryRemainingSum4 * hungryRemainingSum\n \
    \       val hungryRemainingSum6 = hungryRemainingSum5 * hungryRemainingSum\n \
    \       val hungryRemainingSum7 = hungryRemainingSum6 * hungryRemainingSum\n \
    \       val hungryRemainingSum8 = hungryRemainingSum7 * hungryRemainingSum\n \
    \       val hungryRemainingSum9 = hungryRemainingSum8 * hungryRemainingSum\n \
    \       val hungryRemainingSum10 = hungryRemainingSum9 * hungryRemainingSum\n\
    \        val hungryRemainingSum11 = hungryRemainingSum10 * hungryRemainingSum\n\
    \        val hungryRemainingSum12 = hungryRemainingSum11 * hungryRemainingSum\n\
    \        val hungryRemainingSum13 = hungryRemainingSum12 * hungryRemainingSum\n\
    \        val hungryRemainingSum14 = hungryRemainingSum13 * hungryRemainingSum\n\
    \        val hungryRemainingSum15 = hungryRemainingSum14 * hungryRemainingSum\n\
    \        val hungryRemainingSum16 = hungryRemainingSum15 * hungryRemainingSum\n\
    \        val hungryRemainingSum17 = hungryRemainingSum16 * hungryRemainingSum\n\
    \        val hungryRemainingSum18 = hungryRemainingSum17 * hungryRemainingSum\n\
    \        val hun\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp6rm11hpb.scala:45:4 ----------------------------\e\
    [0m\e[0m\n\e[31m45 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rm11hpb.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rm11hpb.scala:24:21\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mhungry\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m           \
    \          ^^^^^^^\e[0m\n\e[31m   |\e[0m                     Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp6rm11hpb.scala:25:30\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\e[31m\e[31m   |\e\
    [0m                              ^^^^^^^\e[0m\n\e[31m   |\e[0m               \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmp6rm11hpb.scala:45:5 ---------------------\e[0m\e[0m\n\e[31m45\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n5 errors found\n"
  stdout: ''
  timestamp: 1660010516
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots > 0\n      \
    \  val hungryCarrots = carrots - hungry\n        val hungryMeals = meals - hungry\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = hungryMeals.toLong\n\
    \        val hungryCarrots = hungryCarrots.toLong\n        val hungryMeals = h\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp8bfn90x2.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    [31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = hungryMeals.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp8bfn90x2.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = hungryCarrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e\
    ["
  stdout: ''
  timestamp: 1660010460
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result :: eat(number, need, remaining)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7k6n4z9_.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result :: eat(number,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (result : List[Long])\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingArray = Array(mealsRemaining)\n        val\
    \ mealsRemainingArrayArray = Array(mealsRemainingArray)\n        val mealsRemainingArrayArrayArray\
    \ = Array(mealsRemainingArrayArray)\n        val mealsRemainingArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArray)\n        val mealsRemainingArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArray)\n        val mealsRemainingArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArray)\n        val mealsRemainingArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArray)\n        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArray)\n        val\
    \ mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArray = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val meals\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpb9tuzdwu.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb9tuzdwu.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\e\
    [0m = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpb9tuzdwu.scala:32:70 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayArrayArrayArrayArrayArrayArray\e\
    [0m = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArray)\n\e[31m\e[31m \
    \  |\e[0m                                                                    \
    \  ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmealsRemainingArrayArrayArrayArrayArrayArrayArray\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpb9tuzdwu.scala:33:75\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayArrayArrayArrayArrayArrayArrayArray\e[0m = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                   ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35mmealsRemainingArrayArrayArrayArrayArrayArr"
  stdout: ''
  timestamp: 1660010559
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val hungry = if (carrots > 0) true else false\n        val eaten = if\
    \ (carrots > need) need else carrots\n        val left  = remaining - eaten\n\
    \        List(left,eaten)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp9zfm9b4b.scala:30)\n\tat Problem.main(tmp9zfm9b4b.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(carrots, meals)\n\
    \        if (meals > 0) {\n            val remainingCarrots = number - meals\n\
    \            val remainingMeals = need - remainingCarrots\n            val newResult\
    \ = eat(number, need, remainingCarrots) ++ eat(number, remainingMeals, remaining)\n\
    \            if (newResult.size == 2) {\n                result ++ newResult\n\
    \            } else {\n                result\n            }\n        } else {\n\
    \            result\n        }\n    }\n    def main(args: Array[String]) = {\n\
    \    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpzd5bfdng.scala:40)\n\tat Problem.main(tmpzd5bfdng.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010564
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpf3elcfpl.scala:29)\n\tat Problem.main(tmpf3elcfpl.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ListBuffer[Long]()\n\
    \        var carrots_left = remaining\n        while (carrots_left > 0) {\n  \
    \          carrots_left -= 1\n            carrots += number\n        }\n     \
    \   val carrots_after_meals = carrots.sum\n        val carrots_left_after_meals\
    \ = carrots_left - carrots_after_meals\n        carrots_left - carrots_after_meals\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpb37bjec7.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010557
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val carrotsRemaining = mealsRemaining - carrots\n        val\
    \ mealsRemainingList = List(carrotsRemaining, mealsRemaining)\n        val mealsRemainingList2\
    \ = List(carrotsRemaining, mealsRemaining)\n        val mealsRemainingList3 =\
    \ List(carrotsRemaining, mealsRemaining)\n        val mealsRemainingList4 = List(carrotsRemaining,\
    \ mealsRemaining)\n        val mealsRemainingList5 = List(carrotsRemaining, mealsRemaining)\n\
    \        val mealsRemainingList6 = List(carrotsRemaining, mealsRemaining)\n  \
    \      val mealsRemainingList7 = List(carrotsRemaining, mealsRemaining)\n    \
    \    val mealsRemainingList8 = List(carrotsRemaining, mealsRemaining)\n      \
    \  val mealsRemainingList9 = List(carrotsRemaining, mealsRemaining)\n        val\
    \ mealsRemainingList10 = List(carrotsRemaining, mealsRemaining)\n        val mealsRemainingList11\
    \ = List(carrotsRemaining, mealsRemaining)\n        val mealsRemainingList12 =\
    \ List(carrotsRemaining, mealsRemaining)\n        val mealsRemainingList13 = List(carrotsRemaining,\
    \ mealsRemaining)\n        val mealsRemainingList14 = List(carrotsRemaining, mealsRemaining)\n\
    \        val mealsRemainingList15 = List(carrotsRemaining, mealsRemaining)\n \
    \       val mealsRemainingList16 = List(carrotsRemaining, mealsRemaining)\n  \
    \      val mealsRemainingList17 = List(carrotsRemaining, mealsRemaining)\n   \
    \     val mealsRemainingList18 = List(carrotsRemaining, mealsRemaining)\n    \
    \    val mealsRemainingList19 = List(carrotsRemaining, mealsRemaining)\n     \
    \   val mealsRemainingList20 = List(carrotsRemaining, mealsRemaining)\n      \
    \  val mealsRemainingList21 = List(carrotsRemaining, mealsRemaining)\n       \
    \ val mealsRemainingList22 = List(carrotsRemaining, mealsRemaining)\n        val\
    \ mealsRemainingList23 = List(carrotsRemaining, \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp_u85ngoz.scala:50:4 ----------------------------\e\
    [0m\e[0m\n\e[31m50 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    ')' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp_u85ngoz.scala:50:5 ---------------------\e[0m\e[0m\n\e[31m50 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010562
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number\
    \ - remaining\n        val hungryRabbits = hungryRabbit / need\n        val hungryRabbitsLeft\
    \ = hungryRabbit % need\n        val eatenCarrots = hungryRabbitsLeft + need\n\
    \        val carrots = eatenCarrots / need\n        val carrotsLeft = eatenCarrots\
    \ % need\n        val carrots = carrots.toLong\n        val carrotsLeft = carrotsLeft.toLong\n\
    \        val carrots = carrots + carrotsLeft\n        val carrots = carrots.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val carrots = carrots +\
    \ carrotsLeft\n        val carrots = carrots.toLong\n        val carrotsLeft =\
    \ carrotsLeft.toLong\n        val carrots = carrots + carrotsLeft\n        val\
    \ carrots = carrots.toLong\n        val carrotsLeft = carrotsLeft.toLong\n   \
    \     val carrots = carrots + carrotsLeft\n        val carrots = carrots.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val carrots = carrots +\
    \ carrotsLeft\n        val carrots = carrots.toLong\n        val carrotsLeft =\
    \ carrotsLeft.toLong\n        val carrots = carrots + carrotsLeft\n        val\
    \ carrots = carrots.toLong\n        val carrotsLeft = carrotsLeft.toLong\n   \
    \     val carrots = carrots + carrotsLeft\n        val carrots = carrots.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val carrots = carrots +\
    \ carrotsLeft\n        val carrots = carrots.toLong\n        val carrotsLeft =\
    \ carrotsLeft.toLong\n        val carrots = carrots + carrotsLeft\n        val\
    \ carrots = carrots.toLong\n        val carrotsLeft = carrotsLeft.toLong\n   \
    \     val carrots = carrots + carrotsLeft\n        val carrots = carrots.toLong\n\
    \        val carrotsLeft = carrotsLeft.toLong\n        val carrots = carrots +\
    \ car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb4vnnva_.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = carrots.toLong\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots\
    \ is already defined as \e[33mvalue\e[0m \e[35mcarrots\e[0m\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb4vnnva_.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsLeft\e[0m = carrotsLeft.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsLeft is already defined as \e[33mvalue\e[0m \e[35mcarrotsLeft\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpb4vnnva_.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = carrots + carrotsLeft\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mcarrots is already defined as \e[33mvalue\e[0m \e[35mcarrots\e[0m\n\e\
    [31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined\
    \ in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpb4vnnva_.scala:32:12 ---------------------------\e[0m\e[0m\n\e[31m32\
    \ |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = carrots.toLong\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mcarrots is\
    \ already defined as \e[33mvalue\e[0m \e[35mcarrots\e[0m\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0mNote that overloaded methods must all be defined in the same group\
    \ of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpb4vnnva_.scala:33:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m33 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsLeft\e[0m = carrotsLeft.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsLeft is already defined as \e[33mvalue\e[0m \e[35mcarrotsLeft\e\
    [0m\n\e[31m   |"
  stdout: ''
  timestamp: 1660010563
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        if (remaining <= 0) {\n            val carrots = number - remaining\n\
    \            val meals = need - carrots\n            val result = List(meals,\
    \ carrots)\n        }\n        result\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpmj26tvgy.scala:34)\n\tat Problem.main(tmpmj26tvgy.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010461
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungry = mutable.ArrayBuffer.empty[Long]\n        val hungryCount\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount2 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount3 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount4\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount5 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount6 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount7\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount8 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount9 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount10\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount11 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount12 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount13\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount14 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount15 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount16\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount17 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount18 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount19\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount20 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount21 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount22\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount23 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount24 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount25\
    \ = mutable.ArrayBuffer.empty[Long]\n        val hungryCount26 = mutable.ArrayBuffer.empty[Long]\n\
    \        val hungryCount27 = mutable.ArrayBuffer.empty[Long]\n        val hungryCount28\
    \ = mut\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:24:21 ------------------------\e\
    [0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:25:26 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mhungryCount\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                          ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                          Not found: mutable\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:26:27 ------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhungryCount2\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:27:27 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhungryCount3\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                           ^^^^^^^\e[0m\n\
    \e[31m   |\e[0m                           Not found: mutable\n\e[31m   |\e[0m\n\
    \e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpd4h4jsqo.scala:28:27 --------"
  stdout: ''
  timestamp: 1660010459
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ carrots\n        val mealsRemainingArray = Array(mealsRemaining)\n        val\
    \ mealsRemainingArrayList = List(mealsRemainingArray)\n        val mealsRemainingArrayListArray\
    \ = Array(mealsRemainingArrayList)\n        val mealsRemainingArrayListArrayList\
    \ = List(mealsRemainingArrayListArray)\n        val mealsRemainingArrayListArrayListArray\
    \ = Array(mealsRemainingArrayListArrayList)\n        val mealsRemainingArrayListArrayListArrayList\
    \ = List(mealsRemainingArrayListArrayListArray)\n        val mealsRemainingArrayListArrayListArrayListArray\
    \ = Array(mealsRemainingArrayListArrayListArrayList)\n        val mealsRemainingArrayListArrayListArrayListArrayList\
    \ = List(mealsRemainingArrayListArrayListArrayListArray)\n        val mealsRemainingArrayListArrayListArrayListArrayListArray\
    \ = Array(mealsRemainingArrayListArrayListArrayListArrayList)\n        val mealsRemainingArrayListArrayListArrayListArrayListArrayList\
    \ = List(mealsRemainingArrayListArrayListArrayListArrayListArray)\n        val\
    \ mealsRemainingArrayListArrayListArrayListArrayListArrayListArray = Array(mealsRemainingArrayListArrayListArrayListArrayListArrayListArray)\n\
    \        val mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ = List(mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArray)\n\
    \        val mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ = Array(mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArray)\n\
    \        val mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ = List(mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray)\n\
    \        val mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ = Array(mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray)\n\
    \        val mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ = List(mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray)\n\
    \        \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpqk6mceir.scala:39:12 ---------------------------\e\
    [0m\e[0m\n\e[31m39 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray\e\
    [0m = List(mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmpqk6mceir.scala:36:85 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayListArrayListArrayListArrayListArrayListArray\e\
    [0m = Array(mealsRemainingArrayListArrayListArrayListArrayListArrayListArray)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                             ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e[0m\
    \ \e[35mmealsRemainingArrayListArrayListArrayListArrayListArrayListArray\e[0m\
    \ needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpqk6mceir.scala:37:93\
    \ ---------------------------\e[0m\e[0m\n\e[31m37 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArray\e\
    [0m = List(mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArray)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArray\e\
    [0m needs type\n\e[3"
  stdout: ''
  timestamp: 1660010566
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = if (carrots > 0) true\
    \ else false\n        val hungryCarrots = if (hungry) carrots else 0\n       \
    \ val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots = if (hungry)\
    \ carrots else 0\n        val hungryMeals = if (hungry) meals else 0\n       \
    \ val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals = if\
    \ (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots else\
    \ 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals else 0\n        val hungryCarrots = if (hungry) carrots\
    \ else 0\n        val hungryMeals = if (hungry) meals else 0\n        val hungryCarrots\
    \ = if (hungry) carrots else 0\n        val hungryMeals = if (hungry) meals else\
    \ 0\n        val hungryCarrots = if (hungry) carrots else 0\n        val hungryMeals\
    \ = if (hungry) meals \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjeusykaq.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = \e\
    [33mif\e[0m (hungry) carrots \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e\
    [0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungryCarrots\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e[0m\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the same\
    \ group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpjeusykaq.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryMeals\e[0m = \e[33mif\e[0m (hungry) meals \e[33melse\e[0m \e[31m0\e\
    [0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjeusykaq.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = \e[33mif\e[0m (hungry)\
    \ carrots \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjeusykaq.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryMeals\e[0m = \e[33mif\e[0m (hungry)\
    \ meals \e[33melse\e[0m \e[31m0\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryMeals is already defined as \e[33mvalue\e[0m \e[35mhungryMeals\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpjeusykaq.scala:32:12 ---------------------------\e[0m\e["
  stdout: ''
  timestamp: 1660010565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingArray = Array(mealsRemaining)\n        val\
    \ mealsRemainingArrayArray = Array(mealsRemainingArray)\n        val mealsRemainingArrayArrayArray\
    \ = Array(mealsRemainingArrayArray)\n        val mealsRemainingArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArray)\n        val mealsRemainingArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArray)\n        val mealsRemainingArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArray)\n        val mealsRemainingArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArray)\n        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArray)\n        val\
    \ mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArray = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \        val mealsRemain\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmposps2c9i.scala:43:4 ----------------------------\e\
    [0m\e[0m\n\e[31m43 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmposps2c9i.scala:38:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m38 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\e\
    [0m = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E161] Naming Error: /tmp/tmposps2c9i.scala:41:12 ---------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\e\
    [0m = Array(mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray)\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  mealsRemainingArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArrayArray\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E"
  stdout: ''
  timestamp: 1660010565
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val carrots_left = need - carrots\n        val carrots_left_in_stock\
    \ = carrots_left / carrot\n        val carrots_left_in_stock = carrots_left_in_stock.toInt\n\
    \        val carrots_left_in_stock = carrots_left_in_stock * carrot\n        val\
    \ carrots_left_in_stock = carrots_left_in_stock.toLong\n        val carrots_left_in_stock\
    \ = carrots_left_in_stock.toDouble\n        val carrots_left_in_stock = carrots_left_in_stock.toInt\n\
    \        val carrots_left_in_stock = carrots_left_in_stock.toLong\n        val\
    \ carrots_left_in_stock = carrots_left_in_stock.toDouble\n        val carrots_left_in_stock\
    \ = carrots_left_in_stock.toInt\n        val carrots_left_in_stock = carrots_left_in_stock.toLong\n\
    \        val carrots_left_in_stock = carrots_left_in_stock.toDouble\n        val\
    \ carrots_left_in_stock = carrots_left_in_stock.toInt\n        val carrots_left_in_stock\
    \ = carrots_left_in_stock.toLong\n        val carrots_left_in_stock = carrots_left_in_stock.toDouble\n\
    \        val carrots_left_in_stock = carrots_left_in_stock.toInt\n        val\
    \ carrots_left_in_stock = carrots_left_in_stock.toLong\n        val carrots_left_in_stock\
    \ = carrots_left_in_stock.toDouble\n        val carrots_left_in_stock = carrots_left_in_stock.toInt\n\
    \        val carrots_left_in_stock = carrots_left_in_stock.toLong\n        val\
    \ carrots_left_in_stock = carrots_left_in_stock.toDouble\n        val carrots_left_in_stock\
    \ = carrots_left_in_stock.toInt\n        val carrots_left_in_stock = carrots_left_in_stock.toLong\n\
    \        val carrots_left_in_stock = carrots_left_in_stock.toDouble\n        val\
    \ carrots_left_in_stock = carrots_left_in_stock.toInt\n        val carrots_left_in_stock\
    \ = carrots_left_in_stock.toLong\n        val carrots_left_in_stock = carrots_left_in_stock.toDouble\n\
    \        val carrots_left_in_stock = carrots_left_in_stock.toInt\n        val\
    \ carrots_\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpw0i37g5g.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw0i37g5g.scala:26:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_in_stock\e[0m = carrots_left_in_stock.toInt\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\
    \e[31m   |\e[0mcarrots_left_in_stock is already defined as \e[33mvalue\e[0m \e\
    [35mcarrots_left_in_stock\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpw0i37g5g.scala:27:12 ---------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_in_stock\e\
    [0m = carrots_left_in_stock * carrot\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_in_stock is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_in_stock\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw0i37g5g.scala:28:12 ---------------------------\e\
    [0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_in_stock\e\
    [0m = carrots_left_in_stock.toLong\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_in_stock is already defined as \e[33mvalue\e\
    [0m \e[35mcarrots_left_in_stock\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that\
    \ overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmpw0i37g5g.scala:29:12 ---------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mcarrots_left_in_stock\e\
    [0m = carrots_left_in_stock.toDouble\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrots_left_in_stock is already defined as \e[3"
  stdout: ''
  timestamp: 1660010566
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val hungry = math.min(meals,\
    \ carrots)\n        val eaten = math.min(carrots, meals)\n        val leftOver\
    \ = math.min(remaining, carrots)\n        val result = List(math.min(meals, carrots),\
    \ math.min(carrots, meals))\n        if (leftOver > 0) {\n            result :+\
    \ math.min(leftOver, carrots)\n        }\n        result\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpo1x6g3gu.scala:35)\n\tat Problem.main(tmpo1x6g3gu.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010568
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        if (remaining <= 0) result\n        else eat(number, need, remaining\
    \ - meals)\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpms9t6r_i.scala:30)\n\tat Problem.main(tmpms9t6r_i.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010568
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val hungry = carrots <= 0\n     \
    \   val leftCarrots = remaining - carrots\n        if (hungry) {\n           \
    \ List(meals, leftCarrots)\n        } else {\n            List(meals, leftCarrots,\
    \ carrots)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmphyhh77v0.scala:34)\n\tat Problem.main(tmphyhh77v0.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val leftCarrots = remaining - carrots\n        val result = List(carrots,\
    \ leftCarrots)\n        result :: eat(number, need, remaining)\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpma8zu11p.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result :: eat(number,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (result : List[Long])\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val hungry = if (carrots > 0) true else false\n        val eaten = if\
    \ (carrots > need) need else carrots\n        val left = if (carrots > 0) carrots\
    \ - need else 0\n        List(eaten, hungry, left)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpk6zbkl0e.scala:27:20\
    \ --------------------\e[0m\e[0m\n\e[31m27 |\e[0m        List(eaten, hungry, left)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^\e[0m\n\e[31m   |\e[0m        \
    \            Found:    (hungry : Boolean)\n\e[31m   |\e[0m                   \
    \ Required: Long\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010567
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val carrots_left = remaining\n        val carrots_left_after_meals =\
    \ carrots - meals\n        val carrots_left_after_meals_2 = carrots_left - meals\n\
    \        val carrots_left_after_meals_3 = carrots_left_after_meals_2 - meals\n\
    \        val carrots_left_after_meals_4 = carrots_left_after_meals_3 - meals\n\
    \        val carrots_left_after_meals_5 = carrots_left_after_meals_4 - meals\n\
    \        val carrots_left_after_meals_6 = carrots_left_after_meals_5 - meals\n\
    \        val carrots_left_after_meals_7 = carrots_left_after_meals_6 - meals\n\
    \        val carrots_left_after_meals_8 = carrots_left_after_meals_7 - meals\n\
    \        val carrots_left_after_meals_9 = carrots_left_after_meals_8 - meals\n\
    \        val carrots_left_after_meals_10 = carrots_left_after_meals_9 - meals\n\
    \        val carrots_left_after_meals_11 = carrots_left_after_meals_10 - meals\n\
    \        val carrots_left_after_meals_12 = carrots_left_after_meals_11 - meals\n\
    \        val carrots_left_after_meals_13 = carrots_left_after_meals_12 - meals\n\
    \        val carrots_left_after_meals_14 = carrots_left_after_meals_13 - meals\n\
    \        val carrots_left_after_meals_15 = carrots_left_after_meals_14 - meals\n\
    \        val carrots_left_after_meals_16 = carrots_left_after_meals_15 - meals\n\
    \        val carrots_left_after_meals_17 = carrots_left_after_meals_16 - meals\n\
    \        val carrots_left_after_meals_18 = carrots_left_after_meals_17 - meals\n\
    \        val carrots_left_after_meals_19 = carrots_left_after_meals_18 - meals\n\
    \        val carrots_left_after_meals_20 = carrots_left_after_meals_19 - meals\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmep_xk0s.scala:25:25 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpmep_xk0s.scala:47:5\
    \ ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010568
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val carrots_left = mutable.ArrayBuffer(need)\n        val hungry = mutable.ArrayBuffer(0)\n\
    \        val hungry_left = mutable.ArrayBuffer(0)\n        val hungry_left_max\
    \ = 100\n        val hungry_left_min = 50\n        val hungry_left_step = 50\n\
    \        val hungry_left_max = 100\n        val hungry_left_min = 50\n       \
    \ val hungry_left_step = 50\n        val hungry_left_max = 100\n        val hungry_left_min\
    \ = 50\n        val hungry_left_step = 50\n        val hungry_left_max = 100\n\
    \        val hungry_left_min = 50\n        val hungry_left_step = 50\n       \
    \ val hungry_left_max = 100\n        val hungry_left_min = 50\n        val hungry_left_step\
    \ = 50\n        val hungry_left_max = 100\n        val hungry_left_min = 50\n\
    \        val hungry_left_step = 50\n        val hungry_left_max = 100\n      \
    \  val hungry_left_min = 50\n        val hungry_left_step = 50\n        val hungry_left_max\
    \ = 100\n        val hungry_left_min = 50\n        val hungry_left_step = 50\n\
    \        val hungry_left_max = 100\n        val hungry_left_min = 50\n       \
    \ val hungry_left_step = 50\n        val hungry_left_max = 100\n        val hungry_left_min\
    \ = 50\n        val hungry_left_step = 50\n        val hungry_left_max = 100\n\
    \        val hungry_left_min = 50\n        val hungry_left_step = 50\n       \
    \ val hungry_left_max = 100\n        val hungry_left_min = 50\n        val hungry_left_step\
    \ = 50\n        val hungry_left_max = 100\n        val hungry_left_min = 50\n\
    \        val hungry_left_step = 50\n        val hungry_left_max = 100\n      \
    \  val hungry_left_min = 50\n        val hungry_left_step = 50\n        val hungry_left_max\
    \ = 100\n        val hungry_left_min = 50\n        val hungry_left_step = 50\n\
    \        val hungry_left_max = 100\n        val h\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpj4qi02q3.scala:74:4 ----------------------------\e\
    [0m\e[0m\n\e[31m74 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj4qi02q3.scala:30:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungry_left_max\e[0m = \e[31m100\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungry_left_max is already defined as \e[33mvalue\e[0m \e\
    [35mhungry_left_max\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded\
    \ methods must all be defined in the same group of toplevel definitions\n\e[31m\e\
    [31m-- [E161] Naming Error: /tmp/tmpj4qi02q3.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mhungry_left_min\e[0m = \e\
    [31m50\e[0m\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungry_left_min is already defined as \e[33mvalue\e[0m \e[35mhungry_left_min\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpj4qi02q3.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mhungry_left_step\e[0m = \e[31m50\e[0m\n\
    \e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungry_left_step\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungry_left_step\e[0m\n\e[31m \
    \  |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in\
    \ the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error:\
    \ /tmp/tmpj4qi02q3.scala:33:12 ---------------------------\e[0m\e[0m\n\e[31m33\
    \ |\e[0m        \e[33mval\e[0m \e[36mhungry_left_max\e[0m = \e[31m100\e[0m\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m   |\e[0mhungry_left_max\
    \ is already defined as \e[33mvalue\e[0m \e[35mhungry_left_max\e[0m\n\e[31m  \
    \ |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be defined in the\
    \ same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpj4qi02q3.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m3"
  stdout: ''
  timestamp: 1660010569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealList = mutable.ListBuffer[Long]()\n\
    \        val carrotsList = mutable.ListBuffer[Long]()\n        val carrotsNeeded\
    \ = meals - carrots\n        val carrotsNeededList = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList2 = mutable.ListBuffer[Long]()\n        val carrotsNeededList3\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList4 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList5 = mutable.ListBuffer[Long]()\n        val carrotsNeededList6\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList7 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList8 = mutable.ListBuffer[Long]()\n        val carrotsNeededList9\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList10 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList11 = mutable.ListBuffer[Long]()\n        val carrotsNeededList12\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList13 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList14 = mutable.ListBuffer[Long]()\n        val carrotsNeededList15\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList16 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList17 = mutable.ListBuffer[Long]()\n        val carrotsNeededList18\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList19 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList20 = mutable.ListBuffer[Long]()\n        val carrotsNeededList21\
    \ = mutable.ListBuffer[Long]()\n        val carrotsNeededList22 = mutable.ListBuffer[Long]()\n\
    \        val carrotsNeededList23 = mutable.ListBuffer[Long]()\n        val carrotsNeededList24\
    \ = mutable.ListBuffer[Long]()\n        val carrots\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp1kfg384c.scala:53:4 ----------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1kfg384c.scala:25:23\
    \ ------------------------\e[0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e\
    [36mmealList\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                       ^^^^^^^\e[0m\n\e[31m   |\e[0m                      \
    \ Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1kfg384c.scala:26:26\
    \ ------------------------\e[0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrotsList\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e\
    [0m                          ^^^^^^^\e[0m\n\e[31m   |\e[0m                   \
    \       Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1kfg384c.scala:28:32 ------------------------\e[0m\e[0m\n\e[31m28 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrotsNeededList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                ^^^^^^^\e\
    [0m\n\e[31m   |\e[0m                                Not found: mutable\n\e[31m\
    \   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    \e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1kfg384c.scala:29:33 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m \e[36mcarrotsNeededList2\e[0m\
    \ = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \                    ^^^^^^^\e[0m\n\e[31m   |\e[0m                           \
    \      Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1kfg384c.scala:30:33 ------------------------\e[0m\e[0m\n\e[31m30 |\e\
    [0m        \e[33mval\e[0m \e[36mcarrotsNeededList3\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                                 ^"
  stdout: ''
  timestamp: 1660010569
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val result = List(meals, carrots)\n\
    \        result :: eat(number, need, remaining)\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmp7k6n4z9_.scala:26:8\
    \ ---------------------\e[0m\e[0m\n\e[31m26 |\e[0m        result :: eat(number,\
    \ need, remaining)\n\e[31m\e[31m   |\e[0m        ^^^^^^\e[0m\n\e[31m   |\e[0m\
    \        Found:    (result : List[Long])\n\e[31m   |\e[0m        Required: Long\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010480
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val carrots_left = need - remaining\n        val carrots_left_after_meals\
    \ = carrots - carrots_left\n        val carrots_left_after_meals_after_meals =\
    \ carrots_left_after_meals - carrots_left\n        val carrots_left_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals - carrots_left\n        val carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals - carrots_left\n\
    \        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals -\
    \ carrots_left\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left\n        val carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left\n        val carrots_left_after_meals_after_\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0wt665nk.scala:35:4 ----------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0wt665nk.scala:28:75\
    \ ---------------------------\e[0m\e[0m\n\e[31m28 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals\e[0m = carrots_left_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left\n\e[31m\e[31m   |\e[0m                                      \
    \                                     ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35mcarrots_left_after_meals_after_meals_after_meals_after_meals\e[0m needs\
    \ type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling\
    \ with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0wt665nk.scala:29:87\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left\n\e[31m\e[31m   |\e[0m                                      \
    \                                                 ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmp0wt665nk.scala:30:99\
    \ ---------------------------\e[0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\e\
    [0m = carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\
    \ - carrots_left\n\e[31m\e[31m   |\e[0m                                      \
    \                                                             ^\e[0m\n\e[31m \
    \  |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrots_left_after_meals_after_meals_after_meals_after_meals_after_meals_after_meals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e"
  stdout: ''
  timestamp: 1660010573
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val left  = mutable.ArrayBuffer(remaining)\n\
    \        val result: List[Long] = mutable.ArrayBuffer.empty\n        while(meals.size\
    \ < need && carrots.size > 0) {\n            val carrot: Long = carrots.head\n\
    \            carrots -= carrot\n            meals += carrot\n            left\
    \ -= carrot\n            result += carrot\n        }\n        if(meals.size <\
    \ need) {\n            result ++= carrots\n        }\n        if(left.size > 0)\
    \ {\n            result ++= carrots\n        }\n        result\n    }\n    def\
    \ main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp1jdphcwf.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp1jdphcwf.scala:24:20 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmeals\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1jdphcwf.scala:25:20 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mleft\e[0m  = mutable.ArrayBuffer(remaining)\n\e\
    [31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m         \
    \           Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp1jdphcwf.scala:26:33 ------------------------\e[0m\e[0m\n\e[31m26 |\e\
    [0m        \e[33mval\e[0m \e[36mresult\e[0m: \e[35mList\e[0m[\e[35mLong\e[0m]\
    \ = mutable.ArrayBuffer.empty\n\e[31m\e[31m   |\e[0m                         \
    \        ^^^^^^^\e[0m\n\e[31m   |\e[0m                                 Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmp1jdphcwf.scala:32:19\
    \ ------------------------\e[0m\e[0m\n\e[31m32 |\e[0m            result += carrot\n\
    \e[31m\e[31m   |\e[0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m        value\
    \ += is not a member of List[Long] - did you mean result.!=?\n\e[31m\e[31m-- [E008]\
    \ Not Found Error: /tmp/tmp1jdphcwf.scala:35:19 ------------------------\e[0m\e\
    [0m\n\e[31m35 |\e[0m            result ++= carrots\n\e[31m\e[31m   |\e[0m    \
    \        ^^^^^^^^^^\e[0m\n\e[31m   |\e[0m       value ++= is not a member of List[L"
  stdout: ''
  timestamp: 1660010575
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungryRabbit = number\
    \ - need\n        val hungryRabbits = hungryRabbit / 2\n        val hungryRabbitLeft\
    \ = hungryRabbit - hungryRabbits\n        val hungryRabbits = hungryRabbits +\
    \ hungryRabbitLeft\n        val hungryRabbits = hungryRabbits + hungryRabbitLeft\n\
    \        val hungryRabbits = hungryRabbits + hungryRabbitLeft\n        val hungryRabbits\
    \ = hungryRabbits + hungryRabbitLeft\n        val hungryRabbits = hungryRabbits\
    \ + hungryRabbitLeft\n        val hungryRabbits = hungryRabbits + hungryRabbitLeft\n\
    \        val hungryRabbits = hungryRabbits + hungryRabbitLeft\n        val hungryRabbits\
    \ = hungryRabbits + hungryRabbitLeft\n        val hungryRabbits = hungryRabbits\
    \ + hungryRabbitLeft\n        val hungryRabbits = hungryRabbits + hungryRabbitLeft\n\
    \        val hungryRabbits = hungryRabbits + hungryRabbitLeft\n        val hungryRabbits\
    \ = hungryRabbits + hungryRabbitLeft\n        val hungryRabbits = hungryRabbits\
    \ + hungryRabbitLeft\n        val hungryRabbits = hungryRabbits + hungryRabbitLeft\n\
    \        val hungryRabbits = hungryRabbits + hungryRabbitLeft\n        val hungryRabbits\
    \ = hungryRabbits + hungryRabbitLeft\n        val hungryRabbits = hungryRabbits\
    \ + hun\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l),\
    \ (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l), (8l),\
    \ (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l), (10l),\
    \ (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l), (11l),\
    \ (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l), (5l),\
    \ (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l), (5l),\
    \ (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E161] Naming Error: /tmp/tmpvugclljq.scala:26:12 ---------------------------\e\
    [0m\e[0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = hungryRabbits\
    \ + hungryRabbitLeft\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvugclljq.scala:27:12 ---------------------------\e[0m\e[0m\n\e\
    [31m27 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = hungryRabbits +\
    \ hungryRabbitLeft\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvugclljq.scala:28:12 ---------------------------\e[0m\e[0m\n\e\
    [31m28 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = hungryRabbits +\
    \ hungryRabbitLeft\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvugclljq.scala:29:12 ---------------------------\e[0m\e[0m\n\e\
    [31m29 |\e[0m        \e[33mval\e[0m \e[36mhungryRabbits\e[0m = hungryRabbits +\
    \ hungryRabbitLeft\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryRabbits is already defined as \e[33mvalue\e[0m \e[35mhungryRabbits\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmpvugclljq.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m"
  stdout: ''
  timestamp: 1660010576
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsList = mutable.ListBuffer[Long]()\n\
    \        mealsList.add(meals)\n        mealsList.add(carrots)\n        mealsList.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpv685fupa.scala:25:24 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mmealsList\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e\
    [31m   |\e[0m                        Not found: mutable\n\e[31m   |\e[0m\n\e[31m\
    \   |\e[0m longer explanation available when compiling with `-explain`\n1 error\
    \ found\n"
  stdout: ''
  timestamp: 1660010518
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number - need\n\
    \        val left  = remaining - eaten\n        val meals = List(need)\n     \
    \   if (left > 0) meals ::: eat(left, need, remaining)\n        else meals\n \
    \   }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "Exception in thread \"main\" java.lang.StackOverflowError\n\tat scala.collection.immutable.List.prependedAll(List.scala:148)\n\
    \tat scala.collection.immutable.List$.from(List.scala:684)\n\tat scala.collection.immutable.List$.from(List.scala:681)\n\
    \tat scala.collection.IterableFactory.apply(Factory.scala:103)\n\tat scala.collection.IterableFactory.apply$(Factory.scala:103)\n\
    \tat scala.collection.immutable.List$.apply(List.scala:681)\n\tat Problem$.eat(tmpj08_xteu.scala:25)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu.scala:26)\n\tat Problem$.eat(tmpj08_xteu.scala:26)\n\
    \tat Problem$.eat(tmpj08_xteu"
  stdout: ''
  timestamp: 1660010581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrots_left = remaining - carrots\n        val meals = List(need)\n\
    \        val meals_left = List(meals.last)\n        val meals_left_carrots = List(meals_left.last)\n\
    \        val meals_left_carrots_left = List(meals_left_carrots.last)\n       \
    \ val meals_left_carrots_left_carrots = List(meals_left_carrots_left.last)\n \
    \       val meals_left_carrots_left_carrots_left = List(meals_left_carrots_left_carrots.last)\n\
    \        val meals_left_carrots_left_carrots_left_carrots = List(meals_left_carrots_left_carrots_left.last)\n\
    \        val meals_left_carrots_left_carrots_left_carrots_left = List(meals_left_carrots_left_carrots_left_carrots.last)\n\
    \        val meals_left_carrots_left_carrots_left_carrots_left_carrots = List(meals_left_carrots_left_carrots_left_carrots_left.last)\n\
    \        val meals_left_carrots_left_carrots_left_carrots_left_carrots_left =\
    \ List(meals_left_carrots_left_carrots_left_carrots_left_carrots.last)\n     \
    \   val meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = List(meals_left_carrots_left_carrots_left_carrots_left_carrots_left.last)\n\
    \        val meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ = List(meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left.last)\n\
    \        val meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots\
    \ = List(meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left.last)\n\
    \        val meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\
    \ = List(meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left.last)\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpj27m751x.scala:36:95 ---------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m        \e[33mval\e[0m \e[36mmeals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\e\
    [0m = List(meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left.last)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                       ^\e[0m\n\e[31m   |\e[0mRecursive \e[33mvalue\e\
    [0m \e[35m\n\e[31m   |\e[0m  meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E045] Cyclic Error:\
    \ /tmp/tmpj27m751x.scala:38:108 --------------------------\e[0m\e[0m\n\e[31m38\
    \ |\e[0m        \e[33mval\e[0m \e[36mmeals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\e\
    [0m = List(meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left.last)\n\
    \e[31m\e[31m   |\e[0m                                                        \
    \                                                    ^\e[0m\n\e[31m   |\e[0mRecursive\
    \ \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  meals_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left_carrots_left\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmpj27m751x.scala:39:5 ---------------------\e[0m\e[0m\n\e[31m39\
    \ |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:  \
    \  Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n3 errors found\n"
  stdout: ''
  timestamp: 1660010577
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer.empty[Long]\n\
    \        var carrots_left = remaining\n        var hungry = true\n        while(number\
    \ > 0 && carrots_left > 0 && hungry) {\n            carrots += number\n      \
    \      carrots_left -= 1\n            number -= 1\n            hungry = false\n\
    \        }\n        carrots ++= carrots_left\n        carrots.toList\n    }\n\
    \    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpmc3zu_1k.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer.empty[\e\
    [35mLong\e[0m]\n\e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m\
    \   |\e[0m                      Not found: mutable\n\e[31m   |\e[0m\n\e[31m  \
    \ |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E008] Not Found Error: /tmp/tmpmc3zu_1k.scala:29:19 ------------------------\e\
    [0m\e[0m\n\e[31m29 |\e[0m            number -= \e[31m1\e[0m\n\e[31m\e[31m   |\e\
    [0m            ^^^^^^^^^\e[0m\n\e[31m   |\e[0m            value -= is not a member\
    \ of Long - did you mean number.!=?\n2 errors found\n"
  stdout: ''
  timestamp: 1660010578
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val carrotsRemaining = carrots - meals\n        val mealsRemainingArray\
    \ = Array(mealsRemaining)\n        val carrotsRemainingArray = Array(carrotsRemaining)\n\
    \        val mealsRemainingArrayList = List(mealsRemainingArray)\n        val\
    \ carrotsRemainingArrayList = List(carrotsRemainingArray)\n        val mealsRemainingArrayListArray\
    \ = Array(mealsRemainingArrayList)\n        val carrotsRemainingArrayListArray\
    \ = Array(carrotsRemainingArrayList)\n        val mealsRemainingArrayListArrayList\
    \ = List(mealsRemainingArrayListArray)\n        val carrotsRemainingArrayListArrayList\
    \ = List(carrotsRemainingArrayListArray)\n        val mealsRemainingArrayListArrayListArray\
    \ = Array(mealsRemainingArrayListArrayList)\n        val carrotsRemainingArrayListArrayListArray\
    \ = Array(carrotsRemainingArrayListArrayList)\n        val mealsRemainingArrayListArrayListArrayList\
    \ = List(mealsRemainingArrayListArrayListArray)\n        val carrotsRemainingArrayListArrayListArrayList\
    \ = List(carrotsRemainingArrayListArrayListArray)\n        val mealsRemainingArrayListArrayListArrayListArray\
    \ = Array(mealsRemainingArrayListArrayListArrayList)\n        val carrotsRemainingArrayListArrayListArrayListArray\
    \ = Array(carrotsRemainingArrayListArrayListArrayList)\n        val mealsRemainingArrayListArrayListArrayListArrayListArray\
    \ = List(mealsRemainingArrayListArrayListArrayListArray)\n        val carrotsRemainingArrayListArrayListArrayListArrayListArray\
    \ = List(carrotsRemainingArrayListArrayListArrayListArray)\n        val mealsRemainingArrayListArrayListArrayListArrayListArrayListArray\
    \ = Array(mealsRemainingArrayListArrayListArrayListArrayListArray)\n        val\
    \ carrotsRemainingArrayListArrayListArrayListArrayListArrayListArray = List(carrotsRemainingArrayListArrayListArrayListArrayListArray)\n\
    \        val mealsRemainingArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ = Array(mealsRemainingArrayListArrayListArrayListArrayListArray)\n        val\
    \ carrotsRemainingArray\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp2moz93ks.scala:47:4 ----------------------------\e\
    [0m\e[0m\n\e[31m47 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmp2moz93ks.scala:47:5 ---------------------\e[0m\e[0m\n\e[31m47 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsRemaining = remaining -\
    \ meals\n        val mealsRemainingArray = Array.ofDim[Long](mealsRemaining)\n\
    \        val mealsRemainingArrayCopy = mealsRemainingArray.clone()\n        val\
    \ mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy\
    \ = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy =\
    \ mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n\
    \        val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n \
    \       val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n  \
    \      val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n   \
    \     val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n    \
    \    val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n     \
    \   val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n      \
    \  val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n       \
    \ val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n        val\
    \ mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy\
    \ = mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy =\
    \ mealsRemainingArrayCopy.clone()\n        val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n\
    \        val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n \
    \       val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n  \
    \      val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n   \
    \     val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n    \
    \    val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n     \
    \   val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n      \
    \  val mealsRemainingArrayCopyCopy = mealsRemainingArrayCopy.clone()\n       \
    \ val mealsRemainingArrayCopyCopy\n    }\n    def main(args: Array[String]) =\
    \ {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp40gz3wsf.scala:52:4 ----------------------------\e\
    [0m\e[0m\n\e[31m52 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp40gz3wsf.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mmealsRemainingArrayCopyCopy\e[0m = mealsRemainingArrayCopy.clone()\n\e\
    [31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp40gz3wsf.scala:30:12 ---------------------------\e\
    [0m\e[0m\n\e[31m30 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayCopyCopy\e\
    [0m = mealsRemainingArrayCopy.clone()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp40gz3wsf.scala:31:12 ---------------------------\e\
    [0m\e[0m\n\e[31m31 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayCopyCopy\e\
    [0m = mealsRemainingArrayCopy.clone()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mmealsRemainingArrayCopyCopy is already defined as \e[33mvalue\e\
    [0m \e[35mmealsRemainingArrayCopyCopy\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote\
    \ that overloaded methods must all be defined in the same group of toplevel definitions\n\
    \e[31m\e[31m-- [E161] Naming Error: /tmp/tmp40gz3wsf.scala:32:12 ---------------------------\e\
    [0m\e[0m\n\e[31m32 |\e[0m        \e[33mval\e[0m \e[36mmealsRemainingArrayCopyCopy\e\
    [0m = mealsRemainingArrayCopy.clone()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
  stdout: ''
  timestamp: 1660010523
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val hungry = mutable.ArrayBuffer(need)\n        val hungryRemaining =\
    \ mutable.ArrayBuffer(remaining)\n        val hungryRemainingSum = hungryRemaining.sum\n\
    \        val hungryRemainingCount = hungryRemaining.count\n        val hungryRemainingSumCount\
    \ = hungryRemainingSum + hungryRemainingCount\n        val hungryRemainingSumCount2\
    \ = hungryRemainingSumCount + 1\n        val hungryRemainingSumCount3 = hungryRemainingSumCount\
    \ + 2\n        val hungryRemainingSumCount4 = hungryRemainingSumCount + 3\n  \
    \      val hungryRemainingSumCount5 = hungryRemainingSumCount + 4\n        val\
    \ hungryRemainingSumCount6 = hungryRemainingSumCount + 5\n        val hungryRemainingSumCount7\
    \ = hungryRemainingSumCount + 6\n        val hungryRemainingSumCount8 = hungryRemainingSumCount\
    \ + 7\n        val hungryRemainingSumCount9 = hungryRemainingSumCount + 8\n  \
    \      val hungryRemainingSumCount10 = hungryRemainingSumCount + 9\n        val\
    \ hungryRemainingSumCount11 = hungryRemainingSumCount + 10\n        val hungryRemainingSumCount12\
    \ = hungryRemainingSumCount + 11\n        val hungryRemainingSumCount13 = hungryRemainingSumCount\
    \ + 12\n        val hungryRemainingSumCount14 = hungryRemainingSumCount + 13\n\
    \        val hungryRemainingSumCount15 = hungryRemainingSumCount + 14\n      \
    \  val hungryRemainingSumCount16 = hungryRemainingSumCount + 15\n        val hungryRemainingSumCount17\
    \ = hungryRemainingSumCount + 16\n        val hungryRemainingSumCount18 = hungryRemainingSumCount\
    \ + 17\n        val hungryRemainingSumCount19 = hungryRemainingSumCount + 18\n\
    \        val hungryRemainingSumCount20 = hungryRemaining\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmp44bgn5a2.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmp44bgn5a2.scala:24:21 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m   |\e[0m      \
    \               Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmp44bgn5a2.scala:25:30 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mhungryRemaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                              ^^^^^^^\e[0m\n\e[31m   |\e\
    [0m                              Not found: mutable\n\e[31m   |\e[0m\n\e[31m \
    \  |\e[0m longer explanation available when compiling with `-explain`\n\e[31m\e\
    [31m-- [E007] Type Mismatch Error: /tmp/tmp44bgn5a2.scala:48:5 ---------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e\
    [0m     Found:    Unit\n\e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e\
    [0m\n\e[31m   |\e[0m longer explanation available when compiling with `-explain`\n\
    4 errors found\n"
  stdout: ''
  timestamp: 1660010580
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.max(need - carrots, 0)\n        val remaining = math.max(remaining\
    \ - carrots, 0)\n        val result = List(meals, remaining)\n        result\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E045] Cyclic Error: /tmp/tmpsx08fvnl.scala:25:33 ---------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mremaining\e[0m = math.max(remaining\
    \ - carrots, \e[31m0\e[0m)\n\e[31m\e[31m   |\e[0m                            \
    \     ^\e[0m\n\e[31m   |\e[0m                                 Recursive \e[33mvalue\e\
    [0m \e[35mremaining\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n1 error found\n"
  stdout: ''
  timestamp: 1660010576
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = number - remaining\n\
    \        val left = need - eaten\n        if (left <= 0) List(number, need) else\
    \ List(number, need, left)\n    }\n    def main(args: Array[String]) = {\n   \
    \ assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8bogqy60.scala:28)\n\tat Problem.main(tmp8bogqy60.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val carrots_left = need - carrots\n        val carrots_left_after_meals\
    \ = carrots_left / 2\n        val carrots_left_after_meals_2 = carrots_left /\
    \ 4\n        val carrots_left_after_meals_3 = carrots_left / 8\n        val carrots_left_after_meals_4\
    \ = carrots_left / 16\n        val carrots_left_after_meals_5 = carrots_left /\
    \ 32\n        val carrots_left_after_meals_6 = carrots_left / 64\n        val\
    \ carrots_left_after_meals_7 = carrots_left / 128\n        val carrots_left_after_meals_8\
    \ = carrots_left / 256\n        val carrots_left_after_meals_9 = carrots_left\
    \ / 512\n        val carrots_left_after_meals_10 = carrots_left / 1024\n     \
    \   val carrots_left_after_meals_11 = carrots_left / 2048\n        val carrots_left_after_meals_12\
    \ = carrots_left / 4096\n        val carrots_left_after_meals_13 = carrots_left\
    \ / 8192\n        val carrots_left_after_meals_14 = carrots_left / 16384\n   \
    \     val carrots_left_after_meals_15 = carrots_left / 32768\n        val carrots_left_after_meals_16\
    \ = carrots_left / 65536\n        val carrots_left_after_meals_17 = carrots_left\
    \ / 131072\n        val carrots_left_after_meals_18 = carrots_left / 262144\n\
    \        val carrots_left_after_meals_19 = carrots_left / 524288\n        val\
    \ carrots_left_after_meals_20 = carrots_left / 1048576\n        val carrots_left_after_meals_21\
    \ = carrots_left / 2097152\n        val carrots_left_after_meals_22 = carrots_left\
    \ / 4194304\n        val carrots_left_after_meals_23 = carrots_left / 8388608\n\
    \        val carrots_left_after_meals_24 = carrots_left / 16777216\n        val\
    \ carrots_left_after_meals_25 = carrots_left / 33554432\n        val carrots_left_after_\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjwaa7684.scala:51:4 ----------------------------\e\
    [0m\e[0m\n\e[31m51 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpjwaa7684.scala:51:5 ---------------------\e[0m\e[0m\n\e[31m51 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010581
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val hungry = number - need\n\
    \        val left  = remaining - need\n        val result = new mutable.ListBuffer[Long]()\n\
    \        val carrots = mutable.ListBuffer[Long]()\n        val hungryCarrots =\
    \ mutable.ListBuffer[Long]()\n        val leftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryCarrots = mutable.ListBuffer[Long]()\n        val leftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryCarrots = mutable.ListBuffer[Long]()\n\
    \        val leftCarrots = mutable.ListBuffer[Long]()\n        val hungryCarrots\
    \ = mutable.ListBuffer[Long]()\n        val leftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryCarrots = mutable.ListBuffer[Long]()\n        val leftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryCarrots = mutable.ListBuffer[Long]()\n\
    \        val leftCarrots = mutable.ListBuffer[Long]()\n        val hungryCarrots\
    \ = mutable.ListBuffer[Long]()\n        val leftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryCarrots = mutable.ListBuffer[Long]()\n        val leftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryCarrots = mutable.ListBuffer[Long]()\n\
    \        val leftCarrots = mutable.ListBuffer[Long]()\n        val hungryCarrots\
    \ = mutable.ListBuffer[Long]()\n        val leftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryCarrots = mutable.ListBuffer[Long]()\n        val leftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungryCarrots = mutable.ListBuffer[Long]()\n\
    \        val leftCarrots = mutable.ListBuffer[Long]()\n        val hungryCarrots\
    \ = mutable.ListBuffer[Long]()\n        val leftCarrots = mutable.ListBuffer[Long]()\n\
    \        val hungryCarrots = mutable.ListBuffer[Long]()\n        val leftCarrots\
    \ = mutable.ListBuffer[Long]()\n        val hungr\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmp0s1vapg7.scala:56:4 ----------------------------\e\
    [0m\e[0m\n\e[31m56 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmp0s1vapg7.scala:29:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m29 |\e[0m        \e[33mval\e[0m\
    \ \e[36mhungryCarrots\e[0m = mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m\
    \   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e[0m\n\e[31m\
    \   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0s1vapg7.scala:30:12 ---------------------------\e[0m\e[0m\n\e\
    [31m30 |\e[0m        \e[33mval\e[0m \e[36mleftCarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftCarrots is already defined as \e[33mvalue\e[0m \e[35mleftCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0s1vapg7.scala:31:12 ---------------------------\e[0m\e[0m\n\e\
    [31m31 |\e[0m        \e[33mval\e[0m \e[36mhungryCarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mhungryCarrots is already defined as \e[33mvalue\e[0m \e[35mhungryCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same group of toplevel definitions\n\e[31m\e[31m-- [E161] Naming\
    \ Error: /tmp/tmp0s1vapg7.scala:32:12 ---------------------------\e[0m\e[0m\n\e\
    [31m32 |\e[0m        \e[33mval\e[0m \e[36mleftCarrots\e[0m = mutable.ListBuffer[\e\
    [35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mleftCarrots is already defined as \e[33mvalue\e[0m \e[35mleftCarrots\e\
    [0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods must all be\
    \ defined in the same"
  stdout: ''
  timestamp: 1660010582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val meals = mutable.ArrayBuffer(need)\n        val remaining = mutable.ArrayBuffer(remaining)\n\
    \        val result = mutable.ArrayBuffer(2)\n        val hungry = mutable.ArrayBuffer(0)\n\
    \        val notHungry = mutable.ArrayBuffer(0)\n        val hungryCarrots = mutable.ArrayBuffer(0)\n\
    \        val notHungryCarrots = mutable.ArrayBuffer(0)\n        val hungryMeals\
    \ = mutable.ArrayBuffer(0)\n        val notHungryMeals = mutable.ArrayBuffer(0)\n\
    \        val hungryRemaining = mutable.ArrayBuffer(0)\n        val notHungryRemaining\
    \ = mutable.ArrayBuffer(0)\n        val hungryEaten = mutable.ArrayBuffer(0)\n\
    \        val notHungryEaten = mutable.ArrayBuffer(0)\n        val hungryEatenRemaining\
    \ = mutable.ArrayBuffer(0)\n        val notHungryEatenRemaining = mutable.ArrayBuffer(0)\n\
    \        val hungryEatenMeals = mutable.ArrayBuffer(0)\n        val notHungryEatenMeals\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenRemainingMeals = mutable.ArrayBuffer(0)\n\
    \        val notHungryEatenRemainingMeals = mutable.ArrayBuffer(0)\n        val\
    \ hungryEatenCarrots = mutable.ArrayBuffer(0)\n        val notHungryEatenCarrots\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenRemainingCarrots = mutable.ArrayBuffer(0)\n\
    \        val notHungryEatenRemainingCarrots = mutable.ArrayBuffer(0)\n       \
    \ val hungryEatenMealsCarrots = mutable.ArrayBuffer(0)\n        val notHungryEatenMealsCarrots\
    \ = mutable.ArrayBuffer(0)\n        val hungryEatenRemainingMealsCarrots = mutable.ArrayBuffer(0)\n\
    \        val notHungryEatenRemainingMealsCarrots = mutable.ArrayBuffer(0)\n  \
    \      val hungryEatenCarrotsRemaining = mutable.ArrayBuffer(0)\n        val notHungryEatenCarrotsRemaining\
    \ = mutable.ArrayBuffer(0)\n        val \n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E032] Syntax Error: /tmp/tmpbgu5td4o.scala:53:11 ---------------------------\e\
    [0m\e[0m\n\e[31m53 |\e[0m        \e[33mval\e[0m \n\e[31m\e[31m   |\e[0m      \
    \     ^\e[0m\n\e[31m   |\e[0m           pattern expected\n\e[31m   |\e[0m\n\e\
    [31m   |\e[0m longer explanation available when compiling with `-explain`\n\e\
    [31m\e[31m-- [E006] Not Found Error: /tmp/tmpbgu5td4o.scala:23:22 ------------------------\e\
    [0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e[36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\
    \e[31m\e[31m   |\e[0m                      ^^^^^^^\e[0m\n\e[31m   |\e[0m     \
    \                 Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbgu5td4o.scala:24:20 ------------------------\e[0m\e\
    [0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e[36mmeals\e[0m = mutable.ArrayBuffer(need)\n\
    \e[31m\e[31m   |\e[0m                    ^^^^^^^\e[0m\n\e[31m   |\e[0m       \
    \             Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E006] Not Found Error:\
    \ /tmp/tmpbgu5td4o.scala:25:24 ------------------------\e[0m\e[0m\n\e[31m25 |\e\
    [0m        \e[33mval\e[0m \e[36mremaining\e[0m = mutable.ArrayBuffer(remaining)\n\
    \e[31m\e[31m   |\e[0m                        ^^^^^^^\e[0m\n\e[31m   |\e[0m   \
    \                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n\e[31m\e[31m-- [E006]\
    \ Not Found Error: /tmp/tmpbgu5td4o.scala:26:21 ------------------------\e[0m\e\
    [0m\n\e[31m26 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = mutable.ArrayBuffer(\e\
    [31m2\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m                     Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e\
    [0m longer explanation available when compiling with `-explain`\n\e[31m\e[31m--\
    \ [E006] Not Found Error: /tmp/tmpbgu5td4o.scala:27:21 ------------------------\e\
    [0m\e[0m\n\e[31m27 |\e[0m        \e[33mval\e[0m \e[36mhungry\e[0m = mutable.ArrayBuffer(\e\
    [31m0\e[0m)\n\e[31m\e[31m   |\e[0m                     ^^^^^^^\e[0m\n\e[31m  \
    \ |\e[0m     "
  stdout: ''
  timestamp: 1660010582
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrotsLeft = remaining - carrots\n        val meals = if (carrotsLeft\
    \ <= 0) 1 else carrotsLeft / 2\n        val carrotsLeftAfterMeals = carrotsLeft\
    \ - meals\n        val carrotsLeftAfterMealsRemaining = carrotsLeft - meals *\
    \ 2\n        val carrotsLeftAfterMealsRemaining2 = carrotsLeft - meals * 3\n \
    \       val carrotsLeftAfterMealsRemaining3 = carrotsLeft - meals * 4\n      \
    \  val carrotsLeftAfterMealsRemaining4 = carrotsLeft - meals * 5\n        val\
    \ carrotsLeftAfterMealsRemaining5 = carrotsLeft - meals * 6\n        val carrotsLeftAfterMealsRemaining6\
    \ = carrotsLeft - meals * 7\n        val carrotsLeftAfterMealsRemaining7 = carrotsLeft\
    \ - meals * 8\n        val carrotsLeftAfterMealsRemaining8 = carrotsLeft - meals\
    \ * 9\n        val carrotsLeftAfterMealsRemaining9 = carrotsLeft - meals * 10\n\
    \        val carrotsLeftAfterMealsRemaining10 = carrotsLeft - meals * 11\n   \
    \     val carrotsLeftAfterMealsRemaining11 = carrotsLeft - meals * 12\n      \
    \  val carrotsLeftAfterMealsRemaining12 = carrotsLeft - meals * 13\n        val\
    \ carrotsLeftAfterMealsRemaining13 = carrotsLeft - meals * 14\n        val carrotsLeftAfterMealsRemaining14\
    \ = carrotsLeft - meals * 15\n        val carrotsLeftAfterMealsRemaining15 = carrotsLeft\
    \ - meals * 16\n        val carrotsLeftAfterMealsRemaining16 = carrotsLeft - meals\
    \ * 17\n        val carrotsLeftAfterMealsRemaining17 = carrotsLeft - meals * 18\n\
    \        val carrotsLeftAfterMealsRemaining18 = carrotsLeft - meals * 19\n   \
    \     val carrotsLeftAfterMealsRemaining19 = carrotsLeft - meals * 20\n      \
    \  val carrotsLeftAfterMealsRemaining20 = carrotsLeft - meals * 21\n        val\
    \ carrotsLeft\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpjvvdi5_0.scala:48:4 ----------------------------\e\
    [0m\e[0m\n\e[31m48 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmpjvvdi5_0.scala:48:5 ---------------------\e[0m\e[0m\n\e[31m48 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val eaten = math.min(number,\
    \ need)\n        val left  = math.max(number, need)\n        val result = new\
    \ mutable.ListBuffer[Long]()\n        if (number > need) {\n            val remaining\
    \ = math.min(number, need)\n            while (number > remaining) {\n       \
    \         number -= remaining\n                result += remaining\n         \
    \   }\n        }\n        if (number < need) {\n            val remaining = math.max(number,\
    \ need)\n            while (number < remaining) {\n                number += remaining\n\
    \                result += remaining\n            }\n        }\n        result.toList\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpid2e66cw.scala:25:25 ------------------------\e\
    [0m\e[0m\n\e[31m25 |\e[0m        \e[33mval\e[0m \e[36mresult\e[0m = \e[33mnew\e\
    [0m mutable.ListBuffer[\e[35mLong\e[0m]()\n\e[31m\e[31m   |\e[0m             \
    \            ^^^^^^^\e[0m\n\e[31m   |\e[0m                         Not found:\
    \ mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E008] Not Found Error: /tmp/tmpid2e66cw.scala:29:23\
    \ ------------------------\e[0m\e[0m\n\e[31m29 |\e[0m                number -=\
    \ remaining\n\e[31m\e[31m   |\e[0m                ^^^^^^^^^\e[0m\n\e[31m   |\e\
    [0m              value -= is not a member of Long - did you mean number.!=?\n\e\
    [31m\e[31m-- [E008] Not Found Error: /tmp/tmpid2e66cw.scala:36:23 ------------------------\e\
    [0m\e[0m\n\e[31m36 |\e[0m                number += remaining\n\e[31m\e[31m   |\e\
    [0m                ^^^^^^^^^\e[0m\n\e[31m   |\e[0m              value += is not\
    \ a member of Long - did you mean number.!=?\n3 errors found\n"
  stdout: ''
  timestamp: 1660010584
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = math.min(need, carrots)\n        val leftCarrots = math.max(0,\
    \ carrots - meals)\n        List(meals, leftCarrots)\n    }\n    def main(args:\
    \ Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmp8w2yv1g3.scala:29)\n\tat Problem.main(tmp8w2yv1g3.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010484
- exit_code: 0
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrots_left = remaining - carrots\n        val meals = if (carrots_left\
    \ > 0) 1 else 0\n        val carrots_after_meals = carrots + meals\n        val\
    \ carrots_left_after_meals = carrots_left - meals\n        List(carrots_after_meals,\
    \ carrots_left_after_meals)\n    }\n    def main(args: Array[String]) = {\n  \
    \  assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: Exception
  stderr: "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\
    \tat Problem$.main(tmpu3m5i4qf.scala:31)\n\tat Problem.main(tmpu3m5i4qf.scala)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\
    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\
    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\
    \tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\
    \tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\
    \tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\
    \tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\
    \tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\
    \tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat\
    \ dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\
    \tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n"
  stdout: ''
  timestamp: 1660010584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = mutable.ArrayBuffer(number)\n\
    \        val carrots_left = mutable.ArrayBuffer(need)\n        val carrots_left_to_eat\
    \ = (remaining - number).toInt\n        val carrots_left_to_eat_max = carrots_left.max\n\
    \        val carrots_left_to_eat_min = carrots_left.min\n        val carrots_left_to_eat_sum\
    \ = carrots_left.sum\n        val carrots_left_to_eat_product = carrots_left.product\n\
    \        val carrots_left_to_eat_product2 = carrots_left.product\n        val\
    \ carrots_left_to_eat_product3 = carrots_left.product\n        val carrots_left_to_eat_product4\
    \ = carrots_left.product\n        val carrots_left_to_eat_product5 = carrots_left.product\n\
    \        val carrots_left_to_eat_product6 = carrots_left.product\n        val\
    \ carrots_left_to_eat_product7 = carrots_left.product\n        val carrots_left_to_eat_product8\
    \ = carrots_left.product\n        val carrots_left_to_eat_product9 = carrots_left.product\n\
    \        val carrots_left_to_eat_product10 = carrots_left.product\n        val\
    \ carrots_left_to_eat_product11 = carrots_left.product\n        val carrots_left_to_eat_product12\
    \ = carrots_left.product\n        val carrots_left_to_eat_product13 = carrots_left.product\n\
    \        val carrots_left_to_eat_product14 = carrots_left.product\n        val\
    \ carrots_left_to_eat_product15 = carrots_left.product\n        val carrots_left_to_eat_product16\
    \ = carrots_left.product\n        val carrots_left_to_eat_product17 = carrots_left.product\n\
    \        val carrots_left_to_eat_product18 = carrots_left.product\n        val\
    \ carrots_left_to_eat_product19 = carrots_left.product\n        val carrots_left_to_eat_product20\
    \ = carrots_left.product\n        val carrots_left_to_eat_product21 = carrots_left.product\n\
    \        val carrots_left_to_eat_product22 = carrots_left.product\n        val\
    \ carrots_left_to_eat_product23 = carrots_left.product\n        val carrots_left_to_eat_product24\
    \ = carrots_left.product\n        val carrots_\n    }\n    def main(args: Array[String])\
    \ = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n\
    \    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n\
    \    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n\
    \    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n\
    \    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n\
    \    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n\
    \    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmpx5_tp87k.scala:54:4 ----------------------------\e\
    [0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx5_tp87k.scala:23:22\
    \ ------------------------\e[0m\e[0m\n\e[31m23 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots\e[0m = mutable.ArrayBuffer(number)\n\e[31m\e[31m   |\e[0m        \
    \              ^^^^^^^\e[0m\n\e[31m   |\e[0m                      Not found: mutable\n\
    \e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when compiling with\
    \ `-explain`\n\e[31m\e[31m-- [E006] Not Found Error: /tmp/tmpx5_tp87k.scala:24:27\
    \ ------------------------\e[0m\e[0m\n\e[31m24 |\e[0m        \e[33mval\e[0m \e\
    [36mcarrots_left\e[0m = mutable.ArrayBuffer(need)\n\e[31m\e[31m   |\e[0m     \
    \                      ^^^^^^^\e[0m\n\e[31m   |\e[0m                         \
    \  Not found: mutable\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available\
    \ when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpx5_tp87k.scala:54:5\
    \ ---------------------\e[0m\e[0m\n\e[31m54 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n4 errors found\n"
  stdout: ''
  timestamp: 1660010583
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - need\n\
    \        val carrotsLeft = remaining - carrots\n        val carrotsLeftToEat =\
    \ carrotsLeft - carrots // how many carrots left to eat\n        val carrotsLeftToEatList\
    \ = List(carrotsLeftToEat)\n        val carrotsLeftToEatArray = carrotsLeftToEatList.toArray\n\
    \        val carrotsLeftToEatArrayList = List(carrotsLeftToEatArray)\n       \
    \ val carrotsLeftToEatArrayListArray = carrotsLeftToEatArrayList.toArray\n   \
    \     val carrotsLeftToEatArrayListArrayList = List(carrotsLeftToEatArrayListArray)\n\
    \        val carrotsLeftToEatArrayListArrayListArray = carrotsLeftToEatArrayListArrayList.toArray\n\
    \        val carrotsLeftToEatArrayListArrayListArrayList = List(carrotsLeftToEatArrayListArrayListArray)\n\
    \        val carrotsLeftToEatArrayListArrayListArrayListArray = carrotsLeftToEatArrayListArrayListArrayList.toArray\n\
    \        val carrotsLeftToEatArrayListArrayListArrayListArrayList = List(carrotsLeftToEatArrayListArrayListArrayListArray)\n\
    \        val carrotsLeftToEatArrayListArrayListArrayListArrayListArray = carrotsLeftToEatArrayListArrayListArrayListArrayList.toArray\n\
    \        val carrotsLeftToEatArrayListArrayListArrayListArrayListArrayListArray\
    \ = carrotsLeftToEatArrayListArrayListArrayListArrayListArray.toArray\n      \
    \  val carrotsLeftToEatArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ = carrotsLeftToEatArrayListArrayListArrayListArrayListArrayListArray.toArray\n\
    \        val carrotsLeftToEatArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ = carrotsLeftToEatArrayListArrayListArrayListArrayListArrayListArrayListArray.toArray\n\
    \        val carrotsLeftToEatArrayListArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray\
    \ = carrotsLeftToEatArrayListArrayListArrayListArrayListArrayListArrayListArrayListArray.toArray\n\
    \        val car\n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmplxk4zgae.scala:41:4 ----------------------------\e\
    [0m\e[0m\n\e[31m41 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E007] Type Mismatch Error:\
    \ /tmp/tmplxk4zgae.scala:41:5 ---------------------\e[0m\e[0m\n\e[31m41 |\e[0m\
    \    }\n\e[31m\e[31m   |\e[0m     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\
    \e[31m   |\e[0m     Required: List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer\
    \ explanation available when compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val carrotsLeft = (remaining - carrots)\n\
    \        val carrotsLeftAfterMeals = carrotsLeft - meals\n        val carrotsLeftAfterMealsAfterMeals\
    \ = carrotsLeftAfterMeals - meals\n        val carrotsLeftAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMeals - meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMeals - meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMeals - meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals - meals\n  \
    \      val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals -\
    \ meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - meals\n        val carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMe\n\
    \    }\n    def main(args: Array[String]) = {\n    assert(eat((5l), (6l), (10l)).equals((List[Long](11l.toLong,\
    \ 4l.toLong))));\n    assert(eat((4l), (8l), (9l)).equals((List[Long](12l.toLong,\
    \ 1l.toLong))));\n    assert(eat((1l), (10l), (10l)).equals((List[Long](11l.toLong,\
    \ 0l.toLong))));\n    assert(eat((2l), (11l), (5l)).equals((List[Long](7l.toLong,\
    \ 0l.toLong))));\n    assert(eat((4l), (5l), (7l)).equals((List[Long](9l.toLong,\
    \ 2l.toLong))));\n    assert(eat((4l), (5l), (1l)).equals((List[Long](5l.toLong,\
    \ 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E040] Syntax Error: /tmp/tmph8uwegt9.scala:37:4 ----------------------------\e\
    [0m\e[0m\n\e[31m37 |\e[0m    }\n\e[31m\e[31m   |\e[0m    ^\e[0m\n\e[31m   |\e\
    [0m    '=' expected, but '}' found\n\e[31m\e[31m-- [E161] Naming Error: /tmp/tmph8uwegt9.scala:34:12\
    \ ---------------------------\e[0m\e[0m\n\e[31m34 |\e[0m        \e[33mval\e[0m\
    \ \e[36mcarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e\
    [0m = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - meals\n\e[31m\e[31m   |\e[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\e\
    [0m\n\e[31m   |\e[0mcarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ is already defined as \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \e[31m   |\e[0m\e[0m\n\e[31m   |\e[0m\n\e[31m   |\e[0mNote that overloaded methods\
    \ must all be defined in the same group of toplevel definitions\n\e[31m\e[31m--\
    \ [E045] Cyclic Error: /tmp/tmph8uwegt9.scala:35:116 --------------------------\e\
    [0m\e[0m\n\e[31m35 |\e[0m        \e[33mval\e[0m \e[36mcarrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\e\
    [0m = carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\
    \ - meals\n\e[31m\e[31m   |\e[0m                                             \
    \                                                                       ^\e[0m\n\
    \e[31m   |\e[0mRecursive \e[33mvalue\e[0m \e[35m\n\e[31m   |\e[0m  carrotsLeftAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMealsAfterMeals\n\
    \e[31m   |\e[0m\e[0m needs type\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation\
    \ available when compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch\
    \ Error: /tmp/tmph8uwegt9.scala:37:5 ---------------------\e[0m\e[0m\n\e[31m37\
    \ |\e[0m    }\n\e[31m\e[31m"
  stdout: ''
  timestamp: 1660010584
- exit_code: 1
  program: "import scala.math._\nimport scala.collection.mutable._\nobject Problem\
    \ {\n    // You're a hungry rabbit, and you already have eaten a certain number\
    \ of carrots,\n    // but now you need to eat more carrots to complete the day's\
    \ meals.\n    // you should return an array of [ total number of eaten carrots\
    \ after your meals,\n    // the number of carrots left after your meals ]\n  \
    \  // if there are not enough remaining carrots, you will eat all remaining carrots,\
    \ but will still be hungry.\n    // Example:\n    // Variables:\n    // @number\
    \ : integer\n    // the number of carrots that you have eaten.\n    // @need :\
    \ integer\n    // the number of carrots that you need to eat.\n    // @remaining\
    \ : integer\n    // the number of remaining carrots thet exist in stock\n    //\
    \ Constrain:\n    // * 0 <= number <= 1000\n    // * 0 <= need <= 1000\n    //\
    \ * 0 <= remaining <= 1000\n    // Have fun :)\n    def eat(number : Long, need\
    \ : Long, remaining : Long) : List[Long] = {\n        val carrots = number - remaining\n\
    \        val meals = need - carrots\n        val mealsLeft = meals - carrots\n\
    \        val mealsRight = meals - carrots + 1\n        val mealsRight1 = mealsRight\
    \ - 1\n        val mealsRight2 = mealsRight - 2\n        val mealsRight3 = mealsRight\
    \ - 3\n        val mealsRight4 = mealsRight - 4\n        val mealsRight5 = mealsRight\
    \ - 5\n        val mealsRight6 = mealsRight - 6\n        val mealsRight7 = mealsRight\
    \ - 7\n        val mealsRight8 = mealsRight - 8\n        val mealsRight9 = mealsRight\
    \ - 9\n        val mealsRight10 = mealsRight - 10\n        val mealsRight11 =\
    \ mealsRight - 11\n        val mealsRight12 = mealsRight - 12\n        val mealsRight13\
    \ = mealsRight - 13\n        val mealsRight14 = mealsRight - 14\n        val mealsRight15\
    \ = mealsRight - 15\n        val mealsRight16 = mealsRight - 16\n        val mealsRight17\
    \ = mealsRight - 17\n        val mealsRight18 = mealsRight - 18\n        val mealsRight19\
    \ = mealsRight - 19\n        val mealsRight20 = mealsRight - 20\n        val mealsRight21\
    \ = mealsRight - 21\n        val mealsRight22 = mealsRight - 22\n        val mealsRight23\
    \ = mealsRight - 23\n        val mealsRight24 = mealsRight - 24\n        val mealsRight25\
    \ = mealsRight - 25\n        val mealsRight26 = mealsRight - 26\n        val mealsRight27\
    \ = mealsRight - 27\n        val mealsRight28 = mealsRight - 28\n        val mealsRight29\
    \ = mealsRight - 29\n        val mealsRight30 = mealsRight - 30\n        val mealsRight31\
    \ = mealsRight - 31\n        val mealsRight32 = mealsRight - 32\n        val mealsRight33\
    \ = mealsRight - 33\n        val mealsRight34 = mealsRight - 34\n        val mealsRight35\
    \ = mealsRight - 35\n        val mealsRight36 = mealsRight - 36\n        val mealsRight37\
    \ = mealsRight - \n    }\n    def main(args: Array[String]) = {\n    assert(eat((5l),\
    \ (6l), (10l)).equals((List[Long](11l.toLong, 4l.toLong))));\n    assert(eat((4l),\
    \ (8l), (9l)).equals((List[Long](12l.toLong, 1l.toLong))));\n    assert(eat((1l),\
    \ (10l), (10l)).equals((List[Long](11l.toLong, 0l.toLong))));\n    assert(eat((2l),\
    \ (11l), (5l)).equals((List[Long](7l.toLong, 0l.toLong))));\n    assert(eat((4l),\
    \ (5l), (7l)).equals((List[Long](9l.toLong, 2l.toLong))));\n    assert(eat((4l),\
    \ (5l), (1l)).equals((List[Long](5l.toLong, 0l.toLong))));\n    }\n\n}\n"
  status: SyntaxError
  stderr: "\e[31m\e[31m-- [E018] Syntax Error: /tmp/tmpas7obgd6.scala:63:39 ---------------------------\e\
    [0m\e[0m\n\e[31m63 |\e[0m        \e[33mval\e[0m \e[36mmealsRight37\e[0m = mealsRight\
    \ - \n\e[31m\e[31m   |\e[0m                                       ^\e[0m\n\e[31m\
    \   |\e[0m                                       expression expected but \e[31m'}'\e\
    [0m found\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n\e[31m\e[31m-- [E007] Type Mismatch Error: /tmp/tmpas7obgd6.scala:64:5\
    \ ---------------------\e[0m\e[0m\n\e[31m64 |\e[0m    }\n\e[31m\e[31m   |\e[0m\
    \     ^\e[0m\n\e[31m   |\e[0m     Found:    Unit\n\e[31m   |\e[0m     Required:\
    \ List[Long]\n\e[31m   |\e[0m\n\e[31m   |\e[0m longer explanation available when\
    \ compiling with `-explain`\n2 errors found\n"
  stdout: ''
  timestamp: 1660010584
